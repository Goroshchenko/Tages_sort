Эффективное объектно-ориентированное
программирования
Изучаем
3-е издание
охватывает Python 2.5
Марк Лутц
Python

Mark Lutz
Learning
Python
Third Edition
Марк Лутц
Изучаем
Python
СанктПетербург–Москва
2009
Третье издание
Марк Лутц
Изучаем Python, 3е издание
Перевод А. Киселева
Главный редактор А. Галунов
Зав. редакцией Н. Макарова
Выпускающий редактор П. Щеголев
Научный редактор Б. Попов
Редактор Ю. Бочина
Корректор C. Минин
Верстка Д. Орлова
Лутц М.
Изучаем Python, 3е издание – Пер. с англ. – СПб.: СимволПлюс, 2009. –
848 с., ил.
ISBN 9785932861387
Мощный, переносимый и легкий в использовании язык программирования
Python идеально подходит для разработки самостоятельных программ и сце
нариев. Эта книга позволит быстро и эффективно овладеть базовыми основами
языка Python независимо от степени предварительного знакомства с ним.
Третье издание «Изучаем Python» основано на материалах учебных курсов,
которые автор, Марк Лутц, ведет уже на протяжении десяти лет. В книге
представлены основные типы объектов в языке Python, порядок их создания
и работы с ними, а также функции как основной процедурный элемент языка.
Рассматриваются методы работы с модулями и дополнительными объектно
ориентированными инструментами языка Python – классами. Включены опи
сания моделей и инструкций обработки исключений, а также обзор инструмен
тов разработки, используемых при создании крупных программ. Обсуждаются
изменения в ожидаемой версии 3.0. В конце глав представлены упражнения и
вопросы, которые позволят применить новые знания на практике и проверить,
насколько хорошо усвоен материал.
Если вы хотите понять, почему выбирают Python такие компании, как Google
и Intel, Cisco и HewlettPackard, почему этот язык используют в NASA для
научных вычислений, то эта книга станет для вас лучшей отправной точкой.
ISBN 9785932861387
ISBN 9780596513986 (англ)
© Издательство СимволПлюс, 2009
Authorized translation of the English edition © 2008 O’Reilly Media, Inc. This trans
lation is published and sold by permission of O’Reilly Media, Inc., the owner of all
rights to publish and sell the same.
Все права на данное издание защищены Законодательством РФ, включая право на полное или час
тичное воспроизведение в любой форме. Все товарные знаки или зарегистрированные товарные зна
ки, упоминаемые в настоящем издании, являются собственностью соответствующих фирм.
Издательство «СимволПлюс». 199034, СанктПетербург, 16 линия, 7,
тел. (812) 3245353, www.symbol.ru. Лицензия ЛП N 000054 от 25.12.98.
Налоговая льгота – общероссийский классификатор продукции
ОК 00593, том 2; 953000 – книги и брошюры.
Подписано в печать 21.11.2008. Формат 70×100 1/16. Печать офсетная.
Объем 53 печ. л. Тираж 2000 экз. Заказ №
Отпечатано с готовых диапозитивов в ГУП «Типография «Наука»
199034, СанктПетербург, 9 линия, 12.
Посвящается Вере.
Ты жизнь моя.

Оглавление
Предисловие . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
I. Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
1. Python в вопросах и ответах . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
Почему программисты используют Python? . . . . . . . . . . . . . . . . . . . . . . 35
Является ли Python «языком сценариев»?. . . . . . . . . . . . . . . . . . . . . . . . 38
Все хорошо, но есть ли у него недостатки? . . . . . . . . . . . . . . . . . . . . . . . . 40
Кто в наше время использует Python?. . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
Что можно делать с помощью Python? . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
В чем сильные стороны Python?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
Какими преимуществами обладает Python перед языком X? . . . . . . . 54
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
2. Как Python запускает программы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
Введение в интерпретатор Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
Выполнение программы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
Разновидности модели выполнения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
3. Как пользователь запускает программы . . . . . . . . . . . . . . . . . . . . . . 72
Интерактивный режим . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
Системная командная строка и файлы . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Щелчок на ярлыке файла . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Импортирование и перезагрузка модулей . . . . . . . . . . . . . . . . . . . . . . . . 86
Пользовательский интерфейс IDLE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
Другие интегрированные среды разработки . . . . . . . . . . . . . . . . . . . . . . 98
Встраивание вызовов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
Фиксированные исполняемые двоичные файлы. . . . . . . . . . . . . . . . . . 101
Возможность запуска программ из текстового редактора . . . . . . . . . . 101
Прочие возможности запуска . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
Будущие возможности . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
8 Оглавление
Какие способы следует использовать?. . . . . . . . . . . . . . . . . . . . . . . . . . . 102
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
II. Типы и операции . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
4. Введение в типы объектов языка Python . . . . . . . . . . . . . . . . . . . . . 111
Зачем нужны встроенные типы? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
Числа. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
Строки. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
Списки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
Словари. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
Кортежи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
Файлы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
Другие базовые типы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
5. Числа . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
Числовые типы в Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
Операторы выражений. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
Числа в действии. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
Другие числовые типы. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
6. Интерлюдия о динамической типизации. . . . . . . . . . . . . . . . . . . . . 166
Отсутствие инструкций объявления . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
Разделяемые ссылки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
Динамическая типизация повсюду . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
7. Строки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
Литералы строк. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
Строки в действии. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
Форматирование строки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
Строковые методы. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
Общие категории типов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
8. Списки и словари . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Списки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Списки в действии . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
Оглавление 9
Словари. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
Словари в действии. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
9. Кортежи, файлы и все остальное. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
Кортежи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
Кортежи в действии . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
Файлы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
Пересмотренный перечень категорий типов . . . . . . . . . . . . . . . . . . . . . 252
Гибкость объектов. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
Сравнения, равенство и истина . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Иерархии типов данных в языке Python . . . . . . . . . . . . . . . . . . . . . . . . 260
Другие типы в Python. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
Ловушки встроенных типов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
III. Инструкции и синтаксис . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
10. Введение в инструкции языка Python . . . . . . . . . . . . . . . . . . . . . . . . 273
Структура программы на языке Python . . . . . . . . . . . . . . . . . . . . . . . . . 273
История о двух if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
Короткий пример: интерактивные циклы . . . . . . . . . . . . . . . . . . . . . . . 284
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
11. Присваивание, выражения и print . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
Инструкции присваивания . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
Инструкции выражений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
Инструкция print . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
12. Условная инструкция if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
Условные инструкции if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
Синтаксические правила языка Python . . . . . . . . . . . . . . . . . . . . . . . . . 318
Проверка истинности . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328
13. Циклы while и for . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
Циклы while. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
break, continue, pass и else . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
10 Оглавление
Циклы for. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
Итераторы: первое знакомство . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
Приемы программирования циклов . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
Генераторы списков: первое знакомство. . . . . . . . . . . . . . . . . . . . . . . . . 357
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
14. Документация . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364
Источники документации в языке Python . . . . . . . . . . . . . . . . . . . . . . . 364
Типичные ошибки программирования . . . . . . . . . . . . . . . . . . . . . . . . . . 377
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
IV. Функции . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
15. Основы функций. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
Зачем нужны функции?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386
Создание функций . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 387
Первый пример: определения и вызовы . . . . . . . . . . . . . . . . . . . . . . . . . 390
Второй пример: пересечение последовательностей. . . . . . . . . . . . . . . . 393
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396
16. Области видимости и аргументы . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
Правила видимости . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
Инструкция global . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
Области видимости и вложенные функции . . . . . . . . . . . . . . . . . . . . . . 410
Передача аргументов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
Специальные режимы сопоставления аргументов . . . . . . . . . . . . . . . . 423
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
17. Расширенные возможности функций . . . . . . . . . . . . . . . . . . . . . . . . 440
Анонимные функции: lambda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
Применение функций к аргументам . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
Отображение функций на последовательности: map . . . . . . . . . . . . . . 449
Средства функционального программирования: filter и reduce . . . . . 451
Еще раз о генераторах списков: отображения . . . . . . . . . . . . . . . . . . . . 452
Еще раз об итераторах: генераторы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459
Хронометраж итерационных альтернатив . . . . . . . . . . . . . . . . . . . . . . . 466
Концепции проектирования функций . . . . . . . . . . . . . . . . . . . . . . . . . . 469
Типичные ошибки при работе с функциями . . . . . . . . . . . . . . . . . . . . . 472
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
Оглавление 11
V. Модули . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
18. Модули: общая картина. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
Зачем нужны модули? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 486
Архитектура программы на языке Python . . . . . . . . . . . . . . . . . . . . . . . 487
Как работает импорт. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
19. Основы программирования модулей . . . . . . . . . . . . . . . . . . . . . . . . 501
Создание модуля . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501
Использование модулей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
Пространства имен модулей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
Повторная загрузка модулей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 518
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519
20. Пакеты модулей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Основы операции импортирования пакетов. . . . . . . . . . . . . . . . . . . . . . 521
Пример импортирования пакета . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 525
Зачем используется операция импортирования пакетов? . . . . . . . . . 527
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 532
21. Дополнительные возможности модулей . . . . . . . . . . . . . . . . . . . . . 533
Сокрытие данных в модулях. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533
Включение будущих возможностей языка. . . . . . . . . . . . . . . . . . . . . . . 534
Смешанные режимы использования: __name__ и __main__ . . . . . . . 535
Изменение пути поиска модулей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538
Расширение import as. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
Синтаксис относительного импорта. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
Концепции проектирования модулей . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
Типичные проблемы при работе с модулями . . . . . . . . . . . . . . . . . . . . . 547
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555
VI. Классы и ООП. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 559
22. ООП: общая картина . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561
Зачем нужны классы? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
ООП с высоты 30 000 футов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 564
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 575
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 575
12 Оглавление
23. Основы программирования классов . . . . . . . . . . . . . . . . . . . . . . . . . 577
Классы генерируют множество экземпляров объектов . . . . . . . . . . . . 577
Классы адаптируются посредством наследования . . . . . . . . . . . . . . . . 582
Классы могут переопределять операторы языка Python . . . . . . . . . . . 586
Самый простой в мире класс на языке Python . . . . . . . . . . . . . . . . . . . . 589
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 592
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 592
24. Подробнее о программировании классов . . . . . . . . . . . . . . . . . . . . 595
Инструкция class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595
Методы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 599
Наследование. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 602
Перегрузка операторов. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 606
Пространства имен: окончание истории . . . . . . . . . . . . . . . . . . . . . . . . . 624
Более реалистичный пример. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 631
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 635
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 635
25. Шаблоны проектирования с классами . . . . . . . . . . . . . . . . . . . . . . . 637
Python и ООП. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 637
Классы как записи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 639
ООП и наследование: взаимосвязи типа «является» . . . . . . . . . . . . . . 641
ООП и композиция: взаимосвязи типа «имеет» . . . . . . . . . . . . . . . . . . 643
ООП и делегирование . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 648
Множественное наследование. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 649
Классы – это объекты: фабрики универсальных объектов . . . . . . . . . 653
Методы – это объекты: связанные и несвязанные методы. . . . . . . . . . 655
Еще раз о строках документирования . . . . . . . . . . . . . . . . . . . . . . . . . . . 657
Классы и модули . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 660
26. Дополнительные возможности классов . . . . . . . . . . . . . . . . . . . . . . 661
Расширение встроенных типов. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 661
Псевдочастные атрибуты класса . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 665
Классы нового стиля. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 668
Статические методы и методы класса . . . . . . . . . . . . . . . . . . . . . . . . . . . 677
Декораторы функций . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 681
Типичные проблемы при работе с классами. . . . . . . . . . . . . . . . . . . . . . 684
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 690
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 690
Оглавление 13
VII. Исключения и инструменты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 699
27. Основы исключений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
Зачем нужны исключения?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 702
Обработка исключений: краткий обзор. . . . . . . . . . . . . . . . . . . . . . . . . . 704
Инструкция try/except/else . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Инструкция try/finally . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 716
Объединенная инструкция try/except/finally . . . . . . . . . . . . . . . . . . . . 718
Инструкция raise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 722
Инструкция assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 725
Контекстные менеджеры with/as. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 726
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 731
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 732
28. Объекты исключений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 733
Исключения на основе строк. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 734
Исключения на основе классов. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 735
Общие формы инструкции raise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 747
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 748
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 749
29. Использование исключений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 751
Вложенные обработчики исключений . . . . . . . . . . . . . . . . . . . . . . . . . . 751
Идиомы исключений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 756
Советы по применению исключений . . . . . . . . . . . . . . . . . . . . . . . . . . . . 760
Типичные проблемы при работе с исключениями. . . . . . . . . . . . . . . . . 764
Заключение по основам языка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 766
В заключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 771
Закрепление пройденного . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 772
VIII. Приложения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 775
A. Установка и настройка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 777
B. Решения упражнений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 786
Алфавитный указатель. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 824

Предисловие
Эта книга представляет собой введение в язык программирования Py
thon. Python – это популярный язык программирования, используе
мый как для разработки самостоятельных программ, так и для созда
ния прикладных сценариев в самых разных областях применения. Это
мощный, переносимый, простой в использовании и свободно распро
страняемый язык программирования.
Цель этой книги – позволить вам быстро овладеть основными принци
пами базового языка Python независимо от уровня вашей подготовки.
Прочитав эту книгу, вы получите объем знаний, достаточный для ис
пользования Python в самых разных областях.
О третьем издании
За четыре года, прошедшие с момента выхода второго издания книги
в 2003 году, произошли существенные изменения как в самом языке
Python, так и в темах, которые я представляю на своих курсах обучения
языку Python. Я постарался оставить как можно больше из предыдуще
го издания, кроме того, это новое издание отражает изменения послед
него времени, появившиеся в самом языке Python и в обучении языку
Python. Помимо этого была несколько изменена структура книги.
Изменения в языке Python
Если говорить о версии языка, это издание описывает Python 2.5 и от
ражает все изменения, появившиеся в языке с момента выхода второго
издания книги. (Во втором издании описывался язык Python 2.2 и не
которые нововведения версии 2.3.) Кроме того, в этом издании обсуж
даются изменения, которые ожидаются в версии Python 3.0. Ниже
приводится список основных тем, касающихся языка программирова
ния, которые вы найдете в этом издании:
• Новая условная конструкция B if A else C (глава 12).
• Оператор контекста with/as (глава 27).
• Унификация конструкции try/except/finally (глава 27).
• Синтаксис относительного импорта (глава 21).
• Выражениягенераторы (глава 17).
• Новые особенности функцийгенераторов (глава 17).
16 Предисловие
• Функциидекораторы (глава 26).
• Объектный тип множества (глава 5).
• Новые встроенные функции: sorted, sum, any, all, enumerate (главы 4
и 13).
• Объектный тип десятичных чисел с фиксированной точностью
представления (глава 5).
• Расширенные сведения о файлах, списках, итераторах и многом
другом (главы 13 и 17).
• Новые инструменты разработки: Eclipse, dustutils, unittest и doctest,
расширения IDLE, Shedskin и т. д. (главы 3 и 29).
Менее значительные изменения в языке (такие, как широко исполь
зуемые значения True и False, новая функция sys.exc_info, которая воз
вращает подробную информацию об исключении, и обработка строко
вых исключений, методы для работы со строками и встроенные функ
ции apply и reduce) обсуждаются на протяжении всей книги. Кроме того,
здесь приводится расширенное описание некоторых новых особенно
стей, впервые появившихся в предыдущем издании, включая третье
измерение при работе со срезами и передачу произвольного числа ар
гументов функции, включая функцию apply.
Изменения в обучении языку Python
Кроме уже перечисленных изменений в самом языке это издание кни
ги дополнено новыми темами и примерами, наработанными мною при
преподавании на курсах обучения языку Python в последние годы. На
пример, здесь вы найдете:
• Новую главу о встроенных типах (глава 4).
• Новую главу о синтаксических конструкциях (глава 10).
• Полностью новую главу о динамической типизации с углубленным
освещением этого вопроса (глава 6).
• Расширенное введение в ООП (глава 22).
• Новые примеры работы с файлами, областями видимости, вложен
ными инструкциями, классами, исключениями и т. д.
Множество изменений и дополнений было сделано, чтобы облегчить
чтение книги начинающим программистам. Учитывая опыт препода
вания языка Python на курсах, обсуждение некоторых моментов было
перенесено в другие, более соответствующие тематике разделы. Напри
мер, описание списков и итераторов теперь приводится вместе с описа
нием оператора цикла for, а не с описанием функциональных инстру
ментов, как это было ранее.
Поскольку книга фактически превратилась в стандартный учебник по
Python, в этом издании существенно расширено описание основ язы
ка, изложение материала стало более полным и наглядным.
Предисловие 17
В дополнение в этом издании приводится полностью обновленный
комплект советов и рекомендаций, подобранных из опыта преподава
ния в течение последних 10 лет и практического использования Python
в течение последних 15 лет. Также были дополнены и расширены учеб
ные упражнения – с целью отразить наиболее удачные современные
приемы программирования на языке Python, его новые особенности
и показать наиболее типичные ошибки, которые совершают начинаю
щие программисты на моих курсах. Вообще основы языка в этом изда
нии обсуждаются более широко, чем в предыдущих изданиях, вопер
вых, потому что сам язык был расширен, а вовторых, потому что я до
бавил немало информации, которая имеет важное значение для прак
тического применения.
Структурные изменения в этом издании
Учитывая разросшийся объем книги, материал, как и в предыдущем
издании, разбит на несколько частей. Чтобы облегчить усвоение основ
языка, весь материал поделен на несколько частей, каждая из кото
рых содержит несколько глав. Например, типы и инструкции теперь
описываются в двух разных частях, в каждой из которых основным
типам и инструкциям отведены отдельные главы. Новая структура по
зволяет сказать больше, не перегружая читателя при этом. При пере
работке материала упражнения и описания наиболее распространен
ных ошибок были перемещены из конца главы в конец части, и теперь
они приводятся в конце последней главы каждой части.
Упражнения, которые приводятся в конце каждой части, я также до
полнил в этом издании кратким обзором и контрольными вопросами
в конце каждой главы, что должно помочь вам «пролистать» прочи
танный материал. Каждая глава заканчивается серией вопросов, кото
рые помогут вам проверить, насколько хорошо вы поняли изложенный
материал. В отличие от упражнений в конце каждой части, решения
для которых приводятся в приложении B, ответы на вопросы в конце
каждой главы следуют непосредственно за вопросами. Я рекомендую
просматривать ответы, даже если вы уверены, что правильно ответили
на вопросы, потому что эти ответы, кроме всего, являются кратким об
зором только что пройденной темы.
Несмотря на наличие новых тем, эта книга попрежнему ориентирова
на на тех, кто только начинает знакомство с языком Python. Она заду
мывалась как учебник по Python для программистов1. Во многом она
унаследовала из первых двух изданий и материал, и структуру, и ак
центы подачи материала. Где это необходимо, я расширил вводную
1 Под «программистами» я подразумеваю всех, кто в прошлом написал хотя
бы одну строчку программного кода на любом языке программирования.
Если вы не относитесь к этой категории, эта книга все равно будет вам по
лезна, но вы должны знать, что она в основном обучает языку Python, а не
основам программирования.
18 Предисловие
часть для начинающих и отделил более сложные темы от основного
потока обсуждения, чтобы не усложнять описание основ. Поскольку
это издание в значительной степени основано на проверенном време
нем опыте преподавания, оно, как и первые два, может служить ввод
ным курсом для самостоятельного изучения языка Python.
Ограничение области применения книги
Третье издание представляет собой учебник по основам языка про
граммирования Python и ничего больше. Здесь приводятся всесторон
ние сведения о языке, которые необходимо знать, прежде чем присту
пать к практическому его использованию. Материал подается в поряд
ке постепенного усложнения и дает полное представление о языке про
граммирования, не фокусируясь на областях его применения.
Для некоторых «изучить Python» означает потратить часдругой на изу
чение руководств в сети Интернет. Такой подход пригоден для опытных
программистов – в конце концов, Python – довольно простой язык по
сравнению с другими языками программирования. Однако проблема та
кого ускоренного изучения состоит в том, что на практике программи
сты часто сталкиваются с необычными случаями необъяснимого изме
нения значений переменных, параметров по умолчанию и т. д. Цель
этой книги состоит в том, чтобы дать твердое понимание основ языка Py
thon, чтобы даже самые необычные случаи находили свое объяснение.
Это ограничение было введено преднамеренно. Ограничившись обсуж
дением основ языка, мы можем заняться более глубоким и полным их
исследованием. Более полное обсуждение темы прикладного использо
вания Python и справочные материалы, не вошедшие в эту книгу, вы
найдете в других публикациях издательства O’Reilly, таких как «Pro
gramming Python», «Python Cookbook», «Python in a Nutshell» и «Py
thon Pocket Reference». Цель книги, которую вы сейчас читаете, со
стоит исключительно в изучении языка Python, чтобы потом вы смог
ли применять его для решения прикладных задач, независимо от
предметной области, в которой вы работаете.
По этой причине некоторые справочные материалы и разделы предыду
щих изданий (примерно 15 процентов предыдущего издания) были вы
резаны с целью расширить разделы с описанием основ языка Python.
Благодаря этому читатели этого издания получат более полное пред
ставление об основах языка программирования и – как следствие – бо
лее полезный учебник по языку Python. В качестве заключительного
упражнения в конце книги (глава 29) приводится несколько услож
ненных примеров для самостоятельного изучения.
Об этой книге
В этом разделе приводятся некоторые наиболее важные замечания об
этой книге в общем, не зависящие от номера издания. Никакая книга
Предисловие 19
не способна удовлетворить все нужды и потребности читателя, поэто
му важно понимать основные цели книги.
Предварительные условия
В действительности книга не предъявляет никаких предварительных
условий. Она с успехом использовалась как начинающими программи
стами, так и умудренными опытом ветеранами. Если у вас есть жела
ние изучать Python, эта книга наверняка поможет вам. Наличие у чи
тателя некоторого опыта в программировании не является обязатель
ным, но будет совсем не лишним.
Эта книга задумывалась как введение в Python для программистов. Воз
можно, она не идеальна для тех, кто раньше никогда не имел дела с ком
пьютерами (например, мы не будем тратить время, чтобы объяснять,
что такое компьютер), но я не делал никаких предположений о наличии
у читателя опыта программирования или об уровне его подготовки.
С другой стороны, – я не считаю нужным обижать читателей, предпо
лагая, что они «чайники», что бы это ни означало, – писать полезные
программы на языке Python просто, и эта книга покажет, как это де
лается. В книге Python иногда противопоставляется другим языкам
программирования, таким как C, C++, Java™ и Pascal, но эти сравне
ния можно просто игнорировать, если ранее вам не приходилось рабо
тать с этими языками программирования.
Отношения этой книги с другими книгами
Эта книга охватывает все основные аспекты языка программирования
Python, но при этом я старался ограничить круг обсуждаемых тем, что
бы уменьшить объем книги. Для сохранения простоты в ней рассмат
риваются самые основные понятия, используются небольшие и оче
видные примеры и опущены некоторые незначительные детали, кото
рые вы найдете в справочных руководствах. По этой причине данная
книга скорее должна рассматриваться как введение, как первый шаг
к другим, более специализированным и более полным книгам.
Например, мы не будем говорить об интеграции Python/C – это слиш
ком сложная тема, которая, однако, является центральной для мно
гих систем, основанных на применении Python. Мы также не будем го
ворить об истории развития Python и о процессе его разработки. А та
ких популярных применений Python, как создание графического ин
терфейса, разработка системных инструментов и работа с сетью, мы
коснемся лишь очень кратко, если они вообще будут упоминаться. Ес
тественно, при таком подходе из поля зрения выпадает значительная
часть общей картины.
Вообще говоря, Python стоит на более высоком качественном уровне
относительно других языков в мире языков сценариев. Некоторые из
его идей требуют более глубокого изучения, чем может вместить эта
книга, поэтому с моей стороны было бы ответственно порекомендовать
20 Предисловие
продолжить его изучение после того, как вы закончите читать эту кни
гу. Я надеюсь, что большинство читателей продолжит изучение прин
ципов разработки приложений на этом языке, обратившись к другим
источникам информации.
Ориентированная в основном на начинающих программистов, книга
«Изучаем Python» может быть дополнена другими книгами издатель
ства O’Reilly о языке Python. Например, существует еще одна моя кни
га «Programming Python», содержащая более объемные и полные при
меры наряду с описанием приемов прикладного программирования,
которая задумывалась как продолжение книги, которую вы сейчас чи
таете. Текущие издания книг «Изучаем Python» и «Programming Py
thon» представляют собой две части курса обучения, который препода
ет автор, – основы языка и прикладное программирование. Кроме того,
в качестве справочника можно использовать еще одну книгу издатель
ства O’Reilly, «Pyton Pocket Reference», где приводятся некоторые под
робности, опущенные здесь.
Для дальнейшего изучения можно порекомендовать книги, содержа
щие дополнительные сведения, примеры или особенности использова
ния языка Python в определенных прикладных областях, таких как
вебприложения и создание графических интерфейсов. Например, кни
ги «Python in a Nutshell» (O’Relly) и «Python Essential Reference»
(Sams) содержат справочную информацию. Книга «Python Cookbook»
(O’Reilly) представляет собой сборник примеров для тех, кто уже зна
ком с приемами прикладного программирования. Поскольку выбор
книг является делом достаточно субъективным, я рекомендую вам са
мостоятельно поискать такие, которые наиболее полно будут отвечать
вашим потребностям. Неважно, какие книги вы выберете, главное
чтобы вы помнили, что для дальнейшего изучения Python вам необхо
димы более реалистичные примеры, чем приводятся здесь.
На мой взгляд, эта книга будет для вас отличным учебником началь
ного уровня, даже несмотря на ее ограниченность (и скорее всего имен
но поэтому). Здесь вы найдете все, что необходимо знать, прежде чем
приступать к созданию программ и сценариев на языке Python. К тому
моменту, когда вы закончите чтение этой книги, вы изучите не только
сам язык, но и начнете понимать, как лучше применить его к реше
нию ваших повседневных задач. Кроме того, у вас будет все необходи
мое для изучения более сложных тем и примеров, которые будут
встречаться на вашем пути.
Стиль и структура книги
Эта книга основана на материалах трехдневных практических курсов
изучения языка Python. В конце каждой главы содержится список
контрольных вопросов, а в конце последней главы каждой части – уп
ражнения. Ответы на контрольные вопросы приводятся непосредствен
но в самих главах, а примеры решения упражнений – в приложении B.
Предисловие 21
Контрольные вопросы подобраны так, что они представляют собой
краткий обзор рассмотренного материала, а упражнения спроектиро
ваны так, чтобы сразу же научить вас правильному стилю программи
рования и, как правило, каждое упражнение соответствует одному из
ключевых аспектов курса.
Я настоятельно рекомендую прорабатывать контрольные вопросы и уп
ражнения в ходе чтения книги не только для того, чтобы получить опыт
программирования на Python, но и потому, что в упражнениях подни
маются проблемы, которые не обсуждаются нигде в книге. Ответы на
вопросы в главах и примеры решения упражнений в приложении B
в случае необходимости помогут вам выйти из затруднительных поло
жений (вы можете заглядывать в ответы так часто, как это потребуется).
Общая структура книги также следует структуре учебного курса. Так
как эта книга задумывалась как быстрое введение в основы языка про
граммирования, изложение материала организовано так, чтобы оно
отражало основные особенности языка, а не частности. Мы будем дви
гаться от простого к сложному: от встроенных типов объектов к инст
рукциям, элементам программ и т. д. Каждая глава является полным
и самостоятельным описанием одной темы, но каждая последующая
глава основана на идеях, введенных в предыдущих главах (например,
когда речь пойдет о классах, я буду исходить из предположения, что
вы уже знаете, как создаются функции), поэтому для большинства чи
тателей имеет смысл читать книгу последовательно.
В общих чертах, эта книга описывает язык программирования Python
при движении от простого к сложному. Каждая часть посвящена от
дельной крупной характеристике языка – типам, функциям и т. д.
В большинстве своем примеры являются законченными небольшими
сценариями (некоторые из них являются достаточно искусственными,
но они иллюстрируют достижение поставленной цели). Если быть бо
лее точным, здесь вы найдете:
Часть I. Введение
Изучение Python мы начнем с общего обзора этого языка и с ответов
на очевидно возникающие вопросы: почему ктото использует этот
язык, для решения каких задач он может использоваться и т. д.
В первой главе рассматриваются основные идеи, лежащие в основе
технологии, которые должны дать вам некоторые начальные пред
ставления. Далее начинается сугубо технический материал книги.
Здесь мы рассмотрим, как выполняют программы человек и интер
претатор Python. Цель этой части книги состоит в том, чтобы дать
вам начальные сведения, которые позволят вам работать с после
дующими примерами и упражнениями.
Часть II. Типы и операции
Далее мы приступим к исследованию языка программирования Py
thon и начнем его изучение с основных типов объектов, таких как
числа, списки, словари и т. д. Обладая только этими инструментами,
22 Предисловие
вы уже сможете писать достаточно сложные программы. Это самая
важная часть книги, потому что она закладывает основу для после
дующих глав. В этой части мы также рассмотрим динамическую
типизацию и ссылки – ключевые аспекты языка Python.
Часть III. Инструкции и синтаксис
В следующей части вводятся инструкции языка Python – программ
ный код на языке Python, который создает и обслуживает объекты.
Здесь также будет представлена общая синтаксическая модель Py
thon. Хотя эта часть в основном сосредоточена на описании синтак
сиса, тем не менее, здесь приводятся сведения о дополнительных
инструментальных средствах, таких как система PyDoc, и рассмат
риваются альтернативные стили написания программного кода.
Часть IV. Функции
В этой части мы начнем рассматривать выскоуровневые способы
структурирования программ на языке Python. Функции предостав
ляют простой способ упаковки программного кода многократного
использования и предотвращения появления избыточного кода.
В этой части мы исследуем правила видимости программных элемен
тов в языке Python, приемы передачи аргументов и многое другое.
Часть V. Модули
Модули Python позволяют организовать наборы инструкций и функ
ций в виде крупных компонентов, и в этой части будет показано,
как создавать модули, как их использовать и перезагружать. Здесь
мы также рассмотрим некоторые более сложные темы, такие как
пакеты модулей, перезагрузка модулей и переменная __name__.
Часть VI. Классы и ООП
Здесь мы приступим к исследованию объектноориентированного
программирования (ООП). Классы – это необязательный, но очень
мощный инструмент структурирования программного кода много
кратного использования. Здесь вы увидите, что классы по большей
части используют идеи, которые будут описаны к этому моменту,
а ООП в языке Python в основном представляет собой поиск имен
в связанных объектах. Здесь вы также увидите, что объектноори
ентированный стиль программирования в языке Python не являет
ся обязательным, но может существенно сократить время разработ
ки, особенно если речь идет о долгосрочных проектах.
Часть VII. Исключения и инструменты
Изучение языка мы закончим рассмотрением модели обработки ис
ключительных ситуаций, а также кратким обзором инструмен
тальных средств разработки, которые особенно удобны при разра
ботке крупных программ (например, инструменты отладки и тести
рования). Эта часть появляется в последний раз, в следующих вер
сиях все исключения должны быть классами.
Предисловие 23
Часть VIII. Приложения
Книга заканчивается двумя приложениями, где приводятся реко
мендации по использованию языка Python на различных платфор
мах (Приложение A) и варианты решения упражнений, которые
приводятся в конце каждой части (Приложение B). Ответы на кон
трольные вопросы, которые приводятся в конце каждой главы, на
ходятся непосредственно в самих главах.
Обратите внимание: предметный указатель и оглавление могут ис
пользоваться для поиска информации, но в этой книге нет приложе
ний со справочными материалами (эта книга – учебник, а не справоч
ник). Как уже говорилось выше, в качестве справочников по синтак
сису и встроенным особенностям языка Python вы можете использо
вать книгу «Python Pocket Reference» (O’Reilly) и справочники на
сайте http://www.python.org.
Обновления книги
Книга продолжает улучшаться (и исправляются оши#%& опечатки).
Обновления, дополнения и исправления к этой книге можно найти
в сети Интернет на одном из следующих сайтов:
http://www.oreilly.com/catalog/9780596513986/
(вебстраница книги на сайте издательства O’Reilly)
http://www.rmi.net/~lutz (сайт автора книги)
http://www.rmi.net/~lutz/about+lp.html
(вебстраница книги на сайте автора)
Последний из этих трех URL указывает на вебстраницу, где я выкла
дываю обновления, однако если эта ссылка окажется ошибочной, вам
придется воспользоваться поисковой системой, чтобы восстановить ее.
Если бы я был ясновидящим, я указал бы точную ссылку, но Интернет
меняется быстрее, чем печатаются книги.
О программах в этой книге
Эта книга и все примеры программ в ней основаны на использовании
Python 2.5. Я не стремлюсь предсказывать будущее, тем не менее, в хо
де изучения мы будем обсуждать некоторые идеи, которые, как ожи
дается, будут реализованы в версии 3.0.
Однако, так как эта книга описывает базовые основы языка, можно
быть уверенным, что большая часть из того, о чем здесь рассказывает
ся, в следующих версиях Python изменится не очень сильно. Большая
часть информации из этой книги применима и к более ранним версиям
Python, кроме некоторых случаев; и, естественно, в случае использо
вания расширений, которые появятся после выхода этой книги, ниче
го гарантировать нельзя.
24 Предисловие
Существует эмпирическое правило: лучшей версией Python является
последняя его версия. Так как эта книга описывает основы языка,
большинство сведений применимо к Jython – реализации Python на
языке Java, а также к другим реализациям, описанным в главе 2.
Исходные тексты примеров, а также ответы к заданиям можно полу
чить на вебсайте книги по адресу http://www.oreilly.com/catalog/
9780596513986/. Вас волнует вопрос, как запускать примеры? Он во
всех подробностях обсуждается в главе 3, поэтому потерпите до этой
главы.
В преддверии выхода Python 3.0
Первая альфаверсия Python 3.0 вышла как раз перед тем, как эта кни
га была отправлена в печать, уже после того, как она была написана.
Официально это издание книги основано на линейке версий Python 2.x
(в частности, на версии 2.5), но она была дополнена многочисленными
примечаниями об ожидаемых изменениях в версии Python 3.0.
Официальная версия 3.0 выйдет как минимум через год после выхода
этой книги и едва ли будет широко использоваться, по меньшей мере,
еще два года. Однако, если вы приобрели эту книгу, когда версия 3.0
уже получила широкое распространение, в этом разделе вы найдете
краткое описание изменений в языке, которое поможет вам выпол
нить переход на новую версию.
За редкими исключениями, в основном язык Python 3.0 будет соответ
ствовать описываемому в книге и влияние этих изменений на типич
ный программный код будет весьма незначительным. То есть основы
языка Python, о которых говорится в этой книге, не будут изменяться
от версии к версии, и благодаря этому читатели могут с пользой для се
бя изучать эти основы, прежде чем переходить к рассмотрению особен
ностей, характерных для конкретных версий.
Однако, чтобы помочь вам в будущем, ниже приводится список основ
ных отличий Python 3.0. Здесь же приводятся ссылки на главы, где об
суждаются или упоминаются эти изменения. Этот список упорядочен по
возрастанию номеров глав. Некоторые из этих изменений могут быть
реализованы в современной версии Python 2.5, а некоторые нет. По
скольку в данный момент для большинства читателей изучать этот спи
сок не имеет большого смысла, я рекомендую сначала прочитать эту кни
гу, чтобы изучить основы языка Python, а затем вернуться сюда позднее
и ознакомиться с грядущими изменениями. В версии Python 3.0:
• Удалена нынешняя встроенная функция execfile(). Вместо нее сле
дует использовать функцию exec() (глава 3).
• Встроенная функция reload() возможно будет удалена. Альтерна
тива пока не известна (главы 3 и 19).
• Преобразование в строковое представление с помощью обратных ка
вычек `X` будет недоступно: используйте функцию repr(X) (глава 5).
Предисловие 25
• Избыточная операция проверки на неравенство X<>Y будет удалена:
используйте операцию X!=Y (глава 5).
• Множества можно будет создавать с использованием синтаксиса
литералов {1, 3, 2}, что эквивалентно используемой в настоящее
время форме записи: set([1, 3, 2]) (глава 5).
• Множества могут определяться программно: {f(x) for x in S if P(x)},
что эквивалентно используемой в настоящее время форме записи
выражениягенератора: set(f(x) for x in S if P(x)) (глава 5).
• Операция деления X/Y всегда возвращает число с плавающей точ
кой, даже если оба операнда являются целыми числами. Чтобы по
лучить нынешнюю операцию деления с усечением дробной части,
следует использовать X//Y (глава 5).
• Существует единственный целочисленный тип int, который обеспе
чивает точность представления целых чисел, соответствующую ны
нешнему типу long (глава 5).
• Восьмеричные и двоичные литералы: текущая форма записи вось
меричных чисел 0666 будет вызывать ошибку: используйте вместо
нее запись в форме 0o666, соответствующим образом будет изменен
и результат, возвращаемый функцией oct(). Также запись в форме
0b1010 будет эквивалентна числу 10, а функция bin(10) будет воз
вращать "0b1010" (глава 5).
• Строковый тип str поддерживает текст Unicode, а для представления
строк с однобайтовыми символами создан новый тип bytes (например,
для случаев, когда текст загружается из файлов в двоичном режиме).
Тип bytes – это последовательность переменной длины малых целых
чисел с интерфейсом, несколько отличающимся от str (глава 7).
• Появился новый дополнительный способ форматирования строк,
так "See {0}, {1} and {foo}".format("A", "B", foo="C") вернет результат
"See A, B and C" (глава 7).
• Метод словаря D.has_key(X) будет удален. Вместо него следует ис
пользовать проверку на членство X in D (главы 4 и 8).
• Сравнение (при сортировке) смешанных нечисловых типов вместо
использования текущей реализации механизма упорядочения бу
дет вызывать исключение (главы 8 и 9).
• Методы словаря .keys(), .items() и .values() вместо списков будут
возвращать «представления» объектов, поддерживающие возмож
ность выполнения итераций. Чтобы вернуться к прежней логике
выполнения, следует выполнять принудительное преобразование
с помощью list() (глава 8).
• Согласно предыдущему пункту следующий шаблон программиро
вания будет неработоспособен: k = D.keys(); k.sort(); вместо него
следует использовать k = sorted(D) (главы 4 и 8).
• Встроенная функция file() может быть удалена. Вместо нее следу
ет использовать функцию open() (глава 9).
26 Предисловие
• Встроенная функция raw_input() будет переименована в input().
Чтобы обеспечить поддержку логики работы нынешней функции
input(), следует использовать eval(input()) (глава 10).
• Инструкция выполнения строки программного кода exec снова ста
нет встроенной функцией (глава 10).
• Появятся новые зарезервированные слова as, with и nonlocal. Со
гласно предыдущему пункту exec перестанет быть зарезервирован
ным словом (глава 11).
• Инструкция печати станет функцией, поддерживающей большое
число возможностей. Вместо print x, y следует использовать
print(x, y), а также можно использовать новые ключевые аргумен
ты функции для настройки параметров печати: file=sys.stdout,
sep=" " и end="\n" (глава 11).
• Появится расширенная реализация операции распаковки: инст
рукция, поддерживающая универсальную форму присваивания по
следовательности, такая как a, b, *rest = some_sequence, теперь будет
работать, как и *rest, a = stuff. Таким образом, число элементов
слева и справа от инструкции присваивания больше не должно сов
падать (глава 11).
• Автоматический режим распаковки кортежей через присваивание
последовательности для функций будет недоступен. Больше нельзя
будет записать def foo(a, (b, c)):, вместо этого необходимо будет
выполнять явное присваивание последовательности: def foo(a, bc):
b, c = bc (глава 11).
• Встроенная функция xrange() будет переименована в range(). То
есть в этой версии Python будет существовать только функция
range() (глава 13).
• В протоколе итераций метод X.next() будет переименован
в X.__next__(), и появится новая встроенная функция next(X), кото
рая будет вызывать метод X.__next__() объекта (главы 13 и 17).
• Встроенные функции zip(), map() и filter() будут возвращать ите
раторы. Чтобы вернуться к логике использования списков, следует
применять list() (главы 13 и 17).
• Функции могут включать необязательные комментарии, описываю
щие аргументы и результаты: так, в результате объявления def foo(x:
"spam", y: list(range(3))) > 42*2: к объектуфункции на этапе време
ни выполнения будет присоединен атрибутсловарь foo.func_an
notations: {'x': "spam", 'y': [0, 1, 2], "return": 84} (глава 15).
• Новая инструкция nonlocal x, y позволит выполнять присваивание
переменным в области видимости функции (глава 16).
• Функция apply(func, args, kws) будет удалена. Вместо нее следует
использовать синтаксическую конструкцию func(*args, **kws) (гла
вы 16 и 17).
Предисловие 27
• Встроенная функция reduce() будет удалена. Вместо нее организуй
те циклы, как показано в этой книге; lambda, map() и filter() будут
сохранены в версии 3.0 (глава 17).
• Все импортирование по умолчанию будет выполняться по абсолют
ному пути, а собственный каталог пакета будет пропускаться: для
выполнения импорта по относительному пути, как это делается сей
час, следует использовать синтаксическую конструкцию from . import
(глава 21).
• Все классы будут классами нового стиля и будут поддерживать со
временные новые расширения (глава 26).
• Наследование class Spam(object), необходимое для создания нынеш
них классов, будет необязательным для классов. В версии 3.0 и ны
нешняя «классика», и классы «нового стиля» будут относиться
к тому, что сейчас называется классами нового стиля (глава 26).
• В инструкции try конструкция except name превратится в конструк
цию except name as value (глава 27).
• В инструкции raise конструкция raise E, V должна будет записы
ваться как raise E(V), то есть экземпляр исключения должен созда
ваться явно (глава 27).
• Включен оператор контекста исключений with/as, описываемый
в этой книге (глава 27).
• Все пользовательские и встроенные исключения описываются
классами, а не строками (глава 28).
• Все исключения, определяемые пользователем, должны наследо
вать встроенный BaseEsception – корневой класс иерархии классов
исключений (Exception – это его подкласс и его вполне можно ис
пользовать в качестве базового для организации своей иерархии).
Встроенный класс StandardException будет ликвидирован (глава 28).
• Структура пакета стандартной библиотеки может быть существен
но изменена (подробности – в примечаниях к выпуску Python 3.0).
Список нововведений может показаться устрашающим на первый
взгляд, однако не следует забывать, что основы языка Python, описы
ваемые в этой книге, останутся неизменными и в версии 3.0. В дейст
вительности большая часть из того, что перечислено выше, будет ока
зывать на программистов не слишком большое влияние, если это
влияние вообще будет ощущаться.
Кроме того, следует отметить, что этот список попрежнему остается
достаточно гипотетическим и в конечном счете может оказаться непол
ным и неточным, поэтому за официальной информацией следует озна
комиться с примечаниями к выпуску Python 3.0. Если вы пишете про
граммный код для линейки Python 2.0, обратите внимание на сценарий
«2to3», который выполняет автоматическое преобразование программ
ного кода, написанного для интерпретатора версии 2.x в программный
28 Предисловие
код для интерпретатора версии 3.0. Этот сценарий будет поставляться
в составе Python 3.0.
Об этой серии
Книги издательства O’Reilly из серии «Изучаем…» предназначены для
тех, кто хочет приобрести новые знания и предпочитает структурный
подход к изучению. Каждая книга из этой серии использует принци
пы обучения, которые мы (не без вашей помощи) выработали для пере
дачи знаний, необходимых вам, чтобы присоединиться к новому про
екту, справиться с неожиданным заданием или быстро изучить новый
язык программирования.
Чтобы получить максимум пользы от любой книги из серии «Изуча
ем…», мы рекомендуем прорабатывать главы последовательно. Вы
увидите, что усвоение материала идет быстрее, если внимательно чи
тать указания и рекомендации, включенные в них. Вы можете также
использовать заключительные разделы для предварительного знаком
ства с ключевыми аспектами каждой главы и с тем, что вам предстоит
изучать. Наконец, чтобы помочь вам проверить степень усвоения ма
териала, каждая глава завершается разделом «Закрепление пройден
ного», который включает короткие контрольные вопросы. Кроме того,
каждая часть включает практические упражнения.
Книги серии «Изучаем…» работают с вами как надежный и проверен
ный коллега или преподаватель; мы стремимся сделать ваше обучение
как можно более приятным. Свои отзывы о нашей работе и предложе
ния по улучшению можете направлять по адресу learning@oreilly.com.
Использование программного кода примеров
Данная книга призвана оказать вам помощь в решении ваших задач. Вы
можете свободно использовать примеры программного кода из этой кни
ги в своих приложениях и в документации. Вам не нужно обращаться
в издательство за разрешением, если вы не собираетесь воспроизводить
существенные части программного кода. Например, если вы разрабаты
ваете программу и используете в ней несколько отрывков программного
кода из книги, вам не нужно обращаться за разрешением. Однако в слу
чае продажи или распространения компактдисков с примерами из этой
книги вам необходимо получить разрешение от издательства O’Reilly.
Если вы отвечаете на вопросы, цитируя данную книгу или примеры из
нее, получение разрешения не требуется. Но при включении существен
ных объемов программного кода примеров из этой книги в вашу доку
ментацию вам необходимо будет получить разрешение издательства.
Мы приветствуем, но не требуем добавлять ссылку на первоисточник
при цитировании. Под ссылкой на первоисточник мы подразумеваем
указание авторов, издательства и ISBN. Например: «Learning Python,
by Mark Lutz. Copyright 2008 O’Reilly Media, Inc., 9780596513986».
Предисловие 29
За получением разрешения на использование значительных объемов
программного кода примеров из этой книги обращайтесь по адресу per+
missions@oreilly.com.
Типографские соглашения
В этой книге приняты следующие соглашения:
Курсив
Курсив применяется для выделения адресов электронной почты,
URL, имен файлов и каталогов, а также терминов, когда они упо
минаются впервые.
Моноширинный шрифт
Применяется для представления содержимого файлов, вывода ко
манд, а также для выделения имен модулей, методов, инструкций
и команд.
Моноширинный жирный
Используется для выделения команд или текста, который должен
быть введен пользователем, а также для выделения участков про
граммного кода в листингах.
Моноширинный курсив
Обозначает замещаемые элементы в программном коде и коммента
рии.
<Моноширинный шрифт>
Таким способом выделяются синтаксические элементы, которые
должны замещаться действительным программным кодом.
Так выделяются советы, предложения или примечания общего
характера, имеющие отношение к расположенному рядом тексту.
Так выделяются предупреждения или предостережения, имею
щие отношение к расположенному рядом тексту.
В примерах этой книги символ % в начале системной командной строки
обозначает приглашение к вводу независимо от того, какое приглаше
ние используется на вашей машине (например, C:\Python25> в окне
Dos). Вам не нужно вводить символ %. Точно также в листингах, ото
бражающих сеанс работы с интерпретатором, не нужно вводить симво
лы >>> и ..., которые показаны в начале строки, – это приглашения
к вводу, которые выводятся интерпретатором Python. Вводите лишь
текст, который находится сразу же за этими приглашениями. Чтобы
помочь вам запомнить это правило, все, что должно вводиться пользо
вателем, выделено жирным шрифтом. Кроме того, обычно не требует
ся вводить текст в листингах, начинающийся с символа #, так как это
комментарии, а не исполняемый программный код.
30 Предисловие
Safari® Books Online
Если на обложке технической книги есть пиктограмма
«Safari® Books Online», это означает, что книга доступ
на в Сети через O’Reilly Network Safari Bookshelf.
Safari предлагает намного лучшее решение, чем электронные книги.
Это виртуальная библиотека, позволяющая без труда находить тысячи
лучших технических книг, вырезать и вставлять примеры кода, за
гружать главы и находить быстрые ответы, когда требуется наиболее
верная и свежая информация. Она свободно доступна по адресу http://
safari.oreilly.com.
Как с нами связаться
С вопросами и предложениями, касающимися этой книги, обращай
тесь в издательство:
O’Reilly Media
1005 Gravenstein Highway North
Sebastopol, CA 95472
8009989938 (в Соединенных Штатах Америки или в Канаде)
7078290515 (международный)
7078290104 (факс)
Список опечаток, файлы с примерами и другую дополнительную ин
формацию вы найдете на сайте книги:
http://www.oreilly.com/catalog/9780596513986
Свои пожелания и вопросы технического характера отправляйте по
адресу:
bookquestions@oreilly.com
Дополнительную информацию о книгах, обсуждения, Центр ресурсов
издательства O’Reilly вы найдете на сайте:
http://www.oreilly.com
Обновления и дополнения к книге вы также можете найти на сайтах,
упоминавшихся выше в этом предисловии.
Благодарности
Учитывая, что я работаю уже над третьим изданием этой книги, я не
могу не пребывать в настроении, что «сложное задание выполнено».
Я использовал и пропагандировал Python на протяжении 15 лет и обу
чал этому языку 10 лет. Несмотря на то, что все течет и все меняется,
я попрежнему поражаюсь успеху, который сопутствует языку Python.
В 1992 году большинство из нас едва ли могло предполагать, какими
путями он будет развиваться. Но, чтобы не выглядеть безнадежно эго
Предисловие 31
центричным, я хотел бы немного вспомнить о прошлом и сказать не
сколько слов благодарности.
Это была длинная и извилистая дорога. Огладываясь назад, когда
в 1992 году я открыл для себя Python, я предположить не мог, какое
влияние он будет оказывать на мою жизнь в следующие 15 лет. Через
два года после начала работы над первым изданием «Learning Python»
в 1995 году я начал путешествовать по стране и миру, обучая начинаю
щих программистов этому языку программирования. После выхода
первого издания в 1999 году преподавание Python и работа над книга
ми стали моей основной работой, во многом благодаря интенсивному
росту популярности Python.
В середине 2007 года, когда я пишу эти слова, мною уже написано де
вять книг о Python; опыт преподавания Python насчитывает более
10 лет. Проведя более 200 курсов в США, Европе, Канаде и Мексике,
я обучил более 3000 студентов. Помимо множества мучительных ча
сов, проведенных в самолетах, эти курсы дали мне возможность суще
ственно улучшить эту и другие книги о Python. За эти годы преподава
ние помогало улучшать качество книг, а работа над книгами – качест
во преподавания. Фактически книга, которую вы читаете, была почти
полностью получена из программы моих курсов.
В связи с этим я хотел бы поблагодарить всех студентов, которые уча
ствовали в моих курсах на протяжении последних 10 лет. Как разви
тие языка Python, так и ваши отзывы сыграли немаловажную роль
в становлении этой книги. (Нет ничего более поучительного, чем на
блюдение за 3000 студентами, которые совершают одни и те же ошиб
ки, свойственные начинающим программистам!) Это издание стало
возможным в первую очередь благодаря тем, кто посещал мои курсы
после 2003 года, и тем не менее, все, кто посещал мои курсы, начиная
с 1997 года, так или иначе помогли в улучшении этой книги. Я особен
но хотел бы поблагодарить компании, предоставившие помещения для
проведения курсов в Дублине, Мехико, Барселоне, Лондоне, Эдмон
тоне и Пуэрто Рико; лучшие условия аренды трудно себе представить.
Я также хотел бы выразить свою благодарность всем, кто принимал
участие в производстве этой книги. Редакторам, работавшим над этим
проектом: Татьяне Апанди (Tatiana Apandi), работавшей над этим из
данием, и многим другим редакторам, работавшим над предыдущими
изданиями. Лизе Дейли (Liza Daly) за участие в техническом обзоре
этой книги. И издательству O’Reilly, за то что я получил шанс рабо
тать над этими девятью проектами книг – это было здорово (правда,
порой я чувствовал себя как герой фильма «День сурка»).
Я хочу поблагодарить своего первого соавтора Дэвида Ашера (David
Ascher) за его работу над ранними изданиями этой книги. Дэвид на
писал часть «Outer Layers (Внешние уровни)» для предыдущих изда
ний, которую мы, к сожалению, убрали из книги, чтобы освободить
место для новых материалов об основах языка Python. В это издание
32 Предисловие
я добавил больше усложненных программ и заключительное упраж
нение для самостоятельного изучения, но это не компенсирует все то,
что пришлось вырезать. Если вам не хватает этого материала, прочи
тайте ранее приведенные в предисловии примечания по поводу книг,
описывающих вопросы прикладного программирования.
За создание такого замечательного и полезного языка я должен поблаго
дарить Гвидо ван Россума (Guido van Rossum) и все сообщество разработ
чиков и пользователей Python. Подобно большинству программных про
дуктов с открытыми исходными текстами Python развивается благода
ря героическим усилиям многих программистов. Обладая 15летним
опытом программирования на Python, я попрежнему нахожу его серь
езной забавой. Мне очень повезло, что я смог наблюдать, как из малень
кого младенца в семействе языков сценариев Python вырос в популяр
ный инструмент, которым пользуются практически все компании, зани
мающиеся разработкой программного обеспечения. Участвовать в этом
процессе было очень волнующим занятием, и поэтому я хотел бы побла
годарить и поздравить с достигнутыми успехами все сообщество Python.
Я также хотел бы поблагодарить своего первого редактора из изда
тельства O’Reilly, Фрэнка Уиллисона (Frank Willison). Идея этой кни
ги во многом принадлежит Фрэнку, и в ней нашли отражение его
взгляды. Оглядываясь назад, можно заметить, что Фрэнк оказал су
щественное влияние как на мою карьеру, так и на Python. Не будет
преувеличением сказать, что успех развития Python на начальном эта
пе в определенной степени обусловлен влиянием Фрэнка. Мы по
прежнему скучаем по нему.
В заключение хотелось бы выразить личную благодарность. Компании
OQO за самые лучшие игрушки, какие я только видел. Покойному
Карлу Сагану (Carl Sagan), за то что вдохновил 18летнего мальчишку
из Висконсина. Йону Стюарту (Jon Stewart) и Майклу Муру (Michael
Moore) за патриотизм. И всем крупным корпорациям, с которыми мне
приходилось иметь дело, за то, что напоминают мне о том, как это здо
рово – работать на самого себя.
Моим детям, Майку (Mike), Сэмми (Sammy) и Рокси (Roxy), за любую
будущность, которую они выберут. Вы были детьми, когда я начинал
работать с языком Python, и вы какимто образом выросли за это вре
мя; я горжусь вами. Жизнь может перекрыть нам все пути, но путь до
мой всегда остается открытым.
Но больше всего я благодарен Вере (Vera), моему лучшему другу, моей
подруге и моей жене. День, когда я нашел тебя, был лучшим днем
в моей жизни. Я не знаю, что принесут мне следующие 50 лет, но
я знаю, что хотел бы прожить их рядом с тобой.
Марк Лутц (Mark Lutz)
Бертуд, Колорадо
Июль 2007
I
Введение

1
Python в вопросах и ответах
Если вы купили эту книгу, вы, скорее всего, уже знаете, что такое Py
thon и насколько важно овладеть этим инструментом. Если это не так,
вы наверняка не сможете зарабатывать на Python, пока не изучите
язык, прочитав оставшуюся часть этой книги, и не напишете пару
проектов. Но прежде чем мы приступим к изучению деталей, давайте
сначала рассмотрим основные причины высокой популярности языка
Python. Перед тем как приступить собственно к языку Python, в этой
главе рассматриваются некоторые вопросы, которые обычно задают
начинающие программисты, и даются ответы на них.
Почему программисты используют Python?
Это самый типичный вопрос, который задают начинающие програм
мисты, потому что на сегодняшний день существует масса других язы
ков программирования. Учитывая, что число пользователей Python
составляет порядка 1 миллиона человек, достаточно сложно однознач
но ответить на этот вопрос. Выбор средств разработки иногда зависит
от уникальных особенностей и личных предпочтений.
Однако после обучения примерно 200 групп и 3000 студентов за по
следние 10 лет у меня накопились некоторые общие мысли по этому
поводу. Основные факторы, которые приводятся пользователями Py
thon, примерно таковы:
Качество программного обеспечения
Для многих основное преимущество языка Python заключается
в удобочитаемости, ясности и более высоком качестве, отличающи
ми его от других инструментов в мире языков сценариев. Программ
ный код на языке Python читается легче, а значит, многократное
его использование и обслуживание выполняется гораздо проще, чем
использование программного кода на других языках сценариев.
36 Глава 1. Python в вопросах и ответах
Единообразие оформления программного кода на языке Python об
легчает его понимание даже для тех, кто не участвовал в создании
этого кода. Кроме того, Python поддерживает самые современные
механизмы многократного использования программного кода, ка
ким является объектноориентированное программирование (ООП).
Высокая скорость разработки
По сравнению с компилирующими или строго типизированными
языками, такими как C, C++ и Java, Python во много раз повышает
производительность труда разработчика. Объем программного кода
на языке Python обычно составляет треть или даже пятую часть эк
вивалентного программного кода на языке C++ или Java. Это озна
чает меньший объем ввода с клавиатуры, меньшее количество вре
мени на отладку и меньший объем трудозатрат на сопровождение.
Кроме того, программы на языке Python запускаются сразу же, ми
нуя длительные этапы компиляции и связывания, необходимые
в некоторых других языках программирования, что еще больше
увеличивает производительность труда программиста.
Переносимость программ
Большая часть программ на языке Python выполняется без измене
ний на всех основных платформах. Перенос программного кода из
операционной системы Linux в Windows обычно заключается в про
стом копировании программного кода сценария с одной машины на
другую. Более того, Python предоставляет массу возможностей по
созданию переносимых графических интерфейсов, программ досту
па к базам данных, вебприложений и многих других типов про
грамм. Даже интерфейсы операционных систем, включая способ
запуска программ и обработку каталогов, в языке Python реализо
ваны переносимым способом.
Поддержка библиотек
В составе Python поставляется большое число собранных и перено
симых функциональных возможностей, известных как стандарт+
ная библиотека. Эта библиотека предоставляет массу возможно
стей, востребованных в прикладных программах, начиная от поис
ка текста по шаблону и заканчивая сетевыми функциями. Кроме
того, Python допускает расширение, как за счет ваших собственных
библиотек, так и за счет библиотек, созданных сторонними разра
ботчиками. Из числа сторонних разработок можно назвать инстру
менты создания вебсайтов, программирование математических
вычислений, доступ к последовательному порту, разработку игро
вых программ и многое другое. Например, расширение NumPy по
зиционируется как свободный и более мощный эквивалент системы
программирования математических вычислений Mathlab.
Интеграция компонентов
Сценарии Python легко могут взаимодействовать с другими частя
ми приложения благодаря различным механизмам интеграции.
Почему программисты используют Python? 37
Эта интеграция позволяет использовать Python для настройки и
расширения функциональных возможностей программных про
дуктов. На сегодняшний день программный код на языке Python
имеет возможность вызывать функции из библиотек на языке C/
C++, сам вызываться из программ, написанных на языке C/C++,
интегрироваться с Javaкомпонентами, взаимодействовать с такими
платформами, как COM и .NET, и производить обмен данными по
сети с помощью таких протоколов, как SOAP, XMLRPC и CORBA.
Python не является обособленным инструментом.
Удовольствие
Благодаря непринужденности языка Python и наличию встроен
ных инструментальных средств процесс программирования может
приносить удовольствие. На первый взгляд это трудно назвать пре
имуществом, тем не менее, удовольствие, получаемое от работы,
напрямую влияет на производительность труда.
Из всех перечисленных факторов наиболее существенными для поль
зователей являются первые два (качество и производительность).
Качество программного обеспечения
По своей природе Python имеет простой, удобочитаемый синтаксис и яс
ную модель программирования. Согласно лозунгу, выдвинутому на
недавней конференции по языку Python, основное его преимущество
состоит в том, что Python «каждому по плечу» – характеристики язы
ка взаимодействуют ограниченным числом непротиворечивых спосо
бов и естественно вытекают из небольшого круга базовых концепций.
Это делает язык простым в освоении, понимании и запоминании. Про
граммистам, использующим язык Python, почти не приходится при
бегать к справочным руководствам – это непротиворечивая система,
на выходе которой получается профессиональный программный код.
Философия Python диктует использование минималистского подхода.
Это означает, что даже при наличии нескольких вариантов решения
задачи в этом языке обычно существует всего один очевидный путь,
небольшое число менее очевидных альтернатив и несколько взаимосвя
занных вариантов организации взаимодействий. Более того, Python не
принимает решения за вас, когда порядок взаимодействий неочевиден –
предпочтение отдается явному описанию, а не «волшебству». В терми
нах Python явное лучше неявного, а простое лучше сложного.1
1 Чтобы получить более полное представление о философии Python, введите
в командной строке интерпретатора команду import this (как это сделать,
будет рассказано в главе 2). В результате будет активизировано «пасхаль
ное яйцо», скрытое в недрах Python, – сборник принципов проектирова
ния, лежащих в основе Python. Аббревиатура EIBTI, происходящая от фра
зы «explicit is better than implicit» («явное лучше неявного»), превратилась
в модное жаргонное словечко.
38 Глава 1. Python в вопросах и ответах
Помимо философии Python обладает такими возможностями, как мо
дульное и объектноориентированное программирование, что естест
венно упрощает возможность многократного использования программ
ного кода. Поскольку качество находится в центре внимания самого
языка Python, оно также находится в центре внимания программистов.
Высокая скорость разработки
Во время бума развития Интернета во второй половине 1990х годов,
было сложно найти достаточное число программистов для реализации
программных проектов – от разработчиков требовалось писать про
граммы со скоростью развития Интернета. Теперь, в эпоху экономиче
ского спада, картина изменилась. Сегодня от программистов требует
ся умение решать те же задачи меньшим числом сотрудников.
В обоих этих случаях Python блистал как инструмент, позволяющий
программистам получать большую отдачу при меньших усилиях. Он
изначально оптимизирован для достижения высокой скорости разра+
ботки – простой синтаксис, динамическая типизация, отсутствие эта
па компиляции и встроенные инструментальные средства позволяют
программистам создавать программы за меньшее время, чем при ис
пользовании некоторых других инструментов. В результате Python
увеличивает производительность труда разработчика во много раз по
сравнению с традиционными языками программирования. Это значи
тельное преимущество, которое с успехом может использоваться как
во время бума, так и во время спада, а также во время любого проме
жуточного этапа развития индустрии программного обеспечения.
Является ли Python «языком сценариев»?
Python – это многоцелевой язык программирования, который зачас
тую используется для создания сценариев. Обычно он определяется
как объектно+ориентированный язык сценариев – такое определение
смешивает поддержку ООП с общей ориентацией на сценарии. Дейст
вительно, для обозначения файлов с программным кодом на языке Py
thon программисты часто используют слово «сценарий» вместо слова
«программа». В этой книге термины «сценарий» и «программа» рас
сматриваются как взаимозаменяемые, с некоторым предпочтением
термина «сценарий» для обозначения простейших программ, поме
щающихся в единственный файл, и термина «программа» для обозна
чения более сложных приложений, программный код которых разме
щается в нескольких файлах.
Термин «язык сценариев» имеет множество различных толкований.
Некоторые предпочитают вообще не применять его к языку Python.
У большинства термин «язык сценариев» вызывает три разных ассо
циации, из которых одни более применимы к языку Python, чем другие:
Является ли Python «языком сценариев»? 39
Командные оболочки
Иногда, когда ктото слышит, что Python – это язык сценариев, то
представляет себе Python как инструмент для создания системных
сценариев. Такие программы часто запускаются из командной
строки с консоли и решают такие задачи, как обработка текстовых
файлов и запуск других программ.
Программы на языке Python способны решать такие задачи, но это
лишь одна из десятков прикладных областей, где может приме
няться Python. Это не только язык сценариев командной оболочки.
Управляющий язык
Другие пользователи под названием «язык сценариев» понимают
«связующий» слой, который используется для управления (то есть
для описания сценария работы) другими прикладными компонен
тами. Программы на языке Python действительно нередко исполь
зуются в составе крупных приложений. Например, при проверке
аппаратных устройств программы на языке Python могут вызывать
компоненты, осуществляющие низкоуровневый доступ к устройст
вам. Точно так же программы могут запускать программный код на
языке Python для поддержки настройки программного продукта
у конечного пользователя, что ликвидирует необходимость постав
лять и пересобирать полный объем исходных текстов.
Простота языка Python делает его весьма гибким инструментом
управления. Тем не менее, технически – это лишь одна из многих ро
лей, которые может играть Python. Многие программисты пишут на
языке Python автономные сценарии, которые не используют какие
либо интегрированные компоненты. Это не только язык управления.
Удобство в использовании
Пожалуй, лучше всего представлять себе термин «язык сценариев»
как обозначение простого языка, используемого для быстрого ре
шения задач. Это особенно верно, когда термин применяется к язы
ку Python, который позволяет вести разработку гораздо быстрее,
чем компилирующие языки программирования, такие как C++.
Ускоренный цикл разработки способствует применению зондирую
щего, поэтапного стиля программирования, который следует по
пробовать, чтобы оценить по достоинству.
Не надо заблуждаться, Python предназначен не только для реше
ния простых задач. Скорее он упрощает решение задач, благодаря
своей простоте и гибкости. Язык Python имеет небольшой набор
возможностей, но он позволяет создавать программы неограничен
ной сложности. По этой причине Python обычно используется как
для быстрого решения тактических, так и для решения долговре
менных, стратегических задач.
Итак, является ли Python языком сценариев? Ответ зависит от того,
к кому обращен вопрос. Вообще термин «создание сценариев», вероят
40 Глава 1. Python в вопросах и ответах
но, лучше использовать для описания быстрого и гибкого способа раз
работки, который поддерживается языком Python, а не для описания
прикладной области программирования.
Все хорошо, но есть ли у него недостатки?
После 15 лет работы с языком Python и 10 лет преподавания единст
венный недостаток, который мне удалось обнаружить, – это скорость
выполнения программ, которая не всегда может быть такой же высо
кой, как у программ, написанных на компилирующих языках про
граммирования, таких как C или C++.
Подробнее о концепциях реализации мы поговорим ниже в этой кни
ге. В двух словах замечу, что в современной реализации Python ком
пилирует (то есть транслирует) инструкции исходного программного
кода в промежуточное представление, известное как байт+код, и затем
интерпретирует этот байткод. Байткод обеспечивает переносимость
программ, поскольку это платформонезависимый формат. Однако, из
за того что Python не создает двоичный машинный код (например, ма
шинные инструкции для микропроцессора Intel), некоторые програм
мы на языке Python могут работать медленнее своих аналогов, напи
санных на компилирующих языках, таких как C.
Будет ли вас когданибудь волновать разница в скорости выполнения
программ, зависит от того, какого рода программы вы пишете. Python
многократно подвергался оптимизации, и в отдельных прикладных
областях программный код на этом языке отличается достаточно вы
сокой скоростью выполнения. Кроме того, когда в сценарии Python де
лается чтонибудь «значительное», например обрабатывается файл
или конструируется графический интерфейс, ваша программа факти
чески выполняется со скоростью, которую способен дать язык C, пото
му что такого рода задачи решаются компилированным с языка С про
граммным кодом, лежащим в недрах интерпретатора Python. Гораздо
важнее, что преимущество в скорости разработки порой важнее поте
ри скорости выполнения, особенно если учесть быстродействие совре
менных компьютеров.
Тем не менее, даже при высоком быстродействии современных процес
соров остаются такие области, где требуется максимальная скорость
выполнения. Реализация математических вычислений и анимацион
ных эффектов, например, часто требуют наличия базовых вычисли
тельных компонентов, которые решают свои задачи со скоростью язы
ка C (или еще быстрее). Если вы работаете как раз в такой области, вы
все равно сможете использовать Python, достаточно лишь выделить из
приложения компоненты, требующие максимальной скорости рабо
ты, в виде компилированных расширений и связать их системой сце
нариев на языке Python.
В этой книге мы не будем обсуждать расширения слишком подробно,
но это один из примеров, когда Python может играть упоминавшуюся
Кто в наше время использует Python? 41
выше роль языка управления. Типичным примером такой двуязыч
ной стратегии может служить расширение NumPy, содержащее реали
зацию математических вычислений для Python; благодаря комбиниро
ванию компилированных и оптимизированных библиотек расширения
с языком Python, NumPy превращает Python в мощный, эффективный
и удобный инструмент математических вычислений. Возможно, вам
никогда не придется создавать подобные расширения, но вы должны
знать, что в случае необходимости они могут предоставить в ваше рас
поряжение мощный механизм оптимизации.
Кто в наше время использует Python?
К моменту, когда я пишу эти строки (2007 год), наиболее правдоподоб
ной оценкой числа пользователей Python является число, близкое
к 1 миллиону человек во всем мире (с небольшой погрешностью). Эта
оценка основана на различных статистических показателях, таких как
количество загрузок и результаты опросов разработчиков. Дать более
точную оценку достаточно сложно, потому что Python является откры
тым программным обеспечением – для его использования не требуется
проходить лицензирование. Более того, Python по умолчанию включа
ется в состав дистрибутивов Linux, поставляется вместе с компьютера
ми Macintosh и некоторыми другими программными и аппаратными
продуктами, что существенно искажает оценку числа пользователей.
Вообще же количество пользователей Python значительно больше
и вокруг него сплотилось очень активное сообщество разработчиков.
Благодаря тому что Python появился более 15 лет тому назад и полу
чил широкое распространение, он отличается высокой стабильностью
и надежностью. Python используется не только отдельными пользова
телями, он также применяется настоящими компаниями для созда
ния продуктов, приносящих настоящую прибыль. Например:
• Компания Google широко использует Python в своей поисковой сис
теме и оплачивает труд создателя Python.
• Служба коллективного использования видеоматериалов YouTube
в значительной степени реализована на языке Python.
• Популярная программа BitTorrent для обмена файлами в пиринго
вых сетях (peertopeer) написана на языке Python.
• Такие компании, как Intel, Cisco, HewlettPackard, Seagate, Qual
comm и IBM используют Python для тестирования аппаратного
обеспечения.
• Такие компании, как Industrial Light & Magic, Pixar и другие ис
пользуют Python в производстве анимационных фильмов.
• Компании JPMorgan Chase, UBS, Getco и Citadel применяют Python
для прогнозирования финансового рынка.
• NASA, Los Alamos, Fermilab, JPL и другие используют Python для
научных вычислений.
42 Глава 1. Python в вопросах и ответах
• iRobot использует Python в разработке коммерческих роботизиро
ванных пылесосов.
• ESRI использует Python в качестве инструмента настройки своих
популярных геоинформационных программных продуктов под ну
жды конечного пользователя.
• NSA использует Python для шифрования и анализа разведданных.
• В реализации почтового сервера IronProt используется более 1 мил
лиона строк программного кода на языке Python.
• Проект «ноутбук каждому ребенку» (One Laptop Per Child, OLPC)
строит свой пользовательский интерфейс и модель функционирова
ния на языке Python.
И так далее. Пожалуй, единственное, что объединяет все эти компа
нии, – это то, что для решения широкого спектра задач прикладного
программирования используется язык программирования Python.
Универсальная природа языка обеспечивает возможность его приме
нения в самых разных областях. Фактически, с определенной долей
уверенности можно утверждать, что Python так или иначе использует
ся практически каждой достаточно крупной организацией, занимаю
щейся разработкой программного обеспечения, – как для решения
краткосрочных тактических задач, так и для разработки долгосроч
ных стратегических проектов. Как оказалось, Python прекрасно заре
комендовал себя в обоих случаях.
За дополнительными сведениями о компаниях, использующих Py
thon, обращайтесь на вебсайт http://www.python.org.
Что можно делать с помощью Python?
Кроме того, будучи удачно спроектированным языком программиро
вания, Python прекрасно подходит для решения реальных задач из
разряда тех, которые разработчикам приходится решать ежедневно.
Он используется в самом широком спектре применений – и как инст
румент управления другими программными компонентами, и для реа
лизации самостоятельных программ. Фактически, круг ролей, кото
рые может играть Python как многоцелевой язык программирования,
практически не ограничен: он может использоваться для реализации
всего, что угодно, – от вебсайтов и игровых программ до управления
роботами и космическими кораблями.
Однако сферу использования Python в настоящее время можно разбить
на несколько широких категорий. Следующие несколько разделов опи
сывают наиболее типичные области применения Python в наши дни,
а также инструментальные средства, используемые в каждой из облас
тей. У нас не будет возможности заняться исследованием инструмен
тов, упоминаемых здесь. Если какието из них заинтересуют вас, обра
щайтесь на вебсайт проекта Python за более подробной информацией.
Что можно делать с помощью Python? 43
Системное программирование
Встроенные в Python интерфейсы доступа к службам операционных
систем делают его идеальным инструментом для создания переноси
мых программ и утилит системного администрирования (иногда они
называются инструментами командной оболочки). Программы на
языке Python могут отыскивать файлы и каталоги, запускать другие
программы, производить параллельные вычисления с использовани
ем нескольких процессов и потоков и делать многое другое.
Стандартная библиотека Python обеспечивает возможность связыва
ния в соответствии с требованиями стандартов POSIX и поддерживает
все типичные инструменты операционных систем: переменные окру
жения, файлы, сокеты, каналы, процессы, многопоточную модель ис
полнения, поиск по шаблону с использованием регулярных выраже
ний, аргументы командной строки, стандартные интерфейсы доступа
к потокам данных, запуск команд оболочки, дополнение имен файлов
и многое другое. Кроме того, системные интерфейсы в языке Python
созданы переносимыми, например, сценарий копирования дерева ка
талогов не требует внесения изменений, в какой бы операционной сис
теме он ни использовался.
Графический интерфейс
Простота Python и высокая скорость разработки делают его отличным
средством разработки графического интерфейса. В состав Python вхо
дит стандартный объектноориентированный интерфейс к Tk GUI API,
который называется Tkinter, позволяющий программам на языке Py
thon реализовать переносимый графический интерфейс с внешним ви
дом, присущим операционной системе. Графические интерфейсы на
базе Python/Tkinter без изменений могут использоваться в MS Win
dows, X Window (в операционных системах UNIX и Linux) и Mac OS
(как в классической версии, так и в OS X). Свободно распространяемый
пакет расширения PMW содержит дополнительные визуальные ком
поненты для набора Tkinter. Кроме того, существует прикладной ин
терфейс wxPython GUI API, основанный на библиотеке C++, который
предлагает альтернативный набор инструментальных средств по
строения переносимых графических интерфейсов на языке Python.
Инструменты высокого уровня, такие как PythonCard и Dabo, построе
ны на основе таких API, как wxPython и Tkinter. При выборе соответ
ствующей библиотеки вы также сможете использовать другие инстру
менты создания графического интерфейса, такие как Qt, GTK, MFC
и Swing. Для разработки приложений с вебинтерфейсом или не предъ
являющих высоких требований к интерфейсу можно использовать Jy
thon (реализация Python на языке Java, описывается в главе 2) и CGI
сценарии, которые обеспечивают дополнительные возможности по
созданию пользовательского интерфейса.
44 Глава 1. Python в вопросах и ответах
Вебсценарии
Интерпретатор Python поставляется вместе со стандартными интер
нетмодулями, которые позволяют программам выполнять разнооб
разные сетевые операции как в режиме клиента, так и в режиме серве
ра. Сценарии могут производить взаимодействия через сокеты, извле
кать информацию из форм, отправленных серверным CGIсценариям;
передавать файлы по протоколу FTP; обрабатывать файлы XML; пере
давать, принимать, создавать и производить разбор писем электронной
почты; загружать вебстраницы с указанных адресов URL; произво
дить разбор кода HTML и XML полученных вебстраниц; производить
взаимодействия по протоколам XMLRPC, SOAP и Telnet; и многое
другое. Библиотеки, входящие в состав Python, делают реализацию
подобных задач удивительно простым делом.
Кроме того, существует огромная коллекция сторонних инструментов
для создания сетевых программ на языке Python, которые можно найти
в Интернете. Например, система HTMLGen позволяет создавать HTML
страницы на основе описаний классов Python. Пакет mod_python пред
назначен для запуска сценариев на языке Python под управлением веб
сервера Apache и поддерживает шаблоны механизма Python Server
Pages. Система Jython обеспечивает бесшовную интеграцию Python/
Java и поддерживает серверные апплеты, которые выполняются на
стороне клиента. Помимо этого для Python существуют полноценные
пакеты вебразработки, такие как Django, TurboGears, Pylons, Zope
иWebWare, поддерживающие возможность быстрого создания полно
функциональных высококачественных вебсайтов на языке Python.
Интеграция компонентов
Возможность интеграции программных компонентов в единое прило
жение с помощью Python уже обсуждалась выше, когда мы говорили
о Python как о языке управления. Возможность Python расширяться
и встраиваться в системы на языке C и C++ делает его удобным и гиб
ким языком для описания поведения других систем и компонентов.
Например, интеграция с библиотекой на языке C позволяет Python
проверять наличие и запускать библиотечные компоненты, а встраи
вание Python в программные продукты позволяет производить на
стройку программных продуктов без необходимости пересобирать эти
продукты или поставлять их с исходными текстами.
Такие инструменты, как SWIG и SIP, автоматически генерирующие
программный код, могут автоматизировать действия по связыванию
скомпилированных компонентов в Python для последующего их ис
пользования в сценариях. А такие огромные платформы, как под
держка COM в MS Windows, Jython – реализация на языке Java, Iron
Python – реализация на базе .NET и разнообразные реализации CORBA,
предоставляют альтернативные возможности организации взаимодей
ствий с компонентами. Например, в операционной системе Windows
Что можно делать с помощью Python? 45
сценарии на языке Python могут использовать платформы управления
такими приложениями, как MS Word и Excel.
Приложения баз данных
В языке Python имеются интерфейсы доступа ко всем основным реля
ционным базам данных – Sybase, Oracle, Informix, ODBC, MySQL,
PostgreSQL, SQLite и многим другим. В мире Python существует также
переносимый прикладной программный интерфейс баз данных, пред
назначенный для доступа к базам данных SQL из сценариев на языке
Python, который унифицирует доступ к различным базам данных. На
пример, при использовании переносимого API сценарий, предназна
ченный для работы со свободной базой данных MySQL, практически
без изменений сможет работать с другими системами баз данных (та
кими как Oracle). Все, что потребуется сделать для этого, – заменить
используемый низкоуровневый интерфейс.
Стандартный модуль pickle реализует простую систему хранения объ+
ектов, что позволяет программам сохранять и восстанавливать объек
ты Python в файлах или в специализированных объектах. В Сети мож
но также найти систему сторонних разработчиков, которая называется
ZODB. Она представляет собой полностью объектноориентированную
базу данных для использования в сценариях на языке Python. Сущест
вует еще один инструмент под названием SQLObject, который отобра
жает реляционные таблицы в модель классов языка Python. В версии
Python 2.5 стандартной частью Python стала база данных SQLite.
Быстрое создание прототипов
В программах на языке Python компоненты, написанные на Python
и на C, выглядят одинаково. Благодаря этому можно сначала созда
вать прототипы систем на языке Python, а затем переносить выбранные
компоненты на компилирующие языки, такие как C и C++. В отличие
от ряда других инструментов разработки прототипов, Python не требу
ет, чтобы система была полностью переписана, как только прототип
будет отлажен. Части системы, которые не требуют такой эффективно
сти выполнения, какую обеспечивает C++, можно оставить на языке
Python, что существенно упростит ее сопровождение и использование.
Программирование математических
и научных вычислений
Расширение NumPy для математических вычислений, упоминавшееся
выше, включает такие мощные элементы, как объектмассив, интер
фейсы к стандартным математическим библиотекам и многое другое.
Расширение NumPy – за счет интеграции с математическими библиоте
ками, написанными на компилирующих языках программирования, –
превращает Python в сложный, но удобный инструмент программиро
вания математических вычислений, который зачастую может заменить
46 Глава 1. Python в вопросах и ответах
существующий программный код, написанный на традиционных ком
пилирующих языках, таких как FORTRAN и C++. Дополнительные
инструменты математических вычислений для Python поддерживают
возможность создания анимационных эффектов и трехмерных объек
тов, позволяют организовать параллельные вычисления и т. д.
Игры, изображения, искусственный интеллект,
XMLроботы и многое другое
Язык программирования Python можно использовать для решения бо
лее широкого круга задач, чем может быть упомянуто здесь. Напри
мер, с помощью системы pygame можно создавать игровые программы
и анимационные ролики; обрабатывать изображения с помощью паке
та PIL и других; управлять роботом с помощью инструмента PyRo;
производить разбор XMLдокументов с помощью пакета библиотек
xml, модуля xmlrpclib и расширений сторонних разработчиков; про
граммировать искусственный интеллект с помощью эмулятора нейро
сетей и оболочек экспертных систем; анализировать фразы на естест
венном языке с помощью пакета NLTK. Можно даже разложить пась
янс с помощью программы PySol. Поддержку многих других приклад
ных областей можно найти на вебсайтах Vaults of Parnassus и PyPI
(ищите ссылки с помощью Google или на сайте http://www.python.org).
Вообще говоря, многие из этих областей применения Python – всего
лишь разновидности одной и той же роли под названием «интеграция
компонентов». Использование Python в качестве интерфейса к биб
лиотекам компонентов, написанных на языке C, делает возможным
создание сценариев на языке Python для решения задач в самых раз
ных прикладных областях. Как универсальный, многоцелевой язык
программирования, поддерживающий возможность интеграции, Py
thon может применяться очень широко.
В чем сильные стороны Python?
Естественно – это вопрос разработчика. Если у вас еще нет опыта про
граммирования, язык следующих нескольких разделов может пока
заться немного непонятным, но не волнуйтесь, мы будем рассматри
вать все эти термины позднее, в ходе изложения материала. А для раз
работчиков ниже приводится краткое введение в некоторые особенно
сти языка Python.
Он объектноориентированный
Python изначально является объектноориентированным языком про
граммирования. Его объектная модель поддерживает такие понятия,
как полиморфизм, перегрузка операторов и множественное наследова
ние, однако, учитывая простоту синтаксиса и типизации Python, ООП
не вызывает сложностей в применении. Если эти термины вам непо
В чем сильные стороны Python? 47
нятны, позднее вы обнаружите, что изучать Python гораздо легче, чем
другие объектноориентированные языки программирования.
Объектноориентированная природа Python, являясь мощным средст
вом структурирования программного кода многократного пользова
ния, кроме того, делает этот язык идеальным инструментом поддерж
ки сценариев для объектноориентированных языков, таких как C++
и Java. Например, при наличии соответствующего связующего про
граммного кода программы на языке Python могут использовать меха
низм наследования от классов, реализованных на C++, Java и C#.
Как бы то ни было, но ООП не является обязательным в Python; вы
сможете стать опытным программистом и при этом не быть специали
стом по ООП. Как и C++, Python поддерживает оба стиля программи
рования – процедурный и объектноориентированный. Объектноори
ентированные механизмы могут использоваться по мере необходимо
сти. Это особенно удобно при решении тактических задач, когда отсут
ствует фаза проектирования.
Он свободный
Python может использоваться и распространяться совершенно бес
платно. Как и в случае с другими открытыми программными продук
тами, такими как Tcl, Perl, Linux и Apache, вы сможете получить в Ин
тернете полные исходные тексты реализации Python. Нет никаких ог
раничений на его копирование, встраивание в свои системы или распро
странение в составе ваших продуктов. Фактически вы сможете даже
продавать исходные тексты Python, если появится такое желание.
Но «свободный» не означает «не поддерживается». Напротив, сообще
ство сторонников Python в Интернете отвечает на вопросы пользовате
лей со скоростью, которой могли бы позавидовать большинство разра
ботчиков коммерческих продуктов. Кроме того, свободное распростра
нение кода способствует расширению команды экспертов по реализа
ции. И хотя предоставляемая возможность изучать или изменять
реализацию языка не у всех вызывает восторг, тем не менее наличие
последней инстанции в виде исходных текстов придает уверенность.
Вы уже не зависите от прихотей коммерческого производителя.
Разработка Python ведется сообществом, усилия которого координи
руются в основном через Интернет. В состав сообщества входит созда
тель Python – Гвидо ван Россум (Guido van Rossum), получивший офи
циальное звание Пожизненного Великодушного Диктатора (Benevo
lent Dictator for Life, BDFL) Python, плюс тысячи других разработчи
ков. Изменения в языке принимаются только после прохождения
формальной процедуры (известной как «программа совершенствова
ния продукта», или PEP) и тщательно проверяются формальной систе
мой тестирования и самим Пожизненным Диктатором. Это обеспечи
вает большую степень консерватизма Python в отношении изменений
по сравнению с некоторыми другими языками программирования.
48 Глава 1. Python в вопросах и ответах
Он переносим
Стандартная реализация языка Python написана на переносимом
ANSI C, благодаря чему он компилируется и работает практически на
всех основных платформах. Например, программы на языке Python
могут выполняться на самом широком спектре устройств, начиная от
наладонных компьютеров (PDA) и заканчивая суперкомпьютерами.
Ниже приводится далеко не полный список операционных систем
и устройств, где можно использовать Python:
• Операционные системы Linux и UNIX
• Microsoft Windows и DOS (все современные версии)
• Mac OS (обе разновидности: OS X и Classic)
• BeOS, OS/2, VMS и QNX
• Системы реального времени, такие как VxWorks
• Суперкомпьютеры Cray и ЭВМ производства компании IBM
• Наладонные компьютеры, работающие под управлением PalmOS,
PocketPC или Linux
• Сотовые телефоны, работающие под управлением операционных
систем Symbian и Windows Mobile
• Игровые консоли и iPod
• И многие другие
Помимо самого интерпретатора языка в составе Python распространя
ется стандартная библиотека модулей, которая также реализована пе
реносимым способом. Кроме того, программы на языке Python компи
лируются в переносимый байткод, который одинаково хорошо рабо
тает на любых платформах, где установлена совместимая версия Py
thon (подробнее об этом будет рассказываться в следующей главе).
Все это означает, что программы на языке Python, использующие основ
ные возможности языка и стандартные библиотеки, будут работать оди
наково и в Linux, и в Windows, и в любых других операционных систе
мах, где установлен интерпретатор Python. В большинстве реализаций
Python под определенные операционные системы имеется также под
держка специфических механизмов этих систем (например, поддержка
COM в Windows), но ядро языка Python и библиотеки работают совер
шенно одинаково в любой системе. Как уже говорилось выше, Python
включает в себя средства создания графического интерфейса Tk GUI под
названием Tkinter, что позволяет программам на языке Python созда
вать графический интерфейс, совместимый со всеми основными графи
ческими платформами без индивидуальной программной настройки.
Он мощный
С точки зрения функциональных возможностей Python можно назвать
гибридом. Его инструментальные средства укладываются в диапазон
В чем сильные стороны Python? 49
между традиционными языками сценариев (такими как Tcl, Scheme
и Perl) и языками разработки программных систем (такими как C, C++
и Java). Python обеспечивает простоту и непринужденность языка сце
нариев и мощь, которую обычно можно найти в компилирующих язы
ках. Превышая возможности других языков сценариев, такая комби
нация делает Python удобным средством разработки крупномасштаб
ных проектов. Для предварительного ознакомления ниже приводится
список основных возможностей, которые есть в арсенале Python:
Динамическая типизация
Python сам следит за типами объектов, используемых в программе,
благодаря чему не требуется писать длинные и сложные объявле
ния в программном коде. В действительности, как вы увидите в гла
ве 6, в языке Python вообще отсутствуют понятие типа и необходи
мость объявления переменных. Так как программный код на языке
Python не стеснен рамками типов данных, он автоматически может
обрабатывать целый диапазон объектов.
Автоматическое управление памятью
Python автоматически распределяет память под объекты и освобо
ждает ее («сборка мусора»), когда объекты становятся ненужными.
Большинство объектов могут увеличивать и уменьшать занимае
мый объем памяти по мере необходимости. Как вы узнаете, Python
сам проиводит все низкоуровневые операции с памятью, поэтому
вам не придется беспокоиться об этом.
Модульное программирование
Для создания крупных систем Python предоставляет такие возмож
ности, как модули, классы и исключения. Они позволяют разбить
систему на составляющие, применять ООП для создания программ
ного кода многократного пользования и элегантно обрабатывать
возникающие события и ошибки.
Встроенные типы объектов
Python предоставляет наиболее типичные структуры данных, та
кие как списки, словари и строки, в виде особенностей, присущих
самому языку программирования. Как вы увидите позднее, эти ти
пы отличаются высокой гибкостью и удобством. Например, встро
енные объекты могут расширяться и сжиматься по мере необходи
мости, могут комбинироваться друг с другом для представления
данных со сложной структурой и многое другое.
Встроенные инструменты
Для работы со всеми этими типами объектов в составе Python имеют
ся мощные и стандартные средства, включая такие операции, как
конкатенация (объединения коллекций), получение срезов (извлече
ние части коллекции), сортировка, отображение и многое другое.
50 Глава 1. Python в вопросах и ответах
Библиотеки утилит
Для выполнения более узких задач в состав Python также входит
большая коллекция библиотечных инструментов, которые поддер
живают практически все, что только может потребоваться, – от по
иска с использованием регулярных выражений до работы в сети.
Библиотечные инструменты языка Python – это то место, где вы
полняется большая часть операций.
Утилиты сторонних разработчиков
Python – это открытый программный продукт, и поэтому разработ
чики могут создавать свои, предварительно скомпилированные,
инструменты поддержки задач, решить которые внутренними сред
ствами невозможно. В Сети вы найдете свободную реализацию под
держки COM, средств для работы с изображениями, распределен
ных объектов CORBA, XML, механизмов доступа к базам данных
и многое другое.
Несмотря на широкие возможности, Python имеет чрезвычайно про
стой синтаксис и архитектуру. В результате мы имеем мощный инст
румент программирования, обладающий простотой и удобством, при
сущими языкам сценариев.
Он соединяемый
Программы на языке Python с легкостью могут «склеиваться» с ком
понентами, написанными на других языках программирования. На
пример, прикладной интерфейс C API в Python позволяет программам
на языке C вызывать и быть вызываемыми из программ на языке Py
thon. Из этого следует, что вы можете расширять возможности про
грамм на языке Python и использовать программный код на языке Py
thon в других языковых средах и системах.
Возможность смешивать Python с библиотеками, написанными на та
ких языках, как C или C++, например, превращает его в удобный
язык для создания интерфейсов к этим библиотекам и в средство на
стройки программных продуктов. Как уже говорилось выше, все это
делает Python прекрасным средством разработки прототипов – систе
ма может быть сначала реализована на языке Python, чтобы повысить
скорость разработки, а позднее, в зависимости от требований к произ
водительности системы, по частям перенесена на язык C.
Он удобен
Чтобы запустить программу на языке Python, достаточно просто ввести
ее имя. Не требуется выполнять промежуточную компиляцию и связы
вание, как это делается в языках, подобных C или C++. Интерпретатор
Python немедленно выполняет программу, что позволяет программиро
вать в интерактивном режиме и получать результаты сразу же после
внесения изменений – в большинстве случаев вы сможете наблюдать
В чем сильные стороны Python? 51
эффект изменения программы с той скоростью, с которой вы вводите
изменения с клавиатуры.
Безусловно, скорость разработки – это лишь один из аспектов удобства
Python. Кроме того, он обеспечивает чрезвычайно простой синтаксис
и набор мощных встроенных инструментов. Поэтому некоторые даже
называют Python «исполняемым псевдокодом». Поскольку большая
часть сложностей ликвидируется другими инструментами, програм
мы на языке Python проще, меньше и гибче эквивалентных им про
грамм, написанных на таких языках, как C, C++ и Java!
Программирование на языке Python –
это технический процесс, а не искусство
Когда в начале 1990 годов Python впервые появился на сцене про
граммного обеспечения, это породило чтото вроде конфликта ме
жду сторонниками языка Python и другого популярного языка
сценариев – Perl. Лично я считаю такие дебаты пустыми и бес
смысленными – разработчики достаточно умны, чтобы самостоя
тельно сделать выводы. Однако в моей преподавательской прак
тике мне часто приходится слышать вопросы на эту тему, поэтому
я считаю необходимым сказать несколько слов по этому поводу.
В двух словах: все, что можно сделать на Perl, можно сделать
и на Python, но при использовании Python вы еще сможете прочи+
тать свой программный код. Для большинства удобочитаемость
программного кода на языке Python означает возможность много
кратного его использования и простоту сопровождения, что дела
ет Python отличным выбором для написания программ, которые
не попадут в разряд написанных и сразу после отладки выбро
шенных. Программный код на языке Perl легко писать, но слож
но читать. Учитывая, что период жизни большинства программ
длится много дольше, чем период их создания, многие усматрива
ют в Python более эффективный инструмент программирования.
Вообще говоря, история этого противоречия отражает опыт про
ектировщиков двух языков программирования и подчеркивает
некоторые из основных причин, по которым программисты от
дают предпочтение языку Python. Создатель языка Python – ма
тематик по образованию, и потому он создал язык, обладающий
высокой степенью однородности – его синтаксис и набор воз
можностей отличаются удивительной согласованностью. Более
того, если говорить математическими терминами, язык Python
обладает ортогональной архитектурой – большая часть вырази
тельных возможностей языка следует из небольшого числа базо
вых концепций. Как только программист схватывает суть поли
морфизма в Python, все остальное становится для него мелочью.
52 Глава 1. Python в вопросах и ответах
Создатель языка Perl, напротив, – лингвист, поэтому и язык от
ражает его профессиональный опыт. В языке Perl одну и ту же
задачу можно решить множеством способов, а языковые конст
рукции взаимодействуют между собой контекстнозависимым,
порой трудноуловимым способом, во многом напоминая естест
венный язык общения. Как известно, девизом языка Perl явля
ется выражение: «Всякую задачу можно решить более чем од
ним способом». Учитывая это, можно сказать, что язык Perl
и сообщество его пользователей исторически стремились к сво
боде выражения мыслей при создании программного кода. Про
граммный код одного программиста может радикально отли
чаться от программного кода другого. И правда, искусство созда
ния уникального хитросплетения инструкций всегда было пред
метом гордости программистов на Perl.
Однако любой, кто когдалибо занимался сопровождением про
граммного кода, скажет вам, что свобода выражения хороша для
искусства, но не для технологического процесса. В технологии
нам требуется минимальный набор возможностей и высокая сте
пень предсказуемости. Свобода выражения мыслей в техноло
гии может превратить процесс сопровождения в непрекращаю
щийся кошмар. По секрету говоря, уже не от одного пользовате
ля Perl я слышал, что проще написать свой код, чем внести из
менения в чужой.
Когда художник пишет картину или ваяет скульптуру, он выра
жает этим исключительно себя, свои эстетические побуждения.
Он не предполагает, что картина или скульптура будет изме
няться другим художником. Это важное различие между искус
ством и технологическим процессом. Когда программист пишет
сценарий, он пишет его не для себя самого. Более того, сценарий
пишется даже не для компьютера. Хороший программист знает,
что свой программный код он пишет для другого человека, кото
рый будет вынужден читать его в ходе сопровождения и исполь
зования. Если этот человек не сможет понять сценарий, он ста
нет практически бесполезным в реальной жизни.
Многие находят в этом самое четкое отличие Python от других
языков сценариев, подобных языку Perl. Синтаксическая мо
дель Python вынуждает пользователя писать удобочитаемый
программный код, поэтому программы на языке Python лучше
вписываются в полный цикл разработки программного обеспе
чения. А такие свойства Python, как ограниченное число спосо
бов взаимодействия, единообразие, закономерность и непроти
воречивость способствуют появлению программного кода, кото
рый будет использоваться после того, как будет написан.
В чем сильные стороны Python? 53
Он прост в изучении
Это самый важный аспект данной книги: по сравнению с другими язы
ками программирования базовый язык Python очень легко запомина
ется. В действительности вы сможете писать на языке Python более
или менее значимые программы уже через несколько дней (или даже
через несколько часов, если вы уже опытный программист). Это от
личная новость для разработчиков, стремящихся изучить язык для
применения его в своей работе, а также для конечных пользователей,
которые применяют Python для настройки или управления программ
ным продуктом. Сегодня многие системы исходят из того, что конеч
ные пользователи могут быстро изучить Python в достаточной степе
ни, чтобы самостоятельно создать свой собственный программный код
настройки системы при незначительной поддержке со стороны разра
ботчика. И хотя в Python имеются сложные инструменты программи
рования, основа языка попрежнему остается простой для изучения
как начинающими, так и опытными программистами.
Он назван в честь Монти Пайтона (Monty Python)
Это не имеет отношения к технической стороне дела, но похоже, что
эта тайна, которую я собираюсь открыть, на удивление хорошо охра
няется. Несмотря на то что на эмблеме Python изображена рептилия,
правда в том, что создатель Python, Гвидо ван Россум (Guido van Ros
sum), назвал свое детище в честь комедийного сериала «Летающий
цирк Монти Пайтона» (Monty Python’s Flying Circus), который транс
лировался по телеканалу BBC. Он большой поклонник Монти Пайтона
(Monty Python), как и многие программисты (похоже, что есть какая
то аналогия между разработкой программ и цирком).
В конечном счете, в центре внимания языка Python находится ка
чество программного кода, что само по себе повышает производи
тельность программиста и приводит к появлению у него чувства
удовлетворенности. Программисты, использующие язык Python,
могут быть не менее творческими натурами и, как мы увидим
позднее, в некоторых случаях этот язык также способен предло
жить несколько способов решения одной и той же задачи. Тем не
менее в своей основе Python стимулирует ведение разработки спо
собами, часто недоступными в других языках сценариев.
По крайней мере, это общее мнение многих из тех, кто принял
Python на вооружение. Вы всегда должны сами оценивать подоб
ные суждения при изучении Python. А приступить к изучению
мы сможем в следующей главе.
54 Глава 1. Python в вопросах и ответах
Это обстоятельство неизбежно добавляет юмора в примеры программ
ного кода на языке Python. Например, традиционные имена перемен
ных «foo» и «bar» в языке Python превратились в «spam» и «egg».
Встречающиеся иногда имена «Brian», «ni» и «shrubbery», точно так
же появились благодаря своим тезкам. Это даже оказывает влияние на
сообщество в целом: дискуссии на конференциях по языку Python
обычно имеют именование «Испанская инквизиция».
Все это, конечно, очень забавно, если вы знакомы с сериалом, в про
тивном случае это кажется непонятным. Вам не требуется знать сери
ал, чтобы понимать примеры, где используются ссылки на Монти
Пайтона (включая многие примеры в этой книге), но по крайней мере,
вы теперь знаете, откуда что берется.
Какими преимуществами обладает Python
перед языком X?
Наконец, перейдем к области, которая вам уже, возможно, знакома –
сравнению Python с другими языками программирования, такими
как Perl, Tcl и Java. Ранее мы уже говорили о проблеме производи
тельности, поэтому здесь мы сосредоточим свое внимание на функцио
нальных возможностях. Другие языки программирования также яв
ляются достаточно полезными инструментами, чтобы знать и исполь
зовать их, но многие находят, что Python:
• Имеет более широкие возможности, чем Tcl. Язык Python поддер
живает «программирование в целом», что делает его применимым
для разработки крупных систем.
• Имеет более четкий синтаксис и более простую архитектуру, чем
Perl, что делает программный код более удобочитаемым, простым
в сопровождении и снижает вероятность появления ошибок.
• Проще и удобнее, чем Java. Python – это язык сценариев, а Java
унаследовала сложный синтаксис от таких языков программирова
ния, как C++.
• Проще и удобнее, чем C++, но нередко он не может конкурировать
с C++, поскольку, будучи языком сценариев, Python предназначен
для решения другого круга задач.
• Более мощный и более переносимый, чем Visual Basic. Открытая
природа Python также означает, что нет какойто отдельной компа
нии, которая его контролирует.
• Более зрелый и имеет более ясный синтаксис, чем Ruby. В отличие
от Ruby и Java, объектноориентированный стиль программирова
ния является необязательным в Python – он не вынуждает исполь
зовать ООП в проектах, где этот стиль неприменим.
• Обладает динамическими характеристиками таких языков, как
SmallTalk и Lisp, но имеет более простой и традиционный синтак
В заключение 55
сис, доступный как для разработчиков, так и для конечных пользо
вателей настраиваемых систем.
Многие считают, что Python, по сравнению с другими современными
языками сценариев, гораздо лучше подходит для программ, которые
делают нечто большее, чем простое сканирование текстовых файлов
и код которых, возможно, потребуется читать другим людям (и может
быть, даже вам!). Кроме того, если от вашего приложения не требуется
наивысшая производительность, Python способен составить конкурен
цию таким языкам программирования, как C, C++ и Java: программ
ный код на языке Python проще писать, отлаживать и сопровождать.
Безусловно, автор является горячим поклонником Python с 1992 года,
поэтому воспринимайте эти комментарии по своему усмотрению. Одна
ко они в действительности отражают опыт многих программистов, кото
рые потратили немало времени на исследование возможностей Python.
В заключение
Этот раздел завершает рекламную часть книги. В этой главе мы рас
смотрели некоторые из причин, по которым люди выбирают Python
для программирования своих задач. Здесь также было показано, как
он используется, и приведены представительные примеры тех, кем он
используется в настоящее время. Моя цель состоит в том, чтобы обу
чить вас языку Python, а не продать его. Лучший способ создать собст
венное мнение о языке – это опробовать его в действии, поэтому ос
тальная часть книги целиком и полностью будет сфокусирована на
описании языка, который здесь был представлен.
Следующие две главы могут рассматриваться как техническое введение
в язык. В этих главах мы узнаем, как запускаются программы на языке
Python, коротко рассмотрим модель исполнения байткода и получим
основные сведения об организации файлов модулей, в которых хранит
ся программный код. Цель этих глав состоит в том, чтобы дать вам объ
ем информации, достаточный для запуска примеров и выполнения уп
ражнений в остальной части книги. Мы фактически не будем касаться
вопросов программирования до главы 4, но прежде чем перейти к нему,
вы определенно получите все необходимые начальные сведения.
Закрепление пройденного
Контрольные вопросы
Каждая глава в этом издании книги будет завершаться серией корот
ких контрольных вопросов, которые помогут вам закрепить в памяти
ключевые концепции. Ответы на вопросы следуют ниже, и вы можете
прочитать эти ответы сразу, как только столкнетесь с затруднениями.
Помимо контрольных вопросов в конце каждой части вы найдете
56 Глава 1. Python в вопросах и ответах
упражнения, предназначенные для того, чтобы помочь вам програм
мировать на языке Python. Итак, перед вами первый тест. Удачи!
1. Назовите шесть основных причин, по которым программисты вы
бирают Python.
2. Назовите четыре известные компании или организации, исполь
зующие Python.
3. Почему бы вы не хотели использовать Python в приложениях?
4. Какие задачи можно решать с помощью Python?
5. Какой важный результат можно получить с помощью инструкции
import this?
6. Почему слово «spam» так часто используется в примерах программ
ного кода на языке Python?
7. Какой ваш любимый цвет?
Ответы
Как дела? Ниже приводятся ответы, которые подготовил я, хотя на не
которые вопросы существует несколько правильных ответов. Напом
ню еще раз, даже если вы абсолютно уверены в правильности своих от
ветов, я советую прочитать мои ответы хотя бы ради того, чтобы полу
чить некоторые дополнительные сведения. Если мои ответы кажутся
вам бессмысленными, прочитайте текст главы еще раз.
1. Качество программного обеспечения, скорость разработки, перено
симость программ, поддержка библиотек, интеграция компонентов
и удовольствие. Из этих шести причин качество и скорость разра
ботки являются наиболее существенными при выборе Python.
2. Google, Industrial Light & Magic, Jet Propulsion Labs, ESRI и многие
другие. Практически каждая организация, занимающаяся разра
боткой программного обеспечения, так или иначе использует Py
thon как для решения долговременных, стратегических задач про
ектирования, так и для решения краткосрочных тактических за
дач, таких как тестирование и системное администрирование.
3. Основным недостатком Python является невысокая производитель
ность, программы на языке Python не могут выполняться так же
быстро, как программы на полностью компилируемых языках, та
ких как C и С++. С другой стороны, для большинства применений
он обладает достаточно высокой скоростью выполнения и обычно
программный код на языке Python работает со скоростью, близкой
к скорости языка C, потому что интерпретатор вызывает встроен
ный в него программный код, написанный на языке C. Если ско
рость выполнения имеет критическое значение, отдельные части
приложения можно реализовать на языке C, в виде расширений.
Закрепление пройденного 57
4. Вы можете использовать Python для любых задач, которые можно
решить с помощью компьютера – от реализации вебсайта и игро
вых программ до управления роботами и космическими кораблями.
5. Инструкция import this активизирует «пасхальное яйцо», скрытое
в недрах Python, которое отображает некоторые принципы проек
тирования, лежащие в основе языка. Как запустить эту инструк
цию, вы узнаете в следующей главе.
6. Слово «spam» взято из известной пародии Монти Пайтона (Monty
Python), где герои сериала пытаются заказать блюдо в кафетерии,
а их заглушает хор викингов, поющих о консервах (spam). Ах да!
Это еще и типичное имя переменной, которое используется в сцена
риях на языке Python…
7. Голубой. Нет, желтый!
2
Как Python запускает программы
В этой и в следующей главе будут коротко рассмотрены вопросы ис
полнения программ – как программы запускаются человеком и как
Python выполняет их. В этой главе мы рассмотрим интерпретатор Py
thon. После этого в главе 3 будет показано, как вам следует запускать
свои программы.
Порядок запуска программ в любом случае зависит от типа платфор
мы, и какието сведения из этой главы могут оказаться неприменимы
к платформе, используемой вами, поэтому вы можете просто пропус
кать разделы, которые не относятся к вам. Точно так же опытные
пользователи, которым уже приходилось использовать подобные ин
струменты в прошлом и которые стремятся побыстрее добраться до са
мого языка, могут пропустить эти главы, оставив их «для ознакомле
ния в будущем». А со всеми остальными мы попробуем разобраться,
как запускать некоторый программный код.
Введение в интерпретатор Python
До сих пор я говорил о Python в основном как о языке программирова
ния. Но в текущей реализации это еще и пакет программного обеспе
чения, который называется интерпретатор. Интерпретатор – это та
кая программа, которая выполняет другие программы. Когда вы пи
шете программу на языке Python, интерпретатор Python читает вашу
программу и выполняет составляющие ее инструкции. В действитель
ности, интерпретатор – это слой программной логики между вашим
программным кодом и аппаратурой вашего компьютера.
В процессе установки пакета Python на компьютер создается ряд про
граммных компонентов – как минимум, интерпретатор и библиотека
поддержки. В зависимости от порядка использования интерпретатор
Python может иметь вид исполняемой программы или набора библио
Введение в интерпретатор Python 59
тек, связанных с другой программой. В зависимости от используемой
версии Python сам интерпретатор может быть реализован как про
грамма на языке C, как набор классов Java и в какомлибо другом ви
де. Независимо от используемой вами разновидности Python ваш про
граммный код на этом языке всегда будет выполняться этим интерпре
татором. А чтобы обеспечить такую возможность, вы должны устано
вить интерпретатор Python на свой компьютер.
Процедура установки Python отличается для разных платформ и под
робно описывается в приложении A. В двух словах:
• Пользователи Windows должны получить и запустить инсталляци
онный исполняемый файл, который произведет установку Python
на компьютер. Для этого нужно просто дважды щелкнуть на ин
сталляционном файле и отвечать Yes (Да) или Next (Далее) на все во
просы.
• В Windows Vista вам может потребоваться выполнить дополнитель
ные действия с инсталляционным файлом Python 2.5 MSI. За под
робной информацией по этому поводу обращайтесь к приложению A.
• В Linux или в Mac OS вполне возможно, что Python уже установлен
и готов к использованию, поскольку он является стандартным ком
понентом этих операционных систем.
• В отдельных версиях Linux (и в большинстве версий UNIX) Python
обычно устанавливается из файлов RPM или компилируется из ис
ходных текстов.
• Процедура установки на других платформах зависит от этих плат
форм. Например, Python присутствует также в сотовых телефонах,
игровых консолях и в проигрывателе iPod, но процедуры установ
ки Python на эти устройства слишком отличаются, чтобы описы
вать их здесь.
Дистрибутив Python можно получить на странице загрузок сайта про
екта. Его можно также получить по другим каналам распространения
программного обеспечения. Но имейте в виду: прежде чем приступать
к установке, вы должны убедиться, что Python не был ранее установ
лен на ваш компьютер. Если вы пользуетесь операционной системой
Windows, обычно Python можно найти в меню Start (Пуск), как показа
но на рис. 2.1 (эти пункты меню будут рассматриваться в следующей
главе). В операционных системах Linux и UNIX Python обычно нахо
дится в дереве каталогов /usr.
Поскольку процедура установки сильно зависит от используемой плат
формы, мы здесь прервем рассказ о ней. За дополнительной информа
цией о ней обращайтесь к приложению A. В целях этой и следующей
главы я буду исходить из предположения, что Python уже установлен
и готов к работе.
60 Глава 2. Как Python запускает программы
Выполнение программы
Что стоит за словами «написать и запустить программу на языке Py
thon», зависит от того, как вы смотрите на эту задачу, – как програм
мист или как интерпретатор Python. Обе точки зрения определяют
свой взгляд на программирование.
С точки зрения программиста
Программа на языке Python, в самой простой форме, – это обычный
текстовый файл, содержащий инструкции Python. Например, следую
щий файл, с именем script1.py, – это один из простейших сценариев на
языке Python, который только можно придумать, но его официально
можно назвать программой на языке Python:
print 'hello world'
print 2 ** 100
Этот файл содержит две инструкции print, которые просто выводят
строку (текст в кавычках) и результат числового выражения (2 в сте
пени 100) в выходной поток. Не надо сейчас стараться вникнуть в син
Рис. 2.1. Когда Python установлен в Windows, его можно найти в меню
Start (Пуск). Набор пунктов меню может немного отличаться,
в зависимости от версии, но пункт IDLE запускает среду разработки
с графическим интерфейсом, а пункт Python запускает сеанс работы
с интерактивной командной оболочкой. Кроме того, здесь же можно
увидеть пункты вызова стандартного справочного руководства и запуска
механизма документирования Pydoc (пункт Module Docs)
Выполнение программы 61
таксис языка – в этой главе нас интересует лишь сам порядок запуска
программ. Позднее я расскажу об инструкции print и объясню, почему
можно возвести число 2 в степень 100, не опасаясь получить ошибку
переполнения.
Создать такой файл можно с помощью любого текстового редактора.
По общепринятым соглашениям файлы с программами на языке Py
thon должны иметь расширение .py – с технической точки зрения это
требование должно выполняться только для «импортируемых» фай
лов, как будет показано позднее в этой книге, но большинству файлов
с программами на языке Python даются имена с расширением .py для
единообразия.
После того как инструкции будут введены в текстовый файл, можно
потребовать от Python выполнить его, то есть просто выполнить все
инструкции в файле одну за другой, от начала и до конца. Как будет по
казано в следующей главе, вы можете запускать программы, щелкая
на их пиктограммах, или другими стандартными способами. Если при
выполнении файла все пройдет как надо, вы увидите результаты рабо
ты двух инструкций print гдето на экране своего компьютера – обычно
это происходит в том же окне, где производился запуск программы:
hello world
1267650600228229401496703205376km
Например, ниже показано, что происходило, когда я попытался запус
тить этот сценарий в командной строке DOS на ноутбуке, где установ
лена операционная система Windows (обычно эту программу можно
найти в меню Accessories (Стандартные) под названием Command Prompt (Ко
мандная строка)), чтобы убедиться, что я не допустил никаких опечаток:
D:\temp> python script1.py
hello world
1267650600228229401496703205376
Мы только что запустили сценарий, который вывел строку и число.
Вероятно, мы не получим награды на конкурсе по программированию
за этот сценарий, но его вполне достаточно, чтобы понять основные
принципы запуска программ.
С точки зрения Python
Краткое описание, приведенное в предыдущем разделе, является до
вольно стандартным для языков сценариев, и это обычно все, что необ
ходимо знать программисту. Вы вводите программный код в тексто
вый файл, а затем запускаете этот файл с помощью интерпретатора.
Однако, когда вы говорите интерпретатору «вперед», за кулисами мно
го чего происходит. Хотя знание внутреннего устройства Python и не
требуется для овладения навыками программирования на этом языке,
тем не менее понимание того, как производится выполнение про
грамм, поможет вам увидеть всю картину в целом.
62 Глава 2. Как Python запускает программы
Когда интерпретатор Python получает от вас команду запустить сцена
рий, он выполняет несколько промежуточных действий, прежде чем
ваш программный код начнет «скрипеть колесами». В частности, сце
нарий сначала будет скомпилирован в нечто под названием «байт
код», а затем передан некоторому механизму, известному под назва
нием «виртуальная машина».
Компиляция в байткод
Когда вы запускаете программу, практически незаметно для вас Py
thon сначала компилирует ваш исходный текст (инструкции в файле)
в формат, известный под названием байт+код. Компиляция – это про
сто этап перевода программы, а байткод – это низкоуровневое, плат
формонезависимое представление исходного текста программы. Py
thon транслирует каждую исходную инструкцию в группы инструкций
байткода, разбивая ее на отдельные составляющие. Такая трансляция
в байткод производится для повышения скорости – байткод выполня
ется намного быстрее, чем исходные инструкции в текстовом файле.
В предыдущем параграфе вы могли заметить фразу – практически не
заметно для вас. Если интерпретатор Python на вашем компьютере об
ладает правом записи, он будет сохранять байткод вашей программы
в виде файла с расширением .pyc («.pyc» – это компилированный ис
ходный файл «.py»). Вы будете обнаруживать эти файлы после запус
ка программ по соседству с файлами, содержащими исходные тексты
(то есть в том же каталоге).
Интерпретатор сохраняет байткод для ускорения запуска программ.
В следующий раз, когда вы попробуете запустить свою программу, Py
thon загрузит файл .pyc и минует этап компиляции – при условии, что
исходный текст программы не изменялся с момента последней компи
ляции. Чтобы определить, необходимо ли выполнять перекомпиляцию,
Python автоматически сравнит время последнего изменения файла с ис
ходным текстом и файла с байткодом. Если исходный текст сохранял
ся на диск после компиляции, при следующем его запуске интерпрета
тор автоматически выполнит повторную компиляцию программы.
Если Python окажется не в состоянии записать файл с байткодом на
диск, программа от этого не пострадает, просто байткод будет сгене
рирован в памяти и уничтожен по завершении программы.1 Однако,
поскольку файлы .pyc повышают скорость запуска программы, вам
может потребоваться иметь возможность сохранять их, особенно для
больших программ. Кроме того, файлы с байткодом – это еще один из
1 Строго говоря, байткод сохраняется только для импортируемых файлов,
но не для файла самой программы. Об импорте мы поговорим в главе 3
и снова вернемся к нему в части V. Байткод также никогда не сохраняется
для инструкций, введенных в интерактивном режиме, который описывает
ся в главе 3.
Выполнение программы 63
способов распространения программ на языке Python. Интерпретатор
запустит файл .pyc, даже если нет оригинальных файлов с исходными
текстами. (В разделе «Фиксированные двоичные файлы» описывается
еще один способ распространения программ.)
Виртуальная машина Python (PVM)
Как только программа будет скомпилирована в байткод (или байткод
будет загружен из существующих файлов .pyc), он передается универ
сальному механизму под названием виртуальная машина Python
(PVM – для любителей аббревиатур). Аббревиатура PVM выглядит бо
лее внушительно, чем то, что за ней стоит на самом деле, – это не от
дельная программа, которую требуется устанавливать. Фактически,
PVM – это просто большой цикл, который выполняет перебор инст
рукций в байткоде, одну за одной, и выполняет соответствующие им
операции. PVM – это механизм времени выполнения, она всегда при
сутствует в составе системы Python, и это тот самый программный ком
понент, который выполняет ваши сценарии. Формально – это послед
няя составляющая того, что называют «интерпретатором Python».
На рис. 2.2 показана последовательность действий, которая описыва
ется здесь. Не забывайте, что все эти сложности преднамеренно спря
таны от программистов. Компиляция в байткод производится автома
тически, а PVM – это всего лишь часть системы Python, которую вы
установили на свой компьютер. Повторю еще раз, что программисты
просто создают программный код на языке Python и запускают файлы
с инструкциями.
Производительность
Читатели, имеющие опыт работы с компилирующими языками про
граммирования, такими как C и C++, могут заметить несколько отли
чий в модели выполнения Python. Первое, что бросается в глаза, – это
отсутствие этапа сборки, или вызова утилиты «make»: программный
код может запускаться сразу же, как только будет написан. Второе от
личие: байткод не является двоичным машинным кодом (например,
Исходный текст Байткод Выполнение
m.py m.pyc PVM
Рис. 2.2. Традиционная модель выполнения программ на языке Python:
исходный текст, который вводится программистом, транслируется в байт+
код, который затем исполняется виртуальной машиной Python. Исходный
текст автоматически компилируется и затем интерпретируется
64 Глава 2. Как Python запускает программы
инструкциями для микропроцессора Intel). Байткод – это внутреннее
представление программ на языке Python.
По этой причине программный код на языке Python не может выпол
няться так же быстро, как программный код на языке C или C++, о чем
уже говорилось в главе 1. Обход инструкций выполняет виртуальная
машина, а не микропроцессор, и чтобы выполнить байткод, необходи
ма дополнительная интерпретация, инструкции которого требуют на
выполнение больше времени, чем машинные инструкции микропро
цессора. С другой стороны, в отличие от классических интерпретато
ров, здесь присутствует дополнительный этап компиляции – интерпре
татору не требуется всякий раз снова и снова анализировать инструк
ции исходного текста. В результате Python способен обеспечить ско
рость выполнения гдето между традиционными компилирующими
и традиционными интерпретирующими языками программирования.
Подробнее о проблеме производительности рассказывается в главе 1.
Скорость разработки
С другой стороны, в модели выполнения Python отсутствуют различия
между средой разработки и средой выполнения. То есть системы, кото
рые компилируют и выполняют исходный текст, – это суть одна и та же
система. Для читателей, имеющих опыт работы с традиционными ком
пилирующими языками, это обстоятельство может иметь некоторое
значение, но в Python компилятор всегда присутствует во время выпол
нения и является частью механизма, выполняющего программы.
Это существенно увеличивает скорость разработки. Не нужно всякий
раз выполнять компиляцию и связывание программ, прежде чем за
пустить их, – вы просто вводите исходный текст и запускаете его. Это
также придает языку некоторый динамизм – вполне возможно, а не
редко и удобно, когда программы на языке Python создаются и выпол
няются другими программами Python во время выполнения. Напри
мер, встроенные инструкции eval и exec принимают и выполняют стро
ки, содержащие программный код на языке Python. Благодаря такой
возможности Python может использоваться для настройки продуктов –
программный код Python может изменяться «на лету», а пользователи
могут изменять части системы, написанные на языке Python, без необ
ходимости перекомпилировать систему целиком.
Имейте в виду, если смотреть с более фундаментальных позиций, то все,
что имеется в Python, работает на этапе времени выполнения – здесь пол
ностью отсутствует этап предварительной компиляции, все, что необхо
димо, производится во время выполнения программы. Сюда относятся
даже такие операции, как создание функций и классов и связывание мо
дулей. Эти события в более статичных языках происходят перед выпол
нением, но в программах на языке Python происходят во время выпол
нения. В результате процесс программирования приобретает больший
динамизм, чем тот, к которому привыкли некоторые читатели.
Разновидности модели выполнения 65
Разновидности модели выполнения
Прежде чем двинуться дальше, я должен заметить, что внутренний
поток выполнения, описанный в предыдущем разделе, отражает со
временную стандартную реализацию интерпретатора Python, которая
в действительности не является обязательным требованием самого
языка Python. Вследствие этого модель выполнения склонна изме
няться с течением времени. Фактически уже существуют системы, ко
торые несколько меняют картину, представленную на рис. 2.2. Давай
те потратим несколько минут, чтобы ознакомиться с наиболее замет
ными изменениями.
Альтернативные реализации Python
В то время, когда я писал эту книгу, существовали три основные альтер
нативные реализации языка Python – CPython, Jython и IronPython,
а также несколько второстепенных реализаций, таких как Stackless
Python. В двух словах: CPython – это стандартная реализация, а все
остальные создавались для специфических целей и задач. Все они реа
лизуют один и тот же язык Python, но выполняют программы немного
поразному.
CPython
Оригинальная и стандартная реализация языка Python обычно назы
вается CPython, особенно когда необходимо подчеркнуть ее отличие от
двух других альтернатив. Это название происходит из того факта, что
реализация написана на переносимом языке ANSI C. Это тот самый
Python, который вы загружаете с сайта http://www.python.org, получае
те в составе дистрибутива ActivePython и который присутствует в боль
шинстве систем Linux и Mac OS X. Если вы обнаружили у себя предва
рительно установленную версию Python, то более чем вероятно, что
это будет CPython, – при условии, что ваша компания не использует
какуюто специфическую версию.
Если вы не предполагаете создавать приложения на Java или для плат
формы .NET, возможно, вам следует отдать предпочтение стандартной
реализации CPython. Поскольку это эталонная реализация языка, она,
как правило, работает быстрее, устойчивее и лучше, чем альтернатив
ные системы. Рисунок 2.2 отражает модель выполнения CPython.
Jython
Интерпретатор Jython (первоначальное название – JPython) – это аль
тернативная реализация языка Python, основная цель которой – тесная
интеграция с языком программирования Java. Реализация Jython со
стоит из Javaклассов, которые выполняют компиляцию программного
кода на языке Python в байткод Java и затем передают полученный
байткод виртуальной машине Java (Java Virtual Machine, JVM). Про
граммист помещает инструкции на языке Python в текстовые файлы
66 Глава 2. Как Python запускает программы
как обычно, а система Jython подменяет два расположенных на рис. 2.2
справа этапа на эквиваленты языка Java.
Цель Jython состоит в том, чтобы позволить программам на языке Py
thon управлять Javaприложениями, точно так же, как CPython может
управлять компонентами на языках C и C++. Эта реализация имеет бес
шовную интеграцию с Java. Поскольку программный код на языке Py
thon транслируется в байткод Java, во время выполнения он ведет себя
точно так же, как настоящая программа на языке Java. Сценарии на
языке Jython могут выступать в качестве апплетов и сервлетов, созда
вать графический интерфейс с использованием механизмов Java и т. д.
Более того, Jython обеспечивает поддержку возможности импортиро
вать и использовать Javaклассы в программном коде Python. Тем не
менее, поскольку реализация Jython обеспечивает более низкую ско
рость выполнения и менее устойчива по сравнению с CPython, она пред
ставляет интерес скорее для разработчиков программ на языке Java,
которым необходим язык сценариев в качестве интерфейса к Javaкоду.
IronPython
Третья (и, к моменту написания этих строк, самая новая) реализация
языка Python – это IronPython. Она предназначена для обеспечения
интеграции программ Python с приложениями, созданными для рабо
ты в среде Microsoft .NET Framework операционной системы Win
dows, а также в Mono – открытом эквиваленте для Linux. Платформа
.NET и среда выполнения языка C# предназначены для обеспечения
взаимодействий между программными объектами – независимо от ис
пользуемого языка программирования, в духе более ранней модели
COM компании Microsoft. Реализация IronPython позволяет програм
мам на языке Python играть роль как клиентских, так и серверных
компонентов, доступных из других языков программирования .NET.
Модель реализации IronPython очень напоминает Jython (и фактически
разрабатывается одним и тем же автором) – она подменяет два этапа на
рис. 2.2 справа на эквиваленты среды .NET. Как и Jython, основной ин
терес IronPython представляет для разработчиков, которым необходи
ма интеграция Python с компонентами .NET. Поскольку разработка ве
дется компанией Microsoft, от IronPython, помимо прочего, можно бы
ло бы еще ожидать существенной оптимизации производительности.
К моменту написания этих строк реализация IronPython еще продол
жала разрабатываться. За дополнительной информацией обращайтесь
к ресурсам Python или попробуйте самостоятельно поискать в Сети.1
1 Jython и IronPython – это полностью независимые реализации языка Py
thon, которые компилируют исходный программный код для различных
архитектур времени выполнения. Из программ для CPython также можно
получить доступ к программным компонентам Java и .NET: например, сис
темы JPype и Python для .NET позволяют коду, исполняемому интерпрета
тором CPython, обращаться к компонентам Java и .NET.
Разновидности модели выполнения 67
Средства оптимизации скорости выполнения
Все три реализации, CPython, Jython и IronPython, реализуют язык
Python похожими способами: исходный программный код компили
руют в байткод и выполняют полученный байткод с помощью соот
ветствующей виртуальной машины. Но кроме них существуют и дру
гие реализации, включая динамический компилятор Psyco и трансля
тор Shedskin C++, которые пытаются оптимизировать основную мо
дель выполнения. Знание этих реализаций пока не является для вас
обязательным, тем не менее краткий обзор их реализации модели вы
полнения поможет пролить свет на модель выполнения в целом.
Динамический компилятор Psyco
Система Psyco – это не другая реализация языка Python, а компонент,
расширяющий модель выполнения байткода, что позволяет програм
мам выполняться быстрее. В терминах схемы на рис. 2.2 Psyco – это
расширение PVM, которое собирает и использует информацию о типах,
чтобы транслировать части байткода программы в истинный двоич
ный машинный код, который выполняется гораздо быстрее. Для такой
трансляции не требуется вносить изменения в исходный программный
код или производить дополнительную компиляцию в ходе разработки.
Грубо говоря, во время выполнения программы Psyco собирает инфор
мацию о типах объектов, и затем эта информация используется для ге
нерации высокоэффективного машинного кода, оптимизированного
для объектов этого типа. После этого произведенный машинный код
замещает соответствующие участки байткода и тем самым увеличи
вает скорость выполнения программы. В результате при использова
нии Psyco существенно уменьшается общее время выполнения про
граммы. В идеале некоторые участки программного кода под управле
нием Psyco могут выполняться так же быстро, как скомпилированный
код языка C.
Поскольку эта компиляция из байткода производится во время выпол
нения программы, обычно Psyco называют динамическим (justintime,
JIT) компилятором. Однако в действительности Psyco немного отлича
ется от JITкомпиляторов, которые, возможно, некоторые читатели ви
дели в языке Java. В действительности Psyco – это специализированный
JIT+компилятор; он генерирует машинный код, оптимизированный
для типов данных, которые фактически используются в программе.
Например, если один и тот же участок программы использует различ
ные типы данных в разное время, Psyco может генерировать различ
ные версии машинного кода для поддержки каждой из комбинаций.
Применение Psyco показывает существенное увеличение скорости вы
полнения программного кода Python. Согласно информации, которая
приводится на домашней странице проекта, Psyco обеспечивает увели
чение скорости «от 2 до 100 раз, обычно в 4 раза, при использовании
немодифицированного интерпретатора Python, неизменного исходного
68 Глава 2. Как Python запускает программы
текста, всего лишь за счет использования динамически загружаемого
модуля расширения на языке C». При прочих равных условиях, наи
больший прирост скорости наблюдается для программного кода, реа
лизующего различные алгоритмы на чистом языке Python, – именно
такой программный код обычно переносят на язык C с целью оптими
зации. При использовании Psyco необходимость в таком переносе те
ряет свою остроту.
До сих пор Psyco не является стандартной частью Python – его нужно
загружать и устанавливать отдельно. Кроме того, он до сих пор нахо
дится на экспериментальной стадии развития, поэтому вам нужно бу
дет следить за его разработкой. В действительности, когда я пишу эти
строки, Psyco все еще можно загрузить и установить, но похоже, что
большая его часть будет поглощена более новым проектом «PyPy», ко
торый представляет собой попытку переписать PVM на языке Python
с целью обеспечения высокой степени оптимизации, как в Psyco.
Пожалуй, самым большим недостатком Psyco является то обстоятель
ство, что в настоящее время он способен генерировать машинный код
только для архитектуры Intel x86, впрочем, на этой архитектуре рабо
тают такие операционные системы, как Windows, Linux и даже Mac.
За дополнительной информацией о расширении Psyco и других попыт
ках реализации JITкомпилятора обращайтесь на сайт http://www.py+
thon.org. Кроме того, вы можете посетить домашнюю страницу проек
та Psyco, которая в настоящее время размещается по адресу http://psy+
co.sourceforge.net.
Транслятор Shedskin C++
Shedskin – это еще одна система, которая реализует нетрадиционный
подход к выполнению программ на языке Python. Она преобразует ис
ходный код на языке Python в исходный код на языке C++, который
затем может быть скомпилирован в машинный код. Кроме того, эта
система реализует платформонезависимый подход к выполнению про
граммного кода Python. К моменту написания этих строк система
Shedskin еще находилась на экспериментальной стадии развития и ог
раничивала программы Python неявным использованием статических
типов, что является ненормальным явлением для программ на языке
Python, поэтому мы не будем углубляться в описание этой системы.
Тем не менее, по предварительным результатам, у нее имеется нема
лый потенциал, чтобы выиграть гонку за скоростью как у стандартной
реализации Python, так и у расширения Psyco, и это весьма многообе
щающий проект. Сведения о текущем состоянии проекта вы можете
самостоятельно найти в Сети.
Фиксированные двоичные файлы
Иногда, когда пользователи спрашивают про «настоящий» компиля
тор языка Python, в действительности они просто ищут способ созда
Разновидности модели выполнения 69
вать из своих программ на языке Python самостоятельные исполняе
мые файлы. Это необходимо скорее для упаковки и распространения
программ, чем для их исполнения, но эти две стороны взаимосвязаны
между собой. При помощи инструментов сторонних разработчиков, ко
торые можно загрузить из Сети, вы можете превратить свои программы
на языке Python в настоящие исполняемые файлы, которые в мире Py
thon известны, как фиксированные двоичные файлы (frozen binaries).
Фиксированные двоичные файлы объединяют в единый файл пакета
байткод программ, PVM (интерпретатор) и файлы поддержки, необ
ходимые программам. Существуют разные реализации такого подхо
да, но в конечном результате получается единственный исполняемый
файл (например, файл с расширением .exe в Windows), который легко
можно передать заказчику. Такую модель можно представить, если на
рис. 2.2 объединить байткод и PVM в единый компонент – фиксиро
ванный двоичный файл.
На сегодняшний день существует три основных инструмента создания
фиксированных двоичных файлов: py2exe (для Windows), PyInstaller
(напоминает py2exe, но также работает в Linux и UNIX и способен про
изводить самоустанавливающиеся исполняемые файлы) и freeze (ори
гинальная версия). Вам придется загружать эти инструменты отдельно
от Python, но они распространяются совершенно бесплатно. Кроме то
го, они постоянно развиваются, поэтому за дополнительной информа
цией об этих инструментах обращайтесь на сайт проекта Python (http://
www.python.org) и Vaults of Parnassus (http://www.vex.net/parnassus/).
Чтобы дать вам общее представление об области применения этих ин
струментов, замечу, что py2exe может создавать автономные програм
мы, использующие библиотеки Tkinter, PMW, wxPython и PyGTK для
создания графического интерфейса; программы, использующие инст
рументальные средства создания игр pygame; клиентские программы
win32com и многие другие.
Фиксированные двоичные файлы – это не то же самое, что получается
в результате работы настоящего компилятора, потому что они выпол
няют байткод с помощью виртуальной машины. Следовательно, про
граммы в фиксированных двоичных файлах исполняются с той же
скоростью, что и обычные файлы с исходными текстами программ,
разве что улучшен способ их запуска. Фиксированные двоичные фай
лы имеют немалый размер (они содержат в себе PVM), но по современ
ным меркам их все же нельзя назвать необычно большими. Так как
интерпретатор Python встроен непосредственно в фиксированные дво
ичные файлы, его установка не является обязательным требованием
для запуска программ на принимающей стороне. Более того, посколь
ку программный код упакован в фиксированный двоичный файл, он
надежно скрыт от получателя.
Такая схема упаковки программ в единственный файл особенно подхо
дит для нужд разработчиков коммерческого программного обеспечения.
70 Глава 2. Как Python запускает программы
Например, программа с графическим интерфейсом на базе Tkinter мо
жет быть упакована в исполняемый файл и распространяться как са
мостоятельная программа на CD или через Интернет. Конечному поль
зователю не нужно будет устанавливать (и даже знать о том, что это та
кое) Python, чтобы запустить распространяемую программу.
Будущие возможности
В заключение обратите внимание, что модель выполнения, обсуждав
шаяся здесь, в действительности является лишь отражением текущей
реализации интерпретатора Python, но не самого языка программиро
вания. Например, вполне возможно, что в течение времени, пока эта
книга будет сохранять актуальность (едва ли она сохранится у кого
нибудь через десять лет), появится традиционный компилятор для
трансляции исходного текста на языке Python в машинный код. Кро
ме того, в будущем могут появиться новые варианты реализации ин
терпретатора и разновидности байткода. Например:
• Недавно появившийся проект Parrot поставил перед собой цель вы
работать единый формат байткода, единую виртуальную машину
и методики оптимизации для различных языков программирова
ния (подробности на сайте http://www.python.org).
• Stackless Python – вариант стандартной реализации CPython, в ко
торой не производится сохранение состояния на стеке вызовов язы
ка C. Это упрощает перенос Python на архитектуры с небольшим
размером стека и открывает новые возможности программирова
ния, такие как сопрограммы.
• Новый проект PyPy – попытка реализовать PVM непосредственно
на языке Python, что позволит использовать новые приемы про
граммирования.
Подобные грядущие схемы реализации могут несколько изменить схе
му времени выполнения интерпретатора Python, однако скорее всего
компилятор байткода останется стандартом еще какоето время. Пе
реносимость и гибкость байткода во время выполнения – это очень
важные качества многих реализаций Python. Более того, добавление
в язык конструкций объявления типов с целью обеспечения статиче
ской компиляции только повредит гибкости, осмысленности, простоте
и общему духу языка Python. Изза динамической природы языка Py
thon любые реализации в будущем скорее всего сохранят некоторые
черты нынешней PVM.
В заключение
В этой главе была представлена модель выполнения Python (как Py
thon запускает программы) и исследованы некоторые наиболее извест
ные разновидности этой модели (динамические компиляторы и тому
подобное). Чтобы писать сценарии на языке Python, вам необязатель
Закрепление пройденного 71
но знать внутреннюю организацию интерпретатора и, тем не менее,
некоторое знакомство с темой этой главы поможет вам понять, как вы
полняются ваши программы. В следующей главе вы начнете выпол
нять свой собственный программный код. А теперь – обычные кон
трольные вопросы.
Закрепление пройденного
Контрольные вопросы
1. Что такое интерпретатор Python?
2. Что такое исходный программный код?
3. Что такое байткод?
4. Что такое PVM?
5. Назовите две разновидности стандартной модели выполнения Py
thon.
6. В чем заключаются различия между CPython, Jython и IronPython?
Ответы
1. Интерпретатор Python – это программа, которая выполняет про
граммы на языке Python.
2. Исходный программный код – это инструкции, составляющие ва
шу программу. Он состоит из текста в текстовых файлах, имена ко
торых обычно имеют расширение .py.
3. Байткод – это низкоуровневое представление программы после ее
компиляции. Python автоматически сохраняет полученный байт
код в файлах с расширением .pyc.
4. PVM – это Python Virtual Machine (виртуальная машина Python) –
механизм Python, который интерпретирует компилированный про
граммный код.
5. Psyco, Shedskin и фиксированные двоичные файлы – все это разно
видности модели выполнения.
6. CPython – это стандартная реализация языка. Jython и IronPython
реализуют поддержку программирования на языке Python в среде
Java и .NET, соответственно; они являются альтернативными ком
пиляторами языка Python.
3
Как пользователь запускает программы
Итак, настал момент запустить какойнибудь программный код. Те
перь, когда вы получили представление, как программы запускаются,
вы готовы приступать к программированию на языке Python. С этого
момента я буду предполагать, что интерпретатор Python уже установ
лен у вас на компьютере, в противном случае вернитесь к предыдущей
главе, а также прочитайте приложение A, где приводятся советы по
установке и настройке интерпретатора.
Существует несколько способов заставить интерпретатор Python вы
полнить программу, которую вы написали. В этой главе рассматрива
ются все наиболее часто используемые приемы запуска программ. По
путно вы узнаете, как вводить программный код в интерактивном ре
жиме, как сохранять его в файлах, которые можно будет запускать из
командной строки, щелчком на ярлыке и импортировать в виде моду
лей. Мы также поговорим об интегрированных средах разработки с гра
фическим интерфейсом, таких как IDLE и Eclipse, и о многом другом.
Если вам требуется лишь узнать, как запускать программы на языке
Python, прочитайте раздел, где описывается ваша платформа, и пере
ходите к главе 4. Однако не пропускайте материал, где описывается
импортирование модулей, потому что эти сведения являются основой
для понимания архитектуры программ на языке Python. Я также ре
комендую просмотреть разделы с описанием IDLE и других интегриро
ванных сред разработки, чтобы вы представляли, какие инструмен
тальные средства доступны, когда приступите к разработке более слож
ных программ.
Интерактивный режим
Пожалуй, самый простой способ запускать программы на языке Py
thon – это вводить инструкции непосредственно в командной строке
Интерактивный режим 73
интерпретатора. Запустить эту командную строку можно разными
способами – в интегрированной среде разработки, в системной консо
ли и т. д. Предположим, что интерпретатор установлен в вашей систе
ме как выполняемая программа, тогда самый универсальный способ
запустить интерактивный сеанс работы с интерпретатором заключает
ся в том, чтобы ввести команду python, без аргументов, в командной
строке вашей операционной системы. Например:
% python
Python 2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)] on
win 32
Type "help", "copyright", "credits" or "license" for more information.
>>>
После ввода слова «python» командная оболочка вашей операционной
системы запустит интерактивный сеанс работы с интерпретатором Py
thon (символ «%» здесь означает строку приглашения к вводу, он не
должен вводиться вами). Понятие системной командной строки явля
ется универсальным, но как получить доступ к ней, зависит от исполь
зуемой платформы:
• В операционной системе Windows команду python можно ввести
в консоли DOS (она же – Командная Строка (Command Prompt), которую
обычно можно найти в разделе Стандартные (Accessories), меню Все про
граммы (Programs), которое появляется после щелчка на кнопке Пуск
(Start)), или в диалоге Пуск→ Выполнить… (Start→Run…).
• В операционных системах UNIX, Linux и Mac OS X эту команду
можно ввести в командной оболочке или в окне терминала (напри
мер, в xterm или в консоли, где запущена командная оболочка, та
кая как ksh или csh).
• В других операционных системах можно использовать похожие
или какието специфичные для платформы устройства. Например,
чтобы запустить интерактивный сеанс в PalmPilots, можно щелк
нуть на ярлыке Python.
Если вы не включили путь к каталогу установки Python в переменную
окружения PATH, вам вместо простого слова «python» может потребо
ваться ввести полный путь к выполняемой программе. В операционной
системе Windows можно попробовать ввести команду C:\Python25\python
(для версии 2.5); в UNIX и в Linux: /usr/local/bin/python (или /usr/bin/
python). Или перед вводом команды «python» можно перейти в каталог,
куда был установлен интерпретатор Python (для этого в операционной
системе Windows, например, можно выполнить команду cd c:\python25).
Интерактивный сеанс работы с интерпретатором Python начинается
с вывода двух строк информационного текста (которые я буду опус
кать в примерах, для экономии места), затем выводится приглашение
к вводу >>>, когда интерпретатор Python переходит в режим ожидания
ввода новой инструкции или выражения. При работе в интерактивном
режиме результаты выполнения ваших инструкций будут выводиться
74 Глава 3. Как пользователь запускает программы
сразу же вслед за строкой с приглашением >>>. Ниже приводятся ре
зультаты выполнения двух инструкций print:
% python
>>> print 'Hello world!'
Hello world!
>>> print 2 ** 8
256
Вам пока также не стоит вникать в детали инструкций print, приве
денных здесь (изучение синтаксиса мы начнем в следующей главе).
В двух словах, эта инструкция вывела текстовую строку и целое чис
ло, как видно в строках, которые были напечатаны ниже строк с при
глашением к вводу >>>.
При работе в интерактивном режиме, как показано в этом примере, вы
можете вводить любое число команд Python, и каждая из них будет вы
Тестирование программного кода
в интерактивном режиме
Благодаря тому, что программный код выполняется немедлен
но, интерактивный режим превращается в замечательный инст
румент для выполнения экспериментов с конструкциями язы
ка. Интерактивная оболочка часто будет использоваться в этой
книге для демонстрации небольших примеров. Самое первое,
что вы должны запомнить: если вы чувствуете, что не понимае
те, как работает тот или иной участок программного кода на
языке Python, запустите интерактивный сеанс и попробуйте вве
сти этот фрагмент, чтобы посмотреть, что произойдет. В этом
случае вы едва ли чтонибудь испортите (чтобы стать опасным
для системы, вы должны хорошо знать системные интерфейсы).
Интерактивная оболочка может использоваться для тестирова
ния программного кода, сохраненного в файлах, что избавит вас
от необходимости вводить значительные объемы программного
кода при работе в интерактивном режиме (ведь программный код,
который здесь вводится, не сохраняется). В интерактивном режи
ме вы можете импортировать файлы модулей и тестировать функ
циональные возможности, которые они предоставляют, вводя вы
зовы функций в строке с приглашением к вводу. В более широком
понимании интерактивная оболочка – это инструмент для тести
рования программных компонентов независимо от их происхож
дения – вы можете вводить вызовы функций из связанных биб
лиотек на языке C, создавать экземпляры классов Java в интер
претаторе Jython и многое другое. Интерпретатор поддерживает
возможность проведения экспериментов и исследований при про
граммировании, и вы найдете это удобным, начав работать с ним.
Интерактивный режим 75
полняться сразу же после ввода. Более того, поскольку в интерактив
ном сеансе результаты выражений, которые вы вводите, печатаются ав
томатически, вам необязательно явно вводить «print» после подсказки:
>>> lumberjack = 'okay'
>>> lumberjack
'okay'
>>> 2 ** 8
256
>>> # Для завершения сеанса используйте комбинацию клавиш CtrlD или CtrlZ
%
В этом примере две последние введенные строки являются выражения
ми (lumberjack и 2 ** 8), и результаты их вычисления отображаются ав
томатически. Чтобы завершить работу интерактивного сеанса, как по
казано в данном примере, и вернуться в системную командную строку,
в UNIXподобной системе нажмите комбинацию клавиш CtrlD, а в сис
темах MSDOS и Windows – комбинацию CtrlZ. В интегрированной сре
де разработки IDLE, которая будет рассматриваться ниже, нужно либо
нажать комбинацию клавиш CtrlD, либо просто закрыть окно.
В приведенных примерах мы сделали немногое – всего лишь ввели не
сколько инструкций print, одну инструкцию присваивания и несколь
ко выражений, подробнее о которых мы поговорим позднее. Главное, на
что следует обратить внимание, – интерпретатор немедленно выполняет
введенный программный код, сразу же после нажатия клавиши Enter.
Например, когда в строке приглашения к вводу >>> была введена пер
вая инструкция print, результат (строка) был немедленно выведен на
экран. Нам не потребовалось создавать файл с исходным текстом про
граммы и для выполнения программного кода не понадобилось снача
ла компилировать и компоновать его, что является обычным делом
при использовании таких языков программирования, как C или C++.
Как будет показано в последующих главах, при работе с интерактив
ной оболочкой вы можете также вводить многострочные инструкции –
такие инструкции будут выполняться только после ввода всех строк.
Помимо ввода команды python в окне командной оболочки, вы также
можете запустить подобный интерактивный сеанс в главном окне ин
тегрированной среды разработки IDLE или, в Windows, выбрав пункт
Python (commandline) (Python (командная строка)) в меню кнопки Пуск
(Start), как показано на рис. 2.1. В любом случае вы получите строку
приглашения к вводу >>> с одинаковыми функциональными возмож
ностями – инструкции выполняются сразу же после ввода.
Использование интерактивного режима
Несмотря на то что интерактивный режим прост в использовании, я хо
чу дать несколько советов начинающим, которые следует запомнить:
• Вводите только инструкции на языке Python. Прежде всего, следует
запомнить, что в интерактивном режиме допускается вводить только
76 Глава 3. Как пользователь запускает программы
программный код на языке Python, никаких системных команд.
В программном коде Python предусмотрены возможности выполнять
системные команды (например с помощью os.system), но они не отли
чаются простотой по сравнению с непосредственным вводом команд.
• Инструкция print необходима только в файлах. Поскольку в инте
рактивном режиме интерпретатор автоматически выводит резуль
таты вычисления выражений, вам не требуется вводить полные ин
струкции print при работе в интерактивном режиме. Это замеча
тельная особенность, но она часто приводит пользователей в заме
шательство, когда они приступают к созданию программного кода
в файлах: чтобы программный код в файлах мог чтото выводить,
вы должны использовать инструкции print, потому что в этом слу
чае результаты выражений уже не выводятся автоматически. За
помните, вы должны использовать инструкцию print в файлах, но
не в интерактивном режиме.
• Не используйте отступы в интерактивном режиме (пока). При вво
де программ на языке Python, как в интерактивном режиме, так
и в текстовых файлах, вы обязаны начинать все не вложенные ин
струкции с позиции 1 (то есть с самого начала строки). Если вы не
будете следовать этому правилу, Python может вывести сообщение
«SyntaxError» (синтаксическая ошибка). Пока мы не подойдем
к главе 10, все инструкции, которые вам придется вводить, будут
не вложенными, поэтому пока данное правило распространяется на
все, что будет вводиться. То же относится и к классам Python. Веду
щий пробел в строке вызывает сообщение об ошибке.
• Будьте внимательны, когда строка приглашения к вводу изменяет!
ся на строку ввода составной инструкции. Нам не придется сталки
ваться с составными (многострочными) инструкциями до главы 10,
но вы должны знать, что при вводе второй и каждой последующей
строки составной инструкции в интерактивном режиме строка при
глашения к вводу может изменяться. В простом окне с командной
строкой приглашение к вводу >>> во второй и каждой последующей
строке изменяется на ..., в интегрированной среде IDLE все стро
ки, кроме первой, автоматически получают отступы. В любом слу
чае, чтобы в интерактивном режиме сообщить интерпретатору, что
вы приступаете к вводу многострочной инструкции, необходимо
начинать ее ввод с ввода пустой строки (делается это нажатием кла
виши Enter в начале строки). В файлах, в противоположность этому,
пустые строки интерпретатором игнорируются.
Почему это имеет важное значение, вы узнаете в главе 10. А пока,
если вдруг случится, что вы получите приглашение к вводу ... или
пустую строку при вводе программного кода, это скорее всего будет
означать, что какимто образом вам удалось заставить интерактив
ную оболочку Python думать, что вы начали ввод многострочной
инструкции. Попробуйте нажать комбинацию CtrlC или клавишу
Enter, чтобы вернуться к основному приглашению к вводу. Пригла
Системная командная строка и файлы 77
шения >>> и ... также могут изменяться (они доступны во встроен
ном модуле sys), но в последующих листингах я буду предполагать,
что они не изменялись.
Системная командная строка и файлы
Хотя интерактивная командная оболочка является прекрасным инст
рументом для проведения экспериментов, тем не менее у нее есть один
существенный недостаток: программы, которые вы вводите во время
интерактивного сеанса, исчезают сразу же после того, как интерпрета
тор Python выполнит их. Программный код, который вводится в инте
рактивном режиме, нигде не сохраняется, поэтому вы не сможете за
пустить его еще раз, не введя код с самого начала. Операция копирова
ния и вставки, а также возможность повторного выполнения коман
ды, могут оказать некоторую помощь, но они не способны принести
пользу, когда вы начнете писать большие программы. Чтобы восполь
зоваться операцией копирования и вставки, вы должны исключить из
копирования строку приглашения к вводу, результаты, которые про
грамма выводит в процессе выполнения, и т. д.
Чтобы хранить программы длительное время, вам необходимо сохра
нять программный код в файлах, которые обычно называются модуля+
ми. Модули – это простые текстовые файлы, содержащие инструкции
на языке Python. Как только такой файл будет создан, вы можете пред
ложить интерпретатору Python выполнить инструкции в нем столько
раз, сколько пожелаете. Такой файл можно запустить на выполнение
разными способами – из командной строки системы, щелчком на яр
лыке файла, из интегрированной среды IDLE и другими способами.
Независимо от выбранного вами способа интерпретатор Python будет
выполнять весь программный код в модуле от начала до конца всякий
раз, когда вы будете его запускать.
Терминология в этой области может несколько изменяться. Напри
мер, файлы модулей часто называются программами на языке Python,
где под программой понимается последовательность заранее написан
ных инструкций, сохраненных в файле для обеспечения возможности
многократного использования. Файлы модулей, которые запускаются
на выполнение непосредственно, иногда называют сценариями – этим
неофициальным термином обозначаются файлы программ верхнего
уровня. Термин «модуль» зарезервирован для обозначения файлов,
которые могут импортироваться другими файлами. (Подробнее о про
граммах «верхнего уровня» и об импорте будет говориться чуть ниже.)
Как бы вы ни называли их, в следующих нескольких разделах исследу
ются способы запуска программного кода, который был сохранен в фай
лах модулей. В этом разделе вы узнаете, как запускать файлы наиболее
типичным способом: перечислением их имен в команде python при за
пуске из системной командной строки. В качестве первого упражне
ния откройте привычный для вас текстовый редактор (например, vi,
78 Глава 3. Как пользователь запускает программы
Notepad или редактор IDLE) и сохраните следующие две инструкции
в файле с именем spam.py:
print 2 ** 8 # Возведение в степень
print 'the bright side ' + 'of life' # Знак + означает конкатенацию строк
Этот файл содержит две инструкции print и пару комментариев спра
ва. (Текст, который следует за символом #, просто игнорируется и счи
тается комментарием, созданным для удобства человека; коммента
рии не являются частью инструкций.) Пока не нужно вникать в син
таксис программного кода в этом файле. Главное здесь то, что про
граммный код вводится в текстовый файл, а не в интерактивной
командной оболочке интерпретатора Python. Итак, вы создали полно
ценный сценарий на языке Python.
Сохранив этот текстовый файл, вы сможете предложить интерпрета
тору Python выполнить его, указав полное имя файла в качестве пер
вого аргумента команды python, введя следующую строку в системной
командной строке:
% python spam.py
256
the bright side of life
И в этом случае также вы должны использовать командную оболочку,
которая предоставляется вашей операционной системой, – в окне Ко
мандная строка (Command Prompt) в Windows, в xterm или в подобных им
программах. Не забывайте заменять слово «python» на полный путь
к исполняемому файлу интерпретатора, если переменная окружения
PATH у вас не настроена. Вывод этого сценария можно наблюдать ниже
строки, где была введена команда, – это результат работы двух инст
рукций print, находящихся в текстовом файле.
Обратите внимание, что файл модуля называется spam.py. Как и лю
бой другой файл верхнего уровня, он мог бы также называться просто
spam, однако файлы, которые должны импортироваться клиентом,
обязаны иметь расширение .py. Вопросы импорта мы будем обсуждать
ниже, в этой же главе.
Позднее вам может потребоваться импортировать тот или иной файл,
поэтому всегда желательно использовать расширение .py в именах
файлов с программным кодом на языке Python. Кроме того, некоторые
текстовые редакторы определяют принадлежность файлов по расши
рению .py – если расширение отсутствует, вы можете лишиться таких
функциональных возможностей редактора, как подсветка синтаксиса
и автоматическое оформление отступов.
Поскольку в данной ситуации для запуска программ на языке Python
используется командная оболочка, можно применять любые синтакси
ческие конструкции, допускаемые командной оболочкой. Например,
можно перенаправить вывод сценария Python в файл, чтобы детально
исследовать полученные результаты позднее, как показано ниже:
Системная командная строка и файлы 79
% python spam.py > saveit.txt
В этом случае две строки, которые были показаны в предыдущем при
мере запуска сценария, не будут выводиться на экран, а будут записа
ны в файл saveit.txt. Это широко известная возможность перенаправ+
ления потоков – она может использоваться как для вывода текста, так
и для ввода. Она присутствует в Windows и в UNIXподобных систе
мах. Она мало связана с Python (интерпретатор Python просто поддер
живает ее), поэтому здесь мы не будем углубляться в подробности ра
боты механизма перенаправления.
Если вы пользуетесь операционной системой Windows, этот пример
также будет работать, хотя сама командная строка будет выглядеть
несколько иначе:
C:\Python25> python spam.py
256
the bright side of life
Если у вас переменная окружения PATH не настроена и не был выпол
нен переход в каталог интерпретатора, вам необходимо вводить пол
ный путь к исполняемому файлу интерпретатора Python:
D:\temp> C:\python25\python spam.py
256
the bright side of life
В новейших версиях Windows вы можете просто вводить имя файла
сценария независимо от того, в каком каталоге вы находитесь, потому
что новейшие версии системы Windows отыскивают программы, необ
ходимые для запуска файлов, с помощью реестра Windows и вам не
требуется явно указывать ее в командной строке. Например, в совре
менных версиях Windows предыдущую команду можно упростить до:
D:\temp> spam.py
Наконец, не нужно забывать указывать полный путь к файлу сцена
рия, если он находится в каталоге, отличном от того, в котором вы ра
ботаете. Например, следующая команда будет работать в каталоге
D:\other, в предположении, что путь к команде python включен в пере
менную окружения PATH, но она должна запустить сценарий, располо
женный в некотором другом каталоге:
D:\other> python c:\code\myscript.py
Использование системной командной строки и файлов
Запуск файлов программ из командной строки системы является дос
таточно простой задачей, особенно если вы и раньше работали с ко
мандной строкой. Тем не менее ниже описываются несколько лову
шек, в которые часто попадают начинающие:
• Остерегайтесь автоматического присвоения расширения файлам
в операционной системе Windows. Если для создания файлов про
80 Глава 3. Как пользователь запускает программы
грамм в Windows вы пользуетесь редактором Блокнот (Notepad), пе
ред сохранением выбирайте тип файла Все файлы (All Files) и явно
указывайте расширение .py. В противном случае Блокнот (Notepad)
будет присваивать файлам расширение .txt (например, spam.py.txt),
что в некоторых ситуациях осложнит запуск таких файлов.
Хуже того, по умолчанию операционная система Windows скрывает
расширения файлов, поэтому если вы забыли указать тип файла, вы
можете даже не заметить, что создали обычный текстовый файл,
а не файл, который должен запускаться интерпретатором Python.
Здесь вам может помочь ярлык файла – если на нем отсутствует
изображение головы змеи, у вас могут появиться некоторые про
блемы с запуском. Отсутствие подсветки синтаксиса в IDLE и от
крытие файла в редакторе вместо его запуска в результате щелчка
мышью могут служить еще одним признаком этой проблемы.
Текстовый процессор Microsoft Word похожим образом по умолча
нию добавляет расширение .doc. Мало этого, он добавляет в файл
символы форматирования, которые являются недопустимыми с точ
ки зрения синтаксиса Python. Поэтому возьмите за правило всегда
выбирать тип файла Все файлы (All Files) при сохранении в операцион
ной системе Windows или используйте более удобные для програм
мистов текстовые редакторы, такие как IDLE. IDLE не добавляет рас
ширение к имени файла автоматически, даже расширение .py – эта
особенность нравится программистам, но не пользователям.
• Указывайте расширение в командной строке, но не в инструкциях
импорта. Не забывайте указывать полное имя файла в командной
строке, то есть используйте, например, команду python spam.py, а не
python spam. Инструкция import, с которой мы познакомимся ниже,
в этой же главе, требует, чтобы путь к файлу и его расширение бы
ли опущены (например, import spam). Это несложно, но данная осо
бенность часто является источником ошибок.
Интерпретацией команды в командной строке занимается система,
а не интерпретатор Python, поэтому в ней неприменимы правила по
иска файлов, которые использует Python. Поэтому в командной
строке необходимо всегда указывать расширение файла .py и при не
обходимости – путь к файлу, который требуется запустить. Напри
мер, чтобы запустить файл, находящийся в каталоге, отличном от
того, в котором вы работаете, обычно необходимо указать полный
путь к файлу (например, C:\python25>python d:\tests\spam.py). Однако
в программном коде на языке Python вам достаточно просто указать
инструкцию import spam и доверить интерпретатору самому отыскать
требуемый файл в пути поиска модулей, как будет описано ниже.
• Используйте в файлах инструкции print. Да, мы уже говорили об
этом, но это настолько распространенная ошибка, что она вполне
заслуживает, чтобы еще раз напомнить о ней. В отличие от инте
рактивного режима, чтобы вывести результаты работы файлов про
грамм на экран, вы должны использовать инструкции print.
Системная командная строка и файлы 81
Исполняемые сценарии в UNIX (#!)
Если вы используете Python в UNIX, Linux или в другой UNIXподоб
ной операционной системе, вы можете превратить файлы с программ
ным кодом на языке Python в исполняемые программы, точно так же,
как программы на таких языках командной оболочки, как ksh или
csh. Такие файлы обычно называются исполняемыми сценариями.
Проще говоря, исполняемые сценарии в UNIXподобных системах –
это обычные текстовые файлы, содержащие инструкции на языке Py
thon, но обладающие двумя необходимыми свойствами:
• Первая строка имеет специальный формат. Первая строка в сцена
риях, как правило, начинается с символов #! (эта комбинация час
то называется как «hash bang»), за которыми следует путь к интер
претатору Python.
• Как правило для них установлено право на выполнение. Обычно
файлы сценариев помечаются как исполняемые файлы, чтобы сооб
щить системе, что они могут быть запущены как программы верх
него уровня. В UNIXподобных системах это обычно делается с по
мощью такой команды, как chmod +x file.py.
Давайте рассмотрим пример для UNIXподобных систем. Сначала с по
мощью текстового редактора создайте файл модуля Python с именем
brian:
#!/usr/local/bin/python
print 'The Bright Side of Life...' # Это еще один комментарий
Первая строка в файле сообщает системе, где находится интерпретатор
Python. С технической точки зрения для интерпретатора Python пер
вая строка является комментарием. Как уже говорилось ранее, все, что
начинается с символа # и до конца строки, является комментарием –
в них размещается дополнительная информация, предназначенная для
человека, который будет читать ваш программный код. Но когда в фай
ле присутствует комментарий, такой как в первой строке, он приобре
тает особый смысл, потому что система использует его для поиска ин
терпретатора, который будет выполнять остальной программный код
в файле.
Кроме того, обратите внимание, что этот файл называется просто brian,
в его имени отсутствует расширение .py, которое мы использовали ранее
для обозначения модулей. Наличие расширения .py не повредило бы
(и даже лишний раз напоминало бы, что это файл программы на языке
Python), но так как этот файл не планируется импортировать из дру
гих модулей, такое имя файла является вполне допустимым. Если
дать этому файлу право на выполнение с помощью команды chmod +x
brian, вы сможете запускать его из командной строки системы, как ес
ли бы это была самая обычная программа:
% brian
The Bright Side of Life...
82 Глава 3. Как пользователь запускает программы
Для пользователей Windows замечу, что метод, описываемый здесь,
характерен для UNIX и может быть неприменим на вашей платформе.
Однако вам незачем волноваться, просто используйте метод запуска,
который описывался выше. Укажите имя выполняемого файла, как
первый аргумент команды python.1
C:\book\tests> python brian
The Bright Side of Life...
В этом случае не требуется добавлять специальный комментарий #!
в начало файла (хотя, если он присутствует, Python просто игнорирует
его), и файл не должен иметь право на выполнение. Фактически, если вы
1 Как уже говорилось при обсуждении командной строки, современные вер
сии Windows позволяют указывать в командной строке лишь имя файла
с расширением .py – эти версии Windows с помощью реестра определяют,
что данный файл должен открываться с использованием интерпретатора
Python (например, команда brian.py в них эквивалентна команде python
brian.py). Такой режим работы командной строки сродни использованию #!
в системах UNIX. Следует заметить, что некоторые программы для Win
dows действительно могут использовать и интерпретировать первую строку
#!, но командная оболочка DOS в Windows полностью игнорирует ее.
Трюк с использованием команды env в UNIX
В некоторых версиях системы UNIX можно избежать явного
указания пути к интерпретатору Python, если специальный ком
ментарий в первой строке оформить следующим образом:
#!/usr/bin/env python
...здесь находится программный код сценария...
При таком подходе программа env отыщет интерпретатор Py
thon в соответствии с настройками пути поиска (то есть в боль
шинстве командных оболочек UNIX поиск будет произведен во
всех каталогах, перечисленных в переменной окружения PATH).
Такой способ может оказаться более универсальным, так как он
не требует жестко указывать во всех сценариях путь к каталогу,
куда был установлен Python.
Если у вас имеется доступ к программе env из любого места, ва
ши сценарии будут запускаться независимо от того, где находит
ся интерпретатор Python, – вам достаточно будет лишь настроить
переменную окружения PATH в своих системах, не внося исправле
ния в первую строку всех сценариев. Безусловно, этот способ
предполагает, что во всех системах программа env находится в од
ном и том же каталоге (в некоторых системах она может распо
лагаться в каталогах /sbin, /bin или гдето еще), в противном
случае о переносимости не может быть и речи.
Щелчок на ярлыке файла 83
хотите обеспечить переносимость процедуры запуска между UNIX и Mi
crosoft Windows, ваша жизнь наверняка станет проще, если вы всегда
будете использовать типичный подход к запуску программ из команд
ной строки, а не стиль, используемый для запуска сценариев в UNIX.
Щелчок на ярлыке файла
Использование реестра в операционной системе Windows позволяет от
крывать файл просто щелчком мыши. При установке интерпретатор Py
thon автоматически регистрирует себя в качестве программы, исполь
зуемой для открытия файлов с программами на языке Python щелчком
мыши. Это делает возможным запуск программ на языке Python про
стым щелчком (или двойным щелчком) мыши на ярлыке файла.
В операционных системах, отличных от Windows, вы наверняка сможе
те проделать аналогичный трюк, но сами ярлыки, программа просмот
ра файловой системы, система навигации и прочее могут несколько от
личаться. В некоторых системах UNIX, например, может потребовать
ся зарегистрировать расширение .py в программе просмотра файловой
системы, сделать свой сценарий исполняемым файлом, использующим
специальный комментарий #!, как обсуждалось в предыдущем разделе,
или связать тип MIME файла с приложением или командой редактиро
вания файлов за счет установки программ или с помощью других инст
рументальных средств. Если щелчок мышью не дает нужного результа
та, обращайтесь к документации используемой программы просмотра
файловой системы за дополнительной информацией.
Щелчок на ярлыке в Windows
Чтобы продемонстрировать эту возможность, предположим, что у вас
имеется следующая программа на языке Python, которая была сохра
нена в файле script4.py:
# Комментарий
import sys
print sys.platform
print 2 ** 100
Здесь не так много нового – всего лишь инструкция import и две инст
рукции print (sys.platform – это всего лишь строка, идентифицирую
щая платформу, с которой вы работаете; она определена в модуле с име
нем sys, который необходимо импортировать). Эту программу можно
запустить из командной строки системы:
D:\LP3E\Examples> c:\python25\python script4.py
win32
1267650600228229401496703205376
Однако эту программу можно также запустить щелчком мыши, вооб
ще ничего не вводя с клавиатуры. Можно попробовать отыскать ярлык
этого файла, например, щелкнув на ярлыке Мой компьютер (My Computer)
84 Глава 3. Как пользователь запускает программы
и выполнив переход вглубь дерева каталогов на диске D, в этом случае
вы получите изображение в проводнике, как показано на рис. 3.1 (этот
снимок с экрана был получен в Windows XP). В случае использования
Python 2.5 ярлыки файлов с исходными текстами программ содержат
изображение с текстом на белом фоне, а ярлыки с байткодом – изобра
жение с текстом на черном фоне. Чаще вам придется щелкать (то есть
запускать) на файлах с исходными текстами, чтобы увидеть последние
изменения. Для запуска файла здесь нужно просто щелкнуть на ярлы
ке файла script4.py.
Использование функции raw_input
К сожалению, запуск файла в Windows щелчком на ярлыке может не
привести к удовлетворяющему вас результату. В действительности,
как в данном примере, запуск сценария вызывает появление окна на
очень короткое время, чего явно недостаточно для обеспечения обрат
ной связи, на которую так надеются программисты, использующие
язык Python! Это не ошибка, это лишь особенность обслуживания вы
вода программы в Windows.
По умолчанию интерпретатор Python открывает черное окно консоли
DOS, которое будет служить местом для ввода и вывода программы.
Если сценарий выводит какоето сообщение и завершает работу, что
и происходит в приведенном примере, то окно консоли открывается,
туда выводится текст сообщения, но по завершении программы окно
закрывается и исчезает. Вы сможете увидеть этот текст, только если
вы обладаете мгновенной реакцией или ваш компьютер не отличается
Рис. 3.1. В Windows файлы с программами на языке Python отображаются
в проводнике в виде ярлыков и могут быть запущены двойным щелчком мыши
(хотя при этом вы можете не увидеть текст, выводимый программой,
и сообщения об ошибках)
Щелчок на ярлыке файла 85
высокой скоростью работы. Это вполне нормальное поведение, но ско
рее всего это совсем не то, что вы имели в виду.
К счастью, этот недостаток легко ликвидируется. Если вам требуется,
чтобы результаты работы сценария оставались на экране после щелч
ка мышью на ярлыке файла, просто добавьте вызов встроенной функ
ции raw_input в самом конце сценария. Например:
# Комментарий
import sys
print sys.platform
print 2 ** 100
raw_input() # Добавленная строка
Вообще, функция raw_input считывает следующую строку с устройства
стандартного ввода, ожидая ее, если она еще недоступна. В результате
в данном случае сценарий приостанавливается, благодаря чему окно
остается на экране, пока не будет нажата клавиша Enter, как показано
на рис. 3.2.
Теперь, когда я продемонстрировал этот трюк, вы должны иметь в ви
ду, что прибегать к нему требуется только в операционной системе
Windows, и только если сценарий выводит какиелибо сообщения,
и только если сценарий запускается щелчком мыши на ярлыке. Вызов
функции следует добавлять в самый конец файлов верхнего уровня
и только при выполнении всех трех перечисленных условий. Во всех
остальных случаях нет смысла добавлять этот вызов.1
1 Кроме того, существует возможность полностью подавить появление окна
консоли DOS при запуске файлов щелчком мыши в Windows. Программы,
имена файлов которых имеют расширение .pyw, отображают только те ок
на, которые создаются самими сценариями, – окно консоли DOS при запус
ке таких файлов не открывается. Файлы с расширением .pyw – это обычные
файлы .py с исходными текстами, которые в операционной системе Win
dows обслуживаются специальным образом. Главным образом они исполь
зуются для сценариев Python, которые сами создают окна пользователь
ского интерфейса, что часто сочетается с организацией вывода в файлы ре
зультатов работы и сообщений об ошибках.
Рис. 3.2. При запуске программы в Windows щелчком мыши на ярлыке можно
увидеть результаты ее работы, если добавить вызов функции raw_input()
в самый конец сценария. Но делать это следует, только если это
действительно необходимо!
86 Глава 3. Как пользователь запускает программы
Следует отметить, что функция raw_input – это средство для ввода ин
формации, дополняющая инструкцию print, которая является средст
вом вывода. Она представляет собой простейший способ чтения вводи
мых данных, и обладает более широкими возможностями, чем было
продемонстрировано в этом примере. Например, функция raw_input:
• Может принимать строку в качестве аргумента, которая будет вы
водиться как подсказка (например, raw_input('Press Enter to exit')).
• Возвращает сценарию текстовую строку (например, nextinput =
raw_input()).
• Поддерживает возможность перенаправления потока ввода на уровне
командной оболочки системы (например, python spam.py < input.txt),
точно так же, как инструкция print поддерживает возможность пе
ренаправления вывода.
Далее в этой книге мы найдем более интересное применение этой
функции: например, в главе 10 эта функция будет использована для
организации интерактивного цикла.
Другие ограничения на запуск щелчком мыши
Даже при использовании функции raw_input запуск файлов щелчком
мыши имеет некоторые недостатки. Вы можете не заметить появление
сообщений об ошибках. Если в ходе работы сценария возникает ошиб
ка, текст сообщения о ней выводится в окно консоли, которое тут же
закрывается. Хуже того, даже добавление вызова raw_input не поможет
в такой ситуации, потому что работа сценария будет прервана еще до
того, как будет выполнен этот вызов. Другими словами, вам будет
сложно определить, что именно пошло не так.
Изза этих ограничений способ запуска программы щелчком мыши на
ярлыке лучше использовать уже после того, как сценарий будет пол
ностью отлажен. Старайтесь использовать другие способы запуска
программ, особенно в самом начале работы над ними, такие как запуск
из командной строки системы и из интегрированной среды разработки
IDLE (будет рассматриваться ниже, в этой же главе). Благодаря этому
вы сможете увидеть сообщения об ошибках и обычный вывод от сцена
рия, не прибегая к разного рода хитростям. Когда позднее в этой книге
мы будем рассматривать исключения, вы узнаете, что существует воз
можность перехватывать и обрабатывать ошибки так, чтобы они не
приводили к аварийному завершению программы. Обратите внимание
на приведенное ниже обсуждение инструкции try, которая предостав
ляет альтернативный способ предотвратить преждевременное закры
тие окна в случае возникновения ошибок.
Импортирование и перезагрузка модулей
Мы уже говорили об «импортировании модулей», но до сих пор я не
давал никаких пояснений, что означает этот термин. Подробно о моду
Импортирование и перезагрузка модулей 87
лях и об архитектуре крупных программ мы будем говорить в пятой
части книги, но так как операция импорта модулей – это еще один из
способов запуска программ, мы рассмотрим в этом разделе основы мо
дулей, чтобы дать вам начальное представление о них.
Проще говоря, каждый файл с исходным текстом на языке Python, имя
которого оканчивается расширением .py, является модулем. Другие
файлы могут обращаться к программным компонентам, объявляемым
модулем, импортируя этот модуль. По сути, инструкция import выпол
няет загрузку другого файла и обеспечивает доступ к его содержимому.
Содержимое модуля становится доступным внешнему миру через его
атрибуты (определение этого термина я дам в следующем разделе).
Эта модульная модель является центральной идеей, лежащей в основе
архитектуры программ на языке Python. Крупные программы обычно
организованы в виде множества файлов модулей, которые импортиру
ют и используют функциональные возможности из других модулей.
Один из модулей определяется как основной файл верхнего уровня, ко
торый запускает всю программу.
Проблемы модульной архитектуры мы будем рассматривать подроб
нее позже, в этой же книге, а в этой главе основное внимание уделяет
ся тому факту, что операция импорта приводит к выполнению про
граммного кода загружаемого файла на заключительном этапе. Как
следствие, импорт файла является еще одним способом запустить его.
Например, если запустить интерактивный сеанс работы с интерпрета
тором (в IDLE, из командной строки или както иначе), можно будет
запустить файл script4.py, созданный ранее, с помощью простой инст
рукции import:
D:\LP3E\Examples> c:\python25\python
>>> import script4
win32
1267650600228229401496703205376
Такой способ пригоден только для однократного запуска модуля в тече
ние сеанса. После первой операции импорта все последующие попытки
импортировать модуль не приводят ни к каким результатам, даже если
изменить и сохранить исходный текст модуля в другом окне:
>>> import script4
>>> import script4
Так сделано преднамеренно – операция импорта требует слишком
больших затрат вычислительных ресурсов, чтобы выполнять ее более
одного раза в ходе выполнения программы. Как вы узнаете в главе 18,
в ходе импорта производится поиск файлов, компиляция их в байт
код и выполнение этого байткода.
Если действительно возникает необходимость вынудить интерпрета
тор многократно запускать файл в рамках одного и того же сеанса (без
88 Глава 3. Как пользователь запускает программы
остановки и перезапуска сеанса), можно воспользоваться встроенной
функцией reload:
>>> reload(script4)
win32
65536
<module 'script4' from 'script4.py'>
>>>
Функция reload загружает и запускает текущую версию программного
кода в файле, если он был изменен в другом окне. Это позволяет редак
тировать и использовать новый программный код в ходе одного и того
же интерактивного сеанса работы с интерпретатором Python. В этом
сеансе, например, уже после того как модуль был импортирован, вто
рая инструкция print в файле script4.py была изменена в другом окне
так, чтобы она выводила результат выражения 2 ** 16, после чего была
выполнена перезагрузка модуля с помощью функции reload.
Функция reload ожидает получить имя уже загруженного модуля, по
этому, прежде чем перезагрузка станет возможной, модуль должен
быть импортирован. Примечательно также, что имя модуля при вызо
ве функции reload должно быть заключено в круглые скобки, тогда
как инструкция import не требует этого. Дело в том, что reload – это
функция, которая вызывается, а import – это инструкция. Именно по
этому имя модуля следует передавать функции reload как аргумент,
в круглых скобках, и именно поэтому после перезагрузки модуля вы
водится дополнительная строка. Последняя строка в выводе выше –
это всего лишь представление результата, возвращаемого функцией
reload после перезагрузки модуля.
Более подробно функции будут обсуждаться в главе 15.
Важные сведения о модулях: атрибуты
Операции импортирования и перезагрузки модулей обеспечивают есте
ственный способ запуска программы, так как на заключительном этапе
этих операций производится исполнение файлов. При этом в более ши
роком понимании модули играют роль библиотек инструментов, как
вы узнаете в пятой части книги. Модуль – это, главным образом, всего
лишь пакет имен переменных, известный как пространство имен.
Имена внутри этого пакета называются атрибутами, то есть атрибут –
это имя переменной, которая связана с определенным объектом.
В самом типичном случае импортирующий программный код получа
ет доступ ко всем именам верхнего уровня, определяемым в файле мо
дуля. Эти имена обычно связаны с функциональными возможностя
ми, экспортируемыми модулем, – функциями, классами, переменны
ми и т. д., которые предназначены для использования в других фай
лах и программах. Снаружи доступ к именам в файле модуля можно
получить с помощью двух инструкций языка Python, import и from,
а также с помощью вызова функции reload.
Импортирование и перезагрузка модулей 89
Для иллюстрации вышесказанного с помощью текстового редактора
создайте однострочный файл модуля Python с именем myfile.py со сле
дующим содержимым:
title = "The Meaning of Life"
Это, пожалуй, один из самых простых модулей Python (он содержит
единственную операцию присваивания), но его вполне достаточно для
иллюстрации основных положений. При импортировании этого моду
ля выполняется его программный код, который создает атрибут моду
ля. Инструкция присваивания создает атрибут с именем title.
Доступ к атрибуту title можно получить из других программных ком
понентов двумя разными способами. Первый заключается в том, что
бы загрузить модуль целиком с помощью инструкции import, а затем
обратиться к атрибуту по его имени, уточнив его именем модуля:
% python # Запуск интерпретатора Python
>>> import myfile # Запуск файла; модуль загружается целиком
>>> print myfile.title # Имя атрибута, уточненное именем модуля через '.'
The Meaning of Life
Вообще синтаксис точечной нотации, в виде object.attribute, позволя
ет получить доступ к любому атрибуту в любом объекте, и этот прием
широко используется в программном коде на языке Python. Здесь мы
использовали его для обращения к строковой переменной title, опре
деленной внутри модуля myfile, – то есть myfile.title.
Кроме того, доступ к именам внутри модулей (фактически, копию
имен) можно получать с помощью инструкции from:
% python # Запуск интерпретатора Python
>>> from myfile import title # Запуск файла; выполняется копирование имен
>>> print title # Имя атрибута используется напрямую, уточнение не требуется
The Meaning of Life
Как будет говориться позднее, инструкция from во многом подобна ин
струкции import, которая выполняет присваивание имен в импорти
руемом компоненте. С технической точки зрения, инструкция from ко
пирует атрибуты модуля так, что они становятся простыми перемен+
ными в программном коде, выполняющем импорт, благодаря чему на
этот раз он может обратиться к импортированной строке уже не по
имени myfile.title (ссылка на атрибут), а просто – title (переменная).1
Неважно, как выполняется импортирование модуля, с помощью инст
рукции import или from, это приводит к выполнению инструкций в файле
1 Обратите внимание: в обеих инструкциях, import и from, имя модуля myfile
указывается без расширения .py. Как вы узнаете в пятой части книги, ко
гда интерпретатор Python выполняет поиск файлов модулей, он знает, что
к имени модуля необходимо добавить расширение. Не забывайте, что рас
ширение обязательно должно указываться при вызове файла в системной
командной оболочке и опускаться в инструкциях import.
90 Глава 3. Как пользователь запускает программы
myfile.py, а импортирующий компонент (в данном случае – интерак
тивная оболочка интерпретатора) получает доступ к именам, опреде
ленным в файле на верхнем уровне. В этом простом примере существу
ет только одно такое имя – переменная title, которой присвоена
строка, но сама концепция приобретает более важное значение, когда
речь заходит об определении в модулях таких объектов, как функции
и классы. Такие объекты становятся программными компонентами
многократного использования, доступ к которым можно получить из
одного или более клиентских модулей.
На практике модули обычно определяют более чем одно имя, которые
могут использоваться и внутри, и за пределами модуля. Ниже приво
дится пример модуля, в котором определяются три имени:
a = 'dead' # Определяются три атрибута,
b = 'parrot' # Экспортируемые другим модулям
c = 'sketch'
print a, b, c # Кроме того, они используются и самим этим модулем
В файле threenames.py создаются три переменные, которые становятся
тремя атрибутами, доступными внешнему миру. Этот модуль сам так
же использует эти переменные в инструкции print, в чем можно убе
диться, если запустить этот модуль как файл верхнего уровня:
% python threenames.py
dead parrot sketch
Как обычно, программный код этого модуля выполняется всего один
раз, при импортировании (с помощью инструкции import или from).
Клиенты, использующие инструкцию import, получают модуль со все
ми его атрибутами, а клиенты, использующие инструкцию from, полу
чают копии имен из этого модуля:
% python
>>> import threenames # Загрузить модуль целиком
dead parrot sketch
>>>
>>> threenames.b, threenames.c
('parrot', 'sketch')
>>>
>>> from threenames import a, b, c # Скопировать несколько имен
>>> b, c
('parrot', 'sketch')
Результаты здесь выводятся в круглых скобках, потому что в действи
тельности они являются кортежами (разновидность объектов, кото
рая описывается в следующей части книги).
Как только вы начнете создавать модули, содержащие несколько
имен, как в данном случае, вам наверняка пригодится встроенная
функция dir. Она может использоваться для получения списка имен,
доступных внутри модуля:
Импортирование и перезагрузка модулей 91
>>> dir(threenames)
['_ _builtins_ _', '_ _doc_ _', '_ _file_ _', '_ _name_ _', 'a', 'b', 'c']
При вызове функции dir передается имя импортированного модуля
в круглых скобках, как показано выше, а возвращает она список всех
атрибутов, определенных внутри модуля. Некоторые возвращаемые
имена, которые начинаются и завершаются двумя символами подчер
кивания, присутствуют всегда; эти встроенные имена определяются са
мим интерпретатором Python и имеют для него особый смысл. Имена
переменных, которые определяются нашими инструкциями присваива
ния, – a, b и c – выводятся в конце списка, получаемого от функции dir.
Модули и пространства имен
Импортирование модулей – это один из способов запуска программно
го кода в файлах, но, помимо этого, и это будет рассмотрено в книге
позже, модули являются также самой крупной структурной единицей
в программах на языке Python. Вообще программы на языке Python
состоят из множества файлов модулей, связанных между собой инст
рукциями import. Каждый файл модуля – это самостоятельный пакет
переменных, или пространство имен. Один модуль не сможет увидеть
переменные, определенные в другом модуле, если явно не импортиру
ет его. Модули позволяют уменьшить вероятность конфликтов имен
в программном коде – т. к. каждый файл является самостоятельным
пространством имен, имена в одном файле не вступают в конфликт
с именами в другом файле, даже если они одинаковые.
Как можно понять, модули – одно из ухищрений, которые использу
ются в языке Python для упаковки переменных в категории, чтобы из
бежать конфликтов имен. Далее мы еще будем обсуждать модули
и другие конструкции образования пространств имен (включая клас
сы и функции). А пока будем использовать модули в качестве средства
многократного использования программного кода, позволяющего не
вводить его повторно с клавиатуры.
import и reload, примечания к использованию
Зачастую, узнав о возможности запуска файлов с помощью import и re
load, начинающие разработчики концентрируют все свое внимание на
этом способе и забывают о других возможностях запуска, позволяю
щих всегда запускать самую свежую версию программного кода (на
пример, щелчок мышью на ярлыке, пункты меню интегрированной
среды разработки IDLE и системная командная строка). Такой подход
может быстро привести к появлению ошибок – вам придется запоми
нать, импортировали ли вы тот или иной модуль, чтобы иметь возмож
ность перезагрузить его; вам нужно будет помнить о необходимости
использовать круглые скобки при вызове функции reload (только для
нее) и не забывать использовать ее, чтобы запустить самую последнюю
версию модуля.
92 Глава 3. Как пользователь запускает программы
Изза этих сложностей (и некоторых других, с которыми мы еще
столкнемся позднее) пока лучше избегать пользоваться операциями
импорта и перезагрузки. Пункт меню Run→Run Module интегрирован
ной среды IDLE, например, предоставляет более простой способ запус
ка файлов, менее подверженный ошибкам. С другой стороны, импорт
и перезагрузку оправданно использовать в процессе тестирования
классов Python. В этом случае вы можете отдать предпочтение этому
способу, но если начнут возникать сложности – остановитесь.
Это еще не все сведения о модулях, на которых хотелось бы здесь оста
новиться. Например, встроенная функция execfile('module.py’) – еще
один способ запуска файлов из интерактивной командной строки, ко
торый избавляет от необходимости импортировать и затем перезагру
жать модули. Имея схожее действие, она технически не выполняет
импорт модуля – по умолчанию всякий раз, когда вызывается функ
ция execfile, она снова запускает файл, как если бы на место вызова
функции было подставлено содержимое этого файла. Изза этого
функция execfile, как и упоминавшаяся ранее инструкция from, мо
жет попросту затереть значения переменных, которые уже использо
вались. С другой стороны, инструкция import запускает файл всего
один раз в течение сеанса работы и превращает файл в отдельное про
странство имен, благодаря чему становится невозможным изменение
переменных в текущей области видимости.
Следует добавить, что в случае использования необычных способов
применения модулей, отличных от тех, которые описываются в этой
книге, вы можете столкнуться с некоторыми неприятностями. Напри
мер, если вам необходимо импортировать файл модуля, который хра
нится в каталоге, отличном от того, в котором вы работаете, дожди
тесь, пока мы не подойдем к главе 18, где вы узнаете о пути поиска мо+
дулей. А пока, чтобы избежать осложнений, храните все импортируе
мые файлы модулей в рабочем каталоге.
Для тех, кто не хочет ждать, пока повествование дойдет до гла
вы 18, скажу, что интерпретатор Python выполняет поиск импор
тируемых модулей во всех каталогах, перечисленных в перемен
ной sys.path, – в списке имен каталогов, определенной в модуле
sys, которая инициализируется значением переменной окруже
ния PYTHONPATH, и в наборе стандартных имен каталогов. Если воз
никает потребность импортировать модули из других каталогов,
отличных от того, в котором вы работаете, они должны быть пере
числены в переменной PYTHONPATH. За дополнительной информаци
ей обращайтесь к главе 18.
Пользовательский интерфейс IDLE
До сих пор мы рассматривали запуск программного кода Python с по
мощью интерактивной командной строки интерпретатора, системной
командной строки, с помощью щелчка мышью на ярлыке и с исполь
Пользовательский интерфейс IDLE 93
зованием операции импорта. Если вам требуется более наглядный под
ход, интегрированная среда IDLE может предложить вам графический
интерфейс пользователя (ГИП) для разработки программ на языке Py
thon; IDLE является стандартной и свободно распространяемой частью
системы Python. Обычно она называется интегрированной средой раз+
работки (integrated development environment, IDE), потому что позво
ляет решать разнообразные задачи в единой оболочке.1
Проще говоря, IDLE – это набор инструментальных средств с графиче
ским интерфейсом, который способен работать на самых разных плат
формах, включая Microsoft Windows, X Window (в Linux, UNIX и дру
гих UNIXподобных операционных системах) и Mac OS (включая вер
сии Classic и OS X). Для многих IDLE представляет собой удобную аль
тернативу командной строке, а также альтернативу способу запуска
щелчком мыши.
Основы IDLE
Давайте начнем с примера. Запуск IDLE в операционной системе Win
dows не вызывает проблем – для нее создается отдельный пункт в раз
деле Python меню кнопки Пуск (Start) (рис. 2.1), а кроме того, ее можно
запустить, выбрав пункт контекстного меню, щелкнув правой кноп
кой мыши на ярлыке программы, написанной на языке Python. В не
которых UNIXподобных системах для запуска начального сценария
IDLE может потребоваться использовать командную строку или щелк
нуть мышью на ярлыке файла idle.pyw или idle.py, размещенного в под
каталоге idlelib в каталоге Lib, где установлен интерпретатор Python.
(В Windows IDLE является сценарием Python, который по умолчанию
находится в каталоге C:\Python25\Lib\idlelib.2)
На рис. 3.3 показано, как выглядит среда IDLE, запущенная в опера
ционной системе Windows. Окно с заголовком Python Shell (Оболочка Py
thon), которое открывается первоначально, является основным окном
среды, в котором запускается интерактивный сеанс работы с интерпре
татором (обратите внимание на приглашение к вводу >>>). Это самый
1 Официально название IDLE считается искаженной аббревиатурой IDE, но
в действительности она была названа так в честь члена труппы цирка Мон
ти Пайтона (Monty Python) – Эрика Эйдла (Eric Idle).
2 IDLE – это программа на языке Python, которая создает графический ин
терфейс с помощью библиотеки Tkinter GUI, что обеспечивает ее переноси
мость, но также означает, что для использования IDLE вам придется обес
печить поддержку Tkinter в Python. Версия Python для Windows обладает
такой поддержкой по умолчанию, но некоторым пользователям Linux
и UNIX может потребоваться установить соответствующую поддержку
Tkinter (для этого в некоторых дистрибутивах Linux можно использовать
команду yum tkinter, более подробные сведения об установке вы найдете
в приложении A). В системе Mac OS X все необходимое может быть уже ус
тановлено – поищите на своей машине команду idle.
94 Глава 3. Как пользователь запускает программы
обычный интерактивный сеанс, который играет роль инструмента
проведения экспериментов, – программный код, который здесь вво
дится, немедленно исполняется.
В IDLE присутствуют привычные пункты меню и для выполнения наи
более распространенных операций имеются короткие комбинации кла
виш. Чтобы создать (или отредактировать) файл с исходным программ
ным кодом в среде IDLE, откройте окно текстового редактора: в глав
ном окне откройте меню File (Файл) и выберите пункт New Window (Новое
окно), чтобы открыть окно текстового редактора (или Open… (Открыть) –
чтобы отредактировать существующий файл). В результате на экране
появится новое окно. Это окно текстового редактора среды IDLE, где
создается или изменяется программный код.
В книге это недостаточно четко видно, но IDLE обеспечивает подсвет+
ку синтаксиса программного кода, который вводится как в главном
окне, так и во всех окнах текстового редактора, – ключевые слова вы
деляются одним цветом, литералы другим цветом, и т. д. Это позволя
ет визуально выделять элементы программного кода.
Чтобы запустить файл с программным кодом в среде IDLE, выберите
окно, где редактируется текст, раскройте меню Run (Запустить) и выбе
рите в нем пункт Run Module (Запустить модуль) (или воспользуйтесь соот
ветствующей этому пункту меню горячей комбинацией клавиш). Если
с момента открытия или последнего сохранения файла его содержимое
изменялось, Python предложит сохранить его.
Когда сценарий запускается таким способом, весь вывод, который он ге
нерирует, а также все сообщения об ошибках появляются в основном ок
не интерактивного сеанса работы с интерпретатором (командная оболоч
ка Python). Например, на рис. 3.3 последние три строки являются ре
зультатом выполнения сценария, открытого в отдельном окне редакти
рования. Сообщение «RESTART» говорит о том, что пользовательский
процесс был перезапущен с целью выполнить отредактированный сце
нарий, и позволяет визуально отделить вывод, полученный от сценария.
Совет дня: если потребуется повторно выполнить команду в основ
ном окне интерактивного сеанса в среде IDLE, можно воспользо
ваться комбинацией AltP, выполняющей последовательный пере
ход к началу истории команд, и AltN, выполняющей переход
к концу истории команд (в некоторых системах Mac вместо этих
комбинаций могут использоваться комбинации CtrlP и CtrlN). При
нажатии этих комбинаций клавиш вы сможете вызывать предыду
щие команды, изменять их и запускать. Кроме того, имеется воз
можность повторно вызывать команды, позиционируя в них кур
сор, и использовать операцию «скопировать и вставить», но часто
это оказывается более трудоемко, чем ввести вручную. Вне среды
разработки IDLE, в ходе интерактивного сеанса работы с интерпре
татором в системе Windows, можно повторно возвращаться к пре
дыдущим командам с помощью клавиш управления курсором.
Пользовательский интерфейс IDLE 95
Использование IDLE
Интегрированная среда разработки IDLE проста в использовании, пе
реносима и доступна в большинстве платформ. Я обычно рекомендую
ее тем, кто только начинает программировать на языке Python, пото
му что она упрощает некоторые аспекты и не предполагает наличие
опыта работы с системной командной строкой. Но, по сравнению с не
которыми коммерческими интегрированными средами разработки,
она имеет некоторые ограничения. Ниже приводится список особенно
стей, которые должны приниматься во внимание начинающими поль
зователями IDLE:
• При сохранении файлов необходимо явно добавлять расширение
«.py». Я уже упоминал об этом, когда мы говорили о файлах вооб
ще, но это самый распространенный камень преткновения, особен
но для пользователей Windows. Среда IDLE не выполняет автома
тическое добавление расширения .py к именам сохраняемых фай
лов. Не забывайте добавлять расширение .py, когда сохраняете
файл в первый раз. В противном случае, вы хотя и сможете запус
тить свой файл из среды IDLE (а также из системной командной
Рис. 3.3. Основное окно интерактивного сеанса работы с интерпретатором
Python в интегрированной среде IDLE, запущенной под управлением
операционной системы Windows. Используйте меню File, чтобы создать
(New Window) или изменить (Open…) файл с исходным программным кодом.
Для запуска сценария, открытого в окне редактирования,
используйте меню Run этого окна (пункт Run Module)
96 Глава 3. Как пользователь запускает программы
строки), но не сможете импортировать его в интерактивную ко
мандную оболочку или в другой модуль.
• Запускайте сценарии, выбирая пункт меню Run→Run Module в окне
редактирования, а не за счет их импортирования или перезагрузки
в окне интерактивного сеанса. Ранее в этой главе было показано,
что вполне возможно запустить файл, выполнив операцию импор
тирования в интерактивной оболочке интерпретатора. Однако та
кой способ несет определенные сложности, потому что он требует
вручную выполнять перезагрузку файлов после внесения измене
ний. В противовес ему пункт меню Run→Run Module всегда приводит
к запуску текущей версии файла. Кроме того, в случае необходимо
сти будет предложено сохранить файл (еще одна распространенная
ошибка при работе вне среды IDLE).
• Вам по!прежнему может потребоваться выполнять перезагрузку
импортируемых модулей. Пункт меню Run→Run Module в среде IDLE
всегда запускает текущую версию только файла верхнего уровня.
Если изменениям подвергались модули, импортируемые сценари
ем, их необходимо будет перезагрузить вручную в интерактивной
оболочке. Но, несмотря на это, использование пункта меню Run→
Run Module позволяет избавиться от некоторых ошибок, связанных
с операцией импортирования. Если вы предпочитаете использовать
операции импортирования и перезагрузки, не забывайте о комби
нациях клавиш AltP и AltN, позволяющих возвращаться к ранее за
пускавшимся командам.
• Вы можете настроить IDLE. Чтобы изменить шрифты или цвета
в IDLE, выберите пункт Configure (Настройка) в меню Options (Парамет
ры) в любом окне IDLE. Кроме того, вы сможете настроить комбина
ции клавиш, настройки отступов и многое другое. Более подробные
сведения вы сможете получить в меню Help (Справка) среды IDLE.
• В настоящее время в IDLE отсутствует возможность очистки экра!
на. Похоже, что эта возможность является наиболее востребован
ной (возможно потому, что она присутствует в похожих интегриро
ванных средах разработки), и в конечном счете когданибудь она
будет добавлена. Однако в настоящее время нет никакой возможно
сти выполнить очистку окна интерактивного сеанса. Если вам по
требуется очистить окно, вы можете нажать и удерживать некото
рое время клавишу Enter или написать цикл на языке Python, кото
рый будет выводить последовательность пустых строк.
• Многопоточные программы с графическим интерфейсом на базе
Tkinter могут не работать со средой IDLE. Изза того, что IDLE сама
является программой Python/Tkinter, она может зависать при запус
ке некоторых типов программ на языке Python, использующих биб
лиотеку Tkinter. В более свежих версиях IDLE проблем с этим стало
меньше – благодаря тому, что пользовательский программный код
запускается в виде одного процесса, а сам графический интерфейс
Пользовательский интерфейс IDLE 97
IDLE работает в виде другого процесса, но некоторые программы по
прежнему могут вызывать зависание графического интерфейса IDLE.
Ваш программный код может и не вызывать проблем такого рода, од
нако существует эмпирическое правило: вы без опаски можете ис
пользовать IDLE для редактирования исходных текстов программ
с графическим интерфейсом, но для их запуска желательно исполь
зовать другие способы, например щелчком мыши на ярлыке или из
системной командной строки. Если ваш программный код не работа
ет в IDLE, попробуйте запустить его за пределами среды разработки.
• Если возникают ошибки соединения, попробуйте запустить IDLE
в виде единого процесса. Изза того, что для нормальной работы
IDLE необходимо поддерживать взаимодействие между пользова
тельским процессом и графическим интерфейсом среды разработки,
на определенных платформах могут проявляться проблемы с запус
ком (особенно часто проблема с запуском встречается на некоторых
машинах Windows). Если вам доведется столкнуться с такими ошиб
ками, попробуйте запустить IDLE из командной строки, что вынудит
ее запуститься в виде единственного процесса и позволит избежать
проблем с поддержанием соединения: для принудительного запуска
в этом режиме используйте флаг –n. Например, в операционной сис
теме Windows откройте программу Командная строка (Command Prompt)
и запустите команду idle.py –n из каталога C:\Python25\Lib \idlelib
(перед этим, в случае необходимости, выполните команду cd).
• Остерегайтесь использования некоторых особенностей IDLE. Сре
да IDLE обладает множеством особенностей, облегчающих жизнь
начинающим программистам, но некоторые из них невозможно ис
пользовать за пределами графического интерфейса среды разработ
ки. Например, IDLE запускает ваши сценарии в своем окружении,
поэтому переменные, определяемые сценарием, автоматически ста
новятся доступны в интерактивном сеансе IDLE – вам не придется
запускать команду import, чтобы получить доступ к именам в фай
лах верхнего уровня, которые уже были запущены. Это может быть
удобно, но может вызывать проблемы при работе вне среды IDLE,
потому что в этом случае всегда необходимо импортировать имена
из используемых файлов.
Дополнительные возможности IDLE
Помимо основных функций редактирования и запуска среда IDLE пре
доставляет целый ряд дополнительных возможностей, включая отлад
чик и инспектор объектов. Отладчик IDLE активируется с помощью
меню Debug (Отладка), а инспектор объектов – с помощью меню File
(Файл). Инспектор объектов позволяет переходить, перемещаясь по пу
ти поиска модулей, к файлам и объектам в файлах – щелчок на файле
или объекте приводит к открытию соответствующего исходного текста
в окне редактирования.
98 Глава 3. Как пользователь запускает программы
Режим отладки в IDLE инициируется выбором пункта меню Debug→
Debugger (Отладка→Отладчик) главного окна, после этого можно запус
тить отлаживаемый сценарий выбором пункта меню Run→Run Module
(Запустить→Запустить модуль); как только отладчик будет активирован,
щелчком правой кнопки мыши на выбранной строке в окне редакти
рования вы сможете устанавливать точки останова в своем программ
ном коде, чтобы приостанавливать выполнение сценария, просматри
вать значения переменных и т. д. Кроме того, вы сможете следить за
ходом выполнения программ – в этом случае текущая выполняемая
строка программного кода выделяется цветом.
Кроме того, в случае появления ошибок можно щелкнуть правой кноп
кой мыши на строке с сообщением об ошибке и быстро перейти к стро
ке программного кода, которая вызвала эту ошибку. Это позволяет бы
стро выяснить источник ошибки и ликвидировать ее. Помимо этого,
текстовый редактор IDLE обладает обширным набором возможностей,
которые пригодятся программистам, включая автоматическое оформ
ление отступов, расширенный поиск текста и файлов и многое другое.
Интегрированная среда IDLE обеспечивает интуитивно понятный гра
фический интерфейс, и потому вы можете поэкспериментировать
с ней, чтобы получить представление об имеющихся возможностях.
Другие интегрированные среды разработки
Изза того, что IDLE бесплатна, переносима и является стандартной
частью Python, она прекрасно подходит на роль инструмента разра
ботки, с которым следует познакомиться в первую очередь, если вы во
обще собираетесь использовать интегрированную среду разработки.
Я еще раз рекомендую использовать IDLE для выполнения упражне
ний из этой книги, если вы только начинаете знакомство с языком Py
thon и пока не знакомы с принципами разработки, основанными на
применении командной строки. Однако существует еще несколько
альтернативных средств разработки, и некоторые из них отличаются
более высокой устойчивостью и обладают более широкими возможно
стями по сравнению с IDLE. Ниже приводятся некоторые из наиболее
популярных интегрированных сред разработки:
Eclipse и PyDev
Eclipse – это улучшенная и свободно распространяемая интегриро
ванная среда разработки с графическим интерфейсом. Первона
чально она создавалась как среда разработки программного кода на
языке Java, но при установке модуля расширения PyDev (или по
добного ему) она обеспечивает возможность разработки программ
на языке Python. Eclipse – популярный и мощный инструмент для
разработки программ на языке Python, возможности которой на
много шире возможностей IDLE. Один из ее недостатков заключа
ется в том, что она слишком велика, а модуль расширения PyDev
для получения дополнительных возможностей (включая интегри
Другие интегрированные среды разработки 99
рованную интерактивную консоль), требует установки условнобес
платных пакетов расширений, которые не являются свободно рас
пространяемыми. Когда ваши потребности перерастут возможно
сти IDLE, обратите внимание на комбинацию Eclipse/PyDev.
Komodo
Полнофункциональная среда разработки с графическим интерфей
сом пользователя для Python (и других языков программирования),
Komodo поддерживает такие возможности, как подсветка синтакси
са, редактирование текста, отладка и другие. Кроме того, Komodo об
ладает множеством дополнительных возможностей, отсутствующи
ми в IDLE, включая файлы проектов, интеграцию с системами кон
троля версий исходных текстов, отладку регулярных выражений
и визуальный построитель графических интерфейсов, который гене
рирует программный код Python/Tkinter, реализующий графиче
ские интерфейсы, создаваемые в интерактивном режиме. К моменту
написания этих строк среда Komodo не являлась свободно распро
страняемой. Найти ее можно на сайте http://www.activestate.com.
PythonWin
PythonWin – это свободно распространяемая интегрированная среда
разработки на языке Python для операционной системы Windows.
Она распространяется в составе пакета ActivePython компании Acti
veState (но ее можно также получить отдельно на сайте http://
www.python.org). По своим возможностям она несколько напоминает
IDLE и имеет несколько полезных расширений, специфичных для
Windows, например, PythonWin обладает поддержкой COMобъек
тов. В настоящее время IDLE обладает более широкими возможно
стями, чем PythonWin (например благодаря тому, что IDLE исполь
зует для своей работы два процесса, она реже зависает). Однако Py
thonWin предлагает инструменты для разработки программ под
Windows, которые отсутствуют в IDLE. Более подробную информа
цию вы найдете на сайте http://www.activestate.com.
Прочие
Существует еще примерно с полдесятка других известных мне ин
тегрированных сред разработки (например, WingIDE, PythonCard),
и со временем их число будет увеличиваться. Фактически почти
в каждом современном текстовом редакторе для программистов
имеется поддержка языка Python, которая устанавливается вместе
с редактором по умолчанию или в виде отдельных расширений. На
пример, редакторы Emacs и Vim обладают существенной поддерж
кой языка Python. Я не буду описывать все возможные варианты
здесь, вы сами можете узнать о них на сайте http://www.python.org
или выполнив поиск в Google по строке «Python editors» (редакторы
Python) – это должно привести вас на страницу Wiki, где содержится
информация о множестве интегрированных сред разработки и тек
стовых редакторов для Python.
100 Глава 3. Как пользователь запускает программы
Встраивание вызовов
К настоящему моменту мы рассмотрели, как выполнять программный
код в интерактивной командной оболочке интерпретатора и как запус
кать программный код, сохраненный в файлах, из системной команд
ной строки, из исполняемых сценариев в системе UNIX, щелчком мы
ши, с помощью операции импортирования модулей и в интегрирован
ной среде разработки, такой как IDLE. Это подавляющее большинство
способов, которые встретятся вам в этой книге.
Но в некоторых особых случаях программный код на языке Python
может также запускаться из других программ. В таких ситуациях мы
говорим, что программы на языке Python встроены в другие програм
мы (то есть запускаются другими программами). Сам программный
код Python может храниться в текстовом файле, в базе данных, извле
каться из страницы HTML или из документа XML и т. д. В этом случае
уже не вы, а другая программа предлагает интерпретатору выполнить
программный код, созданный вами. Такой способ запуска программ
ного кода обычно используется для обеспечения поддержки возмож
ности настройки у конечного пользователя, например, игровая про
грамма может позволять изменять ход игры, запуская в ключевые мо
менты внедренный программный код пользователя на языке Python.
Например, вполне возможно создавать и выполнять строки программ
ного кода Python из программ на языке C, вызывая функции API време
ни выполнения интерпретатора Python (набор служб, экспортируемых
библиотеками, созданными при компиляции Python на вашей машине):
#include <Python.h>
...
Py_Initialize();
PyRun_SimpleString("x = brave + sir + robin");
В этом фрагменте программа на языке C, скомпонованная с библиоте
ками Python, инициализирует интерпретатор и передает ему для вы
полнения строку с инструкцией присваивания. Программы на языке C
могут также получать доступ к объектам Python и взаимодействовать
с ними, используя другие функции API языка Python.
Эта книга не описывает вопросы интеграции Python/C, но вы должны
знать, что в зависимости от того, как ваша организация планирует ис
пользовать Python, вы можете оказаться одним из тех, кому действи
тельно придется запускать программы на языке Python.1 При этом бо
1 О встраивании программного кода Python в программы на языке C/C++
подробно рассказывается в книге «Programming Python» (O’Reilly). Ис
пользуя прикладной интерфейс встраиваемого интерпретатора, вы сможе
те напрямую вызывать функции Python, загружать модули и производить
прочие действия. Кроме того, система Jython позволяет программам на
языке Java вызывать программный код на языке Python, используя при
кладной интерфейс на языке Java (класс интерпретатора Python).
Фиксированные исполняемые двоичные файлы 101
лее чем вероятно, что вы попрежнему сможете использовать интерак
тивную оболочку интерпретатора и приемы запуска файлов, описан
ные выше, чтобы протестировать программный код отдельно от
программ, куда этот код внедряется.
Фиксированные исполняемые двоичные файлы
Фиксированные исполняемые двоичные файлы, описанные в преды
дущей главе, представляют собой комбинацию байткода программы
и интерпретатора Python, объединенных в одном исполняемом файле.
Благодаря этому такие программы могут запускаться точно так же,
как любые другие программы (щелчком на ярлыке, из командной
строки и другими способами). Такая возможность замечательно под
ходит для случая распространения готовых программных продуктов,
но она не предназначена для использования в процессе разработки
программ. Обычно фиксирование файлов производится непосредст
венно перед отправкой (когда разработка уже завершена) программы
заказчику. Более подробная информация об этой возможности приво
дится в предыдущей главе.
Возможность запуска программ
из текстового редактора
Как упоминалось ранее, большинство текстовых редакторов для про
граммистов хотя и не являются полноценными интегрированными
средами разработки, тем не менее поддерживают возможность редак
тирования и запуска программ на языке Python. Такая поддержка мо
жет быть изначально встроена в редактор или доступна в виде расши
рений, которые можно загрузить из Сети. Например, если вы знакомы
с текстовым редактором Emacs, вы сможете редактировать программ
ный код на языке Python и запускать его, не покидая текстовый редак
тор. Дополнительную информацию о текстовых редакторах вы найдете
на странице http://www.python.org/editors или поискав в Google по
фразе «Python editors» (редакторы Python).
Прочие возможности запуска
В зависимости от используемой платформы могут существовать и дру
гие способы запуска программ Python. Например, в некоторых систе
мах Macintosh выполнить программу на языке Python можно, перета
щив мышью ярлык файла программы на ярлык интерпретатора Py
thon. В Windows сценарии можно запускать с помощью пункта Выпол
нить… (Run…) меню кнопки Пуск (Start). Наконец, в состав стандартной
библиотеки Python входят вспомогательные функции, позволяющие
запускать программы на языке Python из других программ на языке
102 Глава 3. Как пользователь запускает программы
Python (такие как execfile, os.popen, os.system), однако обсуждение
этих функций выходит за рамки этой главы.
Будущие возможности
В этой главе отражены существующие ныне способы запуска, многие
из которых характерны для определенной платформы и в определен
ное время. В действительности многие методы запуска и выполнения,
представленные здесь, появились между выпусками разных изданий
этой книги. Поэтому вполне возможно, что в будущем появятся новые
способы запуска.
Новые операционные системы и новые версии существующих систем
могут также обеспечивать способы запуска, не описанные здесь. Вооб
ще, т. к. Python продолжает идти в ногу со временем, вы должны быть
готовы запускать программы на языке Python способом, имеющим
смысл для машин, которые вы используете сейчас или будете исполь
зовать в будущем – стилом планшетного или наладонного компьюте
ра, захватывая ярлыки в виртуальной реальности или выкрикивая на
звания сценариев своим коллегам.
Изменения в реализации также могут оказывать влияние на способ за
пуска (например, полноценный компилятор мог бы воспроизводить
обычные исполняемые файлы, которые запускаются так же, как и фик
сированные двоичные файлы ныне). Если бы я знал, что будет в буду
щем, я бы, наверное, начал переговоры с биржевым маклером, а не пи
сал бы сейчас этих слов!
Какие способы следует использовать?
Ознакомившись с таким богатством возможностей, возникает вполне
естественный вопрос – какой способ лучше? Вообще, если вы начинаю
щий разработчик, для вас было бы желательно использовать интегри
рованную среду разработки IDLE. Она предоставляет дружественный
графический интерфейс и скрывает некоторые детали, связанные с не
обходимостью настройки. Кроме того, в ее состав входит платформоне
зависимый текстовый редактор, предназначенный для создания сцена
риев, и она является стандартной и свободно распространяемой состав
ляющей системы Python.
С другой стороны, если вы опытный программист, для вас более ком
фортным может оказаться простой текстовый редактор, а для запуска
программ использовать командную строку системы или щелчок мышью
на ярлыке (именно таким способом автор разрабатывает программы на
языке Python, но это привычка, выработанная при работе с UNIX). По
скольку выбор среды разработки во многом зависит от личных предпоч
тений, я не могу сказать ничего, кроме стандартной рекомендации –
лучшей средой разработки для вас будет та, которая вам нравится.
В заключение 103
В заключение
В этой главе мы познакомились с наиболее часто используемыми спо
собами запуска программ на языке Python: запуск программного кода
в интерактивном сеансе работы с интерпретатором и запуск файлов
с программным кодом из системной командной строки, щелчком мы
ши на ярлыке файла, за счет выполнения операции импортирования
и с помощью интерфейса интегрированной среды разработки, такой
как IDLE. Мы охватили здесь значительную часть темы запуска. Цель
этой главы состояла в том, чтобы дать вам достаточный объем знаний,
владея которыми, вы сможете приступить к работе с программным ко
дом, который мы начнем писать в следующей части книги. В этой час
ти мы приступим к изучению самого языка Python, начав с базовых
типов данных.
Но перед этим ответьте на контрольные вопросы по теме, которую мы
изучали здесь. Так как это последняя глава первой части книги, она
завершается более сложными упражнениями, с помощью которых вы
сможете проверить усвоение всех тем, рассматривавшихся в этой час
ти. За справками и для того, чтобы освежить свои знания, обращай
тесь к приложению B.
Закрепление пройденного
Контрольные вопросы
1. Как запустить интерактивный сеанс работы с интерпретатором?
2. Где следует вводить команду, которая запустит файл сценария?
3. Назовите две ловушки, связанные с щелчком мыши на ярлыках
вWindows.
4. Почему может потребоваться перезагрузить модуль?
5. Как запустить сценарий из среды разработки IDLE?
6. Назовите две ловушки, связанные со средой разработки IDLE.
7. Что такое пространство имен, и какое отношение они имеют к фай
лам модулей?
Ответы
1. В операционной системе Windows интерактивный сеанс работы
с интерпретатором можно запустить, щелкнув на кнопке Пуск (Start),
открыть пункт меню Все программы (All Programs), выбрать пункт ме
ню Python и затем щелкнуть на пункте меню Python (command line) (Py
thon (командная строка)). Тот же результат можно получить в Win
dows и на других платформах, введя команду python в системной ко
мандной строке, в окне консоли (Командная строка (Command Prompt)
вWindows). Как вариант, можно запустить интегрированную среду
104 Глава 3. Как пользователь запускает программы
разработки IDLE, главное окно которой представляет собой инте
рактивную командную оболочку интерпретатора. Если в вашей сис
теме переменная окружения PATH не включает каталог, в который
был установлен интерпретатор Python, вам может потребоваться
выполнить команду cd, чтобы перейти в каталог установки Python,
или указать полный путь к команде python (например, C:\Python25\
python в Windows).
2. Системные команды вводятся в программе, которая в вашей системе
используется в качестве консоли: Командная строка (Command Prompt)
вWindows; xterm или окно терминала в UNIX, Linux и Nac OS X;
и т. д.
3. Если сценарий просто выводит какието данные и завершает рабо
ту, окно с этой информацией исчезает немедленно, еще до того, как
вы сможете увидеть, что было выведено (поэтому в таких ситуаци
ях удобно использовать функцию raw_input). Сообщения об ошиб
ках, возникших в ходе работы сценария, также приводят к немед
ленному закрытию окна еще до того, как вы успеете исследовать его
содержимое (поэтому предпочтительнее в ходе разработки исполь
зовать системную командную строку или среду разработки IDLE).
4. Интерпретатор Python по умолчанию выполняет импорт (загрузку)
модуля один раз за сеанс, поэтому, если вы изменили исходный
текст модуля и вам необходимо запустить его новую версию, не по
кидая интерактивный сеанс, вам следует перезагрузить модуль.
Однако прежде чем выполнить перезагрузку, модуль должен быть
импортирован. Запуск программного кода из системной командной
строки, щелчком мыши на ярлыке или в интегрированной среде
разработки, такой как IDLE, обычно вообще снимает эту проблему,
так как в таких случаях система каждый раз выполняет текущую
версию программного кода.
5. В окне редактирования текста для файла, который требуется запус
тить, выберите пункт меню Run→Run Module (Запустить→Запустить мо
дуль). В результате программный код в окне редактирования будет
запущен как файл сценария верхнего уровня, а вывод, сгенериро
ванный с этим сценарием, появится в главном окне интерактивной
командной оболочки Python.
6. Интегрированная среда разработки IDLE может зависать при за
пуске некоторых типов программ, особенно с графическим интер
фейсом пользователя, которые выполняются в нескольких потоках
(рассмотрение усовершенствованной методики выходит за рамки
данной книги). Кроме того, среда IDLE обладает некоторыми удоб
ными особенностями, которые не поддерживаются при работе вне
этой среды: переменные сценария автоматически импортируются
в интерактивную командную оболочку IDLE, но в командной стро
ке Python такая возможность отсутствует.
Закрепление пройденного 105
7. Пространство имен – это просто пакет переменных (то есть имен).
В Python он приобретает форму объекта с атрибутами. Каждый
файл модуля автоматически становится пространством имен, то
есть пакетом переменных, отражающих выполненные операции
присваивания на верхнем уровне файла. Пространства имен позво
ляют избежать конфликтов имен в программах на языке Python:
поскольку каждый модуль – это самостоятельное пространство
имен, файлы должны явно импортировать другие файлы, чтобы ис
пользовать имена, определяемые в них.
Упражнения к первой части
Пришло время начинать писать программный код самостоятельно.
Здесь представлены достаточно простые упражнения, но некоторые из
поднимаемых вопросов связаны с темами, которые будут рассматри
ваться в последующих главах. Обязательно ознакомьтесь с разделом
«Часть I, Введение» в приложении с решениями (приложение B), где
приводятся ответы – упражнения и их решения иногда содержат до
полнительные сведения, не рассматривавшиеся в основном тексте час
ти, поэтому вам определенно следует ознакомиться с ответами, даже
если вам удастся ответить на вопросы самостоятельно.
1. Взаимодействие. Используя системную командную строку, IDLE
или другой инструмент, запустите интерактивный сеанс интерпре
татора Python (приглашение к вводу >>>) и введите выражение "Hello
World!" (включая кавычки). Строка должна быть повторно выведена
на экран. Цель этого упражнения состоит в том, чтобы помочь вам
настроить окружение для запуска интерпретатора Python. В некото
рых случаях вам может потребоваться сначала выполнить команду
cd, ввести полный путь к каталогу, куда был установлен выполняе
мый файл интерпретатора Python, или добавить путь к этому ката
логу в переменную окружения PATH. При желании значение перемен
ной PATH в системах UNIX можно установить в файле .cshrc или
.kshrc; вWindows для этой цели можно использовать файл setup.bat,
autoexec.bat или выполнить настройку переменной окружения с ис
пользованием инструмента с графическим интерфейсом. Справку по
настройкам переменных окружения см. в приложении А.
2. Программы. В текстовом редакторе, который вы предпочитаете,
создайте простой файл модуля, содержащий единственную инст
рукцию print 'Hello module world!', и сохраните его под именем
module1.py. Теперь запустите этот файл какимлибо способом: из
среды разработки IDLE, щелчком на ярлыке, вызовом интерпрета
тора Python из командной строки, передав ему имя файла в виде ар
гумента (например, python module1.py) и т. д. Попробуйте поэкспери
ментировать с разными способами запуска, которые обсуждались
в этой главе. Какие способы запуска показались вам проще? (На
этот вопрос не может быть единственно правильного ответа.)
106 Глава 3. Как пользователь запускает программы
3. Модули. Запустите интерактивный сеанс работы с интерпретатором
Python (приглашение к вводу >>>) и импортируйте модуль, который
был создан в упражнении 2. Попробуйте переместить файл в другой
каталог и импортировать его снова из первоначального каталога (то
есть запустите Python в каталоге, где производился импорт в пер
вый раз). Что произошло? (Подсказка: посмотрите, остался ли в пер
воначальном каталоге файл с байткодом module1.pyc?)
4. Сценарии. Если ваша платформа поддерживает такую возможность,
добавьте комбинацию символов #! в начало файла модуля modu+
le1.py, дайте файлу право на выполнение и попробуйте запустить его
как обычный исполняемый файл. Что должна содержать первая
строка? Обычно комбинация символов #! имеет особое значение
только на платформе UNIX, Linux и других UNIXподобных систе
мах, таких как MAC OS X. Если вы работаете в Windows, попробуй
те просто запустить файл, введя его имя без предшествующего ему
слова «python» (этот способ работает в последних версиях Windows),
или с помощью диалога Пуск→Выполнить… (Start→Run…).
5. Ошибки. Поэкспериментируйте с математическими выражениями
и операциями присваивания в интерактивной командной оболочке
Python. Для начала введите выражение 1/0. Что произошло? Потом
попробуйте ввести имя переменной, которой еще не было присвоено
значение. Что произошло на этот раз?
Вы еще можете не знать этого, но вы столкнулись с исключениями
(эту тему мы подробно будем рассматривать в седьмой части кни
ги). Там вы узнаете, что с технической точки зрения ваши действия
привели к вызову того, что известно под названием обработчик ис+
ключений по умолчанию, – программного кода, который выводит
стандартные сообщения об ошибках. Если вы не выполняете пере
хват ошибок в своих программах, это за вас сделает обработчик по
умолчанию, который выведет сообщение об ошибке.
Для отладки сложного программного кода среда разработки IDLE
предоставляет отладчик с графическим интерфейсом (описывается
в разделе «Дополнительные возможности IDLE», в этой же главе),
а в состав стандартной библиотеки модулей Python входит модуль
с именем pdb, реализующий отладчик с интерфейсом командной
строки. (Подробнее о модуле pdb можно узнать из руководства к стан
дартной библиотеке.) Для начала вам вполне будет достаточно стан
дартного механизма обработки ошибок – он позволит узнать причи
ну ошибки, а также покажет, какие строки кода выполнялись в мо
мент ее появления.
6. Прерывание программы. В командной строке интерпретатора Py
thon введите следующие инструкции:
L = [1, 2]
L.append(L)
L
Закрепление пройденного 107
Что произошло? Если вы используете версию Python более новую,
чем Release 1.5, скорее всего вы увидите кажущийся странным ре
зультат, который будет описан в следующей части книги. При ис
пользовании версий Python, старее 1.5.1, остановить работу этого
программного кода на большинстве платформ вам поможет комби
нация клавиш CtrlC. Как вы думаете, в чем причина происходяще
го? Что вывел интерпретатор после нажатия комбинации клавиш
CtrlC?
Если вы используете версию Python более старую, чем 1.5.1, преж
де чем выполнить это упражнение, обязательно проверьте, имеет
ся ли возможность прерывать работу программ комбинацией кла
виш CtrlC, в противном случае вам придется ждать очень долго.
7. Документация. Потратьте по крайней мере 17 минут на исследова
ние библиотеки Python и руководства по языку программирования,
чтобы получить представление о стандартной библиотеке и о струк
туре комплекта документации. Вам нужно понять по крайней мере,
где в руководстве находятся описания основных тем. После этого вы
легко сможете отыскать интересующую вас информацию. В системе
Windows это руководство находится в разделе Python меню кнопки
Пуск (Start), а также в виде пункта Python Docs (Документация Python)
в меню Help (Справка) в среде разработки IDLE или в Интернете по ад
ресу: http://www.python.org/doc. Кроме того, хотелось бы также ска
зать несколько слов о других руководствах и источниках докумен
тации, описываемых (включая PyDoc и функцию help) в главе 14.
Если у вас есть свободное время, займитесь исследованием вебсай
тов Python и Vaults of Parnassus, а также вебсайта расширений сто
ронних разработчиков PyPy. В частности, ознакомьтесь со страни
цами документации и поиска на сайте Python.org – они могут ока
заться для вас весьма важными ресурсами.


II
Типы и операции

4
Введение в типы объектов языка Python
Начиная с этой главы, мы приступаем к изучению языка Python. В са
мом общем виде можно сказать, что программы на языке Python вы
полняют некоторые действия над чемто. «Некоторые действия» при
нимают форму операций, таких как сложение или конкатенация, а под
«чемто» подразумеваются объекты, над которыми выполняются опе
рации. В этой части книги мы сосредоточимся на этом «чтото» и на
действиях, которые могут выполняться программой.
Говоря более формальным языком, данные в языке Python представ
лены в форме объектов – встроенных, предоставляемых языком Py
thon, или объектов, которые мы создаем с помощью других инстру
ментов, таких как библиотеки расширений, написанные на языке C.
Мы уточним это определение позднее, но если говорить по сути, объек
ты – это области памяти со значениями и ассоциированными с ними
наборами операций.
Объекты являются самым фундаментальным понятием в программи
ровании на языке Python, поэтому эта глава начинается с обзора
встроенных объектных типов языка Python.
Однако для начала проясним, как эта глава вписывается в общую кар
тину языка Python. С более определенной точки зрения программы на
языке Python можно разложить на такие составляющие, как модули,
инструкции, выражения и объекты; при этом:
1. Программы делятся на модули.
2. Модули содержат инструкции.
3. Инструкции состоят из выражений.
4. Выражения создают и обрабатывают объекты.
В главе 3 рассматривалась самая вершина этой иерархии – модули. Эта
часть книги начинает рассмотрение с конца иерархии – с исследования
112 Глава 4. Введение в типы объектов языка Python
встроенных объектов и выражений, в которых эти объекты могут уча
ствовать.
Зачем нужны встроенные типы?
Если вам приходилось использовать языки программирования более
низкого уровня, такие как C или C++, то вы уже знаете, что значи
тельная доля работы приходится на реализацию объектов, известных
также как структуры данных, которые предназначены для представ
ления компонентов внутри приложений. В таких языках программи
рования необходимо заниматься проработкой структур данных,
управлять выделением памяти, реализовывать функции поиска и дос
тупа к элементам структур и т. д. Это достаточно утомительно (и спо
собствует появлению ошибок) и, как правило, отвлекает от достиже
ния истинных целей.
В типичных программах на языке Python в этом нет необходимости.
Python предоставляет мощную коллекцию объектных типов, встроен
ных непосредственно в язык, поэтому обычно нет никакой необходи
мости создавать собственные реализации объектов, предназначенных
для решения поставленных задач. Фактически, если у вас нет потреб
ностей в специальных видах обработки, которые не обеспечиваются
встроенными типами объектов, вам всегда лучше использовать встро
енные объекты вместо реализации своих собственных. И вот почему:
• Встроенные объекты упрощают создание программ. Для решения
простых задач часто вполне достаточно встроенных типов для пред
ставления структур данных проблемной области. В вашем распоря
жении имеются такие мощные инструментальные средства, как
коллекции (списки) и таблицы поиска (словари), поэтому вы може
те использовать их непосредственно. Благодаря встроенным объ
ектным типам языка Python вы можете выполнить значительный
объем работы.
• Встроенные объекты – это компоненты расширений. Для решения
сложных задач вы можете создавать собственные объекты, исполь
зуя для этого классы языка Python или интерфейсы языка C. Одна
ко, как будет показано ниже, объекты, реализованные вручную,
обычно основаны на таких встроенных типах, как списки и слова
ри. Например, структура данных типа стек может быть реализова
на как класс, основанный на использовании списков.
• Встроенные объекты часто более эффективны, чем созданные вруч!
ную структуры данных. Встроенные типы языка Python использу
ют уже оптимизированные структуры данных, реализованные на
языке C для достижения высокой производительности. Вы можете
сами создавать подобные типы объектов, но вам придется прило
жить немало усилий, чтобы достичь скорости, которая обеспечива
ется встроенными типами объектов.
Зачем нужны встроенные типы? 113
• Встроенные объекты – это стандартная часть языка. В определен
ной степени Python многое заимствует как из языков, полагающихся
на использование встроенных инструментальных средств (таких как
LISP), так и полагающихся на мастерство программиста, который
должен выполнить собственную реализацию инструментов и струк
тур данных (таких как C++). В языке Python вы можете создавать
собственные типы объектов, но в самом начале делать это не реко
мендуется. Более того, изза того, что встроенные компоненты яв
ляются стандартными составляющими языка Python, они всегда
остаются неизменными, тогда как собственные структуры имеют
свойство изменяться от случая к случаю.
Другими словами, встроенные типы объектов не только упрощают про
цесс программирования, но они обладают большей эффективностью
и производительностью, чем большинство типов, созданных вручную.
Даже если вы создаете собственные типы объектов, встроенные объек
ты будут ядром любой программы на Python.
Базовые типы данных в языке Python
В табл. 4.1 представлены некоторые встроенные типы объектов языка
Python и некоторые синтаксические конструкции использования этих
объектов в виде литералов – то есть выражения, которые генерируют
эти объекты.1 Некоторые из этих типов наверняка покажутся вам зна
комыми, если ранее вам приходилось работать с другими языками про
граммирования. Например, числа и строки представляют числовые
и текстовые значения соответственно, а файлы обеспечивают интер
фейс для работы с файлами, хранящимися в компьютере.
Таблица 4.1. Некоторые встроенные объекты
1 В этой книге под термином литерал подразумевается выражение, создаю
щее объект, которое иногда также называется константой. Следует иметь
в виду, что термин «константа» не означает объектов и переменных, кото
рые никогда не изменяются (то есть этот термин никак не связан с директи
вой const языка C++ или с понятием «неизменяемый» («immutable») в язы
ке Python – эта тема будет рассматриваться ниже, в этой же главе).
Тип объекта Пример литерала/создания
Числа 1234, 3.1415, 999L, 3+4j, Decimal
Строки 'spam', "guido's"
Списки [1, [2, 'three'], 4]
Словари {'food': 'spam', 'taste': 'yum'}
Кортежи (1,'spam', 4, 'U')
Файлы myfile = open('eggs', 'r')
Прочие типы Множества, сами типы, None, логические значения
114 Глава 4. Введение в типы объектов языка Python
Таблица 4.1 содержит далеко не полный список, потому что объектами
являются все данные, которые приходится обрабатывать в программах
на языке Python. Например, когда на языке Python мы реализуется по
иск текста по шаблону – создаются объекты шаблонов, когда програм
мируются сетевые взаимодействия – используются объекты сокетов.
Существуют и другие типы объектов, которые создаются в результате
импорта и использования модулей, и все они обладают своим собствен
ным поведением.
Типы объектов, перечисленные в табл. 4.1, мы назвали базовыми, по
тому что они встроены непосредственно в язык Python, то есть для соз
дания большинства из них используется вполне определенный син
таксис. Например, когда выполняется следующий программный код:
>>> 'spam'
то, говоря техническим языком, выполняется выражениелитерал, ко
торое генерирует и возвращает новый строковый объект. Такова специ
фика синтаксиса Python создания этого объекта. Похожим образом вы
ражение, заключенное в квадратные скобки, создает список, заклю
ченное в фигурные скобки – словарь и т. д. Хотя, как вы сможете убе
диться, в языке Python отсутствует конструкция объявления типа, сам
синтаксис выполняемых выражений задает типы создаваемых и ис
пользуемых объектов. Фактически, выражения, создающие объекты,
подобные тем, что представлены в табл. 4.1, в языке Python являются
источниками типов.
Не менее важно отметить, что как только будет создан объект, он будет
ассоциирован со своим собственным набором операций на протяжении
всего времени существования – над строками можно будет выполнять
только строковые операции, над списками – только операции, приме
нимые к спискам. Как вы узнаете далее, в языке Python используется
динамическая типизация (типы данных определяется автоматиче
ски, и их не требуется объявлять в программном коде), но при этом он
является языком со строгой типизацией (вы сможете выполнять над
объектом только те операции, которые применимы к его типу).
Функционально типы объектов, представленные в табл. 4.1, являются
более универсальными и более эффективными, чем может показаться.
Например, вы узнаете, что списки и словари являются достаточно
мощными средствами представления данных, которые обеспечивают
поддержку коллекций и функций поиска, которые в низкоуровневых
языках программирования приходится реализовывать вручную. Гово
ря коротко, списки обеспечивают поддержку упорядоченных коллек
ций других объектов, а словари реализуют возможность хранения объ
ектов по ключам. И списки, и словари могут быть вложенными, по ме
ре необходимости могут увеличиваться и уменьшаться в размерах и мо
гут содержать объекты любых типов.
В последующих главах мы подробно изучим каждый из типов объек
тов, перечисленных в табл. 4.1. Но прежде чем углубляться в детали,
Числа 115
давайте познакомимся с базовыми типами объектов Python в действии.
Оставшаяся часть главы представляет собой обзор операций, которые
мы более подробно будем исследовать в последующих главах. Не ждите
в этой главе исчерпывающих объяснений, поскольку основная ее цель
состоит в том, чтобы разжечь ваш аппетит и представить некоторые ба
зовые идеи. Однако лучший способ чтото начать – это просто начать,
поэтому перейдем сразу к программному коду.
Числа
Если в прошлом вам приходилось заниматься программированием,
некоторые типы объектов из табл. 4.1 скорее всего покажутся вам зна
комыми. Но даже если это не так, числа являются чрезвычайно про
стым понятием. Базовый набор объектов языка Python включает в се
бя вполне ожидаемые типы: целые числа (числа без дробной части),
числа с плавающей точкой (грубо говоря, числа с десятичной точкой)
и более экзотические типы («длинные» целые числа с неограниченной
точностью, комплексные числа с мнимой частью, числа с фиксирован
ной десятичной точкой и множества).
Несмотря на наличие некоторых необычных типов, базовые числовые
типы в языке Python действительно являются базовыми. Числа в Py
thon поддерживают набор самых обычных математических операций.
Например, символ «плюс» (+) означает сложение, символ «звездочка»
(*) – умножение, а два символа «звездочка» (**) – возведение в степень:
>>> 123 + 222 # Целочисленное сложение
345
>>> 1.5 * 4 # Умножение вещественных чисел
6.0
>>> 2 ** 100 # 2 в степени 100
1267650600228229401496703205376L
Обратите внимание на символ L в конце результата последней опера
ции: когда возникает необходимость в более высокой точности, Python
автоматически преобразует целые числа в «длинные» целые. Напри
мер, вы можете попробовать отыскать 2 в степени 1 000 000 (но едва ли
стоит это делать, так как на экран будет выведено число длиной более
300 000 знаков, что может занять продолжительное время!). Посмот
рите, что происходит при выводе чисел с плавающей точкой:
>>> 3.1415 * 2 # repr: в виде кода
6.2830000000000004
>>> print 3.1415 * 2 # str: более удобочитаемо
6.283
Первый результат – это не ошибка, проблема здесь связана с отображе
нием. Оказывается, вывести содержимое любого объекта можно двумя
способами: с полной точностью (как в первом результате) и в форме,
более удобной для восприятия человеком (как во втором результате).
116 Глава 4. Введение в типы объектов языка Python
Формально первая форма называется repr (объект в виде кода), а вто
рая, более дружественная к пользователю, – str. Различия между ни
ми станут более понятны, когда мы приступим к изучению классов,
а пока, если чтото выглядит непонятным, попробуйте вывести тот же
результат с помощью инструкции print.
Помимо выражений для выполнения операций с числами в составе Py
thon есть несколько полезных модулей:
>>> import math
>>> math.pi
3.1415926535897931
>>> math.sqrt(85)
9.2195444572928871
Модуль math содержит более сложные математические функции, а мо
дуль random реализует генератор случайных чисел и функцию случай
ного выбора (в данном случае из списка, о котором будет рассказы
ваться ниже, в этой же главе):
>>> import random
>>> random.random()
0.59268735266273953
>>> random.choice([1, 2, 3, 4])
1
Кроме того, Python включает в себя более экзотические числовые объ
екты, такие как комплексные числа, числа с фиксированной десятич
ной точкой и множества, а среди свободно распространяемых расшире
ний можно найти и другие числовые типы (например, матрицы и век
торы). Обсуждение этих типов будет приводиться далее в этой книге.
Пока что мы использовали Python как простой калькулятор, но чтобы
иметь большую возможность судить о встроенных типах, перейдем
к строкам.
Строки
Строки используются для записи текстовой информации, а также про
извольных последовательностей байтов. Это наш первый пример после+
довательностей, или упорядоченных коллекций других объектов по
их позиции, в языке Python. Последовательности поддерживают поря
док размещения элементов, которые они содержат, слева направо: эле
менты сохраняются и извлекаются, исходя из их позиции в последова
тельности. Строго говоря, строки являются последовательностями од
носимвольных строк. Другими типами последовательностей являются
списки и кортежи (будут описаны ниже).
Операции над последовательностями
Будучи последовательностями, строки поддерживают операции, пред
полагающие определенный порядок позиционирования элементов.
Строки 117
Например, если имеется четырехсимвольная строка, то с помощью
встроенной функции len можно проверить ее длину, а отдельные эле
менты строки извлечь с помощью выражений индексирования:
>>> S = 'Spam'
>>> len(S) # Длина
4
>>> S[0] # Первый элемент в S, счет начинается с позиции 0
'S'
>>> S[1] # Второй элемент слева
'p'
В языке Python индексы реализованы в виде смещений от начала,
и потому индексация начинается с 0: первый элемент имеет индекс 0,
второй – 1 и т. д. В языке Python предусмотрена возможность индекса
ции в обратном порядке, от конца:
>>> S[
1] # Последний элемент в конце S
'm'
>>> S[
2] # Второй элемент с конца
'a'
Формально отрицательные индексы просто складываются с длиной
строки, поэтому следующие две операции эквивалентны (хотя первая
проще записывается и более понятна, чем вторая):
>>> S[
1] # Последний элемент в S
'm'
>>> S[len(S)
1] # Отрицательная индексация, более сложный способ
'm'
Примечательно, что внутри квадратных скобок допускается использо
вать не только жестко заданные числовые литералы, но и любые дру
гие выражения – везде, где Python ожидает получить значение, можно
использовать литералы, переменные или любые выражения. Весь син
таксис языка Python следует этому общему принципу.
В дополнение к простой возможности индексирования по номеру пози
ции последовательности поддерживают более общую форму индекси
рования, известную как получение среза (slicing), которая обеспечива
ет возможность извлечения за одну операцию целого раздела (среза).
>>> S # Строка из 4 символов
'Spam'
>>> S[1:3] # Срез строки S начиная со смещения 1 и до 2 (не 3)
'pa'
Проще всего можно представить себе срез как способ извлечения цело
го столбца из строки за один шаг. В общем виде синтаксис операции
получения среза выглядит как X[I:J] и означает: «извлечь из X все, счи
тая со смещения I и до смещения J, но не включая его». В качестве ре
зультата возвращается новый объект. Например, последняя операция
из примера выше вернет все символы строки S со смещениями с 1 по 2
118 Глава 4. Введение в типы объектов языка Python
(то есть 31 штук) в виде новой строки. В результате получается срез,
или выборка двух символов из середины.
При выполнении операции получения среза левая граница по умолча
нию принимается равной нулю, а правая – длине последовательности,
к которой применяется операция. В результате мы получаем следую
щие наиболее распространенные варианты использования:
>>> S[1:] # Все, кроме первого элемента (1:len(S))
'pam'
>>> S # Сама строка S без изменений
'Spam'
>>> S[0:3] # Все, кроме последнего элемента
'Spa'
>>> S[:3] # То же, что и S[0:3]
'Spa'
>>> S[:
1] # Еще раз все, кроме последнего элемента, но проще (0:1)
'Spa'
>>> S[:] # Все содержимое S, как обычная копия (0:len(S))
'Spam'
Обратите внимание, что в качестве границ срезов можно использовать
отрицательные индексы и что последняя операция фактически созда
ет копию всей строки. Как мы узнаем позднее, нет смысла копировать
строки таким способом, но такая форма копирования очень удобна
при работе с другими последовательностями, такими как списки.
Наконец, будучи последовательностями, строки поддерживают опера
цию конкатенации, которая записывается в виде знака плюс (объеди
нение двух строк в одну строку), и операцию повторения (новая стро
ка создается за счет многократного повторения другой строки):
>>> S
'Spam'
>>> S + 'xyz' # Конкатенация
'Spamxyz'
>>> S # S остается без изменений
'Spam'
>>> S * 8 # Повторение
'SpamSpamSpamSpamSpamSpamSpamSpam'
Обратите внимание, что знак плюс (+) имеет различное значение для
разных объектов: для чисел – сложение, а для строк – конкатенация.
Это универсальное свойство языка Python, которое далее в книге будет
названо полиморфизмом, означает, что фактически выполняемая опе
рация зависит от объектов, которые принимают в ней участие. Как бу
дет показано, когда мы приступим к изучению динамической типиза
ции, такой полиморфизм в значительной степени обеспечивает выра
зительность и гибкость программного кода на языке Python. Посколь
ку отсутствуют ограничения, связанные с типами, операции в языке
Python обычно в состоянии автоматически обрабатывать объекты са
мых разных типов, при условии, что они поддерживают совместимый
Строки 119
интерфейс (как в данном случае операция +). В языке Python идея по
лиморфизма является ключевой концепцией, которую мы будем рас
сматривать далее в этой книге.
Неизменяемость
Обратите внимание: в предыдущих примерах ни одна из использован
ных операций не изменяла оригинальную строку. Все операции над
строками в результате создают новую строку, потому что строки в язы
ке Python являются неизменяемыми – после того, как строка будет
создана, ее нельзя изменить. Например, вы не сможете изменить стро
ку присвоением значения одной из ее позиций, но вы всегда можете
создать новую строку и присвоить ей то же самое имя. Поскольку Py
thon очищает память, занятую не нужными больше объектами (как
будет показано позднее), такой подход не так уж неэффективен, как
могло бы показаться на первый взгляд:
>>> S
'Spam'
>>> S[0] = 'z' # Неизменяемые объекты нельзя изменить
...текст сообщения об ошибке опущен...
TypeError: 'str' object does not support item assignment
>>> S = 'z' + S[1:] # Но с помощью выражений мы можем
# создавать новые объекты
>>> S
'zpam'
Все объекты в языке Python либо относятся к классу неизменяемых,
либо нет. Если говорить о базовых типах, то числа, строки и кортежи
являются неизменяемыми, а списки и словари – нет (они легко могут
изменяться в любой своей части). Помимо всего, неизменяемость мо
жет рассматриваться как гарантия, что некоторый объект будет оста
ваться постоянным на протяжении работы программы.
Методы, специфичные для типа
Все строковые операции, которые мы до сих пор рассматривали, в дей
ствительности являются операциями над последовательностями, то
есть эти операции могут использоваться для работы с любыми после
довательностями языка Python, включая списки и кортежи. Однако,
помимо операций, универсальных для последовательностей, строки
также имеют свои собственные операции, выполненные в виде мето+
дов (функции, присоединенные к объекту, которые запускаются выра
жением вызова).
Например, метод строк find выполняет поиск подстроки в строке (он
возвращает смещение переданной ему подстроки или 1, если поиск не
увенчался успехом), а метод replace производит глобальный поиск с за
меной:
120 Глава 4. Введение в типы объектов языка Python
>>> S.find('pa') # Поиск смещения подстроки
1
>>> S
'Spam'
>>> S.replace('pa', 'XYZ') # Замена одной подстроки другой
'SXYZm'
>>> S
'Spam'
И снова, независимо от имен этих строковых методов, мы не изменя
ем, применяя методы, оригинальную строку, а создаем новую, т. к.
строки являются неизменяемыми, и это следует учитывать. Строко
вые методы – это первый уровень в комплекте инструментальных
средств обработки текста языка Python. Другие методы позволяют
разбивать строки на подстроки по определенному символуразделите
лю (достаточно удобно для простых случаев разбора строк), преобразо
вывать регистр символов, проверять тип содержимого строк (цифры,
алфавитные символы и т. д.) и отсекать пробельные символы с обоих
концов строк.
>>> line = 'aaa,bbb,ccccc,dd'
>>> line.split(',') # Разбивает строку по разделителю и создает список строк
['aaa', 'bbb', 'ccccc', 'dd']
>>> S = 'spam'
>>> S.upper() # Преобразование символов в верхний и в нижний регистр
'SPAM'
>>> S.isalpha() # Проверка содержимого: isalpha, isdigit и т. д.
True
>>> line = 'aaa,bbb,ccccc,dd\n'
>>> line = line.rstrip() # Удаляет завершающие пробельные символы
>>> line
'aaa,bbb,ccccc,dd'
Следует заметить, что в отличие от универсальных операций, приме
няемых к последовательностям, строковые методы могут применяться
только к строкам и ни к каким другим объектам. Следует понимать, что
инструментальные средства языка Python делятся на несколько уров
ней: универсальные операции, которые могут применяться к несколь
ким типам, реализованы в виде встроенных функций и выражений (на
пример, len(X), X[0]), а операции, специфичные для определенного ти
па, реализованы в виде методов (например, aString.upper()). Выбор тре
буемых инструментов из всех этих категорий станет более простым по
мере изучения языка Python, а в следующем разделе приводится не
сколько рекомендаций, которые вы сможете использовать уже сейчас.
Получение помощи
Методы, представленные в предыдущем разделе, являются лишь не
большой частью того, что доступно при работе со строковыми объекта
Строки 121
ми. Вообще эта книга не является исчерпывающим источником ин
формации о методах объектов. Чтобы получить дополнительную ин
формацию, вы всегда можете воспользоваться функцией dir, которая
возвращает список всех доступных атрибутов заданного объекта. По
скольку методы являются атрибутамифункциями, они также присут
ствуют в списке:
>>> dir(S)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__',
'__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__',
'__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__',
'__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__rmod__', '__rmul__', '__setattr__', '__str__', 'capitalize', 'center',
'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'index',
'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper',
'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex',
'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines',
'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
Скорее всего, вам не понадобятся имена из этого списка, содержащие
символы подчеркивания, до того момента, пока мы не приступим к изу
чению возможности перегрузки операторов в классах, – они представ
ляют собой реализацию строкового объекта и доступны для поддерж
ки настроек. Вообще ведущие и завершающие символы подчеркива
ния используются для обозначения механизмов внутренней реализа
ции. Имена без символов подчеркивания в этом списке обозначают
методы строковых объектов.
Функция dir возвращает лишь имена методов. Чтобы узнать назначе
ние того или иного метода, можно передать его имя функции help:
>>> help(S.index)
Help on builtin function index:
(Справка о встроенной функции index:)
index(...)
S.index(sub [,start [,end]]) > int
Like S.find() but raise ValueError when the substring is not found.
(Сходна с функцией S.find(), но вызывает ошибку ValueError,
если подстрока не найдена)
Функция help – один из немногих интерфейсов к системе программно
го кода Python, который поставляется в составе интерпретатора под
названием PyDoc – инструмент, который позволяет извлекать описа
ние из объектов. Далее в этой же книге вы узнаете, что PyDoc позволя
ет отображать информацию в формате HTML.
Можно запросить информацию и для самого строкового объекта (на
пример, help(S)), но в этом случае вы можете получить больше инфор
мации, чем хотелось бы, – описание всех строковых методов. Часто
бывает удобнее запрашивать информацию о конкретном методе, как
это было продемонстрировано выше.
122 Глава 4. Введение в типы объектов языка Python
За дополнительной информацией всегда можно обратиться к справоч
ному руководству по стандартной библиотеке или к печатным спра
вочным изданиям, но функции dir и help в языке Python представляют
собой самое первое средство получения доступа к документации.
Другие способы представления строк
К этому моменту мы познакомились с операциями над последователь
ностями и методами, специфичными для строк. Однако, кроме этого,
язык программирования Python предоставляет несколько различных
способов представления строк в программном коде, которые мы будем
исследовать позднее (включая служебные символы, которые представ
лены, например, в виде последовательностей, начинающихся с симво
ла обратного слеша):
>>> S = 'A\nB\tC' # \n – это символ "конец строки", \t – символ табуляции
>>> len(S) # Каждая из этих пар соответствует единственному символу
5
>>> ord('\n') # В ASCII \n – это байт с числовым значением 10
10
>>> S = 'A\0B\0C' # \0 – это двоичный ноль, не является завершителем строки
>>> len(S)
5
Язык Python допускает заключать строки в кавычки или в апострофы
(они означают одно и то же). Кроме того, имеется специальная форма
определения многострочных строковых литералов – тройные кавычки
или апострофы. Когда используется такая форма, все строки в про
граммном коде объединяются в одну строку, а там, где в исходном тек
сте выполняется переход на новую строку, вставляется символ «конец
строки». Это незначительное синтаксическое удобство весьма полезно
для оформления в сценариях на языке Python крупных блоков текста,
таких как разметка HTML или XML:
>>> msg = """
aaaaaaaaaaaaa
bbb'''bbbbbbbbbb""bbbbbbb'bbbb
cccccccccccccc"""
>>> msg
'\naaaaaaaaaaaaa\nbbb\'\'\'bbbbbbbbbb""bbbbbbb\'bbbb\ncccccccccccccc'
Кроме того, Python предоставляет поддержку «неформатированных»
строковых литералов, в которых символ обратного слеша интерпрети
руется как обычный символ (они начинаются с символа r), а также
поддержку строк с символами Юникода, обеспечивающих интерна
ционализацию (такие строки начинаются с символа u и состоят из
многобайтовых символов). С технической точки зрения строка с сим
волами Юникода представляет собой иной тип данных, отличный от
обычной строки, но он поддерживает те же самые строковые опера
Списки 123
ции. В последующих главах мы встретимся с этими специальными
формами строк.
Поиск по шаблону
Прежде чем двинуться дальше, хочется заметить, что ни один из стро
ковых объектов не поддерживает возможность обработки текста на ос
нове шаблонов. Рассмотрение инструментов, выполняющих поиск
текста по шаблону, выходит за рамки этой книги, но для читателей,
знакомых с другими языками сценариев, будет интересно узнать, как
выполняется поиск по шаблону в языке Python – для этого необходимо
импортировать модуль с именем re. Этот модуль содержит аналогич
ные функции для выполнения поиска, разбиения и замены, но за счет
использования шаблонов мы можем использовать более общие вариан
ты решения задач:
>>> import re
>>> match = re.match('Hello[ \t]*(.*)world', 'Hello Python world')
>>> match.group(1)
'Python '
В этом примере выполняется поиск строки, начинающейся со слова
«Hello», вслед за которым следуют ноль или более символов табуля
ции или пробелов, за которыми могут следовать произвольные симво
лы, которые будут сохранены, как группа совпадения, и завершаю
щаяся словом «world». Если такая подстрока будет найдена, части ее,
соответствующие шаблону, заключенному в круглые скобки, будут
доступны в виде групп. Например, следующий шаблон извлекает три
группы, разделенные символами слеша:
>>> match = re.match('/(.*)/(.*)/(.*)', '/usr/home/lumberjack')
>>> match.groups()
('usr', 'home', 'lumberjack')
Поиск по шаблону реализован в виде чрезвычайно сложного механиз
ма обработки текста, но в языке Python имеется поддержка еще более
сложных механизмов, включая возможность обработки естественного
языка человеческого общения. Впрочем, для этого руководства я и так
сказал уже достаточно об обработке строк, поэтому теперь мы перей
дем к рассмотрению другого типа.
Списки
Списки – это самое общее представление последовательностей, реали
зованных в языке Python. Списки – это упорядоченные по местополо
жению коллекции объектов произвольных типов, размер которых не
ограничен. Кроме того, в отличие от строк, списки являются изменяе
мыми – они могут модифицироваться как с помощью операций при
сваивания по смещениям, так и с помощью разнообразных методов ра
боты со списками.
124 Глава 4. Введение в типы объектов языка Python
Операции над последовательностями
Поскольку списки являются последовательностями, они поддерживают
все операции над последовательностями, которые обсуждались в разде
ле, посвященном строкам. Единственное отличие состоит в том, что
результатом таких операций являются списки, а не строки. Напри
мер, для списка, состоящего из трех элементов:
>>> L = [123, 'spam', 1.23] # Список из трех объектов разных типов
>>> len(L) # Число элементов в списке
3
Мы можем обращаться к элементам списка по их индексам, получать
срезы и т. д., точно так же, как и в случае со строками:
>>> L[0] # Доступ к элементу списка по его индексу
123
>>> L[:
1] # Операция получения среза возвращает новый список
[123, 'spam']
>>> L + [4, 5, 6] # Операция конкатенации также возвращает новый список
[123, 'spam', 1.23, 4, 5, 6]
>>> L # Наши действия не привели к изменению оригинального списка
[123, 'spam', 1.23]
Методы, специфичные для типа
Списки в языке Python являются аналогом массивов в других языках
программирования, но они обладают более широкими возможностя
ми. С одной стороны, они не ограничены одним типом элементов, на
пример, только что рассмотренный список содержит три элемента со
вершенно разных типов (целое число, строку и число с плавающей
точкой). Кроме того, размер списков не ограничен, благодаря чему они
могут увеличиваться и уменьшаться по мере необходимости в резуль
тате выполнения операций, характерных для списков:
>>> L.append('NI') # Увеличение: в конец списка добавляется новый объект
>>> L
[123, 'spam', 1.23, 'NI']
>>> L.pop(2) # Уменьшение: удаляется элемент из середины списка
1.23
>>> L # Инструкция "del L[2]" также удалит элемент списка
[123, 'spam', 'NI']
В данном примере метод append увеличивает размер списка и вставляет
в конец новый элемент. Метод pop (или эквивалентная ему инструкция
del) удаляет из списка элемент с заданным смещением, что приводит
к уменьшению списка. Другие методы списков позволяют вставлять
новые элементы в произвольное место списка (insert), удалять эле
мент, заданный значением (remove), и т. д. Так как списки являются
Списки 125
изменяемыми, большинство методов списков не создают новый спи
сок, а изменяют оригинальный список:
>>> M = ['bb', 'aa', 'cc']
>>> M.sort()
>>> M
['aa', 'bb', 'cc']
>>> M.reverse()
>>> M
['cc', 'bb', 'aa']
Метод sort, использованный в этом примере, по умолчанию упорядочи
вает элементы списка по возрастанию, а метод reverse – по убыванию.
В обоих случаях происходит непосредственное изменение самого списка.
Проверка выхода за границы
Хотя списки не имеют фиксированного размера, язык Python все рав
но не допускает возможности обращаться к несуществующим элемен
там списка. Обращение к элементам списка по индексам, значения ко
торых выходят за пределы списка, всегда является ошибкой:
>>> L
[123, 'spam', 'NI']
>>> L[99]
...текст сообщения об ошибке опущен...
IndexError: list index out of range
>>> L[99] = 1
... текст сообщения об ошибке опущен...
IndexError: list assignment index out of range
В этом примере я специально допустил ошибку (особенно неприятную
в языке C, который не выполняет проверку выхода за границы масси
ва, как Python) и попытался выполнить присваивание за пределами
списка. Вместо того, чтобы увеличить размер списка, интерпретатор
Python сообщает об ошибке. Чтобы увеличить список, необходимо вос
пользоваться таким методом, как append.
Вложенные списки
Одна из замечательных особенностей базовых типов языка Python со
стоит в том, что они поддерживают возможность создания вложенных
конструкций произвольной глубины и в любых комбинациях (напри
мер, можно создать список, содержащий словарь, который содержит
другой список, и т. д.). Одно из очевидных применений этой особенно
сти – представление матриц, или «многомерных массивов» в языке Py
thon. Делается это с помощью списка, содержащего вложенные списки:
>>> M = [[1, 2, 3], # Матрица 3×3 в виде вложенных списков
[4, 5, 6],
126 Глава 4. Введение в типы объектов языка Python
[7, 8, 9]]
>>> M
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Здесь мы реализовали список, состоящий из трех других списков.
В результате была получена матрица чисел 3×3. Обращаться к такой
структуре можно разными способами:
>>> M[1] # Получить строку 2
[4, 5, 6]
>>> M[1][2] # Получить строку 2, а затем элемент 3 в этой строке
6
Первая операция в этом примере возвращает вторую строку целиком,
а вторая – третий элемент в этой строке. Соединение операций индек
сирования позволяет все дальше и дальше погружаться вглубь вло
женной структуры объектов.1
Дополнительные операции над списками
Помимо обычных операций над последовательностями и методов спи
сков, Python предоставляет возможность выполнять более сложные
операции над списками, известные как выражения генераторов спи+
сков (list comprehension expression), которые представляют эффектив
ный способ обработки таких структур, как наша матрица. Предполо
жим, например, что нам требуется извлечь из нашей матрицы второй
столбец. Строку легко можно получить, выполнив операцию индекси
рования, потому что матрица хранится в виде строк, однако, благода
ря генераторам списков, получить столбец ничуть не сложнее:
>>> col2 = [row[1] for row in M] # Выбирает элементы второго столбца
>>> col2
[2, 5, 8]
>>> M # Матрица не изменилась
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Генераторы списков следуют традиции системы представления мно
жеств; они позволяют создавать новые списки, выполняя выражение
для каждого элемента в последовательности, по одному за раз, слева
1 Такая организация матриц вполне пригодна для решения небольших за
дач, но для реализации более сложных программ числовой обработки ин
формации желательно использовать специализированные расширения, на
пример NumPy. Такого рода инструменты позволяют хранить и обрабаты
вать матрицы намного эффективнее, чем такая структура, реализованная
в виде вложенных списков. Как уже говорилось, расширение NumPy пре
вращает Python в свободный и более мощный эквивалент системы MatLab,
и такие организации, как NASA, Los Alamos и JPMorgan Chase используют
его для решения научных и финансовых задач. Дополнительную информа
цию об этом расширении вы без труда найдете в Сети.
Словари 127
направо. Генераторы списков заключены в квадратные скобки (чтобы
отразить тот факт, что они создают список) и составлены из выражения
и конструкции цикла, которые используют одно и то же имя перемен
ной (в данном случае row). В предыдущем примере генератор списков
интерпретируется так: «Получить элементы row[1] из каждой строки
матрицы M и создать из них новый список». Результатом является но
вый список, содержащий значения из второго столбца матрицы.
На практике генераторы списков могут приобретать еще более слож
ную форму:
>>> [row[1] + 1 for row in M] # Добавить 1 к каждому элементу в столбце 2
[3, 6, 9]
>>> [row[1] for row in M if row[1] % 2 == 0] # Отфильтровать нечетные значения
[2, 8]
Первая операция в этом примере прибавляет 1 к значениям всех ото
бранных элементов, а вторая использует условный оператор if для ис
ключения из результата нечетных чисел с помощью операции деления
по модулю – % (остаток от деления). Генераторы списков, применяе
мые к спискам, возвращают в качестве результатов новые списки, но
могут использоваться и для любых других объектов, допускающих
выполнение итераций, например, ниже показано использование гене
ратора списков для обхода жестко заданного в программном коде спи
ска координат и строк:
>>> diag = [M[i][i] for i in [0, 1, 2]] # Выборка элементов диагонали матрицы
>>> diag
[1, 5, 9]
>>> doubles = [c * 2 for c in 'spam'] # Дублирование символов в строке
>>> doubles
['ss', 'pp', 'aa', 'mm']
Генераторы списков, на мой взгляд, достаточно сложная тема, чтобы
говорить о них здесь более подробно. Главная цель этого краткого обзо
ра состоит в том, чтобы проиллюстрировать наличие как простых, так
и очень сложных инструментов в арсенале Python. Генераторы списков
можно и не использовать, но на практике они оказываются очень удоб
ными и нередко обеспечивают более высокую производительность при
работе со списками. Кроме того, их можно применять к любым другим
последовательностям в языке Python, а также к некоторым другим ти
пам, которые не являются последовательностями. Мы еще будем гово
рить об этих выражениях далее, в этой книге.
Словари
Словари в языке Python – это нечто совсем иное (по выражению Монти
Пайтона), они вообще не являются последовательностями, это то, что
известно, как отображения. Отображения – это коллекции объектов,
128 Глава 4. Введение в типы объектов языка Python
но доступ к ним осуществляется не по определенным смещениям от
начала коллекции, а по ключам. В действительности отображения во
обще не подразумевают какоголибо упорядочения элементов по их
позиции, они просто отображают ключи на связанные с ними значе
ния. Словари – единственный тип отображения в наборе базовых объ
ектов Python – также относятся к классу изменяемых объектов: они
могут изменяться непосредственно, и в случае необходимости могут
увеличиваться и уменьшаться в размерах, подобно спискам.
Операции отображения
Когда словарь определяется как литерал, программный код определе
ния заключается в фигурные скобки и состоит из последовательности
пар «ключ: значение». Словари удобно использовать всегда, когда воз
никает необходимость связать значения с ключами, например чтобы
описать свойства чеголибо. В качестве примера рассмотрим следую
щий словарь, состоящий из трех элементов (с ключами «food» (про
дукт питания), «quantity» (количество) и «color» (цвет)):
>>> D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}
Мы можем обращаться к элементам этого словаря по ключам и изме
нять значения, связанные с ключами. Для доступа к элементам словаря
используется тот же синтаксис, который используется для обращения
к элементам последовательностей, только в квадратных скобках указы
вается не смещение относительно начала последовательности, а ключ:
>>> D['food'] # Получить значение, связанное с ключом 'food'
'Spam'
>>> D['quantity'] += 1 # Прибавить 1 к значению ключа 'quantity'
>>> D
{'food': 'Spam', 'color': 'pink', 'quantity': 5}
Несмотря на то что форма определения словаря в виде литерала, заклю
ченного в фигурные скобки, достаточно наглядна, на практике чаще
встречаются другие способы создания словарей. Следующий пример
начинается с создания пустого словаря, который затем заполняется по
одному ключу за раз. В отличие от списков, не допускающих присваи
вания значений отсутствующим элементам, присваивание значения по
несуществующему ключу в словаре приводит к созданию этого ключа:
>>> D = {}
>>> D['name'] = 'Bob' # В результате присваивания создается ключ
>>> D['job'] = 'dev'
>>> D['age'] = 40
>>> D
{'age': 40, 'job': 'dev', 'name': 'Bob'}
>>> print D['name']
Bob
Словари 129
В этом примере ключи словаря играют роль имен полей в записи, кото
рая описывает некоторого человека. В других приложениях словари
могут использоваться для замены операций поиска, поскольку обра
щение к элементу словаря по ключу обычно выполняется быстрее, чем
поиск, реализованный на языке Python.
Еще раз о вложенности
В предыдущем примере словарь использовался для описания гипоте
тической персоны с помощью трех ключей. Теперь предположим, что
информация имеет более сложную структуру. Возможно, придется за
писать имя и фамилию, а также несколько названий должностей, за
нимаемых одновременно. Это приводит к необходимости использова
ния вложенных объектов Python. Словарь в следующем примере опре
делен в виде литерала и имеет более сложную структуру:
>>> rec = {'name': {'first': 'Bob', 'last': 'Smith'},
'job': ['dev', 'mgr'],
'age': 40.5}
Здесь мы опять имеем словарь, содержащий три ключа верхнего уров
ня (ключи «name» (имя), «job» (должность) и «age» (возраст)), однако
значения имеют более сложную структуру: для описания имени челове
ка используется вложенный словарь, чтобы обеспечить поддержку
имен, состоящих из нескольких частей, и для перечисления занимае
мых должностей используется вложенный список, что обеспечит воз
можность расширения в будущем. К компонентам этой структуры мож
но обращаться почти так же, как мы делали это в случае с матрицей, но
на этот раз вместо числовых индексов мы используем ключи словаря:
>>> rec['name'] # 'Name' – это вложенный словарь
{'last': 'Smith', 'first': 'Bob'}
>>> rec['name']['last'] # Обращение к элементу вложенного словаря
'Smith'
>>> rec['job'] # 'Job' – это вложенный список
['dev', 'mgr']
>>> rec['job'][
1] # Обращение к элементу вложенного списка
'mgr'
>>> rec['job'].append('janitor') # Расширение списка должностей Боба (Bob)
>>> rec
{'age': 40.5, 'job': ['dev', 'mgr', 'janitor'], 'name': {'last': 'Smith',
'first': 'Bob'}}
Обратите внимание, как последняя операция в этом примере выполня
ет расширение вложенного списка. Так как список должностей – это от
дельный от словаря участок в памяти, он может увеличиваться и умень
шаться без какихлибо ограничений (размещение объектов в памяти
будет обсуждаться позже, в этой же книге).
130 Глава 4. Введение в типы объектов языка Python
Основная цель демонстрации этого примера состоит в том, чтобы пока
зать вам гибкость базовых типов данных в языке Python. Здесь вы мо
жете видеть, что возможность вложения позволяет легко воспроизво
дить достаточно сложные структуры данных. Для создания подобной
структуры на языке C потребовалось бы приложить больше усилий
и написать больше программного кода: нам пришлось бы описать и объ
явить структуры и массивы, заполнить их значениями, связать их меж
ду собой и т. д. В языке Python все это делается автоматически – запуск
выражения приводит к созданию всей структуры вложенных объектов.
Фактически, это одно из основных преимуществ языков сценариев, та
ких как Python.
Так же как и в низкоуровневых языках программирования, мы могли
бы выполнить освобождение памяти, занимаемой объектами, которые
стали не нужны. В языке Python память освобождается автоматиче
ски, когда теряется последняя ссылка на объект, например в случае
присваивания переменной какоголибо другого значения:
>>> rec = 0 # Теперь память, занятая объектом, будет освобождена
С технической точки зрения, интерпретатор Python обладает такой
особенностью, как сборка мусора, благодаря которой в ходе выполне
ния программы производится освобождение неиспользуемой памяти,
что освобождает нас от необходимости предусматривать специальные
действия в программном коде. Интерпретатор освобождает память
сразу же, как только будет ликвидирована последняя ссылка на объ
ект. С работой этого механизма мы познакомимся далее, в этой же
книге, а пока достаточно знать, что вы можете работать с объектами,
не беспокоясь о выделении или освобождении памяти для них.1
Сортировка по ключам: циклы for
Будучи отображениями, как мы уже видели, словари поддерживают
доступ к элементам только по ключам. Однако они кроме того поддер
живают ряд специфических для данного типа операций, реализован
ных в виде методов, которые удобно использовать в разных случаях.
Как уже упоминалось ранее, изза того, что словари не являются после
довательностями, они не предусматривают какойлибо надежный спо
соб упорядочения позиций элементов. Это означает, что если мы созда
дим словарь и попытаемся вывести его, порядок следования ключей
при выводе может не совпадать с порядком, в каком они определялись:
1 В качестве примечания: имейте в виду, что запись rec, которую мы создали
здесь, в действительности может быть записью в базе данных, если бы мы
использовали систему хранения объектов Python – простейший способ
хранения объектов Python в файлах или в базах данных, обеспечивающих
доступ по ключу. Мы не будем здесь углубляться в подробности, а за допол
нительной информацией по этому вопросу обращайтесь к модулям Python –
pickle и shelve.
Словари 131
>>> D = {'a': 1, 'b': 2, 'c': 3}
>>> D
{'a': 1, 'c': 3, 'b': 2}
Как же быть, если нам действительно потребуется упорядочить эле
менты словаря? В наиболее общем случае мы могли бы получить спи
сок всех ключей словаря методом keys, отсортировать их с помощью
метода списка sort и затем выполнить обход значений в цикле for:
>>> Ks = D.keys() # Неупорядоченный список ключей
>>> Ks
['a', 'c', 'b']
>>> Ks.sort() # Сортировка списка ключей
>>> Ks
['a', 'b', 'c']
>>> for key in Ks: # Обход отсортированного списка ключей
print key, '=>', D[key]
a => 1
b => 2
c => 3
Этот процесс, состоящий из трех этапов, в последних версиях Python
можно упростить до единственной операции, как будет показано в по
следующих главах, с помощью новой встроенной функции sorted
(функция sorted сортирует объекты разных типов и возвращает их):
>>> D
{'a': 1, 'c': 3, 'b': 2}
>>> for key in sorted(D):
print key, '=>', D[key]
a => 1
b => 2
c => 3
Этот пример может служить поводом для знакомства с циклом for язы
ка Python. Цикл for представляет собой самый простой и эффективный
способ произвести обход всех элементов в последовательности и выпол
нить блок программного кода для каждого из элементов. Переменная
цикла, определяемая пользователем (в данном случае key), служит для
ссылки на текущий элемент. В этом примере выводятся ключи и значе
ния несортированного словаря, в отсортированном по ключам виде.
Цикл for и родственный ему цикл while – это основные способы реализа
ции повторяющихся действий в сценариях. Однако в действительности
цикл for, так же как и родственные ему генераторы списков
(с которыми мы познакомились выше), является операцией над после
довательностью. Он способен работать с любыми объектами, являющи
мися последовательностями, а также с некоторыми объектами, которые
последовательностями не являются. Ниже приводится пример обхода
всех символов в строке и вывод их в верхнем регистре:
132 Глава 4. Введение в типы объектов языка Python
>>> for c in 'spam':
print c.upper()
S
P
A
M
Инструкции циклов мы рассмотрим позднее, в этой же книге.
Итерации и оптимизация
Если цикл for выглядит похожим на генераторы списков, введенные
ранее, следовательно, оба эти инструмента должны представлять собой
универсальные средства выполнения итераций. Фактически обе конст
рукции способны работать с любыми объектами, которые поддержива
ют протокол итераций – идею, недавно появившуюся в Python, кото
рая по сути подразумевает наличие в памяти последовательности или
объекта, который генерирует по одному элементу в контексте выполне
ния итерации. Именно поэтому функция sorted, которая использова
лась в предыдущем разделе, способна работать со словарем непосредст
венно – нам не требуется вызывать метод keys для получения последо
вательности, потому что словари поддерживают выполнение итераций.
О протоколе итераций я расскажу позднее, в этой же книге. А пока
просто запомните, что любой генератор списков, такой, как показано
ниже, который вычисляет квадраты чисел в списке:
>>> squares = [x ** 2 for x in [1, 2, 3, 4, 5]]
>>> squares
[1, 4, 9, 16, 25]
всегда можно запрограммировать в виде эквивалентного цикла for, ко
торый создает список с результатами, добавляя новые элементы в ходе
выполнения итераций:
>>> squares = []
>>> for x in [1, 2, 3, 4, 5]: # Это список, который участвует в вычислениях
squares.append(x ** 2)
>>> squares
[1, 4, 9, 16, 25]
Однако генераторы списков обычно выполняются быстрее (примерно
раза в два), что особенно важно для программ, обрабатывающих боль
шие объемы данных. И тем не менее следует заметить, что оценка про
изводительности – вещь очень хитрая в языке Python, потому что в про
цессе разработки он продолжает оптимизироваться, и производитель
ность тех или иных конструкций может изменяться от версии к версии.
Главное правило, которому желательно следовать при использовании
языка Python, – это простота и удобочитаемость программного кода,
а проблему производительности следует рассматривать во вторую оче
редь, уже после того, как будет создана работоспособная программа
Словари 133
и когда проблема производительности программы действительно за
служивает того, чтобы на нее обратили внимание. Но чаще всего ваш
программный код будет обладать достаточно высокой производитель
ностью. Если же вам потребуется оптимизировать программу, в соста
ве Python вы найдете инструменты, которые помогут вам в этом,
включая модули time и timeit, а также модуль profile. Более подроб
ную информацию об этих модулях вы найдете далее в книге и в руко
водствах по языку Python.
Отсутствующие ключи: проверка с помощью оператора if
Еще одно замечание о словарях, прежде чем двинуться дальше. Несмот
ря на то что операция присваивания значений элементам с несущест
вующими ключами приводит к расширению словаря, тем не менее при
попытке обратиться к несуществующему элементу возникает ошибка:
>>> D
{'a': 1, 'c': 3, 'b': 2}
>>> D['e'] = 99 # Присваивание по новому ключу приводит к расширению словаря
>>> D
{'a': 1, 'c': 3, 'b': 2, 'e': 99}
>>> D['f'] # При попытке обращения к несуществующему ключу возникает ошибка
...текст сообщения об ошибке опущен...
KeyError: 'f'
Программная ошибка при попытке получить значение несуществую
щего элемента – это именно то, что нам хотелось бы получать. Но в не
которых универсальных программах, когда создается программный
код, мы не всегда можем знать, какие ключи будут присутствовать.
Как быть в таких случаях, чтобы не допустить появление ошибок? Для
этого можно, например, выполнить предварительную проверку. Метод
словаря has_key позволяет определить наличие ключа и с помощью ус
ловного оператора if выполнить тот или иной программный код:
>>> D.has_key('f')
False
>>> if not D.has_key('f'):
print 'missing'
missing
Далее в этой книге я расскажу подробнее об инструкции if и о ее син
таксисе. Однако форма инструкции, которая используется здесь, доста
точно очевидна: она состоит из ключевого слова if, следующего за ним
выражения, результат которого интерпретируется как «истина» или
«ложь». Далее следует блок программного кода, который будет выпол
нен, если результатом выражения будет значение «истина». В полной
форме инструкция if предусматривает наличие предложения else –,
для реализации действия по умолчанию, и одно или более предложение
elif (else if) для выполнения других проверок. Это основное средство
134 Глава 4. Введение в типы объектов языка Python
выбора в языке Python и именно этим способом мы реализуем логику
работы в наших сценариях.
Существуют также и другие способы создания словарей и исключения
ошибок обращения к несуществующим элементам словаря (включая
метод get, выражение in и инструкцию try, с которой мы познакомим
ся в главе 10, которая позволяет перехватывать и обрабатывать ис
ключения), но подробнее об этом мы поговорим в одной из следующих
глав. А сейчас рассмотрим кортежи.
Кортежи
Объекткортеж (tuple – произносится как «тъюпл» или «тъюпел»,
в зависимости от того, у кого вы спрашиваете) в общих чертах напоми
нает список, который невозможно изменить, – кортежи являются по
следовательностями, как списки, но они являются неизменяемыми,
как строки. Синтаксически, определение кортежа заключается в круг
лые, а не в квадратные скобки. Они также поддерживают включение
объектов различных типов, вложение и операции, типичные для по
следовательностей:
>>> T = (1, 2, 3, 4) # Кортеж из 4 элементов
>>> len(T) # Длина
4
>> T + (5, 6) # Конкатенация
(1, 2, 3, 4, 5, 6)
>>> T[0] # Извлечение элемента, среза и т. д.
1
Единственное реальное отличие кортежей – это невозможность их из
менения после создания. То есть кортежи являются неизменяемыми
последовательностями:
>>> T[0] = 2 # Кортежи являются неизменяемыми
...текст сообщения об ошибке опущен...
TypeError: 'tuple' object does not support item assignment
(TypeError: объект 'tuple' не поддерживает операцию присваивания элементам)
Для чего нужны кортежи?
Зачем нужен тип, который напоминает список, но поддерживает мень
шее число операций? Откровенно говоря, на практике кортежи ис
пользуются не так часто, как списки, но главное их достоинство – не
изменяемость. Если коллекция объектов передается между компонен
тами программы в виде списка, он может быть изменен любым из ком
понентов. Если используются кортежи, такие изменения становятся
невозможны. То есть кортежи обеспечивают своего рода ограничение
целостности, что может оказаться полезным в крупных программах.
Далее в книге мы еще вернемся к кортежам. А сейчас перейдем к по
следнему базовому типу данных – к файлам.
Файлы 135
Файлы
Объектыфайлы – это основной интерфейс между программным кодом
на языке Python и внешними файлами на компьютере. Файлы явля
ются одним из базовых типов, но они представляют собой нечто не
обычное, поскольку для файлов отсутствует возможность создания
объектов в виде литералов. Вместо этого чтобы создать объект файла,
необходимо вызвать встроенную функцию open, передав ей имя внеш
него файла и строку режима доступа к файлу. Например, чтобы соз
дать файл для вывода данных, вместе с именем файла функции необ
ходимо передать строку режима 'w':
>>> f = open('data.txt', 'w') # Создается новый файл для вывода
>>> f.write('Hello\n') # Запись строки байтов в файл
>>> f.write('world\n')
>>> f.close() # Закрывает файл и выталкивает выходные буферы на диск
В этом примере создается файл в текущем каталоге и в него записыва
ется текст (имя файла может содержать полный путь к каталогу, если
требуется получить доступ к файлу, находящемуся в другом месте).
Чтобы прочитать то, что было записано в файл, файл нужно открыть
в режиме 'r' (этот режим используется по умолчанию, если строка ре
жима в вызове функции опущена), затем прочитать содержимое файла
в строку байтов и отобразить ее. Содержимое файла для сценария все
гда является строкой байтов, независимо от типов данных, фактиче
ски хранящихся в файле:
>>> f = open('data.txt') # 'r' – это режим доступа к файлу по умолчанию
>>> bytes = f.read() # Файл читается целиком в строку
>>> bytes
'Hello\nworld\n'
>>> print bytes # Вывод, с попутной интерпретацией служебных символов
Hello
world
>>> bytes.split() # Содержимое файла всегда является строкой
['Hello', 'world']
Объектыфайлы имеют и другие методы, поддерживающие дополни
тельные возможности, рассматривать которые у нас нет времени. На
пример, объекты файлов предоставляют различные способы чтения
и записи данных (метод read принимает необязательный параметр –
количество байтов, метод readline считывает по одной строке за одно
обращение и т. д.) и другие методы (seek – перемещает позицию чте
ния/записи в файле). В этой книге мы будем изучать их позднее, но ес
ли у вас появится желание быстро ознакомиться с ними, запустите
функцию dir, передав ей слово file (имя типа данных), а затем функ
цию help с любым из имен методов в качестве аргумента:
>>> dir(file)
['_ _class_ _', '_ _delattr_ _', '_ _doc_ _', '_ _enter_ _', '_ _exit_ _',
136 Глава 4. Введение в типы объектов языка Python
'_ _getattribute_ _', '_ _hash_ _', '_ _init_ _', '_ _iter_ _', '_ _new_ _',
'_ _reduce_ _', '_ _reduce_ex_ _', '_ _repr_ _', '_ _setattr_ _', '_ _str_ _',
'close', 'closed', 'encoding', 'fileno', 'flush', 'isatty', 'mode',
'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines',
'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines']
>>> help(file.seek)
...попробуйте и увидите...
Другие средства, напоминающие файлы
Функция open – это рабочая лошадка в большинстве операций с файла
ми, которые можно выполнять в языке Python. Для решения более
специфичных задач Python поддерживает и другие инструментальные
средства, напоминающие файлы: каналы, очереди, сокеты, файлы
с доступом по ключу, хранилища объектов, файлы с доступом по деск
риптору, интерфейсы к реляционным и объектноориентированным
базам данных и многие другие. Файлы с доступом по дескриптору, на
пример, поддерживают возможность блокировки и другие низкоуров
невые операции, а сокеты представляют собой интерфейс к сетевым
взаимодействиям. В этой книге мы не будем подробно рассматривать
эти темы, но знание этих особенностей окажется для вас полезным,
как только вы начнете всерьез программировать на языке Python.
Другие базовые типы
Помимо базовых типов данных, которые мы уже рассмотрели, сущест
вуют и другие, которые могут считаться базовыми, в зависимости от
широты определения этой категории. Например, множества совсем
недавно появились в языке. Множества – это контейнеры для других
объектов. Множества создаются встроенной функцией set и поддер
живают типичные математические операции над множествами:
>>> X = set('spam')
>>> Y = set(['h', 'a', 'm']) # Создаются два множества последовательностей
>>> X, Y
(set(['a', 'p', 's', 'm']), set(['a', 'h', 'm']))
>>> X & Y # Пересечение
set(['a', 'm'])
>>> X | Y # Объединение
set(['a', 'p', 's', 'h', 'm'])
>>> X – Y # Разность
set(['p', 's'])
Кроме того, недавно в Python появились вещественные числа с фикси
рованной точностью и тип Boolean (с предопределенными объектами
True и False, которые по сути являются целыми числами 0 и 1 с некото
рыми особенностями отображения на экране), а кроме того, давно уже
существует специальный объект None:
Другие базовые типы 137
>>> import decimal # Вещественные числа с фиксированной точностью
>>> d = decimal.Decimal('3.141')
>>> d + 1
Decimal("4.141")
>>> 1 > 2, 1 < 2 # Логические значения
(False, True)
>>> bool('spam')
True
>>> X = None # Специальный объект None
>>> print X
None
>>> L = [None] * 100 # Инициализация списка из ста объектов None
>>> L
[None, None, None, None, None, None, None, None, None, None, None, None, None,
...список из 100 объектов None...]
>>> type(L) # Типы
<type 'list'>
>>> type(type(L)) # Даже типы являются объектами
<type 'type'>
Как можно нарушить гибкость программного кода
Мы еще будем много говорить обо всех этих типах данных далее в кни
ге, но сначала я хочу сделать важный акцент. Объект type позволяет
выполнять проверку типов объектов в программном коде, который ис
пользует эти объекты. Сделать это в сценариях на языке Python мож
но как минимум тремя способами:
>>> if type(L) == type([]): # Проверка типа, если в этом есть необходимость...
print 'yes'
yes
>>> if type(L) == list: # С использованием имени типа
print 'yes'
yes
>>> if isinstance(L, list): # Проверка в объектноориентированном стиле
print 'yes'
yes
Однако теперь, когда я показал вам все эти способы проверки типа объ
екта, я должен заметить, что использование таких проверок в про
граммном коде практически всегда является неверным решением (и от
личительным признаком бывшего программиста на языке C, присту
пившего к программированию на языке Python). Наличие проверок на
принадлежность объекта к тому или иному типу отрицательно сказы
вается на гибкости программного кода, потому что вы ограничиваете
его работой с единственным типом данных. Без таких проверок ваш
138 Глава 4. Введение в типы объектов языка Python
программный код может оказаться в состоянии работать с более широ
ким диапазоном типов.
Это связано с идей полиморфизма, о которой упоминалось ранее, и это
основная причина отсутствия необходимости описывать типы пере
менных в языке Python. Как будет говориться далее, программный
код на языке Python ориентируется на использование интерфейсов
объектов (набор поддерживаемых операций), а не их типов. Отсутст
вие заботы об определенных типах означает, что программный код ав
томатически может обслуживать большинство из них – допустимыми
будут любые объекты с совместимыми интерфейсами, независимо от
конкретного типа. И хотя контроль типов поддерживается – а в ред
ких случаях даже необходим, – тем не менее это обычно не способ ду
мать на языке Python. Вы сами убедитесь, что ключевой идеей, обеспе
чивающей успех использования Python, является полиморфизм.
Классы, определяемые пользователем
Мы рассмотрим объектноориентированный стиль программирования
на языке Python (необязательную к применению, но весьма мощную
особенность языка, которая позволяет сократить время разработки за
счет многократного использования программного кода) подробно далее
в этой книге. Тем не менее, говоря абстрактными терминами, классы
определяют новые типы объектов, которые расширяют базовый набор,
и потому они заслуживают упоминания здесь. Например, вам мог бы
потребоваться такой тип объектов, который моделировал бы сотрудни
ков. В языке Python нет такого базового типа, тем не менее следующий
класс вполне мог бы удовлетворить ваши потребности:
>>> class Worker:
def _ _init_ _(self, name, pay): # Инициализация при создании
self.name = name # self – это сам объект
self.pay = pay
def lastName(self):
return self.name.split()[
1] # Разбить строку по символам пробела
def giveRaise(self, percent):
self.pay *= (1.0 + percent) # Обновить сумму выплат
Данный класс определяет новый тип объектов, который обладает ат
рибутами name и pay (иногда атрибуты называют информацией о со+
стоянии), а также два описания поведения, оформленных в виде
функций (которые обычно называют методами). Обращение к имени
класса как к функции приводит к созданию экземпляра нового типа,
а методы класса автоматически получают ссылку на текущий экземп
ляр, обрабатываемый этими методами (аргумент self):
>>> bob = Worker('Bob Smith', 50000) # Создаются два экземпляра и для каждого
>>> sue = Worker('Sue Jones', 60000) # определяется имя и сумма выплат
>>> bob.lastName() # Вызов метода: self – это bob
'Smith'
>>> sue.lastName() # self – это Sue
В заключение 139
'Jones'
>>> sue.giveRaise(.10) # Обновить сумму выплат для Sue
>>> sue.pay
66000.0
Модель называется объектноориентированной потому, что здесь при
сутствует подразумеваемый объект «self»: внутри функций, определяе
мых в классах, всегда присутствует подразумеваемый объект. В некото
ром смысле типы, основанные на классах, просто создаются на базе ос
новных типов и используют их функциональные возможности. В дан
ном случае пользовательский класс Worker – это всего лишь коллекция,
состоящая из строки и числа (name и pay), плюс функции, выполняю
щие обработку этих двух встроенных объектов.
Кроме того, механизм наследования классов поддерживает программ
ные иерархии, которые допускают возможность их расширения. Воз
можности программного обеспечения расширяются за счет создания
новых классов, но при этом не изменяется программный код, который
уже работает. Вместе с тем, вы должны понимать, что классы в языке
Python не являются обязательными к применению, и нередко более
простые встроенные типы, такие как списки и словари, оказываются
эффективнее классов, определяемых пользователем. Однако все это
выходит далеко за рамки ознакомительной главы, поэтому, чтобы про
должить знакомство, вам придется прочитать следующие главы.
И все остальное
Как уже упоминалось ранее, все данные, которые обрабатываются сце
нариями на языке Python, являются объектами, поэтому наш краткий
обзор типов объектов никак нельзя назвать исчерпывающим. Однако,
даже при том, что все сущее в языке Python является «объектом»,
только рассмотренные типы образуют базовый набор. Другие типы
объектов, как правило, реализуются в виде модулей и не являются син
таксическими элементами языка. Кроме того, они обычно имеют уз
кий круг применения – текстовые шаблоны, интерфейсы доступа к ба
зам данных, сетевые взаимодействия и т. д.
Более того, имейте в виду, что объекты, с которыми мы здесь познако
мились, действительно являются объектами, но для работы с ними не
требуется использовать объектно+ориентированный подход – концеп
ция, которая обычно подразумевает использование механизма насле
дования и оператора class, с которыми мы еще встретимся далее в этой
книге. Однако базовые объекты языка Python – это рабочие лошадки
практически любого сценария, и, как правило, они являются основой
более крупных типов, не являющихся базовыми.
В заключение
На этом мы заканчиваем наш краткий обзор типов данных. В этой главе
вашему вниманию было предложено краткое введение в базовые типы
140 Глава 4. Введение в типы объектов языка Python
объектов языка Python и операции, которые могут к ним применяться.
Мы рассмотрели наиболее универсальные операции, которые могут
применяться к объектам различных типов (операции над последова
тельностями, такие как обращение к элементам по их индексам и из
влечение срезов), а также операции, специфичные для определенных
типов, реализованные в виде методов (например, разбиение строки
и добавление элементов в список). Здесь также были даны определе
ния некоторых ключевых терминов, такие как неизменность, после
довательности и полиморфизм.
Наряду с этим мы узнали, что базовые типы данных в языке Python об
ладают большей гибкостью и более широкими возможностями, чем ти
пы данных, доступные в низкоуровневых языках программирования,
таких как C. Например, списки и словари избавляют нас от необходи
мости реализовать программный код поддержки коллекций и поиска.
Списки – это упорядоченные коллекции объектов, а словари – это кол
лекции объектов, доступ к которым осуществляется по ключу, а не по
позиции. И словари, и списки могут быть вложенными, могут увеличи
ваться и уменьшаться по мере необходимости и могут содержать объек
ты любых типов. Более того, память, занимаемая ими, автоматически
освобождается, как только будет утрачена последняя ссылка на них.
Я опустил большую часть подробностей здесь, чтобы сделать знаком
ство как можно более кратким, поэтому вы не должны считать, что эта
глава содержит все, что необходимо. В следующих главах мы будем
рассматривать базовые типы языка более подробно, благодаря чему вы
сможете получить более полную картину. В следующей главе мы при
ступим к всестороннему изучению чисел в языке Python. Но для нача
ла ознакомьтесь с контрольными вопросами.
Закрепление пройденного
Контрольные вопросы
В следующих главах мы более подробно будем исследовать понятия,
введенные в этой главе, поэтому здесь мы охватим лишь самые общие
направления:
1. Назовите четыре базовых типа данных в языке Python.
2. Почему они называются базовыми?
3. Что означает термин «неизменяемый», и какие три базовых типа
языка Python являются неизменяемыми?
4. Что означает термин «последовательность», и какие три типа отно
сятся к этой категории?
5. Что означает термин «отображение», и какой базовый тип является
отображением?
6. Что означает термин «полиморфизм», и почему он имеет такое важ
ное значение?
Закрепление пройденного 141
Ответы
1. К базовым типам объектов (данных) относятся числа, строки, спи
ски, словари, кортежи и файлы. Множества, сами типы, None и логи
ческие значения также иногда относят к базовым типам. Существу
ет несколько типов чисел (целые, длинные целые, с плавающей точ
кой и фиксированной точности) и два типа строк (обычные и в коди
ровке Юникод).
2. Базовыми они называются потому, что являются частью самого
языка Python и могут быть использованы в любой момент. Чтобы
создать объект какоголибо другого типа, обычно бывает необходи
мо обращаться к функции из импортированного модуля. Для боль
шинства базовых типов предусмотрен специальный синтаксис соз
дания объектов, например, 'spam' – это выражение, которое создает
строку и определяет набор операций, которые могут применяться
к ней. Вследствие этого базовые типы жестко вшиты в синтаксис
языка Python. Единственное отличие – объектыфайлы, для созда
ния которых необходимо вызывать функцию open.
3. «Неизменяемый» объект – это объект, который невозможно изме
нить после того, как он будет создан. К этой категории объектов от
носятся числа, строки и кортежи. Но даже при том, что вы не може
те изменить «неизменяемый» объект на месте, вы всегда можете
создать вместо него новый объект, выполнив выражение.
4. «Последовательность» – это упорядоченная по местоположению
коллекция объектов. К последовательностям относятся строки, спи
ски и кортежи. Ко всем этим типам могут применяться операции,
общие для всех последовательностей, такие как обращение к эле
ментам по их индексам, конкатенация и получение срезов. Но поми
мо этого каждый из этих типов имеет ряд специфичных методов.
5. Под термином «отображение» подразумевается объект, который ото
бражает ключи на ассоциированные с ними значения. Единствен
ный базовый тип данных в языке Python, который является отобра
жением, – это словарь. Отображения не подразумевают упорядоче
ние элементов по их позиции, но они поддерживают возможность
доступа к элементам по ключу, плюс ряд специфичных методов.
6. «Полиморфизм» означает, что фактически выполняемая операция
(такая как +) зависит от объектов, которые принимают в ней уча
стие. В языке Python идея полиморфизма составляет ключевую кон
цепцию (пожалуй, самую ключевую) – она не ограничивает приме
нимость программного кода какимто определенным типом дан
ных, благодаря чему этот код обычно в состоянии автоматически
обрабатывать объекты самых разных типов.
5
Числа
С этой главы, мы начинаем погружаться в детали реализации языка
Python. Данные в этом языке имеют форму объектов – это либо встро
енные объекты, входящие в состав самого языка, либо объекты, созда
ваемые с помощью языковых конструкций. Фактически объекты яв
ляются основой любой программы на языке Python. Поскольку объек
ты представляют самое фундаментальное понятие для программиро
вания на языке Python, все наше внимание в первую очередь будет
сосредоточено на объектах.
В предыдущей главе мы коротко познакомились с базовыми типами
объектов языка Python. И хотя в этой главе основные понятия были да
ны, мы старались избегать слишком специфичных подробностей в це
лях экономии книжного пространства. В этой главе мы приступаем к бо
лее внимательному изучению концепции типов данных, чтобы воспол
нить детали, о которых раньше умалчивалось. Кроме того, здесь мы рас
смотрим некоторые типы, которые так или иначе связаны с числами,
такие как множества и логические значения (Boolean). Итак, приступим
к изучению чисел – первой категории типов данных в языке Python.
Числовые типы в Python
Числовые типы в языке Python не выделяются ничем необычным и на
верняка покажутся вам знакомыми, если в прошлом вам уже прихо
дилось использовать какойлибо язык программирования. Числа мо
гут использоваться для представления информации о состоянии ваше
го банковского счета, о расстоянии до Марса, о числе посетителей ва
шего вебсайта и всего, что можно выразить в числовой форме.
Числа в языке Python представлены не единственным типом, а целой
категорией родственных типов. Язык Python поддерживает обычные
Числовые типы в Python 143
типы объектов чисел (целые и с плавающей точкой), а также литералы –
для их создания, и выражения – для их обработки. Кроме того, Python
предоставляет дополнительное программное обеспечение поддержки
чисел, включая тип комплексного числа, тип чисел с неограниченной
точностью представления, тип вещественных чисел с фиксированной
точностью, множества, логические значения и целый ряд разнообраз
ных библиотек для работы с числами. В следующих нескольких разде
лах проводится обзор поддержки чисел в языке программирования
Python.
Числовые литералы
Помимо базовых типов данных язык Python предоставляет самые
обычные числовые типы: он поддерживает целые числа и числа с пла
вающей точкой (с дробной частью) и все синтаксические конструкции
и операции, связанные с числами. Подобно языку C, Python позволяет
записывать целые числа с помощью шестнадцатеричных и восьмерич
ных литералов. Но в отличие от C, язык Python дополнительно реали
зует тип комплексных чисел, а также длинные целые числа с неогра
ниченной точностью представления (они могут содержать столько зна
ков, сколько позволит хранить объем оперативной памяти). В табл. 5.1
показано, как выглядят числа различных типов в языке Python в тек
сте программы (то есть в виде литералов).
Таблица 5.1. Числовые литералы
Вообще в числовых типах языка Python нет ничего сложного, но мне
хотелось бы сделать несколько замечаний о принципах использования
литералов в программном коде:
Литералы целых чисел и чисел с плавающей точкой
Целые числа записываются как строки, состоящие из десятичных
цифр. Числа с плавающей точкой могут содержать символ точки
и/или необязательную экспоненту со знаком, которая начинается
с символа e или E. Если в записи числа обнаруживается точка или
экспонента, интерпретатор Python создает объект числа с плаваю
щей точкой и использует вещественную (не целочисленную) матема
тику, когда такой объект участвует в выражении. Правила записи
Литерал Интерпретация
1234, 24, 0 Обычные целые числа (long в языке C)
9999999999999999999L Длинные целые числа (с неограниченной
точностью представления)
1.23, 3.14e10, 4E210, 4.0e+210 Числа с плавающей точкой (double в языке C)
0177, 0x9ff, 0XFF Восьмеричные и шестнадцатеричные лите
ралы целых чисел
3+4j, 3.0+4.0j, 3J Литералы комплексных чисел
144 Глава 5. Числа
вещественных чисел в языке Python ничем не отличаются от пра
вил, используемых в языке C.
Точность представления целых чисел и длинные целые
Простые целые числа в языке Python (первая строка в табл. 5.1)
реализованы как тип long в языке C (то есть имеют размер как ми
нимум 32 бита), а вещественные числа в языке Python реализованы
как тип double в языке C. Таким образом, точность представления
чисел этих типов соответствует точности представления, которую
обеспечивает компилятор языка C, использованный для сборки ин
терпретатора Python.1
Литералы длинных целых чисел
Если числовой литерал заканчивается символом l или L, он рас
сматривается интерпретатором Python как длинное целое число (не
надо путать с типом long в языке C) и может использоваться для
представления сколь угодно больших чисел. В Python 2.2 и более
поздних версиях целые числа автоматически преобразуются в длин
ные целые, если их значения не умещаются в отведенные 32 бита,
поэтому вам не требуется вводить символ L – интерпретатор автома
тически выполнит необходимые преобразования, когда потребует
ся увеличить точность представления.
Шестнадцатеричные и восьмеричные литералы
Правила записи шестнадцатеричных (по основанию 16) и восьме
ричных (по основанию 8) чисел в языке Python ничем не отличают
ся от правил, используемых в языке C. Литералы восьмеричных
чисел начинаются с нуля (0), вслед за которым следуют восьмерич
ные цифры 07. Шестнадцатеричные литералы начинаются с ком
бинации символов 0x или 0X, вслед за которыми следуют шестна
дцатеричные цифры 09 и AF. Шестнадцатеричные цифры в шест
надцатеричных литералах могут вводиться как в нижнем, так
и в верхнем регистре. И восьмеричные, и шестнадцатеричные лите
ралы создают объекты целых чисел – это всего лишь альтернатив
ный синтаксис определения значений этого типа.
Комплексные числа
Литералы комплексных чисел в языке Python записываются в фор
мате вещественная_часть+мнимая_часть, где вещественная_часть является
необязательной и мнимая_часть может указываться без вещественной
составляющей. Во внутреннем представлении комплексное число
реализовано в виде двух чисел с плавающей точкой, но при обработ
ке чисел этого типа используется математика комплексных чисел.
1 Это замечание относится к стандартной реализации CPython. В Jython чи
словые типы Python в действительности соответствуют классам Java.
Операторы выражений 145
Встроенные числовые операции и расширения
Помимо числовых литералов, которые приводятся в табл. 5.1, язык Py
thon предоставляет набор операций для работы с числовыми объектами:
Операторы выражений
+, *, >>, ** и другие.
Встроенные математические функции
pow, abs и другие.
Вспомогательные модули
random, math и другие.
По мере продвижения мы встретимся со всеми этими компонентами.
Наконец, если вам предстоит заниматься сложными математическими
вычислениями, вы можете использовать специализированное расши
рение NumPy (Numeric Python), которое обеспечивает расширенные
возможности при программировании математических вычислений, та
кие как матричный тип, обработка векторов и библиотеки для выпол
нения сложнейших математических вычислений. Группы программи
рования научных вычислений в таких организациях, как Lawrence
Livermore и NASA, используют Python с расширением NumPy для
реализации разнообразных задач, которые раньше решались с помо
щью языков C++, FORTRAN или Matlab.
Изза высокой сложности NumPy мы больше не будем говорить об этом
расширении в данной книге. Дополнительные средства поддержки ма
тематических вычислений в языке Python вы найдете на сайте Vaults
of Parnassus или выполнив поиск в Сети. Следует также заметить, что
в настоящее время расширение NumPy является дополнительным –
оно не входит в состав пакета Python и его необходимо устанавливать
отдельно.
В Python 3.0 типы целых чисел и длинных целых будут унифици
рованы. Таким образом, интерпретатор будет поддерживать един
ственный целочисленный тип – тип int. Он будет поддерживать
неограниченную точность представления, как это сейчас реализо
вано в длинных целых числах. В связи с этим большинство про
граммистов заметят лишь незначительные изменения или вооб
ще ничего не заметят. Дополнительную информацию вы найдете
в примечаниях к выпуску Python 3.0.
Операторы выражений
Пожалуй, самой фундаментальной возможностью обработки чисел яв
ляются выражения: комбинации чисел (или других объектов) и опера
торов, которые возвращают значения при выполнении интерпретатором
Python. Выражения в языке Python записываются с использованием
обычной математической нотации и символов операторов. Например,
146 Глава 5. Числа
сложение двух чисел X и Y производится с помощью выражения X + Y,
которое предписывает интерпретатору Python применить оператор +
к значениям с именами X и Y. Результатом выражения X + Y будет дру
гой числовой объект.
В табл. 5.2 приводится перечень всех операторов, имеющихся в языке
Python. Многие из них достаточно понятны сами по себе, например
обычные математические операторы (+, , *, / и т. д.). Некоторые будут
знакомы тем, кто в прошлом использовал язык C: оператор % вычисля
ет остаток от деления, оператор << производит побитовый сдвиг влево,
оператор & выполняет побитовую операцию и т. д. Другие операторы
более характерны для языка Python, и не все имеют математическую
природу. Например, оператор is проверяет идентичность объектов
(это более строгая форма проверки на равенство), оператор lambda соз
дает неименованные функции и т. д. О большинстве из этих операто
ров мы еще будем говорить более подробно.
Таблица 5.2. Операторы выражений в языке Python и правила
определения старшинства
Операторы Описание
yield x Генератор протокола передачи функции (по
явился в версии 2.5)
lambda args: expression Создает анонимную функцию
x if y else z Трехместный оператор выбора (появился в вер
сии 2.5)
x or y Логическая операция ИЛИ (значение y вычис
ляется, только если значение x ложно)
x and y Логический оператор И (значение y вычисляет
ся, только если значение x истинно)
not x Логическое отрицание
x < y, x <= y, x > y,
x > = y, x == y, x <> y,
x != y, x is y, x is not y,
x in y, x not in y
Операторы сравнения, операторы равенстваa,
операторы проверки идентичности объектов,
операторы проверки вхождения в последова
тельность
a В версии Python 2.5 неравенство значений можно проверить двумя способа
ми, как X != Y или как X <> Y. В Python 3.0 последний вариант будет убран, как
избыточный – используйте выражение X != Y для проверки на неравенство.
x | y Битовая операция ИЛИ
x ^ y Битовая операция «исключающее ИЛИ» (XOR)
x & y Битовая операция И
x << y, x >> y Сдвиг значения x влево или вправо на y битов
x + y, x – y Сложение/конкатенация, вычитание
Операторы выражений 147
Смешанные операторы и определение
старшинства операторов
Как и в большинстве других языков программирования, в языке Py
thon можно создавать сложные выражения, объединяя несколько опе
раторов из табл. 5.2 в одной инструкции. Например, вычисление сум
мы двух произведений можно записать следующим образом:
A * B + C * D
Как в этом случае интерпретатор узнает, какие операторы должны вы
полняться в первую очередь? Ответ на этот вопрос заключается в стар+
шинстве операторов. Когда интерпретатор Python встречает выраже
ние, содержащее более одного оператора, он делит его на отдельные
части в соответствии с правилами старшинства и определяет поря
док вычисления этих частей выражения. В табл. 5.2 чем выше при
оритет оператора, тем ниже он находится в таблице и тем раньше он
выполняется в смешанных выражениях.
Например, если вы запишете выражение X + Y * Z, интерпретатор Py
thon сначала выполнит умножение (Y * Z), а затем прибавит результат
к значению X, потому что оператор * имеет более высокий приоритет
(в табл. 5.2 он находится ниже), чем оператор +. Точно так же в первом
примере этого раздела сначала будут найдены произведения (A * B и C * D),
а затем будет выполнено сложение.
Операторы Описание
x * y, x % y, x / y, x // y Умножение/повторение, остаток/формат, де
лениеa
x, +x, ~x, x ** y Унарный знак «минус», тождественность, би
товое дополнение, возведение в степень
x[i], x[i:j], x.attr, x(...) Индексация, извлечение среза, уточнение
имени, вызов функции
(...), [...], {...}, `...` Кортеж, списокb, словарь, преобразование
в строкуc
a Операция деления с округлением вниз (X // Y), впервые появившаяся в Py
thon 2.2, всегда усекает дробную часть. Она будет описана в разделе «Деле
ние: классическое, с округлением вниз и истинное».
b Начиная с версии Python 2.0, с помощью синтаксиса списка ([...]) можно
определить либо литерал списка, либо генератор списков. Последняя фор
ма представления подразумевает выполнение цикла и сбор результатов
в виде нового списка.
c Преобразование объектов в соответствующие им строки для вывода на эк
ран также может быть выполнено с помощью более удобочитаемых функ
ций str и repr, которые будут описаны в разделе «Форматы отображения
чисел» ниже, в этой же главе. Изза неочевидности выражение `X` плани
руется исключить из Python 3.0, используйте вместо него repr(X).
148 Глава 5. Числа
Группировка подвыражений с помощью круглых скобок
Вы можете навсегда забыть о старшинстве операторов, если будете
группировать части выражений с помощью круглых скобок. Когда
часть выражения заключается в круглые скобки, они отменяют пра
вила старшинства операторов – Python всегда в первую очередь вычис
ляет подвыражения в круглых скобках, а затем использует их резуль
таты в объемлющем выражении.
Например, выражение X + Y * Z можно записать одним из следующих
способов, чтобы вынудить Python произвести вычисления в требуемом
порядке:
(X + Y) * Z
X + (Y * Z)
В первом случае сначала будет выполнено сложение значений X и Y, по
тому что это подвыражение заключено в круглые скобки. Во втором
случае первой будет выполнена операция умножения (точно так же,
как если бы скобки вообще отсутствовали). Вообще говоря, использо
вание круглых скобок в сложных выражениях можно только привет
ствовать – они не только определяют порядок выполнения вычисле
ний, но и повышают удобочитаемость.
Смешивание типов и их преобразование
Помимо смешивания операторов вы можете также смешивать различ
ные числовые типы. Например, вы хотите найти сумму целого числа
и числа с плавающей точкой:
40 + 3.14
Но это влечет за собой другой вопрос: какого типа будет результат –
целое число или число с плавающей точкой? Ответ прост, особенно для
тех, кто уже имеет опыт работы с любыми другими языками програм
мирования: в выражениях, где участвуют значения различных типов,
интерпретатор сначала выполняет преобразование типов операндов
к типу самого сложного операнда, а потом применяет математику,
специфичную для этого типа. Если вам уже приходилось использовать
язык C, вы найдете, что такое поведение соответствует порядку преоб
разования типов в этом языке.
Интерпретатор Python ранжирует сложность числовых типов следую
щим образом: целые числа проще, чем длинные целые числа, которые
проще чисел с плавающей точкой, которые в свою очередь проще ком
плексных чисел. Поэтому, когда в выражении участвуют целое число
и число с плавающей точкой, как в предыдущем примере, то целое
число сначала преобразуется в число с плавающей точкой и затем вы
полняется операция из математики чисел с плавающей точкой, что да
ет в результате число с плавающей точкой. Точно так же, когда один
из операндов в выражении является комплексным числом, другой
Операторы выражений 149
операнд преобразуется в комплексное число, и выражение дает в ре
зультате также комплексное число. Как будет показано далее в этом
разделе, начиная с версии 2.2, интерпретатор Python также автомати
чески преобразует целые числа в длинные целые, если их значения
оказываются слишком большими, чтобы уместиться в формат просто
го целого числа.
Существует возможность принудительного преобразования типов с по
мощью встроенных функций:
>>> int(3.1415)
3
>>> float(3)
3.0
>>> long(4)
4L
Однако в обычных ситуациях делать это не приходится, потому что
Python автоматически выполняет преобразование типов, и тип резуль
тата, как правило, соответствует вашим ожиданиям.
Кроме того, имейте в виду, что все эти преобразования производятся
только при смешивании числовых типов (то есть целых чисел и чисел с
плавающей точкой) в математических операциях или в операциях
сравнения. Вообще, Python не вовлекает в преобразование другие ти
пы. Например, попытка выполнить операцию сложения строки и чис
ла приведет к появлению ошибки, если вы вручную не выполните пре
образование типа одного из операндов – примеры таких преобразова
ний встретятся вам в главе 7, когда мы будем обсуждать строки.
Обзор: перегрузка операторов
Несмотря на то что сейчас в центре нашего внимания находятся встро
енные числа, вы должны знать, что в языке Python существует воз
можность выполнить (то есть реализовать) перегрузку любого операто
ра с помощью классов Python или расширений на языке C для работы
с создаваемыми объектами. Например, как будет показано позже, объ
екты, реализованные в виде классов, могут участвовать в операции
сложения, индексироваться с помощью выражения [i] и т. д.
Кроме того, Python сам автоматически перегружает некоторые опера
торы, чтобы с их помощью можно было выполнять различные дейст
вия, в зависимости от типа обрабатываемых встроенных объектов. На
пример, оператор + выполняет операцию сложения, когда применяет
ся к числам, но когда он применяется к последовательностям, таким
как строки или списки, он выполняет операцию конкатенации. В дей
ствительности оператор + может выполнять любые действия, когда
применяется к объектам, которые вы определяете с помощью классов.
Как было показано в предыдущей главе, эта особенность обычно назы
вается полиморфизмом; термин означает, что выполняемая операция
зависит от типов объектовоперандов, над которыми она выполняется.
150 Глава 5. Числа
Мы еще вернемся к этому понятию в главе 15, когда будем рассматри
вать функции, потому что в этом контексте суть полиморфизма стано
вится более очевидной.
Числа в действии
Самый лучший способ понять числа и выражения состоит в том, чтобы
увидеть их в действии. Давайте запустим интерактивный сеанс работы
с интерпретатором и попробуем выполнить некоторые простые, но
весьма показательные операции (если вы забыли, как запускается ин
терактивный сеанс, обращайтесь к главе 3).
Переменные и основные выражения
Прежде всего мы рассмотрим основные арифметические операции.
В следующем упражнении выполняется присваивание целочисленных
значений двум переменным (a и b), чтобы потом использовать их в более
сложных выражениях. Переменные – это всего лишь имена, создавае
мые в языке Python, которые используются для обозначения информа
ции, сохраняемой в программах. Об этом мы будем говорить более под
робно в следующей главе, а пока вы должны знать, что в языке Python:
• Переменные создаются при выполнении операции присваивания
значения.
• При вычислении выражений имена переменных замещаются их
значениями.
• Прежде чем переменная сможет участвовать в выражениях, ей
должно быть присвоено значение.
• Переменные именуют объекты и никогда не объявляются заранее.
Другими словами, следующие операции присваивания автоматически
приводят к созданию переменных a и b:
% python
>>> a = 3 # Создается имя
>>> b = 4
Здесь я также использовал комментарий. Вспомните, что в программ
ном коде на языке Python текст, следующий за символом #, считается
комментарием и игнорируется интерпретатором. Комментарии – это
один из способов описать программный код на удобном для воспри
ятия языке. Поскольку программный код, который пишется в ходе
интерактивного сеанса, является временным, вам не требуется писать
комментарии, я же буду добавлять их в примеры, чтобы объяснять ра
боту программного кода.1 В следующей части книги мы познакомимся
1 Если вы прогоняете примеры на практике, вам не нужно вводить коммен
тарии, потому что они просто игнорируются интерпретатором Python и не
являются необходимой частью инструкций, которые мы выполняем.
Числа в действии 151
с еще одной похожей особенностью – со строками описания, которые
включают текст комментариев в объекты.
А теперь попробуем использовать наши первые целочисленные объек
ты в выражениях. В настоящий момент переменные a и b все еще име
ют значения 3 и 4, соответственно. Когда переменные, подобные этим,
участвуют в выражении, они замещаются их значениями, и при рабо
те в интерактивном режиме результат вычисления выражения тут же
выводится на экран:
>>> a + 1, a 
 1 # Сложение (3 + 1), вычитание (3  1)
(4, 2)
>>> b * 3, b / 2 # Умножение (4 * 3), деление (4 / 2)
(12, 2)
>>> a % 2, b ** 2 # Деление по модулю (остаток), возведение в степень
(1, 16)
>>> 2 + 4.0, 2.0 ** b # Смешивание типов, выполняется преобразование
(6.0, 16.0)
С технической точки зрения результатами этих инструкций являются
кортежи, состоящие из двух значений, потому что вводимые строки со
держат по два выражения, разделенные запятыми. Именно по этой при
чине результаты отображаются в круглых скобках (подробнее о корте
жах будет рассказываться позднее). Следует заметить, что эти выраже
ния выполняются без ошибок потому, что ранее переменным a и b были
присвоены значения. Если использовать переменную, которой еще не
было присвоено значение, Python выведет сообщение об ошибке:
>>> c * 2
Traceback (most recent call last):
File "<stdin>", line 1, in ?
NameError: name 'c' is not defined
В языке Python от вас не требуется заранее объявлять переменные, но
прежде чем их можно будет использовать, им должны быть присвоены
некоторые значения. На практике это означает, что перед тем, как
к счетчикам можно будет прибавлять некоторые значения, их необхо
димо инициализировать нулевым значением; прежде чем к спискам
можно будет добавлять новые элементы, их необходимо инициализи
ровать пустыми списками, и т. д.
Ниже приводятся два немного более сложных выражения, чтобы про
иллюстрировать порядок выполнения операторов и производимые
преобразования:
>>> b / 2 + a # То же, что и ((4 / 2) + 3)
5
>>> print b / (2.0 + a) # То же, что и (4 / (2.0 + 3))
0.8
В первом выражении отсутствуют круглые скобки, поэтому интер
претатор Python автоматически группирует компоненты выражения
152 Глава 5. Числа
в соответствии с правилами определения старшинства – оператор / на
ходится ниже в табл. 5.2, чем оператор +, поэтому его приоритет счита
ется выше и он выполняется первым. Результат вычисляется так, как
если бы выражение включало скобки, как показано в комментарии.
Кроме того, обратите внимание на то, что в первом выражении все чис
ла являются целыми, поэтому интерпретатор выполняет целочислен
ные операции деления и сложения.
Во втором выражении круглые скобки окружают операцию сложения,
чтобы вынудить интерпретатор выполнить ее в первую очередь (то есть
перед оператором /). Кроме того, один из операндов является числом
с плавающей точкой, т. к. в нем присутствует десятичная точка: 2.0.
Вследствие такого смешения типов перед выполнением операции сло
жения Python преобразует целое число, на которое ссылается имя a,
в число с плавающей точкой (3.0). Кроме того, он также преобразует
значение переменной b в число с плавающей точкой (4.0) и выполняет
вещественное деление (4.0 / 5.0), что в результате также дает число
с плавающей точкой 0.8. Если бы в этом выражении участвовали толь
ко целые числа, была бы выполнена операция целочисленного деления
(4 / 5) и результат был бы усечен до нуля (по крайней мере, в Python 2.5;
смотрите обсуждение истинного деления, которое следует далее).
Форматы отображения чисел
Обратите внимание: в последнем примере была использована инструк
ция print. Без этой инструкции результат мог бы показаться немного
странным:
>>> b / (2.0 + a) # Автоматический вывод: выводится большее число цифр
0.80000000000000004
>>> print b / (2.0 + a) # Инструкция print отбрасывает лишние цифры
0.8
Причина появления такого, немного странного, результата кроется
в ограничениях аппаратных средств, реализующих вещественную ма
тематику, и в невозможности обеспечить точное представление неко
торых значений. Обсуждение аппаратной архитектуры компьютера
выходит далеко за рамки этой книги, тем не менее я замечу, что все
цифры в первом результате действительно присутствуют в аппаратной
части компьютера, выполняющей операции над числами с плавающей
точкой, просто вы не привыкли видеть их. Я использовал этот пример,
чтобы продемонстрировать различия в форматах отображения чисел –
при автоматическом выводе результатов в ходе интерактивного сеанса
отображается больше цифр, чем при использовании инструкции print.
Однако надо заметить, что не всегда значения отображаются с таким
большим числом цифр:
>>> 1 / 2.0
0.5
Числа в действии 153
и что кроме применения инструкции print и автоматического вывода
результатов существуют и другие способы отображения чисел:
>>> num = 1 / 3.0
>>> num # Автоматический вывод
0.33333333333333331
>>> print num # Инструкция print выполняет округление
0.333333333333
>>> "%e" % num # Вывод с использованием строки форматирования
'3.333333e001'
>>> "%2.2f" % num # Вывод с использованием строки форматирования
'0.33'
В последних двух случаях была использована строка форматирова+
ния результата выражения, которая позволяет гибко определять фор
мат представления, но об этом мы поговорим в главе 7, когда займемся
исследованием строк.
Деление: классическое, с округлением вниз и истинное
Теперь, когда вы увидели, как работает операция деления, вы должны
знать, что она претерпит небольшие изменения в будущей версии Py
thon (версия 3.0, которая должна появиться после выпуска этого изда
ния книги). В Python 2.5 она работает так, как только что было описа
но, но фактически существуют два оператора деления (один из кото
рых претерпит изменения):
Форматы представления repr и str
C технической точки зрения различия между функцией автома
тического вывода в интерактивной оболочке и инструкцией
print заключаются в различиях между встроенными функциями
repr и str:
>>> repr(num) # Используется для автоматического вывода:
# в форме как есть
'0.33333333333333331'
>>> str(num) # Используется инструкцией print: дружественная форма
'0.333333333333'
Обе функции преобразуют произвольные объекты в их строковое
представление: repr (и функция автоматического вывода в инте
рактивной оболочке) выводит результаты в том виде, в каком
они были получены; str (и инструкция print) обычно выполняет
преобразование значения в более дружественное представление.
Мы еще будем говорить об этом при обсуждении строк далее
в книге, где вы найдете больше информации об этих встроенных
функциях.
154 Глава 5. Числа
X / Y
Классическое деление. В Python 2.5 и в более ранних версиях ре
зультат усекается при делении целых чисел и сохраняется дробная
часть для чисел с плавающей точкой. Этот оператор станет операто
ром истинного деления – в будущей версии Python 3.0 он будет все
гда сохранять дробную часть, независимо от типов операндов.
X // Y
Деление с округлением вниз. Этот оператор впервые появился в Py
thon 2.2. Он всегда отсекает дробную часть, округляя результат до
ближайшего наименьшего целого, независимо от типов операндов.
Деление с округлением вниз было добавлено по той причине, что в те
кущей модели классического деления тип результата зависит от типов
операндов, который трудно предсказать заранее в языках программи
рования с динамической типизацией, таких как Python.
Изза возможных проблем с обратной совместимостью операция деле
ния в языке Python в настоящее время находится в состоянии постоян
ного изменения. Подытоживая вышесказанное: в версии 2.5 оператор
деления / по умолчанию работает, как было описано выше, а оператор
деления с округлением вниз // может использоваться для округления
результата деления до ближайшего наименьшего целого, независимо
от типов операндов:
>>> (5 / 2), (5 / 2.0), (5 / 
2.0), (5 / 
2)
(2, 2.5, 2.5, 3)
>>> (5 // 2), (5 // 2.0), (5 // 
2.0), (5 // 
2)
(2, 2.0, 3.0, 3)
>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0)
(3, 3.0, 3, 3.0)
В будущей версии Python оператор / изменится так, что будет возвра
щать истинный результат деления, который всегда будет содержать
дробную часть, даже в случае деления целых чисел, например, резуль
татом выражения 1 / 2 будет значение 0.5, а не 0, в то время как резуль
татом выражения 1 // 2 будет значение 0.
А сейчас, пока эти изменения еще не включены полностью, ознако
миться с будущим принципом действия оператора / можно при исполь
зовании специальной формы импорта: from __future__ import division.
В этом случае оператор / превращается в оператор истинного деления
(с сохранением дробной части в результате), а принцип действия опера
тора // остается неизменным. Ниже показано, как эти операторы будут
действовать в будущем:
>>> from _ _future_ _ import division
>>> (5 / 2), (5 / 2.0), (5 / 
2.0), (5 / 
2)
(2.5, 2.5, 2.5, 2.5)
Числа в действии 155
>>> (5 // 2), (5 // 2.0), (5 // 
2.0), (5 // 
2)
(2, 2.0, 3.0, 3)
>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0)
(3.0, 3.0, 3, 3.0)
Рассмотрите простой пример цикла while в главе 13 и соответствующее
упражнение в конце четвертой части книги, которые иллюстрируют
программный код, на котором может сказаться это изменение в пове
дении оператора /. Вообще, воздействию этого изменения может быть
подвержен любой программный код, который подразумевает усечение
дробной части в целочисленном результате (в этих случаях вместо него
следует использовать оператор //). К моменту написания этих строк
данное изменение планируется включить в версию Python 3.0, но вам
обязательно следует опробовать эти выражения в своей версии интер
претатора, чтобы увидеть, как этот оператор действует. Кроме того, за
помните специальную команду from, использованную здесь, – она еще
будет обсуждаться в главе 21.
Битовые операции
Помимо обычных числовых операций (сложение, вычитание и т. д.)
язык Python поддерживает большую часть видов числовых выраже
ний, доступных в языке C. Например, ниже приводится пример вы
полнения операций поразрядного сдвига и логических операций:
>>> x = 1 # 0001
>>> x << 2 # Сдвиг влево на 2 бита: 0100
4
>>> x | 2 # Побитовое ИЛИ: 0011
3
>>> x & 1 # Побитовое И: 0001
1
В первом выражении двоичное значение 1 (по основанию 2, 0001) сдви
гается влево на две позиции, в результате получается число 4 (0100).
В последних двух выражениях выполняются двоичная операция ИЛИ
(0001|0010 = 0011) и двоичная операция И (0001&0001 = 0001). Такого рода
операции позволяют хранить сразу несколько флагов и других значе
ний в единственном целом числе.
Мы не будем здесь слишком углубляться в «жонглирование битами».
Вам пока достаточно знать, что битовые операции поддерживаются
языком, и они могут пригодиться, когда вы будете иметь дело, напри
мер, с сетевыми пакетами или упакованными двоичными данными, ко
торые производятся программами на языке C. Тем не менее вы должны
понимать, что в языках высокого уровня, таких как Python, битовые
операции не имеют такого большого значения, как в низкоуровневых
языках, подобных языку C. Как правило, если у вас возникает желание
использовать битовые операции в программах на языке Python, вам не
обходимо вспомнить, на каком языке вы программируете. В Python
156 Глава 5. Числа
имеются гораздо лучшие способы представления информации, чем по
следовательности битов.
Длинные целые
Теперь добавим немного экзотики и посмотрим на длинные целые в дей
ствии. Когда целочисленный литерал завершается символом L (или l),
интерпретатор создает длинное целое число. В Python длинные целые
могут иметь произвольную величину. То есть такое число может со
держать такое число цифр, на которое хватит памяти в компьютере:
>>> 9999999999999999999999999999999999999L + 1
10000000000000000000000000000000000000L
Символ L в конце литерала предписывает интерпретатору Python соз
дать объект длинного целого числа, способный представлять число
с произвольной точностью. В действительности, начиная с версии Py
thon 2.2, даже символ L в конце литерала можно не указывать. Интер
претатор автоматически преобразует обычное целое число в длинное
целое, если его значение превысит величину, которая может быть
представлена обычным целым числом (с технической точки зрения –
когда число превысит величину, которую способно вместить 32бито
вое целое число). То есть вам не требуется указывать символ L, так как
Python автоматически выполнит необходимые преобразования, когда
в этом возникнет потребность:
>>> 9999999999999999999999999999999999999 + 1
10000000000000000000000000000000000000L
Длинные целые – это достаточно удобный инструмент. Например, с их
помощью можно представить национальный бюджет в копейках (если
вам это интересно и в вашем компьютере имеется достаточный объем
памяти). Именно по этой причине нам удалось в примерах из главы 3
вычислить такую большую степень числа 2:
>>> 2L ** 200
1606938044258990275541962092341162602522202993782792835301376L
>>>
>>> 2 ** 200
1606938044258990275541962092341162602522202993782792835301376L
Так как интерпретатору приходится производить дополнительные
действия, чтобы обеспечить поддержку высокой точности, математи
ческие операции с участием длинных целых чисел обычно выполня
ются существенно медленнее, чем операции с обычными целыми чис
лами (которые, как правило, выполняются непосредственно аппарат
ными средствами). Однако, если важна высокая точность, то фактор
низкой производительности уходит на задний план.
Числа в действии 157
Комплексные числа
Комплексные числа – это особый базовый тип данных в Python. Если
вы знаете о существовании комплексных чисел, вы должны знать, ко
гда они используются. В противном случае этот раздел можно пропус
тить. Комплексные числа состоят из двух чисел с плавающей точкой,
представляющих вещественную и мнимую части, и в тексте програм
мы отличаются наличием суффикса J, или j, после мнимой части. Ес
ли вещественная часть не равна нулю, комплексное число записывает
ся как сумма двух частей, с помощью символа +. Например, комплекс
ное число, вещественная часть которого равна 2, а мнимая часть 3, за
писывается как 2 + 3j.Ниже приводятся примеры некоторых действий
над комплексными числами:
>>> 1j * 1J
(1+0j)
>>> 2 + 1j * 3
(2+3j)
>>> (2 + 1j) * 3
(6+3j)
Кроме того, комплексные числа позволяют обращаться к своим час
тям, как к атрибутам, поддерживают все обычные математические опе
рации и могут обрабатываться с помощью стандартного модуля cmath
(версия модуля math, предназначенная для работы с комплексными
числами). Комплексные числа обычно используются в инженерных
программах. Поскольку это инструмент повышенной сложности, ищи
те подробности в справочном руководстве к языку Python.
Шестнадцатеричная и восьмеричная формы записи чисел
Как уже говорилось ранее, целые числа в языке Python могут записы
ваться в шестнадцатеричной (по основанию 16) и восьмеричной (по ос
нованию 8) форме:
• Восьмеричные литералы должны начинаться с символа 0, вслед за
которым следует последовательность восьмеричных цифр 07, каж
дая из которых представляет три бита.
• Шестнадцатеричные литералы должны начинаться с комбинации
символов 0x или 0X, вслед за которой следует последовательность
шестнадцатеричных цифр 09 и AF (в верхнем или в нижнем реги
стре), каждая из которых представляет четыре бита.
Имейте в виду, что это всего лишь альтернативный синтаксис задания
значений целочисленных объектов. Например, следующие восьмерич
ные и шестнадцатеричные литералы создают обычные целые числа с за
данными значениями:
>>> 01, 010, 0100 # Восьмеричные литералы
(1, 8, 64)
158 Глава 5. Числа
>>> 0x01, 0x10, 0xFF # Шестнадцатеричные литералы
(1, 16, 255)
Здесь восьмеричное значение 0100 соответствует десятичному значе
нию 64, а шестнадцатеричное 0xFF – десятичному 255. По умолчанию
интерпретатор Python выводит числа в десятичной системе счисления
(по основанию 10), но предоставляет встроенные функции, которые
позволяют преобразовывать целые числа в последовательности вось
меричных и шестнадцатеричных цифр:
>>> oct(64), hex(64), hex(255)
('0100', '0x40', '0xff')
Функция oct выводит целое число в восьмеричном представлении,
а функция hex – в шестнадцатеричном. Кроме того, существует воз
можность обратного преобразования – встроенная функция int, кото
рая преобразует строку цифр в целое число. Во втором необязательном
аргументе она может принимать основание системы счисления:
>>> int('0100'), int('0100', 8), int('0x40', 16)
(100, 64, 64)
Функция eval, с которой мы встретимся далее в этой книге, интерпре
тирует строку во входном аргументе, как программный код на языке
Python. Поэтому она имеет похожий эффект (хотя обычно она работает
заметно медленнее, потому что ей приходится компилировать и вы
полнять строку как часть программы, а это предполагает, что вы долж
ны иметь безграничное доверие к источнику запускаемой строки – дос
таточно грамотный пользователь мог бы подсунуть вашей программе
строку, которая при выполнении в функции eval удалит все файлы на
вашем компьютере!):
>>> eval('100'), eval('0100'), eval('0x40')
(100, 64, 64)
Наконец, целые числа могут быть преобразованы в восьмеричное и ше
стнадцатеричное представления с помощью строки выражения форма
тирования:
>>> "%o %x %X" % (64, 64, 255)
'100 40 FF'
Строки форматирования будут рассматриваться в главе 7.
Прежде чем двинуться дальше, считаю своим долгом предупредить
вас: будьте осторожны при использовании ведущего нуля в языке Py
thon, если вы не предполагаете использование восьмеричных литера
лов. Интерпретатор Python будет воспринимать их как числа в восьме
ричной системе счисления, что может не соответствовать вашим ожи
даниям – число 010 всегда соответствует десятичному числу 8, а не де
сятичному 10 (независимо от того, что вы имели в виду!).
Числа в действии 159
Другие встроенные средства для работы с числами
В дополнение к этим базовым типам объектов Python предоставляет
встроенные функции и модули для работы с числами. Встроенные функ
ции int и round, например, усекают и округляют числа с плавающей точ
кой, соответственно. В следующем примере демонстрируется использо
вание модуля math (который содержит реализацию множества функций
из библиотеки math языка C) и нескольких встроенных функций:
>>> import math
>>> math.pi, math.e # Распространенные константы
(3.1415926535897931, 2.7182818284590451)
>>> math.sin(2 * math.pi / 180) # Синус, тангенс, косинус
0.034899496702500969
>>> math.sqrt(144), math.sqrt(2) # Квадратный корень
(12.0, 1.4142135623730951)
>>> abs(
42), 2**4, pow(2, 4)
(42, 16, 16)
>>> int(2.567), round(2.567), round(2.567, 2) # Усечение, округление
(2, 3.0, 2.5699999999999998)
Как уже указывалось ранее, если в последнем случае использовать ин
струкцию print, мы получим результат (2, 3.0, 2.57).
Обратите внимание, что встроенные модули, такие как math, необходи
мо импортировать, а встроенные функции, такие как abs, доступны все
гда, без выполнения операции импорта. Говоря другими словами, моду
ли – это внешние компоненты, а встроенные функции постоянно распо
лагаются в пространстве имен, которое используется интерпретатором
Python по умолчанию для поиска имен, используемых программой. Это
пространство имен соответствует модулю с именем __builtin__. В чет
вертой части книги мы подробнее поговорим о разрешении имен, а по
ка всякий раз, когда слышите слово «модуль», думайте: «импорт».
Модуль random из стандартной библиотеки также необходимо импорти
ровать. Этот модуль предоставляет возможность получения случай
ных чисел с плавающей точкой в диапазоне от 0 до 1, случайных це
лых чисел в заданном диапазоне, случайного выбора элементов после
довательности и многое другое:
>>> import random
>>> random.random()
0.49741978338014803
>>> random.random()
0.49354866439625611
>>> random.randint(1, 10)
5
>>> random.randint(1, 10)
4
160 Глава 5. Числа
>>> random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life'])
'Life of Brian'
>>> random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life'])
'Holy Grail'
Модуль random может использоваться, например, для перемешивания
колоды карт в игре, случайного выбора изображения в программе де
монстрации слайдов, в программах статистического моделирования
и т. д. За дополнительной информацией обращайтесь к руководству по
стандартной библиотеке языка Python.
Другие числовые типы
В этой главе мы рассматривали базовые числовые типы языка Python –
целые числа, длинные целые, числа с плавающей точкой и комплекс
ные числа. Их вполне достаточно для решения математических задач,
с которыми придется столкнуться большинству программистов. Одна
ко язык Python содержит несколько более экзотических числовых ти
пов, которые заслуживают того, чтобы коротко познакомиться с ними.
Числа с фиксированной точностью
В версии Python 2.4 появился новый базовый числовой тип: числа
с фиксированной точностью представления. Синтаксически такие
числа создаются вызовом функции из импортируемого модуля и не
имеют литерального представления. Функционально числа с фикси
рованной точностью напоминают числа с плавающей точкой, с фикси
рованным числом знаков после запятой, отсюда и название «числа
с фиксированной точностью». Например, с помощью таких чисел мож
но хранить значение, которое всегда будет иметь два знака после запя
той. Кроме того, можно указать, как должны обрабатываться лишние
десятичные цифры – усекаться или округляться. И хотя скорость ра
боты с такими числами несколько ниже, чем с обычными числами
с плавающей точкой, тем не менее тип чисел с фиксированной точно
стью идеально подходит для представления величин, имеющих фик
сированную точность, таких как денежные суммы, и для достижения
лучшей точности представления.
Точность при работе с обычными вещественными числами несколько
ниже. Например, результат следующего выражения должен быть ра
вен нулю, но изза недостаточного числа битов в представлении веще
ственных чисел страдает точность вычислений:
>>> 0.1 + 0.1 + 0.1 
 0.3
5.5511151231257827e017
Попытка вывести результат в более дружественной форме мало помо
гает, потому что проблема связана с ограниченной точностью пред
ставления вещественных чисел:
Другие числовые типы 161
>>> print 0.1 + 0.1 + 0.1 
 0.3
5.55111512313e017
Однако при использовании чисел с фиксированной точностью резуль
тат получается точным:
>>> from decimal import Decimal
>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') 
 Decimal('0.3')
Decimal("0.0")
Как показано в этом примере, числа с фиксированной точностью пред
ставления создаются вызовом функции конструктора Decimal из модуля
decimal, которому передается строка, содержащая желаемое число зна
ков после запятой. Когда в выражении участвуют числа с различной
точностью представления, Python автоматически выбирает наиболь
шую точность для представления результата:
>>> Decimal('0.1') + Decimal('0.10') + Decimal('0.10') 
 Decimal('0.30')
Decimal("0.00")
Другие инструменты модуля decimal позволяют задать точность пред
ставления всех таких чисел и многое другое. Например, объект context
из этого модуля позволяет задавать точность (число знаков после запя
той) и режим округления (вниз, вверх и т. д.):
>>> decimal.Decimal(1) / decimal.Decimal(7)
Decimal("0.1428571428571428571428571429")
>>> decimal.getcontext( ).prec = 4
>>> decimal.Decimal(1) / decimal.Decimal(7)
Decimal("0.1429")
Поскольку тип чисел с фиксированной точностью достаточно редко
используется на практике, за дополнительными подробностями я от
сылаю вас к руководствам по стандартной библиотеке Python.
Множества
В версии Python 2.4 также появился новый тип коллекций – множест+
во. Поскольку этот тип является коллекцией других объектов, возмож
но, его обсуждение выходит за рамки этой главы. Но так как он поддер
живает набор математических операций, мы познакомимся с основами
его использования. Чтобы создать объектмножество, нужно передать
последовательность или другой объект, поддерживающий возмож
ность итераций по его содержимому, встроенной функции set (похо
жая функция существовала в Python до версии 2.4 во внешнем модуле,
но начиная с версии Python 2.4 эта функция стала встроенной):
>>> x = set('abcde')
>>> y = set('bdxyz')
Обратно функция возвращает объект множества, который содержит все
элементы объекта, переданного функции (примечательно, что множест
162 Глава 5. Числа
ва не предусматривают возможность определения позиций элементов,
а кроме того, они не являются последовательностями):
>>> x
set(['a', 'c', 'b', 'e', 'd'])
Множества, созданные таким способом, поддерживают обычные мате
матические операции над множествами посредством операторов. Об
ратите внимание: эти операции не могут выполняться над простыми
последовательностями – чтобы использовать их, нам требуется соз
дать из них множества:
>>> 'e' in x # Проверка вхождения в множество
True
>>> x – y # Разница множеств
set(['a', 'c', 'e'])
>>> x | y # Объединение множеств
set(['a', 'c', 'b', 'e', 'd', 'y', 'x', 'z'])
>>> x & y # Пересечение множеств
set(['b', 'd'])
Такие операции удобны при работе с большими множествами данных –
пересечение двух множеств содержит объекты, которые присутствуют
в обоих множествах, а объединение содержит все объекты из обоих
множеств. Ниже приводится более реальный пример применения опе
раций над множествами – при работе со списками служащих гипоте
тической компании:
>>> engineers = set(['bob', 'sue', 'ann', 'vic'])
>>> managers = set(['tom', 'sue'])
>>>
>>> engineers & managers # Кто является и инженером, и менеджером одновременно?
set(['sue'])
>>>
>>> engineers | managers # Все, кто принадлежит к той или иной категории
set(['vic', 'sue', 'tom', 'bob', 'ann'])
>>>
>>> engineers – managers # Инженеры, которые не являются менеджерами
set(['vic', 'bob', 'ann'])
Кроме того, объект множества предоставляет метод, который реализу
ет более экзотический набор операций. Хотя операции над множества
ми в языке Python можно реализовать вручную (часто так и делалось
в прошлом), встроенные операции над множествами обеспечивают вы
сокую скорость выполнения стандартных операций, опираясь на эф
фективные алгоритмы и приемы реализации.
За дополнительной информацией по множествам обращайтесь к руко
водству по стандартной библиотеке языка Python.
Другие числовые типы 163
В версии Python 3.0 предлагается форма записи литералов {1, 2,
3}, которая дает тот же эффект, который имеет вызов функции
set([1, 2, 3]) и тем самым предоставляет еще один способ созда
ния объекта множества. Однако это – будущее расширение язы
ка, поэтому за более подробной информацией обращайтесь к при
мечаниям к выпуску 3.0.
Логические значения
Иногда утверждается, что логический тип bool в языке Python по своей
природе является числовым, потому что два его значения True и False –
это всего лишь целые числа 1 и 0, вывод которых настроен особым об
разом. Хотя этих сведений вполне достаточно для большинства про
граммистов, тем не менее я предлагаю исследовать этот тип немного
подробнее.
В версии Python 2.3 появился новый логический тип с именем bool,
доступный в виде двух новых встроенных предопределенных имен
True и False, которые в свою очередь являются всего лишь подклассом
(в объектноориентированном смысле) встроенного целочисленного
типа int. True и False ведут себя точно так же, как и целые числа 1 и 0,
за исключением того, что для их вывода на экран используется другая
логика – они выводятся как слова True и False, вместо цифр 1 и 0 (тех
нически, класс bool переопределяет функции str и repr).
В соответствии с интерпретацией этих значений, начиная с версии Py
thon 2.3, значения выражений логического типа выводятся как слова
True и False, а не как числа 1 и 0. Можно считать, что логический тип
делает истинные значения более явными. Например, теперь бесконеч
ный цикл можно оформить как while True:, а не как менее очевидный
while 1:. Точно так же более понятной становится инициализация фла
гов, например flag = False.
Во всех остальных практических применениях значения True и False
можно интерпретировать, как предопределенные переменные с цело
численными значениями 1 и 0. В любом случае раньше большинство
программистов создавали переменные True и False, которым присваива
ли значения 1 и 0, таким образом данный новый тип просто следует это
му стандартному приему. Его реализация может приводить к неожи
данным результатам: так как True – это всего лишь целое значение 1,
которое выводится на экран особым образом, выражение True + 3 даст
в языке Python результат 4!
Мы еще вернемся к логическому типу в главе 9 (где будет дано опреде
ление истины в языке Python) и в главе 12 (где познакомимся с такими
логическими операторами, как and и or).
164 Глава 5. Числа
Расширения сторонних разработчиков
Помимо встроенных числовых типов собственно языка Python вы мо
жете встретить различные свободно распространяемые расширения
сторонних разработчиков, реализующие еще более экзотические чи
словые типы. К таким типам можно отнести рациональные числа, век
торы и матрицы. Модули, реализующие эти типы, можно загрузить из
Сети, там же вы найдете более подробную информацию о них.
В заключение
В этой главе были рассмотрены типы числовых объектов языка Python
и операции, применяемые к ним. Здесь мы познакомились со стан
дартными целочисленными типами и с числами с плавающей точкой,
а также с некоторыми экзотическими, нечасто используемыми типа
ми, такими как комплексные числа и числа с фиксированной точно
стью. Мы также исследовали синтаксис выражений в языке Python,
порядок преобразования типов, битовые операции и различные лите
ральные формы представления чисел в сценариях.
Далее, в этой же части книги, мы рассмотрим следующий тип объек
тов – строки. Однако в следующей главе мы потратим некоторое время
на более подробное ознакомление с механизмом операции присваива
ния значений переменным. Это, пожалуй, самая фундаментальная идея
в языке Python, поэтому вам обязательно нужно прочитать следую
щую главу. Но перед этим ответьте на контрольные вопросы главы.
Закрепление пройденного
Контрольные вопросы
1. Каким будет значение выражения 2 * (3 + 4) в языке Python?
2. Каким будет значение выражения 2 * 3 + 4 в языке Python?
3. Каким будет значение выражения 2 + 3 * 4 в языке Python?
4. Какие функции можно использовать для вычисления квадратного
корня числа и квадрата?
5. Какой тип будет иметь результат следующего выражения: 1 + 2.0 +3?
6. Каким образом можно выполнить усечение и округление числа
с плавающей точкой?
7. Как им образом можно преобразовать целое число в число с плаваю
щей точкой?
8. Каким образом можно вывести целое число в восьмеричном и шест
надцатеричном представлениях?
9. Каким образом можно преобразовать строковое представление вось
меричного или шестнадцатеричного числа в простое целое число?
Закрепление пройденного 165
Ответы
1. Результатом выражения будет число 14, то есть результат произве
дения 2 * 7, потому что круглые скобки предписывают выполнить
операцию сложения до операции умножения.
2. В данном случае результат будет равен 10, то есть результат выра
жения 6 + 4. При отсутствии круглых скобок в языке Python ис
пользуются правила старшинства операторов, согласно которым
оператор умножения имеет более высокий приоритет, чем оператор
сложения (стоящий левее).
3. Данное выражение даст в результате число 14, то есть результат вы
ражения 2 + 12, согласно тем же правилам старшинства, что и в пре
дыдущем вопросе.
4. Функции вычисления квадратного корня, а также числа пи, тан
генса и многие другие доступны в импортируемом модуле math. Что
бы найти квадратный корень числа, необходимо импортировать мо
дуль math и вызвать функцию math.sqrt(N). Чтобы найти квадрат
числа, можно воспользоваться либо оператором возведения в сте
пень X ** 2, либо встроенной функцией pow(X, 2).
5. Результатом будет число с плавающей точкой: целые числа будут
преобразованы в числа с плавающей точкой, как к наиболее слож
ному числовому типу в выражении, и для вычисления результата
будет использоваться математика вещественных чисел.
6. Функция int(N) выполняет отсечение дробной части, а функция
round(N, digits?) выполняет округление.
7. Функция float(N) выполняет преобразование целых чисел в числа
с плавающей точкой. Смешивание целых чисел и чисел с плаваю
щей точкой в одном выражении также приводит к выполнению
преобразования.
8. Встроенные функции oct(I) и hex(I) возвращают строковые пред
ставления целых чисел в восьмеричном и в шестнадцатеричном фор
матах. Для этих же целей может использоваться строка формата %.
9. Для преобразования строковых представлений восьмеричных и ше
стнадцатеричных чисел в обычные целые числа может использо
ваться функция int(S, base?). Для этих целей может также исполь
зоваться функция eval(S), но она более медленная и может стать ис
точником проблем, связанных с безопасностью. Обратите внима
ние: целые числа в памяти компьютера всегда хранятся в двоичном
формате, для вывода которых просто используются разные форма
ты представления.
6
Интерлюдия о динамической типизации
В предыдущей главе мы приступили к детальному исследованию базо
вых типов объектов в языке Python, начав с чисел. Мы продолжим на
ши исследования типов в следующей главе, но прежде чем продол
жить, вам необходимо разобраться в самой фундаментальной, на мой
взгляд, идее программирования на языке Python, которая составляет
основу гибкости языка – динамической типизации и полиморфизме.
Как будет показано в этой главе и далее в книге, в сценариях на языке
Python не производится объявление объектов определенных типов.
В действительности нам даже не приходится беспокоиться о конкрет
ных типах; более того, они могут применяться в более широком диапа
зоне ситуаций, чем можно было предусмотреть заранее. Поскольку ди
намическая типизация составляет основу этой гибкости, давайте ко
ротко ознакомимся с этой моделью.
Отсутствие инструкций объявления
Если у вас имеется опыт работы с компилирующими языками или
с языками, обладающими статической типизацией, такими как C,
C++ или Java, вероятно, эта тема в книге вызывает у вас недоумение.
Мы все время использовали переменные, не объявляя ни их самих, ни
их типы, и все както работало. Например, когда вводится инструкция
a = 3 в интерактивной оболочке интерпретатора или в файле сценария,
как интерпретатор Python узнает, что речь идет о целом числе? И вооб
ще, как Python узнает, что есть что?
Как только вы начинаете задавать такие вопросы, вы попадаете в сфе
ру действия модели динамической типизации, используемой в языке
Python. В языке Python типы определяются автоматически, во время
выполнения, а не в результате объявлений в программном коде. Это
Отсутствие инструкций объявления 167
означает, что вам не требуется заранее объявлять переменные (эту кон
цепцию проще понять, если иметь в виду, что все сводится к перемен
ным, объектам и ссылкам между ними).
Переменные, объекты и ссылки
Как было видно из примеров, приводившихся до сих пор в книге, ко
гда запускается операция присваивания, такая как a = 3, интерпрета
тор выполняет ее, хотя перед этим ему нигде не сообщалось, что a – это
имя переменной, или что она представляет объект целочисленного ти
па. В языке Python все это решается весьма естественным способом,
как описано ниже:
Создание переменной
Переменная (то есть имя), такая как a, создается автоматически,
когда в программном коде ей впервые присваивается некоторое
значение. Все последующие операции присваивания просто изме
няют значение, ассоциированное с уже созданным именем. Строго
говоря, интерпретатор Python определяет некоторые имена до за
пуска программного кода, но вполне допустимо думать, что пере
менные создаются первой операцией присваивания.
Типы переменных
Переменные не имеют никакой информации о типе или ограниче
ниях, связанных с ним. Понятие типа присуще объектам, а не име
нам. Переменные универсальны по своей природе – они всегда яв
ляются всего лишь ссылками на конкретные объекты в конкретные
моменты времени.
Использование переменной
Когда переменная участвует в выражении, ее имя замещается объек
том, на который она в настоящий момент ссылается, независимо от
того, что это за объект. Кроме того, прежде чем переменную можно
будет использовать, ей должно быть присвоено значение – исполь
зование неинициализированной переменной приведет к ошибке.
Эта модель существенно отличается от традиционных языков програм
мирования. Динамическая типизация обычно проще поддается пони
манию начинающих, особенно если они четко осознают разницу между
именами и объектами. Например, если ввести такую инструкцию:
>>> a = 3
интерпретатор Python выполнит эту инструкцию в три этапа, по край
ней мере, концептуально. Следующие этапы отражают все операции
присваивания в языке Python:
1. Создается объект, представляющий число 3.
2. Создается переменная a, если она еще отсутствует.
3. Переменная связывается с новым объектом, представляющим чис
ло 3.
168 Глава 6. Интерлюдия о динамической типизации
Результатом выполнения этих этапов будет структура, которая пока
зана на рис. 6.1. Как показано на схеме, переменные и объекты хра
нятся в разных частях памяти и связаны между собой ссылкой (ссыл
ка на рисунке показана в виде стрелки). Переменные всегда ссылают
ся на объекты и никогда на другие переменные, но крупные объекты
могут ссылаться на другие объекты (например, объект списка содер
жит ссылки на объекты, которые включены в список).
Эти ссылки на объекты в языке Python так и называются ссылки, то
есть ссылки – это своего рода ассоциативная связь, реализованная
в виде указателя на область памяти.1 Когда бы ни использовалась пе
ременная (то есть ссылка), интерпретатор Python автоматически пере
ходит по ссылке от переменной на объект. Все на самом деле гораздо
проще, чем кажется. В конкретных терминах:
• Переменные – это записи в системной таблице, где предусмотрено
место для хранения ссылок на объекты.
• Объекты – это области памяти с объемом, достаточным для пред
ставления значений этих объектов.
• Ссылки – это автоматически разыменовываемые указатели на объ
екты.
Всякий раз, по крайней мере концептуально, когда в сценарии в ре
зультате выполнения выражения создается новое значение, интерпре
татор Python создает новый объект (то есть выделяет область памяти),
1 Читатели, знакомые с языком C, сочтут, что между ссылками в языке Py
thon и указателями в языке C много общего (адреса в памяти). И действи
тельно, ссылки реализованы как указатели и они часто играют ту же роль,
особенно когда объект относится к категории изменяемых (подробнее об
этом будет говориться ниже). Однако, так как ссылки при использовании
всегда автоматически разыменовываются, вы никак не сможете использо
вать саму ссылку – эта особенность ликвидирует огромный пласт ошибок,
которые можно допустить в языке C. Вы можете считать ссылки указате
лями типа «void» в языке C, которые автоматически разыменовываются
при любом использовании.
Имена Ссылки Объекты
a 3
Рис. 6.1. Имена и переменные после выполнения операции присваивания a = 3.
Переменная превращается в ссылку на объект 3. Во внутреннем
представлении переменная в действительности является
указателем на пространство памяти с объектом, созданным
в результате интерпретации литерального выражения 3
Отсутствие инструкций объявления 169
представляющий это значение. Внутренняя реализация интерпретато
ра, с целью оптимизации, кэширует и повторно использует некоторые
типы неизменяемых объектов, такие как малые целые числа и строки
(каждый 0 в действительности не является новой областью в памяти,
но подробнее о механизме кэширования мы поговорим позже). Но с ло
гической точки зрения все выглядит так, как если бы результат каж
дого выражения был представлен отдельным объектом и каждый объ
ект занимал отдельную область памяти.
С технической точки зрения объекты имеют более сложную структу
ру, чем просто пространство в памяти, необходимое для хранения зна
чения. Каждый объект имеет два стандартных поля: указатель типа,
используемый для хранения информации о типе объекта, и счетчик
ссылок, используемый для определения момента, когда память, зани
маемая объектом, может быть освобождена. Чтобы понять, какую
роль играют эти два поля в модели динамической типизации, нам не
обходимо двинуться дальше.
Информация о типе хранится в объекте,
но не в переменной
Чтобы увидеть, как используется информация о типах объектов, по
смотрим, что произойдет, если выполнить несколько операций при
сваивания одной и той же переменной:
>>> a = 3 # Это целое число
>>> a = 'spam' # Теперь это строка
>>> a = 1.23 # Теперь это число с плавающей точкой
Это не совсем типичный программный код на языке Python, но он ра
ботает – сначала создается целое число, потом строка и, наконец, чис
ло с плавающей точкой. Этот пример особенно странно выглядит для
программистов, использовавших язык C, поскольку он выглядит так,
как если бы при выполнении инструкции a = 'spam' производилось из
менение типа переменной с целочисленного на строковый.
Однако в действительности этого не происходит. В языке Python все реа
лизовано намного проще: имена не имеют типов, как уже указывалось
ранее, тип – это свойство объекта, а не имени. В предыдущем листинге
просто изменяется ссылка на объект. Так как переменные не имеют ти
пов, мы в действительности не изменяем типы переменных – мы просто
записываем в переменные ссылки на объекты других типов. На самом
деле все, что можно сказать о переменных в языке Python, – это то, что
они ссылаются на конкретные объекты в конкретные моменты времени.
С другой стороны, объекты знают, к какому типу они относятся, – ка
ждый объект содержит поле, в котором хранится информация о его ти
пе. Целочисленный объект 3, например, будет содержать значение 3
плюс информацию, которая сообщит интерпретатору Python, что объ
ект является целым числом (строго говоря – это указатель на объект
170 Глава 6. Интерлюдия о динамической типизации
с названием int, которое играет роль имени целочисленного типа). Ука
затель типа для строки 'spam' указывает на строковый тип (с именем
str). Поскольку информация о типе хранится в объектах, ее не нужно
хранить в переменных.
Итак, типы в языке Python – это свойства объектов, а не переменных.
В типичном программном коде переменная обычно ссылается на объ
екты только одного типа. Так как для языка Python это не является
обязательным требованием, программный код на языке Python обла
дает более высокой гибкостью, чем вам может показаться, – при уме
лом использовании особенностей языка программный код смог бы ра
ботать со многими типами автоматически.
Я уже упоминал, что каждый объект имеет два поля – указатель типа
и счетчик ссылок. Чтобы разобраться с последним из них, нам нужно
пойти еще дальше и взглянуть, что происходит в конце жизненного
цикла объекта.
Объекты уничтожаются автоматически
В листинге из предыдущего раздела мы присваивали одной и той же
переменной объекты различных типов. Но что происходит с прежним
значением, когда выполняется новое присваивание? Например, что
произойдет с объектом 3 после выполнения следующих инструкций:
>>> a = 3
>>> a = 'spam'
Дело в том, что всякий раз, когда имя ассоциируется с новым объек
том, интерпретатор Python освобождает память, занимаемую преды
дущим объектом (если на него не ссылается какоелибо другое имя
или объект). Такое автоматическое освобождение памяти, занимаемой
объектами, называется сборкой мусора (garbage collection).
Чтобы проиллюстрировать сказанное, рассмотрим следующий при
мер, где с имя x ассоциируется с разными объектами при выполнении
каждой операции присваивания:
>>> x = 42
>>> x = 'shrubbery' # Освобождается объект 42 (если нет других ссылок)
>>> x = 3.1415 # Теперь освобождается объект 'shrubbery'
>>> x = [1,2,3] # Теперь освобождается объект 3.1415
Первое, что следует отметить, – каждый раз с именем x связывается объ
ект другого типа. Снова, хотя в действительности это не так, возникает
ощущение изменения типа переменной x с течением времени. Напом
ню, что в языке Python типы связаны с объектами, а не с именами. Так
как имена – это всего лишь ссылки на объекты, данный код работает.
Вовторых, следует помнить, что попутно уничтожаются ссылки на
объекты. Каждый раз, когда имя x ассоциируется с новым объектом,
интерпретатор Python освобождает пространство, занятое прежним
объектом. Например, когда с именем x связывается строка 'shrubbery',
Разделяемые ссылки 171
объект 42 немедленно уничтожается (при условии, что на него не ссы
лается никакое другое имя), а пространство памяти, занимаемое объ
ектом, возвращается в пул свободной памяти для повторного использо
вания в будущем.
Достигается это за счет того, что в каждом объекте имеется счетчик
ссылок, с помощью которого интерпретатор следит за количеством ссы
лок, указывающих на объект в настоящий момент времени. Как только
(и именно в этот момент) значение счетчика достигает нуля, память, за
нимаемая объектом, автоматически освобождается. В предыдущем лис
тинге мы исходили из предположения, что всякий раз, когда имя x ас
социируется с новым объектом, счетчик предыдущего объекта умень
шается до нуля, заставляя интерпретатор освобождать память.
Основная выгода от сборки мусора состоит в том, что программист мо
жет свободно распоряжаться объектами, не будучи обязан освобож
дать память в своем сценарии. Интерпретатор сам будет выполнять
очистку неиспользуемой памяти в ходе выполнения программы. На
практике эта особенность позволяет существенно уменьшить объем
программного кода по сравнению с низкоуровневыми языками про
граммирования, такими как C и C++.
Разделяемые ссылки
До сих пор мы рассматривали вариант, когда ссылка на объект при
сваивается единственной переменной. Теперь введем в действие еще
одну переменную и посмотрим, что происходит с именами и объекта
ми в этом случае:
>>> a = 3
>>> b = a
В результате выполнения этих двух инструкций получается схема
взаимоотношений, отраженная на рис. 6.2. Вторая инструкция вынуж
дает интерпретатор создать переменную b и использовать для инициа
лизации переменную a, при этом она замещается объектом, на который
Имена Ссылки Объекты
a
3
b
a=3
b=a
Рис. 6.2. Имена и объекты после выполнения инструкции присваивания b = a.
Переменная b превращается в ссылку на объект 3. С технической точки
зрения переменная в действительности является указателем
на область памяти объекта, созданного в результате выполнения
литерального выражения 3
172 Глава 6. Интерлюдия о динамической типизации
ссылается (3), и b превращается в ссылку на этот объект. В результате
переменные a и b ссылаются на один и тот же объект (то есть указывают
на одну и ту же область в памяти). В языке Python это называется разде+
ляемая ссылка – несколько имен ссылаются на один и тот же объект.
Далее добавим еще одну инструкцию:
>>> a = 3
>>> b = a
>>> a = 'spam'
Как во всех случаях присваивания в языке Python, в результате вы
полнения этой инструкции создается новый объект, представляющий
строку 'spam', а ссылка на него записывается в переменную a. Однако
эти действия не оказывают влияния на переменную b – она попрежне
му ссылается на первый объект, целое число 3. В результате схема ссы
лок приобретает вид, показанный на рис. 6.3.
То же самое произошло бы, если бы ссылка на объект 'spam' вместо пере
менной a была присвоена переменной b – изменилась бы только перемен
ная b, но не a. Аналогичная ситуация возникает, даже если тип объек
та не изменяется. Например, рассмотрим следующие три инструкции:
>>> a = 3
>>> b = a
>>> a = a + 2
В этой последовательности происходят те же самые события: интер
претатор Python создает переменную a и записывает в нее ссылку на
объект 3. После этого он создает переменную b и записывает в нее ту же
ссылку, что хранится в переменной a, как показано на рис. 6.2. Нако
нец, последняя инструкция создает совершенно новый объект (в данном
a
3
b
Имена Ссылки Объекты
‘spam’
a=3
b=a
a=‘spam’
Рис. 6.3. Имена и объекты после выполнения инструкции присваивания
a = 'spam'. Переменная a ссылается на новый объект (то есть на область
памяти), созданный в результате выполнения литерального выражения
'spam', но переменная b по+прежнему ссылается на первый объект 3.
Так как эта операция присваивания никак не изменяет объект 3,
она изменяет только переменную a, но не b
Разделяемые ссылки 173
случае – целое число 5, которое является результатом выполнения опе
рации сложения). Это не приводит к изменению переменной b. В дейст
вительности нет никакого способа перезаписать значение объекта 3 –
как говорилось в главе 4, целые числа относятся к категории неизме
няемых и потому эти объекты невозможно изменить.
Переменные в языке Python, в отличие от других языков программи
рования, всегда являются указателями на объекты, а не метками об
ластей памяти, доступных для изменения: запись нового значения
в переменную не приводит к изменению первоначального объекта, но
приводит к тому, что переменная начинает ссылаться на совершенно
другой объект. В результате инструкция присваивания может воздей
ствовать только на одну переменную. Однако когда в уравнении появ
ляются изменяемые объекты и операции, их изменяющие, картина
несколько меняется. Чтобы узнать как, давайте двинемся дальше.
Разделяемые ссылки и изменяемые объекты
Как будет показано дальше в этой части книги, существуют такие объ
екты и операции, которые приводят к изменению самих объектов. На
пример, операция присваивания значения элементу списка фактически
изменяет сам список вместо того, чтобы создавать совершенно новый
объект списка. При работе с объектами, допускающими такие измене
ния, необходимо быть особенно внимательными при использовании
разделяемых ссылок, так как изменение одного имени может отразить
ся на других именах.
Чтобы проиллюстрировать сказанное, возьмем в качестве примера
объекты списков, о которых рассказывалось в главе 4. Напомню, что
списки, которые поддерживают возможность присваивания значений
элементам, – это просто коллекция объектов, которая в программном
коде записывается как литерал в квадратных скобках:
>>> L1 = [2, 3, 4]
>>> L2 = L1
В данном случае L1 – это список, содержащий объекты 2, 3 и 4. Доступ
к элементам списка осуществляется по их индексам; так, L1[0] ссыла
ется на объект 2, первый элемент в списке L1. Безусловно, списки явля
ются полноценными объектами, такими же, как целые числа и строки.
После выполнения двух приведенных выше инструкций L1 и L2 будут
ссылаться на один и тот же объект, так же как переменные a и b в пре
дыдущем примере (рис. 6.2). Точно так же, если теперь добавить еще
одну инструкцию:
>>> L1 = 24
переменная L1 будет ссылаться на другой объект, а L2 попрежнему бу
дет ссылаться на первоначальный список. Однако если синтаксис по
следней инструкции чутьчуть изменить, эффект получится радикаль
но другим:
174 Глава 6. Интерлюдия о динамической типизации
>>> L1 = [2, 3, 4] # Изменяемый объект
>>> L2 = L1 # Создание второй ссылки на тот же самый объект
>>> L1[0] = 24 # Изменение объекта
>>> L1 # Переменная L1 изменилась
[24, 3, 4]
>>> L2 # Но также изменилась и переменная L2!
[24, 3, 4]
Здесь мы не изменяем сам объект L1, изменяется компонент объекта,
на который ссылается L1. Данное изменение затронуло часть самого
объекта списка. Поскольку объект списка разделяется разными пере
менными (ссылки на него находятся в разных переменных), то измене
ния в самом списке затрагивают не только L1, то есть следует понимать,
что такие изменения могут сказываться в других частях программы.
В этом примере изменения обнаруживаются также в переменной L2,
потому что она ссылается на тот же самый объект, что и L1. Здесь мы
фактически не изменяли L2, но значение этой переменной изменилось.
Как правило, это именно то, что требовалось, но вы должны понимать,
как это происходит. Это – поведение по умолчанию: если вас оно не
устраивает, можно потребовать от интерпретатора, чтобы вместо созда
ния ссылок он выполнял копирование объектов. Скопировать список
можно несколькими способами, включая встроенную функцию list
и модуль copy из стандартной библиотеки. Однако самым стандартным
способом копирования является получение среза от начала и до конца
списка (подробнее об этой операции рассказывается в главах 4 и 7):
>>> L1 = [2, 3, 4]
>>> L2 = L1[:] # Создается копия списка L1
>>> L1[0] = 24
>>> L1
[24, 3, 4]
>>> L2 # L2 не изменилась
[2, 3, 4]
Здесь изменения в L1 никак не отражаются на L2, потому что L2 ссыла
ется на копию объекта, на который ссылается переменная L1. То есть
эти переменные указывают на различные области памяти.
Обратите внимание: способ, основанный на получении среза, неприме
ним в случае с другим изменяемым базовым типом – со словарями, по
тому что словари не являются последовательностями. Чтобы скопиро
вать словарь, необходимо воспользоваться методом D.copy(). Следует
также отметить, что модуль copy из стандартной библиотеки имеет
в своем составе универсальную функцию, позволяющую копировать
объекты любых типов, включая вложенные структуры (например,
словари с вложенными списками):
import copy
X = copy.copy(Y) # Создание "поверхностной" копии любого объекта Y
X = copy.deepcopy(Y) # Создание полной копии: копируются все вложенные части
Разделяемые ссылки 175
В главах 8 и 9 мы будем рассматривать списки и словари во всей пол
ноте и там же вернемся к концепции разделяемых ссылок и копирова
ния. А пока просто держите в уме, что объекты, допускающие измене
ния в них самих (то есть изменяемые объекты), всегда подвержены
описанным эффектам. В число таких объектов в языке Python попада
ют списки, словари и некоторые объекты, объявленные с помощью ин
струкции class. Если такое поведение является нежелательным, вы
можете просто копировать объекты.
Разделяемые ссылки и равенство
В интересах полноты обсуждения должен заметить, что возможность
сборки мусора, описанная ранее в этой главе, может оказаться более
принципиальным понятием, чем литералы для объектов некоторых
типов. Рассмотрим следующие инструкции:
>>> x = 42
>>> x = 'shrubbery' # Объект 42 теперь уничтожен?
Так как интерпретатор Python кэширует и повторно использует малые
целые числа и небольшие строки, о чем уже упоминалось ранее, объ
ект 42 скорее всего не будет уничтожен. Он, скорее всего, останется
в системной таблице для повторного использования, когда вы вновь
сгенерируете число 42 в программном коде. Однако большинство объ
ектов уничтожаются немедленно, как только будет потеряна послед
няя ссылка, особенно те, к которым применение механизма кэширова
ния не имеет смысла.
Например, согласно модели ссылок в языке Python, существует два
разных способа выполнить проверку равенства. Давайте создадим раз
деляемую ссылку для демонстрации:
>>> L = [1, 2, 3]
>>> M = L # M и L – ссылки на один и тот же объект
>>> L == M # Одно и то же значение
True
>>> L is M # Один и тот же объект
True
Первый способ, основанный на использовании оператора ==, проверяет,
равны ли значения объектов. В языке практически всегда используется
именно этот способ. Второй способ, основанный на использовании опе
ратора is, проверяет идентичность объектов. Он возвращает значение
True, только если оба имени ссылаются на один и тот же объект, вслед
ствие этого он является более строгой формой проверки равенства.
На самом деле оператор is просто сравнивает указатели, которые реа
лизуют ссылки, и тем самым может использоваться для выявления
разделяемых ссылок в программном коде. Он возвращает значение
False, даже если имена ссылаются на эквивалентные, но разные объек
ты, как, например, в следующем случае, когда выполняются два раз
личных литеральных выражения:
176 Глава 6. Интерлюдия о динамической типизации
>>> L = [1, 2, 3]
>>> M = [1, 2, 3] # M и L ссылаются на разные объекты
>>> L == M # Одно и то же значение
True
>>> L is M # Но разные объекты
False
Посмотрите, что происходит, если те же самые действия выполняются
над малыми целыми числами:
>>> X = 42
>>> Y = 42 # Должно получиться два разных объекта
>>> X == Y
True
>>> X is Y # Тот же самый объект: кэширование в действии!
True
В этом примере переменные X и Y должны быть равны (==, одно и то же
значение), но не эквивалентны (is, один и тот же объект), потому что
было выполнено два разных литеральных выражения. Однако изза то
го что малые целые числа и строки кэшируются и используются по
вторно, оператор is сообщает, что переменные ссылаются на один и тот
же объект.
Фактически, если вы действительно хотите взглянуть на работу внут
ренних механизмов, вы всегда можете запросить у интерпретатора ко
личество ссылок на объект: функция getrefcount из стандартного модуля
sys возвращает значение поля счетчика ссылок в объекте. Когда я, на
пример, запросил количество ссылок на целочисленный объект 1 в сре
де разработки IDLE, я получил число 837 (большая часть ссылок была
создана системным программным кодом самой IDLE, а не мною):
>>> import sys
>>> sys.getrefcount(1) # 837 указателей на этот участок памяти
837
Такое кэширование объектов и повторное их использование будет ма
лоприменимо к вашему программному коду (если вы не используете
оператор is!). Так как числа и строки не могут изменяться, совершен
но неважно, сколько ссылок указывает на один и тот же объект. Одна
ко такое поведение наглядно демонстрирует один из реализуемых Py
thon способов оптимизации, направленной на повышение скорости
выполнения.
Динамическая типизация повсюду
В действительности вам совсем не нужно рисовать схемы с именами,
объектами, кружочками и стрелками, чтобы использовать Python. Од
нако в самом начале пути такие схемы иногда помогают разобраться
в необычных случаях. Если после передачи изменяемого объекта в дру
гую часть программы он возвращается измененным, значит, вы стали
свидетелем того, о чем рассказывалось в этой главе.
В заключение 177
Более того, если к настоящему моменту динамическая типизация ка
жется вам немного непонятной, вы, вероятно, захотите устранить это
недопонимание в будущем. Поскольку в языке Python все основано на
присваивании и на ссылках, понимание основ этой модели пригодится
во многих ситуациях. Как будет показано позже, одна и та же модель
используется в операторах присваивания, при передаче аргументов
функциям, в переменных цикла for, при импортировании модулей
и т. д. Но к счастью, в Python реализована всего одна модель присваи
вания! Как только вы разберетесь в динамической типизации, вы об
наружите, что подобные принципы применяются повсюду в этом язы
ке программирования.
На практическом уровне наличие динамической типизации означает,
что вам придется писать меньше программного кода. Однако не менее
важно и то, что динамическая типизация составляет основу полимор
физма – концепции, которая была введена в главе 4 и к которой мы еще
вернемся далее в этой книге – в языке Python. Поскольку мы не ограни
чены применением типов в программном коде на языке Python, он обла
дает очень высокой гибкостью. Как будет показано далее, при правиль
ном использовании динамической типизации и полиморфизма можно
создавать такой программный код, который автоматически будет адап
тироваться под новые требования в ходе развития вашей системы.
В заключение
В этой главе мы подробно рассмотрели модель динамической типиза
ции в языке Python, то есть способ, который используется интерпрета
тором для автоматического хранения информации о типах объектов
и избавляет нас от необходимости вставлять код объявлений в наши
сценарии. Попутно мы узнали, как реализована связь между перемен
ными и объектами. Кроме того, мы исследовали понятие сборки мусо
ра, узнали, как разделяемые ссылки на объекты могут оказывать воз
действие на несколько переменных и как ссылки влияют на понятие
равенства в языке Python.
Поскольку в языке Python имеется всего одна модель присваивания,
и она используется повсюду в этом языке, очень важно, чтобы вы разо
брались в ней, прежде чем двигаться дальше. Контрольные вопросы
к этой главе должны помочь вам повторить некоторые идеи этой гла
вы. После этого в следующей главе мы возобновим наш обзор объек
тов, приступив к изучению строк.
Закрепление пройденного
Контрольные вопросы
1. Взгляните на следующие три инструкции. Изменится ли значение
переменной A?
178 Глава 6. Интерлюдия о динамической типизации
A = "spam"
B = A
B = "shrubbery"
2. Взгляните на следующие три инструкции. Изменится ли значение
переменной A?
A = ["spam"]
B = A
B[0] = "shrubbery"
3. А что можно сказать об этом случае? Изменится ли значение пере
менной A?
A = ["spam"]
B = A[:]
B[0] = "shrubbery"
Ответы
1. Нет, значением переменной A попрежнему будет строка 'spam'. Ко
гда переменной B присваивается строка 'shrubbery', она просто на
чинает указывать на другой строковый объект. Первоначально пе
ременные A и B разделяют (то есть ссылаются или указывают) один
и тот же строковый объект со значением 'spam', но в языке Python
два имени никак не связаны между собой. Таким образом, назначе
ние переменной B ссылки на другой объект не оказывает влияние на
переменную A. То же самое было бы справедливо, если бы послед
няя инструкция имела вид B = B + 'shrubbery', так как операция кон
катенации создает в результате новый объект, ссылка на который
затем записывается в переменную B. Мы не можем изменять сами
строковые объекты (или числа, или кортежи), потому что они отно
сятся к категории неизменяемых объектов.
2. Да, теперь значением переменной A будет ["shrubbery"]. Формально
мы не изменили ни одну из переменных, ни A, ни B, но мы изменили
часть самого объекта, на который они ссылаются (указывают), по
средством переменной B. Поскольку A ссылается на тот же самый
объект, что и B, изменения можно обнаружить и с помощью пере
менной A.
3. Нет, значением переменной A попрежнему будет строка 'spam'. Из
менение самого объекта с помощью ссылки B не оказывает влияние
на переменную A по той причине, что выражение получения среза
создает копию объекта списка, прежде чем присвоить ссылку пере
менной B. После второго оператора присваивания в программе бу
дет существовать два разных объекта списков с одинаковыми зна
чениями (в языке Python мы говорим: «равны, но не эквивалент
ны»). Третья инструкция изменяет значение объекта списка, на ко
торый ссылается переменная B, а объект, на который ссылается
переменная A, остается неизменным.
7
Строки
Следующий основной тип на пути нашего исследования встроенных
объектов языка Python – это строки, упорядоченные последователь
ности символов, используемые для хранения и представления тексто
вой информации. Мы коротко познакомились со строками в главе 4.
Здесь мы займемся более глубоким их исследованием и восполним не
которые подробности, которые ранее были опущены.
С функциональной точки зрения строки могут использоваться для
представления всего, что только может быть выражено в текстовой фор
ме: символы и слова (например, ваше имя), содержимое текстовых фай
лов, загруженных в память, адреса в Интернете, программы на языке
Python и т. д.
Возможно, вам уже приходилось использовать строки в других язы
ках программирования. Строки в языке Python играют ту же роль, что
и массивы символов в языке C, но они являются инструментом более
высокого уровня, нежели простой массив символов. В отличие от C,
строки в языке Python обладают мощным набором средств для их обра
ботки. Кроме того, в отличие от таких языков, как C, в языке Python
отсутствует специальный тип для представления единственного симво
ла (как тип char в языке C), поэтому в случае необходимости использу
ются односимвольные строки.
Строго говоря, строки в языке Python относятся к категории неизме
няемых последовательностей, в том смысле, что символы, которые
они содержат, имеют определенный порядок следования слева напра
во и что сами строки невозможно изменить. Фактически, строки – это
первый представитель большого класса объектов, называемых последо
вательностями, которые мы будем здесь изучать. Обратите особое вни
мание на операции над последовательностями, представленные в этой
главе, так как они похожим образом работают и с другими типами
180 Глава 7. Строки
последовательностей, такими как списки и кортежи, которые мы бу
дем рассматривать позже.
В табл. 7.1 приводятся наиболее типичные литералы строк и операций,
которые обсуждаются в этой главе. Пустые строки записываются как
пара кавычек (или апострофов), между которыми ничего нет; и сущест
вуют различные способы записи строк в программном коде. Для работы
со строками поддерживаются операции выражений, такие как конка
тенация (объединение строк), выделение подстроки, выборка символов
по индексам (по смещению от начала строки) и т. д. Помимо выраже
ний язык Python предоставляет ряд строковых методов, которые реа
лизуют обычные задачи работы со строками, а также модули для реше
ния более сложных задач обработки текста, таких как поиск по шабло
ну. Все эти инструменты будут рассматриваться далее в этой же главе.
Таблица 7.1. Наиболее типичные литералы строк и операции
Помимо базового набора инструментов для работы со строками, Python
также поддерживает более сложные приемы обработки строк, основан
ные на применении шаблонов, с помощью библиотечного модуля re (re
gular expression – регулярные выражения), о котором говорилось в гла
ве 4. Данная глава начинается с краткого обзора форм строковых лите
ралов и базовых строковых выражений, затем мы перейдем к более
сложным инструментам, таким как методы строк и форматирование.
Операция Интерпретация
s1 = '' Пустая строка
s2 = "spam's" Строка в кавычках
block = """...""" Блоки в тройных кавычках
s3 = r'\temp\spam' Неформатированные строки
s4 = u'spam' Строки с символами Юникода
s1 + s2
s2 * 3
Конкатенация, повторение
s2[i]
s2[i:j]
len(s2)
Обращение к символу по индексу, извлечение под
строки (среза), длина
"a %s parrot" % type Форматирование строки
s2.find('pa')
s2.rstrip()
s2.replace('pa', 'xx')
s1.split(',')
s1.isdigit()
s1.lower()
Методы строк: поиск, удаление пробелов, поиск
с заменой, разбиение на подстроки по символураз
делителю, проверка содержимого, преобразование
регистра символов и т. д.
for x in s2
'spam' in s2
Обход в цикле, проверка на вхождение
Литералы строк 181
Литералы строк
Вообще говоря, работать со строками в языке Python достаточно удоб
но. Самое сложное, пожалуй, – это наличие множества способов запи
си строк в программном коде:
• Строки в апострофах: 'spa"m'
• Строки в кавычках: "spa'm"
• Строки в тройных кавычках: '''... spam ...''', """... spam ..."""
• Экранированные последовательности: "s\tp\na\0m"
• Неформатированные строки: r"C:\new\test.spm"
• Строки символов Юникода: u'eggs\u0020spam'
Варианты представления строк в апострофах и кавычках являются
наиболее типичными, остальные играют особую роль. Давайте корот
ко рассмотрим каждый из этих вариантов.
Строки в апострофах и в кавычках – это одно и то же
Кавычки и апострофы, окружающие строки, в языке Python являются
взаимозаменяемыми. То есть строковые литералы можно заключать
как в апострофы, так и в кавычки – эти две формы представления
строк ничем не отличаются и обе они возвращают объект того же само
го типа. Например, следующие две строки совершенно идентичны:
>>> 'shrubbery', "shrubbery"
('shrubbery', 'shrubbery')
Причина наличия двух вариантов состоит в том, чтобы позволить
вставлять в литералы символы кавычек и апострофов, не используя
для этого символ обратного слеша. Вы можете вставлять апострофы
в строки, заключенные в кавычки, и наоборот:
>>> 'knight"s', "knight's"
('knight"s', "knight's")
Между прочим, Python автоматически объединяет последовательно
сти строковых литералов внутри выражения, хотя нет ничего сложно
го в том, чтобы добавить оператор + между литералами и вызвать опе
рацию конкатенации явно:
>>> title = "Meaning " 'of' " Life" # Неявная конкатенация
>>> title
'Meaning of Life'
Обратите внимание, если добавить запятые между этими строками,
будет получен кортеж, а не строка. Кроме того, заметьте, что во всех
этих примерах интерпретатор предпочитает выводить строки в апост
рофах, если их нет внутри строки. Кавычки и апострофы можно встав
лять в строки, экранируя их символом обратного слеша:
182 Глава 7. Строки
>>> 'knight\'s', "knight\"s"
("knight's", 'knight"s')
Чтобы понять, зачем, вам необходимо узнать, как работает механизм
экранирования вообще.
Экранированные последовательности
представляют служебные символы
В последнем примере вставляемые в строку кавычка и апостроф пред
варяются символом обратного слеша. Это частный случай более общей
формы: символы обратного слеша используются для вставки специаль
ных символов, известных как экранированные последовательности.
Экранированные последовательности позволяют вставлять в строки
символы, которые сложно ввести с клавиатуры. В конечном строко
вом объекте символ \ и один или более следующих за ним символов за
мещаются единственным символом, который имеет двоичное значе
ние, определяемое экранированной последовательностью. Например,
ниже приводится строка из пяти символов, в которую вставлены сим
вол новой строки и табуляции:
>>> s = 'a\nb\tc'
Последовательность \n образует единственный символ – байт, содер
жащий двоичное значение кода символа новой строки в используемом
наборе символов (обычно ASCIIкод 10). Аналогично последователь
ность \t замещается символом табуляции. Как будет выглядеть такая
строка при печати, зависит от того, как она выводится. Функция авто
матического вывода в интерактивной оболочке отобразит служебные
символы как экранированные последовательности, а инструкция
print будет интерпретировать их:
>>> s
'a\nb\tc'
>>> print s
a
b c
Чтобы окончательно убедиться, сколько байтов входит в эту строку,
можно воспользоваться встроенной функцией len – она возвращает
фактическое число байтов в строке независимо от того, как строка ото
бражается на экране:
>>> len(s)
5
Длина этой строки составляет пять байтов: она содержит байт ASCII
символа a, байт символа новой строки, байт ASCIIсимвола b и т. д. Об
ратите внимание, что символы обратного слеша не сохраняются в па
мяти строкового объекта. Для представления служебных символов
язык Python обеспечивает полный набор экранированных последова
тельностей, перечисленных в табл. 7.2.
Литералы строк 183
Таблица 7.2. Экранированные последовательности
Некоторые экранированные последовательности позволяют указы
вать абсолютные двоичные значения в байтах строк. Например, ниже
приводится пример строки из пяти символов, содержащей два нуле
вых байта:
>>> s = 'a\0b\0c'
>>> s
'a\x00b\x00c'
>>> len(s)
5
В языке Python нулевой байт (символ null) не является признаком за
вершения строки, как в языке C. Интерпретатор просто сохраняет
в памяти как текст самой строки, так и ее длину. Фактически в языке
Последовательность Назначение
\newline Игнорируется (продолжение на новой строке)
\\ Сам символ обратного слеша (остается один символ \)
\' Апостроф (остается один символ ')
\" Кавычка (остается один символ ")
\a Звонок
\b Забой
\f Перевод формата
\n Новая строка (перевод строки)
\r Возврат каретки
\t Горизонтальная табуляция
\v Вертикальная табуляция
\N{id} Идентификатор ID базы данных Юникода
\uhhhh 16битовый символ Юникода в шестнадцатеричном
представлении
\Uhhhh... 32битовый символ Юникода в шестнадцатеричном
представленииa
a Экранированная последовательность \Uhhhh... состоит ровно из восьми ше
стнадцатеричных цифр (h). Последовательности \u и \U могут использо
ваться только в литералах строк символов Юникода.
\xhh Шестнадцатеричное значение
\ooo Восьмеричное значение
\0 Символ Null (не признак конца строки)
\другое Не является экранированной последовательностью
(символ обратного слеша сохраняется)
184 Глава 7. Строки
Python вообще нет символа, который служил бы признаком заверше
ния строки. Ниже приводится строка, полностью состоящая из экра
нированных кодов, – двоичные значения 1 и 2 (записано в восьмерич
ной форме), за которыми следует двоичное значение 3 (записано в ше
стнадцатеричной форме):
>>> s = '\001\002\x03'
>>> s
'\x01\x02\x03'
>>> len(s)
3
Это обстоятельство приобретает особую важность, когда возникает не
обходимость обрабатывать на языке Python файлы с двоичными дан
ными. Поскольку содержимое таких файлов в сценариях на языке Py
thon представлено строками, вы без труда сможете обрабатывать дво
ичные файлы, содержащие байты с любыми двоичными значениями
(подробнее о файлах рассказывается в главе 9).1
Наконец, последняя строка в табл. 7.2 предполагает, что если интер
претатор не распознает символ после \ как корректный служебный
символ, он просто оставляет символ обратного слеша в строке:
>>> x = "C:\py\code" # Символ \ сохраняется в строке
>>> x
'C:\\py\\code'
>>> len(x)
10
Однако если вы не способны держать в памяти всю табл. 7.2, вам не
следует полагаться на описанное последней строкой таблицы поведе
ние.2 Чтобы явно добавить символ обратного слеша в строку, нужно
указать два символа обратного слеша, идущие подряд (\\ – экраниро
ванный вариант представления символа \), или использовать нефор
матированные строки, которые описываются в следующем разделе.
Неформатированные строки подавляют экранирование
Как было показано, экранированные последовательности удобно ис
пользовать для вставки в строки служебных символов. Однако иногда
зарезервированная экранированная последовательность может поро
1 Если вам требуется работать с файлами, содержащими двоичные данные,
главное отличие в работе с ними заключается в том, что открывать их нуж
но в режиме двоичного доступа (добавляя к флагу режима открытия флаг
b, например "rb", "wb" и т. д.). Кроме того, обратите внимание на модуль
struct, который будет описан в главе 9, с помощью которого можно выпол
нять интерпретацию двоичных данных, загруженных из файла.
2 Мне доводилось встречать людей, которые помнили всю таблицу или боль
шую ее часть. Я бы счел их ненормальными, но пришлось бы себя вклю
чить в их число.
Литералы строк 185
ждать неприятности. Очень часто, например, можно увидеть, как на
чинающие программисты пытаются открыть файл, передавая аргу
мент с именем файла, который имеет примерно следующий вид:
myfile = open('C:\new\text.dat', 'w')
думая, что они открывают файл с именем text.dat в каталоге C:\new.
Проблема здесь заключается в том, что последовательность \n интер
претируется как символ новой строки, а последовательность \t заме
щается символом табуляции. В результате функция open будет пытать
ся открыть файл с именем C:(newline)ew(tab)ext.dat, причем обычно
безуспешно.
Именно в таких случаях удобно использовать неформатированные стро
ки. Если перед кавычкой, открывающей строку, стоит символ r (в верх
нем или в нижнем регистре), он отключает механизм экранирования.
В результате интерпретатор Python будет воспринимать символы об
ратного слеша в строке как обычные символы. Таким образом, чтобы
ликвидировать проблему, связанную с именами файлов в Windows, не
забывайте добавлять символ r.
myfile = open(r'C:\new\text.dat', 'w')
Как вариант, учитывая, что два идущих подряд символа обратного
слеша интерпретируются как один символ, можно просто продублиро
вать символы обратного слеша:
myfile = open('C:\\new\\text.dat', 'w')
Сам интерпретатор Python в определенных случаях использует удваи
вание обратного слеша при выводе строк, содержащих обратный слеш:
>>> path = r'C:\new\text.dat'
>>> path # Показать, как интерпретатор представляет эту строку
'C:\\new\\text.dat'
>>> print path # Более дружественный формат представления
C:\new\text.dat
>>> len(path) # Длина строки
15
Так же как и в случае с числами, при выводе результатов в интерак
тивной оболочке по умолчанию используется такой формат представ
ления, как если бы это был программный код, отсюда и экранирова
ние символов обратного слеша. Чтобы проверить, что дело обстоит
именно так, можно проверить результат с помощью встроенной функ
ции len, которая возвращает число байтов в строке независимо от фор
мата отображения. Если посчитать символы в выводе инструкции
print path, можно увидеть, что каждому символу обратно слеша соот
ветствует один байт, а всего строка содержит 15 символов.
Помимо хранения имен каталогов в Windows неформатированные стро
ки обычно используются для регулярных выражений (возможность по
иска по шаблону, поддерживаемая модулем re, о котором говорилось
186 Глава 7. Строки
в главе 4). Кроме того, следует отметить, что в сценариях на языке Py
thon в строках с именами каталогов в системах Windows и UNIX можно
использовать простые символы слеша, потому что Python старается
поддерживать переносимость для путей к файлам. И все же, когда для
кодирования имен каталогов в Windows используется традиционная
нотация с обратными слешами, удобно использовать неформатирован
ные строки.
Тройные кавычки, многострочные блоки текста
К настоящему моменту мы познакомились с кавычками, апострофа
ми, экранированными последовательностями и неформатированными
строками. Кроме этого в арсенале языка Python имеется формат пред
ставления строковых литералов, в котором используются тройные ка
вычки. Этот формат иногда называют блочной строкой, которую удоб
но использовать для определения многострочных блоков текста в про
граммном коде. Литералы в этой форме начинаются с трех идущих
подряд кавычек (или апострофов), за которыми может следовать про
извольное число строк текста, который закрывается такими же тремя
кавычками. Внутри такой строки могут присутствовать и кавычки,
и апострофы, но экранировать их не требуется – строка не считается
завершенной, пока интерпретатор не встретит три неэкранированные
кавычки того же типа, которые начинают литерал. Например:
>>> mantra = """Always look
... on the bright
... side of life."""
>>>
>>> mantra
'Always look\n on the bright\nside of life.'
Эта строка состоит из трех строк (в некоторых системах строка пригла
шения к вводу изменяется на ..., когда ввод продолжается на следую
щей линии; среда IDLE просто переводит курсор на следующую линию).
Интерпретатор собирает блок текста, заключенный в тройные кавычки,
в одну строку, добавляя символы новой строки (\n) там, где в программ
ном коде выполнялся переход на новую строку. Обратите внимание,
что в результате у второй строки имеется ведущий пробел, а у третьей –
нет, то есть что вы в действительности вводите, то и получаете.
Строки в тройных кавычках удобно использовать, когда в программе
требуется ввести многострочный текст, например, чтобы определить
многострочный текст сообщения об ошибке или код разметки на язы
ке HTML или XML. Вы можете встраивать такие блоки текста прямо
в свои сценарии, не используя для этого внешние текстовые файлы
или явную операцию конкатенации и символы новой строки.
Часто строки в тройных кавычках используются для создания строк
документирования, которые являются литералами строк, восприни
маемыми как комментарии при появлении их в определенных местах
Литералы строк 187
сценария (подробнее о них будет рассказываться позже в этой книге).
Комментарии не обязательно (но часто!) представляют собой много
строчный текст, и данный формат дает возможность вводить много
строчные комментарии.
Наконец, иногда тройные кавычки являются ужасающим, хакерским
способом временного отключения строк программного кода во время
разработки (Хорошо, хорошо! На самом деле это не так ужасно, и в дей
ствительности довольно распространенная практика). Если вам потре
буется отключить несколько строк программного кода и запустить
сценарий снова, просто вставьте по три кавычки до и после нужного
блока кода, как показано ниже:
X = 1
"""
import os
print os.getcwd()
"""
Y = 2
Я назвал этот прием ужасным, потому что при работе интерпретатор
вынужден создавать строку из таких линий программного кода, но,
скорее всего, это слабо сказывается на производительности. В случае
крупных блоков программного кода использовать этот прием гораздо
удобнее, чем вставлять символы решетки в начале каждой строки,
а затем убирать их. Это особенно верно, если используемый вами тек
стовый редактор не поддерживает возможность редактирования ис
ходных текстов на языке Python. При программировании на этом язы
ке практичность часто берет верх над эстетичностью.
Строки символов Юникода позволяют использовать
крупные наборы символов
Последний способ создания строк в сценариях является, пожалуй, са
мым специфичным, и он редко используется за пределами задач обра
ботки кода разметки XML и вебпрограммирования. Строки символов
Юникода иногда называют строками «широких» символов. Так как
символы Юникода могут быть представлены более чем одним байтом,
такие строки могут обеспечить представление более широкого набора
символов, чем стандартные строки.
Строки символов Юникода обычно используются с целью поддержки
интернационализации приложений (иногда называется как «i18n»,
чтобы сжать 18 символов, расположенные между первым и последним
символом в слове «internationalization»). Например, они позволяют
программистам непосредственно использовать в сценариях символы
из европейских и азиатских алфавитов. Поскольку такие наборы мо
гут содержать больше символов, чем можно представить с помощью
однобайтовой кодировки, то для обработки таких видов текста обычно
используется Юникод.
188 Глава 7. Строки
В языке Python строки символов Юникода можно записывать, добав
ляя символ U (в верхнем или нижнем регистре) перед открывающей
кавычкой:
>>> u'spam'
u'spam'
Формально с помощью этого синтаксиса создается объект строки сим
волов Юникода, который является самостоятельным типом данных,
отличным от обычного строкового типа. Однако Python позволяет лег
ко смешивать в выражениях строки символов Юникода и обычные
строки, преобразуя последние до строк символов Юникода при вычис
лении результата (подробнее об операции конкатенации рассказывает
ся в следующем разделе):
>>> 'ni' + u'spam' # Смешивание строк различных типов
u'nispam'
На практике строки символов Юникода поддерживают все обычные
операции над строками, которые встретятся вам в следующем разделе,
поэтому для вашего программного кода различия в типах играют несу
щественную роль. Подобно обычным строкам, строки символов Юни
кода могут объединяться, из них можно извлекать отдельные символы
и подстроки, производить поиск по шаблону с помощью модуля re
и т. д., и эти строки также являются неизменяемыми.
Даже если у вас возникнет необходимость явно выполнить преобразо
вание между этими двумя типами, вы можете использовать встроен
ную функцию unicode:
>>> str(u'spam') # Из Юникода в обычную строку
'spam'
>>> unicode('spam') # Из обычной строки в Юникод
u'spam'
Поскольку кодировка Юникод предназначена для работы с многобай
товыми символами, вы также можете использовать экранированные
последовательности \u и \U для представления символов Юникода
в виде числовых значений, размер которых превышает 8 битов:
>>> u'ab\x20cd' # 8битовые/1байтовые символы
u'ab cd'
>>> u'ab\u0020cd' # 2байтовые символы
u'ab cd'
>>> u'ab\U00000020cd' # 4байтовые символы
u'ab cd'
Первая из этих инструкций встраивает числовой код символа пробела,
который в шестнадцатеричной записи имеет вид x20. Вторая и третья
инструкции делают то же самое, но используют 2байтовое и 4байтовое
представление в виде экранированных последовательностей.
Даже если вы полагаете, что вам не понадобятся символы Юникода,
вам, возможно, хотя бы неявно придется использовать их. Поскольку
Литералы строк 189
некоторые программные интерфейсы (например, COM API в Windows
и некоторые синтаксические анализаторы XML) представляют текст
в кодировке Юникод, это может повлечь за собой необходимость выпол
нять преобразование между обычной кодировкой и кодировкой Юни
код при передаче текста таким API или при получении результатов.
В большинстве случаев интерпретатор Python рассматривает эти два
типа строк как взаимозаменяемые, поэтому присутствие строк симво
лов Юникода часто проходит незамеченным для вашего программного
кода – в большинстве случаев вы можете просто игнорировать тот
факт, что текст передается между программными компонентами в ви
де объектов строк символов Юникода, и использовать обычные стро
ковые операции.
Поддержка Юникода – это полезное встроенное дополнение в языке Py
thon, поэтому данные в кодировке Юникод легко обрабатываются в сце
нариях. Безусловно, о Юникоде можно рассказать больше. Например:
• Объекты строк Юникода предоставляют метод, выполняющий пре
образования строки символов Юникода в обычную строку 8бито
вых символов с использованием указанной кодировки.
• Встроенная функция unicode и модуль codecs поддерживают зареги
стрированные «кодеки» («codec», от слов «COders» и «DECoders»)
Юникода.
• Функция open из модуля codec позволяет обрабатывать текстовые
файлы в кодировке Юникод, где каждый символ может быть пред
ставлен более чем одним байтом.
• Модуль unicodedata предоставляет доступ к базе данных символов
Юникода.
• Модуль sys включает функции для получения и изменения схемы
кодирования Юникод (по умолчанию обычно используется ASCII).
• Допускается комбинировать форматы представления неформатиро
ванных строк и строк символов Юникода (например, ur'a\b\c').
Поскольку тема использования кодировки Юникод является достаточ
но сложной, и это не самый распространенный инструмент, мы не бу
дем обсуждать ее далее в этой вводной книге. Дополнительные сведе
ния о Юникоде вы найдете в стандартном руководстве по языку Python.
В Python 3.0 строковый тип претерпит некоторые изменения:
в версии 3.0 текущий тип str всегда будет представлять строки
символов Юникода, а также появится новый тип – «байты», из
меняемая последовательность малых целых чисел, удобная для
представления коротких строк символов. Некоторые операции
чтения из файла будут возвращать байты вместо типа str (напри
мер, при чтении двоичных файлов). Однако все это пока только
в планах, поэтому подробности вам следует искать в примечани
ях к выпуску 3.0.
190 Глава 7. Строки
Строки в действии
Как только с помощью литеральных выражений, с которыми мы толь
ко что познакомились, строка будет создана, вам наверняка потребует
ся выполнять какиелибо операции с ее участием. В этом и в следую
щих двух разделах демонстрируются основы работы со строками, фор
матирование и методы – первая линия инструментальных средств об
работки текста в языке Python.
Базовые операции
Давайте запустим интерактивный сеанс работы с интерпретатором Py
thon, чтобы проиллюстрировать базовые операции над строками, ко
торые были перечислены в табл. 7.1. Строки можно объединять с по
мощью оператора конкатенации + и дублировать с помощью оператора
повторения *:
% python
>>> len('abc') # Длина: число элементов
3
>>> 'abc' + 'def' # Конкатенация: новая строка
'abcdef'
>>> 'Ni!' * 4 # Повторение: подобно "Ni!" + "Ni!" + ...
'Ni!Ni!Ni!Ni!'
Формально операция сложения двух строковых объектов создает но
вый строковый объект, объединяющий содержимое операндов. Опера
ция повторения напоминает многократное сложение строки с самой
собой. В обоих случаях Python позволяет создавать строки произволь
ного размера – нет никакой необходимости предварительно объявлять
что бы то ни было, включая размеры структур данных.1 Встроенная
функция len возвращает длину строки (или любого другого объекта,
который имеет длину).
Операция повторения на первый взгляд выглядит несколько странно,
но она очень удобна в очень широком диапазоне применений. Напри
1 В отличие от массивов символов в языке C, при работе со строками в языке
Python вам не нужно выделять или управлять памятью массивов – вы про
сто создаете объекты строк, когда в этом возникает необходимость, и позво
ляете интерпретатору самому управлять памятью, выделяемой для этих
объектов. Как уже говорилось в предыдущей главе, Python автоматически
освобождает память, занятую ненужными объектами, используя страте
гию сборки мусора, основанную на подсчете количества ссылок. Каждый
объект следит за количеством имен, структур данных и другими компонен
тами, которые ссылаются на него. Когда количество ссылок уменьшается
до нуля, интерпретатор освобождает память, занятую объектом. Это озна
чает, что интерпретатору не требуется останавливаться и просматривать
всю память в поисках неиспользуемого пространства (дополнительный
компонент сборки мусора собирает также циклические объекты).
Строки в действии 191
мер, чтобы вывести строку из 80 символов дефиса, можно самому со
считать до 80, а можно возложить эту работу на плечи интерпретатора:
>>> print '






 ...много дефисов... 


' # 80 дефисов, сложный способ
>>> print '
'*80 # 80 дефисов, простой способ
Обратите внимание: здесь работает механизм перегрузки операторов:
мы используем те же самые операторы + и *, которые используются
для выполнения операций сложения и умножения с числами. Интер
претатор выполняет требуемую операцию, потому что ему известны
типы объектов, к которым применяются операции сложения и умно
жения. Но будьте внимательны: правила не так либеральны, как мо
жет показаться. Например, интерпретатор не позволяет смешивать
строки и числа в выражениях сложения: 'abc' + 9 вызовет ошибку вме
сто того, чтобы автоматически преобразовать число 9 в строку.
Как показано в последней строке табл. 7.1, допускается выполнять об
ход элементов строки в цикле, используя инструкцию for, и проверять
вхождение подстроки в строку с помощью оператора выражения in,
который, по сути, выполняет операцию поиска:
>>> myjob = "hacker"
>>> for c in myjob: print c, # Обход элементов строки в цикле
...
h a c k e r
>>> "k" in myjob # Найдено
True
>>> "z" in myjob # Не найдено
False
Оператор цикла for присваивает переменной очередной элемент после
довательности (в данном случае – строки) и для каждого элемента вы
полняет одну или более инструкций. В результате переменная c пре
вращается в своего рода курсор, который постепенно перемещается по
строке. Далее в этой книге мы подробнее рассмотрим средства выпол
нения итераций, подобных этим.
Доступ по индексам и извлечение подстроки
Так как строки определены как упорядоченные коллекции символов,
мы можем обращаться к элементам строк по номерам позиций. В язы
ке Python символы извлекаются из строк с помощью операции индек+
сирования – указанием числового смещения требуемого компонента
в квадратных скобках после имени строки. В результате операции вы
получаете строку, состоящую из одного символа, находящегося в ука
занной позиции.
Как и в языке C, в языке Python смещения символов в строках начина
ют исчисляться с 0, а последний символ в строке имеет смещение на
единицу меньше длины строки. Однако, в отличие от C, Python также
позволяет извлекать элементы последовательностей, таких как строки,
192 Глава 7. Строки
используя отрицательные смещения. Технически отрицательное
смещение складывается с длиной строки, чтобы получить положи
тельное смещение. Отрицательные смещения можно также предста
вить себе как отсчет символов с конца строки. Например:
>>> S = 'spam'
>>> S[0], S[
2] # Индексация от начала или от конца
('s', 'a')
>>> S[1:3], S[1:], S[:
1] # Получение среза: извлечение подстроки
('pa', 'pam', 'spa')
В первой строке определяется строка из четырех символов и связыва
ется с именем S. В следующей строке выполняются две операции дос
тупа к элементам по индексам: S[0] возвращает элемент со смещением
0 от начала (односимвольную строку 's'), а S[2] возвращает элемент
со смещением 2 от конца (что эквивалентно смещению (4 + 2) от нача
ла). Смещения и срезы отображаются на элементы последовательно
сти, как показано на рис. 7.1.1
Последняя строка в предыдущем примере демонстрирует операцию
извлечения среза (slicing). Получение среза можно считать некоторой
формой синтаксического анализа, особенно при работе со строками –
она позволяет извлекать целые участки (подстроки) за одно действие.
Операция получения среза может использоваться для извлечения
столбцов данных, обрезания ведущих и завершающих блоков текста
и тому подобного. Позже в этой же главе мы рассмотрим другой при
мер использования операции получения среза для синтаксического ана
лиза строки.
1 Математически более подготовленные читатели (и студенты в моих клас
сах) иногда обнаруживают здесь небольшую асимметрию: самый левый
элемент имеет смещение 0, а самый правый имеет смещение –1. Увы,
в языке Python отсутствует такая вещь, как значение –0.
[начало:конец]
По умолчанию используются начало и конец последовательности
Индексы указывают позиции, в которых будут выполнены «разрезы»
0 1 2 2 1
[ : : ]
S L I С E O F S P A M
Рис. 7.1. Смещения и срезы: положительные смещения отсчитываются
от левого конца (первый элемент имеет смещение 0), а отрицательные
отсчитываются от правого конца (последний элемент имеет смещение –1).
При выполнении операций индексации и получения среза можно
использовать любые виды смещений
Строки в действии 193
Как же выполняется операция получения среза? Когда производится
индексирование объекта последовательности, такого как строка, парой
смещений, разделенных двоеточием, интерпретатор Python возвраща
ет новый объект, содержащий непрерывную область, определяемую па
рой смещений. Значение смещения слева от двоеточия обозначает ле
вую границу (включительно), а справа – верхнюю границу (она не вхо
дит в срез). Интерпретатор извлекает все элементы от нижней границы
до верхней, но верхняя граница в срез не включается. Если левая и пра
вая граница опущены, по умолчанию принимаются значения, равные 0
и длине объекта, из которого извлекается срез, соответственно.
Например, для только что рассмотренного примера выражение S[1:3]
вернет элементы со смещениями 1 и 2. То есть будут извлечены второй
и третий элементы, и операция остановится перед четвертым элемен
том со смещением, равным 3. Выражение S[1:] вернет все элементы,
расположенные за первым, – за значение верхней границы, которая
в выражении опущена, по умолчанию принимается длина строки. На
конец, выражение S[:1] вернет все элементы, кроме последнего, – за
значение нижней границы по умолчанию принимается 0, а индекс –1
соответствует последнему элементу, который в срез не включается.
Все это может показаться на первый взгляд слишком замысловатым,
но операции извлечения отдельных элементов и срезов превратятся
в простые и мощные инструменты, как только вы ими овладеете. Если
вы забыли, как выполняется срез, попробуйте получить его в интерак
тивном сеансе. В следующей главе вы увидите, что существует воз
можность изменить целый раздел определенного объекта одной инст
рукцией, достаточно лишь выполнить операцию присваивания срезу.
Далее приводится краткий обзор для справки:
• Операция индексирования (S[i]) извлекает компоненты по их сме
щениям:
• Первый элемент имеет смещение, равное 0.
• Отрицательные индексы определяют смещения в обратном поряд
ке – от конца, или справа.
• Выражение S[0] извлекает первый элемент.
• Выражение S[2] извлекает второй с конца элемент (так же как
и выражение S[len(S)2]).
• Операция извлечения подстроки (S[i:j]) извлекает непрерывный
раздел последовательности:
• Элемент с индексом, равным верхней границе, не включается
в срез.
• Если границы не указаны, по умолчанию они принимаются рав
ными 0 и длине последовательности.
• Выражение S[1:3] извлекает элементы со смещениями от 1 до 3
(не включая элемент со смещением 3).
194 Глава 7. Строки
• Выражение S[1:] извлекает элементы, начиная со смещения 1
и до конца (длина последовательности).
• Выражение S[:3] извлекает элементы, начиная со смещения 0
и до 3 (не включая его).
• Выражение S[:1] извлекает элементы, начиная со смещения 0
и до последнего (не включая его).
• Выражение S[:] извлекает элементы, начиная со смещения 0
и до конца – это эффективный способ создать поверхностную ко
пию последовательности S.
Последний пункт списка – это самый обычный трюк: с его помощью
создается полная поверхностная копия объекта последовательности, то
есть объект с тем же значением, но расположенный в другой области
памяти (подробнее о копировании объектов рассказывается в главе 9).
Этот прием не очень полезен при работе с неизменяемыми объектами,
такими как строки, но его ценность возрастает при работе с объекта
ми, которые могут изменяться, – такими как списки. В следующей
главе вы узнаете, что синтаксис операции доступа к элементам после
довательности по смещениям (квадратные скобки) также применим
для доступа к элементам словарей по ключам – операции выглядят
одинаково, но имеют разную интерпретацию.
Расширенная операция извлечения подстроки:
третий предел
В версии Python 2.3 в операцию извлечения подстроки была добавлена
поддержка необязательного третьего индекса, используемого как шаг
(иногда называется как шаг по индексу). Величина шага добавляется
к индексу каждого извлекаемого элемента. Полная форма записи опе
рации извлечения подстроки теперь выглядит так: X[I:J:K]. Она озна
чает: «Извлечь все элементы последовательности X, начиная со смеще
ния I, вплоть до смещения J1, с шагом K». Третий предел, K, по умол
чанию имеет значение 1, именно по этой причине в обычной ситуации
извлекаются все элементы среза, слева направо. Однако, если явно
указать значение третьего предела, его можно использовать, чтобы
пропустить некоторые элементы или полностью изменить их порядок.
Например, выражение X[1:10:2] вернет каждый второй элемент после
довательности X в диапазоне смещений от 1 до 9 – то есть будут выбра
ны элементы со смещениями 1, 3, 5, 7 и 9. Как правило, по умолчанию
первый и второй пределы принимают значения 0 и длину последова
тельности соответственно, поэтому выражение X[::2] вернет каждый
второй элемент от начала и до конца последовательности:
>>> S = 'abcdefghijklmnop'
>>> S[1:10:2]
'bdfhj'
>>> S[::2]
'acegikmo'
Строки в действии 195
Можно также использовать отрицательное значение шага. Например,
выражение "hello"[::1] вернет новую строку "olleh". Здесь первые
две границы получают значения по умолчанию – 0 и длина последова
тельности, а величина шага, равная –1, указывает, что срез должен
быть выбран в обратном порядке – справа налево, а не слева направо.
В результате получается перевернутая последовательность:
>>> S = 'hello'
>>> S[::
1]
'olleh'
При использовании отрицательного шага порядок применения пер
вых двух границ меняется на противоположный. То есть выражение
S[5:1:1] извлечет элемент со 2 по 5 в обратном порядке (результат бу
дет содержать элементы последовательности со смещениями 5, 4, 3 и 2):
>>> S = 'abcedfg'
>>> S[5:1:
1]
'fdec'
Пропуск элементов и изменение порядка их следования – это наиболее
типичные случаи использования операции получения среза с тремя
пределами. За более подробной информацией вам следует обратиться
к руководству по стандартной библиотеке языка Python или поэкспе
риментировать в интерактивной оболочке – это расширит ваши пред
ставления о срезах по сравнению с объемом, который мы можем охва
тить здесь. Мы еще вернемся к операции получения среза с тремя пре
делами далее в этой книге, когда будем рассматривать ее в соединении
с оператором цикла for.
Инструменты преобразования строк
Один из девизов языка Python – не поддаваться искушению предпола
гать, что имелось в виду. Например, Python не позволит сложить стро
ку и число, даже если строка выглядит как число (то есть содержит
только цифры):
>>> "42" + 1
TypeError: cannot concatenate 'str' and 'int' objects
(TypeError: невозможно объединить объекты 'str' и 'int')
В соответствии с архитектурой языка оператор + может означать и опе
рацию сложения, и операцию конкатенации, вследствие чего выбор
типа преобразования становится неочевидным. Поэтому интерпрета
тор воспринимает такую инструкцию как ошибочную. Вообще в языке
Python отвергается любая магия, которая может осложнить жизнь
программиста.
Как же быть, если сценарий получает число в виде текстовой строки
из файла или от пользовательского интерфейса? В этом случае следует
использовать инструменты преобразования, чтобы можно было интер
претировать строку как число или наоборот. Например:
196 Глава 7. Строки
>>> int("42"), str(42) # Преобразование в/из строки
(42, '42')
>>> repr(42), `42` # Преобразование в строку, как если бы она была
('42', '42') # программным кодом
Функция int преобразует строку в число, а функция str преобразует
число в строковое представление (по сути – в то, что выводится на эк
ран). Функция repr и прежний ее эквивалент, обратные апострофы,
также преобразуют объект в строковое представление, но они возвра
щают объект в виде строки программного кода, который можно выпол
нить, чтобы воссоздать объект (если объект – строка, то результат, вы
веденный инструкцией print, будет включать кавычки, окружающие
строку). Подробнее о различиях между функциями str и repr можно
прочитать во врезке «Форматы представления repr и str», в главе 5.
Кроме того, функции int и str изначально предназначены для выпол
нения преобразований.
Вы не сможете смешивать строковые и числовые типы в таких опера
торах, как +, но вы можете вручную выполнить необходимые преобра
зования операндов перед выполнением операции:
>>> S = "42"
>>> I = 1
>>> S + I
TypeError: cannot concatenate 'str' and 'int' objects
>>> int(S) + I # Операция сложения
43
>>> S + str(I) # Операция конкатенации
'421'
Придется держать в уме: срезы
Повсюду в этой книге я буду включать аналогичные врезки с опи
санием наиболее типичных случаев использования рассматри
ваемых особенностей языка на практике. Поскольку у вас нет
возможности осознать реальный потенциал языка, пока вы не
увидите большую часть картины, эти врезки будут содержать
множество упоминаний тем, незнакомых для вас. Поэтому вам
следует воспринимать эти сведения как предварительное зна
комство со способами, которые связывают абстрактные концеп
ции языка с решением наиболее распространенных задач про
граммирования.
Например, далее вы увидите, что аргументы командной строки,
переданные сценарию на языке Python при запуске, доступны
в виде атрибута argv встроенного модуля sys:
Строки в действии 197
Существуют похожие встроенные функции для преобразования чисел
с плавающей точкой в/из строки:
>>> str(3.1415), float("1.5")
('3.1415', 1.5)
>>> text = "1.234E
10"
>>> float(text)
1.2340000000000001e010
Позднее мы познакомимся со встроенной функцией eval – она выпол
няет строку, содержащую программный код на языке Python, и пото
му может выполнять преобразование строки в объект любого вида.
# File echo.py
import sys
print sys.argv
% python echo.py 
a 
b 
c
['echo.py', 'a', 'b', 'c']
Обычно вас будут интересовать только параметры, которые сле
дуют за именем программы. Это приводит нас к типичному ис
пользованию операции получения среза (или, что то же самое,
извлечения подстроки): мы можем с помощью единственной ин
струкции получить все элементы списка, за исключением перво
го. В данном случае выражение sys.argv[1:] вернет требуемый
список ['a', 'b', 'c']. После этого список можно обрабаты
вать по своему усмотрению, не заботясь о присутствии имени
программы в начале.
Кроме того, операция получения среза часто используется для
удаления лишних символов из строк, считываемых из файлов.
Если известно, что строки всегда завершаются символом новой
строки (символ \n), его можно удалить однимединственным вы
ражением – line[:1], которое возвращает все символы строки,
кроме последнего (нижняя граница по умолчанию принимается
равной 0). В обоих случаях операция извлечения подстроки
обеспечивает логику выполнения, которую в низкоуровневых
языках программирования пришлось бы реализовывать явно.
Обратите внимание: для удаления символа новой строки часто
предпочтительнее использовать функцию line.rstrip, потому
что она не повреждает строки, в которых отсутствует символ но
вой строки в конце, – типичный случай при создании текстовых
файлов некоторыми текстовыми редакторами. Операция извле
чения подстроки применима, только если вы полностью увере
ны, что строки завершаются корректным образом.
198 Глава 7. Строки
Функции int и float преобразуют только числа, но это ограничение оз
начает, что они обычно выполняют эту работу быстрее (и безопаснее,
потому что они не принимают программный код произвольного выра
жения). Как было показано в главе 5, выражение форматирования
строки также обеспечивает возможность преобразования чисел в стро
ки. Форматирование будет обсуждаться ниже, в этой же главе.
Преобразование кодов символов
Возможно также выполнить преобразование одиночного символа в его
целочисленный код ASCII, для чего нужно передать этот символ функ
ции ord – она возвращает фактическое числовое значение соответст
вующего байта в памяти. Обратное преобразование выполняется с по
мощью функции chr, она получает целочисленный код ASCII и преоб
разует его в соответствующий символ:
>>> ord('s')
115
>>> chr(115)
's'
Эти функции можно применить ко всем символам строки в цикле. Они
могут также использоваться для реализации своего рода строковой ма
тематики. Например, чтобы получить следующий по алфавиту сим
вол, его можно преобразовать в число и выполнить математическое
действие над ним:
>>> S = '5'
>>> S = chr(ord(S) + 1)
>>> S
'6'
>>> S = chr(ord(S) + 1)
>>> S
'7'
Следующий пример преобразования представляет собой альтернативу
встроенной функции int, по крайней мере для односимвольных строк,
для преобразования строки в целое число:
>>> int('5')
5
>>> ord('5') 
 ord('0')
5
Такие преобразования могут использоваться в сочетании с оператором
цикла – для получения целочисленных значений из строковых пред
ставлений двоичных чисел – в каждой итерации текущее значение ум
ножается на 2 и затем к нему прибавляется числовое значение следую
щей цифры:
>>> B = '1101'
>>> I = 0
>>> while B:
Строки в действии 199
... I = I * 2 + (ord(B[0]) 
 ord('0'))
... B = B[1:]
...
>>> I
13
Оператор побитового сдвига влево (I << 1) мог бы дать тот же эффект,
что и операция умножения на 2. Но, пока мы еще не познакомились
с циклами, оставим реализацию этого упражнения как есть.
Изменение строк
Помните термин «неизменяемая последовательность»? Слово «неиз
меняемая» означает, что вы не можете изменить содержимое самой
строки в памяти (то есть невозможно изменить элемент строки, выпол
нив присваивание по индексу):
>>> S = 'spam'
>>> S[0] = "x"
Возникает ошибка!
Тогда каким образом в языке Python производить изменение тексто
вой информации? Чтобы изменить строку, необходимо создать новую
строку с помощью таких операций, как конкатенация и извлечение
подстроки, и затем, если это необходимо, присвоить результат перво
начальному имени:
>>> S = S + 'SPAM!' # Чтобы изменить строку, нужно создать новую
>>> S
'spamSPAM!'
>>> S = S[:4] + 'Burger' + S[
1]
>>> S
'spamBurger!'
Первый пример добавляет подстроку в конец строки S с помощью опе
рации конкатенации. В действительности здесь создается новая стро
ка, которая затем присваивается имени S, но вы можете представить
себе это действие как «изменение» первоначальной строки. Второй
пример замещает четыре символа шестью новыми – с помощью опера
ций извлечения подстроки и конкатенации. Как будет показано далее
в этой главе, похожего эффекта можно добиться с помощью строково
го метода replace. Вот как это выглядит:
>>> S = 'splot'
>>> S = S.replace('pl', 'pamal')
>>> S
'spamalot'
Как и всякая операция, создающая новую строку, строковые методы
создают новые строковые объекты. Если вам необходимо сохранить
эти объекты, вы можете присвоить их переменной. Создание нового
объекта строки для каждого изменения – операция не столь неэффек
200 Глава 7. Строки
тивная, как может показаться, – вспомните, в предыдущей главе гово
рилось, что интерпретатор автоматически производит сборку мусора
(освобождает память, занятую неиспользуемыми строковыми объек
тами), поэтому новые объекты повторно используют память, ранее за
нятую прежними значениями. Интерпретатор Python во многих слу
чаях работает гораздо быстрее, чем можно было бы ожидать.
Наконец, дополнительно существует возможность сборки текстовых
значений с помощью выражений форматирования строк:
>>> 'That is %d %s bird!' % (1, 'dead') # Напоминает функцию sprintf в языке C
That is 1 dead bird!
Это очень мощная операция! В следующем разделе рассказывается
о том, как она работает.
Форматирование строки
В языке Python имеется двухместный оператор %, предназначенный
для работы со строками (вы можете вспомнить, что для чисел он еще
является оператором деления по модулю или получения остатка от де
ления). Когда этот оператор применяется к строкам, он играет роль
функции sprintf в языке C и обеспечивает простой способ форматиро
вания значений в строке согласно заданной строке формата. Проще го
воря, оператор % обеспечивает возможность компактной записи про
граммного кода, выполняющего множественную подстановку строк.
Чтобы отформатировать строку, требуется:
1. Слева от оператора % указать строку формата, содержащую один
или более спецификатор формата, каждый из которых начинается
с символа % (например, %d).
2. Справа от оператора % указать объект (или объекты, в круглых
скобках), которые будут подставляться на место спецификатора
(или спецификаторов) в левой части выражения.
Например, в последнем примере предыдущего раздела мы видели, что
целое число 1 подставляется на место спецификатора %d в строке фор
мата, расположенной в левой части выражения, а строка "dead" под
ставляется на место спецификатора %s. В результате получается новая
строка, которая содержит эти две подстановки.
Строго говоря, выражения форматирования строк не являются абсо
лютно необходимыми – все, что можно сделать с их помощью, точно
так же можно сделать с помощью серии преобразований и операций
конкатенации. Однако операция форматирования позволяет объеди
нить множество шагов в одной инструкции. Мощные возможности
этой операции заслуживают того, чтобы рассмотреть еще несколько
примеров:
>>> exclamation = "Ni"
Форматирование строки 201
>>> "The knights who say %s!" % exclamation
'The knights who say Ni!'
>>> "%d %s %d you" % (1, 'spam', 4)
'1 spam 4 you'
>>> "%s 

 %s 

 %s" % (42, 3.14159, [1, 2, 3])
'42  3.14159  [1, 2, 3]'
В первом примере строка "Ni" подключается к целевой строке слева,
замещая спецификатор %s. Во втором примере в целевую строку встав
ляются три значения. Обратите внимание: когда вставляется более од
ного значения, в правой части выражения их необходимо сгруппиро
вать с помощью круглых скобок (то есть создать из них кортеж).
В третьем примере также вставляются три значения – целое число,
объект числа с плавающей точкой и объект списка, но, обратите вни
мание, что в левой части выражения всем значениям соответствует
спецификатор %s, который соответствует операции преобразования
в строку. Объекты любого типа могут быть преобразованы в строку (это
происходит, например, при выводе на экран), поэтому для любого объ
екта может быть указан спецификатор %s. Вследствие этого вам не при
дется выполнять специальное форматирование, в большинстве случаев
вам достаточно будет знать только о существовании спецификатора %s.
Имейте в виду, что выражение форматирования всегда создает новую
строку, а не изменяет строку, расположенную в левой части. Посколь
ку строки являются неизменяемыми, этот оператор вынужден рабо
тать именно таким способом. Как уже говорилось ранее, если вам тре
буется сохранить полученный результат, присвойте его переменной.
Дополнительные возможности форматирования строки
Для реализации более сложного форматирования в выражениях форма
тирования можно использовать любые спецификаторы формата, пред
ставленные в табл. 7.3. Большинство из них окажутся знакомы про
граммистам, использовавшим язык C, потому что операция форматиро
вания строк в языке Python поддерживает все наиболее типичные спе
цификаторы формата, которые допускается использовать в функции
printf языка C (в отличие от которой выражение в языке Python возвра
щает результат, а не выводит его на экран). Некоторые спецификаторы
из табл. 7.3 предоставляют альтернативные способы форматирования
данных одного и того же типа, например, %e, %f и %g обеспечивают аль
тернативные способы форматирования чисел с плавающей точкой.
Фактически спецификаторы формата в левой части выражения под
держивают целый набор операций преобразования с достаточно слож
ным собственным синтаксисом. В общем виде синтаксис использова
ния спецификатора формата выглядит следующим образом:
%[(name)][flags][width][.precision]code
202 Глава 7. Строки
Таблица 7.3. Спецификаторы формата
Символ спецификатора формата (code) из табл. 7.3 располагается в са
мом конце. Между символом % и символом спецификатора можно до
бавлять следующую информацию: ключ в словаре (name); список фла
гов (flags), которые могут определять, например, признак выравнива
ния (), знак числа (+), наличие ведущих нулей (0); общую ширину по
ля и число знаков после десятичной точки и многое другое.
Полное описание синтаксиса спецификаторов формата вы найдете
в стандартном руководстве по языку Python, а сейчас для демонстра
ции наиболее типичных случаев их использования приведем несколь
ко примеров. В первом примере сначала применяется форматирование
целого числа с параметрами по умолчанию, а затем целое число выво
дится в поле шириной в шесть символов, с выравниванием по левому
краю и с дополнением ведущими нулями:
>>> x = 1234
>>> res = "integers: ...%d...%
6d...%06d" % (x, x, x)
>>> res
'integers: ...1234...1234 ...001234'
Спецификаторы %e, %f и %g отображают числа с плавающей точкой раз
ными способами, как демонстрируется в следующем примере:
>>> x = 1.23456789
>>> x
Спецификатор Назначение
%s Строка (или любой объект)
%r s, но использует функцию repr, а не str
%c Символ
%d Десятичное (целое) число
%i Целое число
%u Целое число без знака
%o Восьмеричное целое число
%x Шестнадцатеричное целое число
%X x, но шестнадцатеричные цифры возвращаются в верхнем ре
гистре
%e Число с плавающей точкой в экспоненциальной форме
%E e, но алфавитные символы возвращаются в верхнем регистре
%f Число с плавающей точкой в десятичном представлении
%g Число с плавающей точкой e или f
%G Число с плавающей точкой E или f
%% Символ %
Форматирование строки 203
1.2345678899999999
>>> '%e | %f | %g' % (x, x, x)
'1.234568e+000 | 1.234568 | 1.23457'
Для чисел с плавающей точкой можно реализовать дополнительные
эффекты форматирования, указав необходимость выравнивания по ле
вому краю, знак числа, ширину поля и число знаков после десятичной
точки. Для простых задач можно было бы использовать простые функ
ции преобразования чисел в строки с применением выражения форма
тирования или встроенной функции str, продемонстрированной ранее:
>>> '%
6.2f | %05.2f | %+06.1f' % (x, x, x)
'1.23 | 01.23 | +001.2'
>>> "%s" % x, str(x)
('1.23456789', '1.23456789')
Форматирование строк из словаря
Операция форматирования позволяет также использовать в специфи
каторах формата ключи словаря, который указывается в правой части
выражения, для извлечения соответствующих значений. Мы пока не
много говорили о словарях, поэтому следующий пример демонстриру
ет самый простой случай:
>>> "%(n)d %(x)s" % {"n":1, "x":"spam"}
'1 spam'
В данном случае (n) и (x) в строке формата ссылаются на ключи в сло
варе в правой части выражения и служат для извлечения соответст
вующих им значений. Этот прием часто используется в программах,
создающих код разметки HTML или XML, – вы можете построить сло
варь значений и затем подставить их все одним выражением формати
рования, которое использует ключи:
>>> reply = """
Greetings...
Hello %(name)s!
Your age squared is %(age)s
"""
>>> values = {'name': 'Bob', 'age': 40}
>>> print reply % values
Greetings...
Hello Bob!
Your age squared is 40
Этот способ также часто используется в комбинации со встроенной
функцией vars, которая возвращает словарь, содержащий все перемен
ные, существующие на момент ее вызова:
>>> food = 'spam'
>>> age = 40
204 Глава 7. Строки
>>> vars()
{'food': 'spam', 'age': 40, ...и еще множество других... }
Если применить эту функцию в правой части оператора форматирова
ния, можно отформатировать значения, обращаясь к ним по именам
переменных (то есть по ключам словаря):
>>> "%(age)d %(food)s" % vars()
'40 spam'
Словари во всех подробностях мы будем изучать в главе 8. А в главе 5
вы найдете примеры использования спецификаторов %x и %o для преоб
разования значений в шестнадцатеричное и восьмеричное строковое
представление.
Строковые методы
В дополнение к операторам выражений строки предоставляют набор
методов, реализующих более сложные операции обработки текста.
Методы – это простые функции, которые связаны с определенными
объектами. Формально они являются атрибутами, присоединенными
к объектам, которые ссылаются на функции. В языке Python методы
являются специфичными для типов объектов: строковые методы, на
пример, работают только с строковыми объектами.
Если говорить более точно, функции – это пакеты программного кода,
а вызовы методов объединяют в себе выполнение двух операций (из
влечение атрибута и вызов функции).
Извлечение атрибута
Выражение в форме object.attribute означает: «извлечь значение
атрибута attribute из объекта object».
Вызов функции
Выражение в форме function(arguments) означает: «вызвать про
граммный код функции function, передав ему ноль или более объек
товаргументов, разделенных запятыми, и вернуть значение функ
ции».
Объединение этих двух действий позволяет вызвать метод объекта.
Выражение вызова метода object.method(arguments) вычисляется слева
направо, то есть интерпретатор сначала извлекает метод объекта, а за
тем вызывает его, передавая ему входные аргументы. Если метод воз
вращает какойлибо результат, он становится результатом всего выра
жения вызова метода.
Как будет много раз показано в этой части книги, большинство объек
тов обладает методами, которые можно вызвать, и все они доступны
с использованием одного и того же синтаксиса вызова метода. Чтобы
вызвать метод объекта, вам потребуется существующий объект. Да
вайте перейдем к рассмотрению некоторых примеров.
Строковые методы 205
Примеры использования строковых методов:
изменение строк
В табл. 7.4 приводятся шаблоны вызова встроенных строковых методов
(более полный и обновленный перечень методов вы найдете в руковод
стве по стандартной библиотеке языка Python или воспользовавшись
функцией help в интерактивной оболочке, передав ей любую строку).
Строковые методы, представленные в этой таблице, реализуют высоко
уровневые операции, такие как разбиение и слияние, преобразование
регистра символов, проверка типа содержимого и поиск подстроки.
Таблица 7.4. Строковые методы
Теперь давайте поработаем над программным кодом, который демон
стрирует некоторые наиболее часто используемые методы в действии
и попутно иллюстрирует основные приемы обработки текста, приме
няемые в языке Python. Как уже говорилось ранее, строки являются
неизменяемыми объектами, поэтому их невозможно изменить непо
средственно. Чтобы из существующей строки сконструировать новое
текстовое значение, необходимо создать новую строку с помощью та
ких операций, как извлечение подстроки и конкатенация. Например,
чтобы изменить два символа в середине строки, можно использовать
такой способ:
>>> S = 'spammy'
>>> S = S[:3] + 'xx' + S[5:]
S.capitalize() S.ljust(width)
S.center(width) S.lower()
S.count(sub [, start [, end]]) S.lstrip()
S.encode([encoding [,errors]]) S.replace(old, new [, maxsplit])
S.endswith(suffix [, start [, end]]) S.rfind(sub [,start [,end]])
S.expandtabs([tabsize]) S.rindex(sub [, start [, end]])
S.find(sub [, start [, end]]) S.rjust(width)
S.index(sub [, start [, end]]) S.rstrip()
S.isalnum() S.split([sep [,maxsplit]])
S.isalpha() S.splitlines([keepends])
S.isdigit() S.startswith(prefix [, start [, end]])
S.islower() S.strip()
S.isspace() S.swapcase()
S.istitle() S.title()
S.isupper() S.translate(table [, delchars])
S.join(seq) S.upper()
206 Глава 7. Строки
>>> S
'spaxxy'
При этом, если требуется только заменить подстроку, можно восполь
зоваться методом replace:
>>> S = 'spammy'
>>> S = S.replace('mm', 'xx')
>>> S
'spaxxy'
Метод replace является более универсальным, чем предполагает этот
программный код. Он принимает в качестве аргумента оригинальную
подстроку (любой длины) и строку (любой длины) замены и выполняет
глобальный поиск с заменой:
>>> 'aa$bb$cc$dd'.replace('$', 'SPAM')
'aaSPAMbbSPAMccSPAMdd'
В этой роли метод replace может использоваться как инструмент реа
лизации поиска с заменой по шаблону (например, замены символов
формата). Обратите внимание, что на этот раз мы просто выводим ре
зультат на экран, а не присваиваем его переменной – присваивать ре
зультат переменной необходимо только в том случае, если потребуется
сохранить результат дальнейшего использования.
Если необходимо заменить одну подстроку фиксированного размера,
которая может появиться в любом месте, можно также выполнить опе
рацию замены или отыскать подстроку с помощью метода find и затем
воспользоваться операциями извлечения подстроки:
>>> S = 'xxxxSPAMxxxxSPAMxxxx'
>>> where = S.find('SPAM') # Поиск позиции
>>> where # Подстрока найдена со смещением 4
4
>>> S = S[:where] + 'EGGS' + S[(where+4):]
>>> S
'xxxxEGGSxxxxSPAMxxxx'
Метод find возвращает смещение, по которому найдена подстрока (по
умолчанию поиск начинается с начала строки), или значение 1, если
искомая подстрока не найдена. Другой вариант использования метода
replace заключается в передаче третьего аргумента, который опреде
ляет число производимых замен:
>>> S = 'xxxxSPAMxxxxSPAMxxxx'
>>> S.replace('SPAM', 'EGGS') # Заменить все найденные подстроки
'xxxxEGGSxxxxEGGSxxxx'
>>> S.replace('SPAM', 'EGGS', 1) # Заменить одну подстроку
'xxxxEGGSxxxxSPAMxxxx'
Обратите внимание: метод replace возвращает новую строку. Так как
строки являются неизменяемыми, методы никогда в действительно
Строковые методы 207
сти не изменяют оригинальную строку, даже если они называются
«replace» (заменить)!
Тот факт, что операция конкатенации и метод replace всякий раз соз
дают новые строковые объекты, может оказаться недостатком их ис
пользования для изменения строк. Если в сценарии производится
множество изменений длинных строк, вы можете повысить произво
дительность сценария, преобразовав строку в объект, который допус
кает внесение изменений:
>>> S = 'spammy'
>>> L = list(S)
>>> L
['s', 'p', 'a', 'm', 'm', 'y']
Встроенная функция list (или функцияконструктор объекта) создает
новый список из элементов любой последовательности – в данном слу
чае «разрывая» строку на символы и формируя из них список. Обла
дая строкой в таком представлении, можно производить необходимые
изменения, не вызывая создания новой копии строки при каждом из
менении:
>>> L[3] = 'x' # Этот прием допустим для списков, но не для строк
>>> L[4] = 'x'
>>> L
['s', 'p', 'a', 'x', 'x', 'y']
Если после внесения изменений необходимо выполнить обратное пре
образование (чтобы, например, записать результат в файл), можно ис
пользовать метод join, который «собирает» список обратно в строку:
>>> S = ''.join(L)
>>> S
'spaxxy'
Метод join на первый взгляд может показаться немного странным.
Так как он является строковым методом (а не методом списка), он вы
зывается через указание желаемой строкиразделителя. Метод join
объединяет строки из списка, вставляя строкуразделитель между
элементами списка. В данном случае при получении строки из списка
используется пустая строкаразделитель. В более общем случае можно
использовать произвольную строкуразделитель:
>>> 'SPAM'.join(['eggs', 'sausage', 'ham', 'toast'])
'eggsSPAMsausageSPAMhamSPAMtoast'
Примеры методов строк: разбор текста
Еще одна распространенная роль, которую играют методы строк, – это
простейший разбор текста, то есть анализ структуры и извлечение
подстрок. Для извлечения подстрок из фиксированных смещений
можно использовать прием извлечения срезов:
208 Глава 7. Строки
>>> line = 'aaa bbb ccc'
>>> col1 = line[0:3]
>>> col3 = line[8:]
>>> col1
'aaa'
>>> col3
'ccc'
В этом примере поля данных располагаются в фиксированных позици
ях и потому могут быть легко извлечены из оригинальной строки.
Этот прием может использоваться, только если анализируемые компо
ненты располагаются в известных фиксированных позициях. Если
для разделения полей используется некоторый разделитель, можно
воспользоваться методом разбиения строки на компоненты. Этот при
ем используется, когда искомые данные могут располагаться в произ
вольных позициях внутри строки:
>>> line = 'aaa bbb ccc'
>>> cols = line.split()
>>> cols
['aaa', 'bbb', 'ccc']
Строковый метод split преобразует строку в список подстрок, окру
жающих строкиразделители. В предыдущем примере мы не указали
строкуразделитель, поэтому в данном случае по умолчанию в качест
ве разделителей принимаются пробельные символы – строка разбива
ется на группы по символам пробела, табуляции или перевода строки,
и в результате мы получили список подстрок. В других случаях дан
ные могут отделяться другими разделителями. В следующем примере
производится разбиение (и, следовательно, разбор) строки по символу
запятой, который обычно используется для отделения данных, извле
ченных из баз данных:
>>> line = 'bob,hacker,40'
>>> line.split(',')
['bob', 'hacker', '40']
Разделители могут содержать более одного символа:
>>> line = "i'mSPAMaSPAMlumberjack"
>>> line.split("SPAM")
["i'm", 'a', 'lumberjack']
Хотя оба способа, основанные на извлечении подстрок и разбиении
строк, имеют определенные ограничения, они работают достаточно
быстро и могут использоваться для разбора текстовой информации
в простых случаях.
Другие часто используемые методы строк в действии
Другие строковые методы имеют более специфическое предназначение,
например, удаляют пробельные символы в конце текстовой строки, вы
Строковые методы 209
полняют преобразование регистра символов, проверяют характер со
держимого строки и проверяют наличие подстроки в конце строки:
>>> line = "The knights who sy Ni!\n"
>>> line.rstrip()
'The knights who sy Ni!'
>>> line.upper()
'THE KNIGHTS WHO SY NI!\n'
>>> line.isalpha()
False
>>> line.endswith('Ni!\n')
True
Для достижения тех же результатов в некоторых случаях могут исполь
зоваться альтернативные приемы – с использованием оператора провер
ки вхождения in можно проверить присутствие подстроки, например,
а функция получения длины строки и операция извлечения подстроки
могут использоваться для имитации действия функции endswith:
>>> line
'The knights who sy Ni!\n'
>>> line.find('Ni') != 
1 # Поиск с использованием вызова метода или выражения
True
>>> 'Ni' in line
True
>>> sub = 'Ni!\n'
>>> line.endswith(sub) # Проверка наличия подстроки в конце строки
True # с помощью метода или операции извлечения подстроки
>>> line[
len(sub):] == sub
True
Для работы со строками существует достаточно много методов, однако
мы не будем рассматривать их все. Некоторые методы вы увидите да
лее в этой книге, а за дополнительной информацией вы можете обра
титься к руководству по библиотеке языка Python и другим источни
кам информации или просто поэкспериментировать с ними в интерак
тивном режиме.
Обратите внимание: ни один из строковых методов не поддерживает
шаблоны, для обработки текста с использованием шаблонов необходи
мо использовать модуль re, входящий в состав стандартной библиоте
ки языка Python, – дополнительный инструмент, начальные сведения
о котором приводились в главе 4, а полное его обсуждение выходит да
леко за рамки этой книги. Тем не менее, несмотря на это ограничение,
строковые методы иногда оказываются эффективнее, чем функции
модуля re.
Оригинальный модуль string
История развития строковых методов достаточно запутанна. В тече
ние первого десятилетия существования Python в состав стандартной
210 Глава 7. Строки
библиотеки входил модуль string, который содержал функции, во
многом напоминающие современные строковые методы. В ответ на
требования пользователей в версии Python 2.0 эти функции были пре
образованы в методы строковых объектов. Однако изза большого
объема программного кода, уже написанного к тому времени, ориги
нальный модуль string был сохранен для обеспечения обратной со
вместимости.
Ныне вы должны использовать не оригинальный модуль string, а при
менять строковые методы. Фактически, как предполагается, ориги
нальные строковые функции, соответствующие методам, будут убра
ны из состава стандартной библиотеки языка Python в версии 3.0, ко
торая должна быть выпущена после выхода в свет этого издания. Од
нако, поскольку использование модуля string еще можно встретить
в старом программном коде, мы коротко рассмотрим его.
В версии Python 2.5 попрежнему существует два способа использова
ния расширенных операций над строками: посредством вызова мето
дов и вызовом функций модуля string, которым в качестве аргумента
передается объект строки. Например, допустим, что переменная X ссы
лается на объект строки, тогда вызов метода объекта будет выглядеть
следующим образом:
X.method(arguments)
что эквивалентно вызову аналогичной функции из модуля string
(представим, что этот модуль уже был импортирован):
string.method(X, arguments)
В следующем примере демонстрируется порядок использования метода:
>>> S = 'a+b+c+'
>>> x = S.replace('+', 'spam')
>>> x
'aspambspamcspam'
Чтобы выполнить ту же самую операцию с помощью модуля string, не
обходимо импортировать модуль (по крайней мере, один раз) и пере
дать функции объект:
>>> import string
>>> y = string.replace(S, '+', 'spam')
>>> y
'aspambspamcspam'
Поскольку подход, основанный на применении модуля, был стандар
том на протяжении многих лет, а строки являются одним из централь
ных компонентов большинства программ, при анализе существующих
программ вам в программном коде наверняка встретятся оба варианта
работы со строками.
И, тем не менее, при создании новых программ вместо функций уста
ревшего модуля вы должны использовать строковые методы. Для это
Общие категории типов 211
го есть и другие серьезные основания помимо того, что многие функ
ции модуля string будут исключены из состава стандартной библиоте
ки с выходом Python 3.0. Одна из таких причин – схема вызова модуля
требует от вас импортировать модуль string (при использовании стро
ковых методов ничего импортировать не нужно). Другая причина за
ключается в том, что при использовании функций модуля с клавиату
ры приходится вводить на несколько символов больше (когда модуль
загружается с использованием инструкции import, а не from). И нако
нец, функции модуля выполняются несколько медленнее, чем методы
(в настоящее время функции модуля отображаются на вызовы мето
дов, в результате чего производятся дополнительные вызовы).
Оригинальный модуль string скорее всего останется в составе Python
3.0, потому что в нем присутствуют дополнительные средства работы
со строками, включая предопределенные строковые константы и сис
тему шаблонных объектов (которая не описывается в этой книге; за
дополнительной информацией обращайтесь к руководству по библио
теке языка Python). Если вы не хотите модифицировать свой про
граммный код после выхода версии 3.0, вы должны смотреть на базо
вые строковые функции как на призраки прошлого.
Общие категории типов
Теперь, когда мы исследовали строки, первый объект из коллекции
языка Python, сделаем паузу, чтобы дать определение некоторым об
щим концепциям, применимым к большинству типов, которые будут
рассматриваться дальше. Оказывается, что операции над встроенны
ми типами работают одинаково в случае применения их к типам одной
категории, поэтому нам необходимо лишь определить эти категории.
К настоящему моменту мы исследовали только числа и строки, но так
как они относятся к двум из трех основных категорий в языке Python,
то вы знаете о других типах гораздо больше, чем могли бы подумать.
Типы одной категории имеют общий набор операций
Как вы уже знаете, строки представляют собой неизменяемые последо
вательности: они не могут быть изменены непосредственно (неизменяе+
мые) и являются упорядоченными коллекциями элементов, доступ
к которым может осуществляться по величине смещения (последова+
тельности). Оказывается, над последовательностями, которые мы бу
дем рассматривать в этой части книги, могут выполняться те же опера
ции, которые были продемонстрированы в этой главе, – конкатенация,
доступ к элементам по индексам, обход элементов в цикле и т. д. Фор
мально в языке Python существует три категории типов (и операций):
Числа
Поддерживают операции сложения, умножения и т. д.
212 Глава 7. Строки
Последовательности
Поддерживают операции индексации, извлечения среза, конкате
нации и т. д.
Отображения
Поддерживают операцию индексации по ключу и т. д.
Мы еще не рассматривали подробно отображения (словари обсуждают
ся в следующей главе), но к другим типам, которые нам встретятся,
в основном будут применимы одни и те же операции. Например, для
любых объектов последовательностей X и Y:
• Выражение X + Y создает новый объект последовательности, вклю
чающий содержимое обоих операндов.
• Выражение X * N создает новый объект последовательности, вклю
чающий N копий операнда X.
Другими словами, эти операции действуют одинаково на любые виды
последовательностей, включая строки, списки, кортежи и некоторые
типы, определяемые пользователем. Единственное отличие состоит
в том, что результат, возвращаемый выражением, имеет тот же тип, что
и операнды X и Y, то есть, если выполняется операция конкатенации
списков, то возвращается новый список, а не строка. Операции индекса
ции и извлечения среза одинаково работают для любых последователь
ностей – тип объекта определяет, какая задача должна быть решена.
Изменяемые типы допускают
непосредственное изменение
Классификация по возможности изменения – это существенное огра
ничение, чтобы не помнить о нем, и все же она часто сбивает с толку
начинающих программистов. Если объект является неизменяемым
типом, вы не сможете изменить его значение непосредственно – в этом
случае интерпретатор будет выдавать сообщение об ошибке. Вместо
этого необходимо, чтобы программный код создавал новый объект, со
держащий новое значение. Вообще неизменяемые типы обеспечивают
определенный уровень поддержки целостности, гарантируя, что объ
ект не подвергнется изменениям в другой части программы. Чтобы
вспомнить, почему это имеет такое большое значение, вернитесь к дис
куссии о разделяемых ссылках на объекты в главе 6.
В заключение
В этой главе мы подробно рассмотрели строковый тип объектов. Мы
узнали о строковых литералах и исследовали операции над строками,
включая операции над последовательностями, форматирование и ме
тоды. Попутно мы подробно изучили различные концепции, такие как
извлечение среза, вызовы методов и блоки строк в тройных кавычках.
Закрепление пройденного 213
Кроме того, мы определили некоторые идеи, общие для различных ти
пов: последовательности, к примеру, поддерживают общий набор опе
раций. В следующей главе мы продолжим наши исследования и рас
смотрим наиболее типичные коллекции объектов в языке Python –
списки и словари. Там вы увидите, что многое из того, что говорилось
здесь, применимо и к этим двум типам. Но перед этим ответьте на кон
трольные вопросы главы, которые помогут вам закрепить сведения,
полученные здесь.
Закрепление пройденного
Контрольные вопросы
1. Можно ли использовать строковый метод find для поиска в спи
сках?
2. Можно ли применить выражение извлечения среза к спискам?
3. Как бы вы преобразовали символы в соответствующие им целочис
ленные коды ASCII? Как бы вы выполнили обратное преобразова
ние – из кодов в символы?
4. Как бы вы реализовали изменение строки на языке Python?
5. Допустим, что имеется строка S со значением "s,pa,m". Укажите два
способа извлечения двух символов в середине строки.
6. Сколько символов в строке "a\nb\x1f\000d"?
7. По каким причинам вы могли бы использовать модуль string вме
сто строковых методов?
Ответы
1. Нет, потому что методы всегда зависят от типа объекта. То есть, они
могут применяться только к одному определенному типу данных.
Но выражения являются более универсальными и могут использо
ваться для выполнения операций над различными типами. В этом
случае, к примеру, оператор проверки вхождения in имеет похо
жий эффект и может использоваться для поиска как в строках, так
и в списках.
2. Да. В отличие от методов, выражения универсальны и могут ис
пользоваться для выполнения операций над различными типами.
В данном случае операция извлечения среза в действительности яв
ляется операцией над последовательностями – она может приме
няться к любому типу последовательностей, включая строки, спи
ски и кортежи. Различие состоит лишь в том, что при выполнении
операции над списком в результате будет получен новый список.
3. Встроенная функция ord(S) преобразует односимвольную строку
в целочисленный код. Функция chr(I) преобразует целочисленный
код в символ.
214 Глава 7. Строки
4. Строки невозможно изменить – они являются неизменяемыми. Од
нако подобного эффекта можно добиться, создав новую строку, –
выполнив операцию конкатенации, извлечения среза, форматиро
вания или вызвав метод, такой как replace, – и затем присвоив ре
зультат первоначальной переменной.
5. Можно извлечь подстроку с помощью выражения S[2:4] или, раз
бив строку по запятым, извлечь строку с помощью выражения
S.split(',')[1]. Попробуйте выполнить эти выражения в интерак
тивном сеансе, чтобы получить представление о том, как они дейст
вуют.
6. Шесть. Строка "a\nb\x1f\000d" содержит следующие символы: a, сим
вол новой строки (\n), b, символ с десятичным кодом 31 (\x1f –
в шестнадцатеричном представлении), символ с кодом 0 (\000 –
в восьмеричном представлении) и d. Передайте строку встроенной
функции len, чтобы проверить этот ответ, и выведите результаты
преобразования каждого символа с помощью функции ord, чтобы
увидеть фактические значения кодов символов. За более подробной
информацией обращайтесь к табл. 7.2.
7. Вам не следует использовать модуль string. При создании новых
программ следует использовать строковые методы – функции этого
модуля считаются устаревшими и скорее всего будут исключены из
Python 3.0. Единственная причина использования модуля string –
это применение других средств из этого модуля, таких как предо
пределенные константы и шаблонные объекты.
8
Списки и словари
В этой главе вашему вниманию будут представлены такие типы объек
тов, как списки и словари, каждый из которых является коллекцией
других объектов. Эти два типа являются основными рабочими лошад
ками практически во всех сценариях на языке Python. Как вы увидите
далее, оба типа обладают исключительной гибкостью: они могут изме
няться непосредственно, могут увеличиваться и уменьшаться в разме
рах по мере необходимости и могут быть вложены в объекты любых
других типов. Благодаря этим типам вы сможете создавать и обрабаты
вать в своих сценариях структуры данных любой степени сложности.
Списки
Следующая остановка в нашем путешествии по встроенным объектам
языка Python называется список. Списки – это самый гибкий тип упо
рядоченных коллекций в языке Python. В отличие от строк списки мо
гут содержать объекты любых типов: числа, строки и даже другие спи
ски. Кроме того, в отличие от строк, списки могут изменяться непосред
ственно, с помощью операции присваивания по смещениям и срезам,
с помощью методов списков, с использованием инструкций удаления
и другими способами – списки являются изменяемыми объектами.
Списки в языке Python реализуют практически все необходимое для
работы с коллекциями данных, что вам пришлось бы писать вручную
при использовании низкоуровневого языка программирования, тако
го как язык C. Ниже приводятся основные свойства списков. Списки
в языке Python – это:
Упорядоченные коллекции объектов произвольных типов
С функциональной точки зрения, списки – это лишь место, в котором
собраны другие объекты, поэтому их можно также рассматривать
216 Глава 8. Списки и словари
как группы. Кроме того, списки обеспечивают позиционное упоря
дочение элементов слева направо (то есть они являются последова
тельностями).
Доступ к элементам по смещению
Так же, как и в случае со строками, вы можете использовать опера
цию индексирования для извлечения отдельных объектов из спи
ска по их смещениям. Поскольку элементы в списках упорядочены
по их местоположению, можно также выполнять такие действия,
как извлечение срезов и конкатенация.
Переменная длина, гетерогенность и произвольное число уровней
вложенности
В отличие от строк списки могут увеличиваться и уменьшаться не
посредственно (их длина может изменяться) и могут содержать не
только односимвольные строки, но и любые другие объекты (спи
ски гетерогенны). Списки могут содержать другие сложные объек
ты и поддерживают возможность создания произвольного числа
уровней вложенности, поэтому имеется возможность создавать
списки из списков из списков и т. д.
Относятся к категории изменяемых объектов
В терминах категорий типов списки могут изменяться непосредст
венно (являются изменяемыми объектами) и поддерживают все опе
рации над последовательностями, которые поддерживаются и стро
ками, такие как индексирование, извлечение срезов и конкатена
ция. Операции над последовательностями одинаковым образом ра
ботают как в случае списков, так и в случае строк, единственное
отличие – при применении операций над последовательностями (та
ких как конкатенация и извлечение среза) к спискам операций воз
вращают новый список, а не новую строку. Кроме того, т. к. списки
являются изменяемыми объектами, они поддерживают также опе
рации, которые не поддерживаются строками (такие как операции
удаления и присваивания по индексам, которые изменяют список
непосредственно).
Массивы ссылок на объекты
Формально списки в языке Python могут содержать ноль или более
ссылок на другие объекты. Списки чемто напоминают массивы ука
зателей (адресов). Извлечение элемента из списка в языке Python
выполняется так же быстро, как извлечение элемента массива в язы
ке C. В действительности списки – это самые настоящие массивы
языка C, реализованные в интерпретаторе Python, а не связанные
структуры данных. Как мы узнали в главе 6, всякий раз, когда ис
пользуется ссылка на объект, интерпретатор разыменовывает ее, по
этому ваши программы всегда будут иметь дело только с объектами.
Всякий раз, когда выполняется присваивание объекта элементу ка
койлибо структуры или имени переменной, интерпретатор Python
Списки 217
сохраняет ссылку на этот объект, а не его копию (за исключением,
когда явно запрашивается выполнение операции копирования).
В табл. 8.1 приводятся наиболее типичные операции, применяемые
к спискам. Как обычно, за дополнительной информацией о списках
вам следует обратиться к руководству по стандартной библиотеке язы
ка Python или запустить help(list) или dir(list) в интерактивной обо
лочке, чтобы получить полный список методов списков – этим функ
циям можно передать существующий список или слово list, которое
является именем типа данных ‘список’.
Таблица 8.1. Литералы списков и операции
Когда список определяется литеральным выражением, он записывает
ся как последовательность объектов (точнее, как последовательность
Операция Интерпретация
L1 = [] Пустой список
L2 = [0, 1, 2, 3] Четыре элемента с индексами 0..3
L3 = ['abc', ['def', ghi']] Вложенные списки
L2[i]
L3[i][j]
L2[i:j]
len(L2)
Индекс, индекс индекса, срез, длина
L1 + L2
L2 * 3
Конкатенация, дублирование
for x in L2
3 in L2
Обход в цикле, проверка вхождения
L2.append(4)
L2.extend([5,6,7])
L2.sort()
L2.index(1)
L2.insert(I, X)
L2.reverse()
Методы: дополнение списка, сортировка, по
иск, вставка, изменение порядка следования
элементов на обратный и т. д.
del L2[k]
del L2[i:j]
L2.pop( )
L2.remove(2)
L2[i:j] = []
Уменьшение списка
L2[i] = 1
L2[i:j] = [4,5,6]
Присваивание по индексу, присваивание срезу
range(4)
xrange(0, 4)
Создание списков/кортежей целых чисел
L4 = [x**2 for x in range(5)] Дополнительные операции над списками (гла
вы 13 и 17)
218 Глава 8. Списки и словари
выражений, создающих объекты) в квадратных скобках, разделенных
запятыми. Например, вторая строка в табл. 8.1 присваивает перемен
ной L2 список из четырех элементов. Вложенные списки описываются
как вложенные последовательности квадратных скобок (строка 3),
а пустые списки определяются как пустая пара квадратных скобок
(строка 1).1
Многие операции из табл. 8.1 должны выглядеть для вас знакомыми,
так как они являются теми же самыми операциями над последова
тельностями, которые мы применяли к строкам, – индексирование,
конкатенация, обход элементов в цикле и т. д. Кроме того, списки под
держивают специфические для своего типа методы (такие как сорти
ровка, перестановка элементов в обратном порядке, добавление эле
ментов в конец списка и т. д.), а также операции непосредственного
изменения списка (удаление элементов, присваивание по индексам
и срезам и т. д.). Списки получили эти операции потому, что они отно
сятся к категории объектов изменяемых типов.
Списки в действии
Возможно, самый лучший способ понять принцип действия списков –
это посмотреть на них в действии. Давайте еще раз вернемся к инте
рактивному сеансу работы с интерпретатором и проиллюстрируем опе
рации из табл. 8.1.
Базовые операции над списками
Списки, как и строки, поддерживают операторы + и * – для списков они
так же соответствуют операции конкатенации и повторения, но в ре
зультате получается новый список, а не строка. Фактически списки
поддерживают все общие операции над последовательностями, кото
рые мы рассматривали применительно к строкам в предыдущей главе.
% python
>>> len([1, 2, 3]) # Длина
3
>>> [1, 2, 3] + [4, 5, 6] # Конкатенация
[1, 2, 3, 4, 5, 6]
>>> ['Ni!'] * 4 # Повторение
['Ni!', 'Ni!', 'Ni!', 'Ni!']
>>> 3 in [1, 2, 3] # Проверка на вхождение
True
>>> for x in [1, 2, 3]: print x, # Обход в цикле
1 На практике в текстах программ обработки списков вы нечасто встретите
списки, заданные подобным образом. Чаще вам будет встречаться про
граммный код, обрабатывающий списки, которые создаются динамически
(во время выполнения). Несмотря на всю важность владения синтаксисом
литералов, следует иметь в виду, что большая часть структур данных
в языке Python конструируется во время выполнения программы.
Списки в действии 219
...
1 2 3
Подробнее об операции обхода элементов списка в цикле for и о встро
енной функции range мы поговорим в главе 13, потому что они имеют
отношению к синтаксису инструкций. Говоря вкратце, оператор цик
ла for выбирает элементы последовательности в порядке слева напра
во и выполняет одну или более инструкций для каждого из них. По
следняя строка в табл. 8.1 – это одна из дополнительных операций над
списками, которые описываются в главе 13 и расширенное обсужде
ние которых приводится в главе 17. Как говорилось в главе 4, они
представляют собой способ построить список, применяя выражение
к каждому элементу последовательности, единственной инструкцией.
Несмотря на то, что оператор + со списками работает точно так же, как
и со строками, очень важно знать, что с обеих сторон оператора долж
ны находиться последовательности одного и того же типа, в противном
случае во время работы программного кода вы получите сообщение об
ошибке. Например, нельзя выполнить операцию конкатенации для
списка и строки, если предварительно не преобразовать список в стро
ку (используя, например, обратные апострофы (backquotes), функцию
str или %форматирование) или строку в список (с помощью встроен
ной функции list):
>>> str([1, 2]) + "34" # То же, что и "[1, 2]" + "34"
'[1, 2]34'
>>> [1, 2] + list("34") # То же, что и [1, 2] + ["3", "4"]
[1, 2, '3', '4']
Индексы, срезы и матрицы
Так как списки являются последовательностями, операции доступа
к элементам по индексам и извлечения срезов работают точно так же,
как и в случае со строками. Однако, в результате обращения к элемен
ту по индексу возвращается объект, который расположен по указанно
му смещению, а в результате операции извлечения среза возвращается
новый список:
>>> L = ['spam', 'Spam', 'SPAM!']
>>> L[2] # Отсчет смещений начинается с нуля
'SPAM!'
>>> L[
2] # Отрицательное смещение: отсчитывается справа
'Spam'
>>> L[1:] # Операция извлечения среза возвращает разделы списка
['Spam', 'SPAM!']
Здесь следует отметить следующее: поскольку списки (и объекты дру
гих типов) могут быть вложены в другие списки, иногда бывает необ
ходимо объединять в цепочку несколько индексов, чтобы получить
доступ к элементам на более глубоком уровне вложенности в структу
ре данных. Например, один из простейших способов представления
220 Глава 8. Списки и словари
матриц (многомерных массивов) в языке Python заключается в ис
пользовании вложенных списков. Ниже приводится пример двухмер
ного массива размером 3×3, построенного на базе списков:
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
С помощью первого индекса извлекается целая строка (в действитель
ности – вложенный список), а с помощью второго извлекается элемент
этой строки:
>>> matrix[1]
[4, 5, 6]
>>> matrix[1][1]
5
>>> matrix[2][0]
7
>>> matrix = [[1, 2, 3],
... [4, 5, 6],
... [7, 8, 9]]
>>> matrix[1][1]
5
Обратите внимание на то, что, как показано в предыдущем примере,
список может быть при необходимости растянут на несколько строк,
ограниченных квадратными скобками (подробнее о синтаксисе будет
говориться в следующей части книги). Далее в этой главе вы также
увидите матрицы, реализованные на базе словарей. Модуль NumPy,
упомянутый в главе 5, для высокопроизводительной работы с число
выми данными предоставляет другие способы организации матриц.
Изменение списка
Списки относятся к категории изменяемых объектов, поэтому они
поддерживают операции, которые изменяют сам список непосредст+
венно. То есть все операции, представленные в этом разделе, изменяют
сам список объектов и не приводят к необходимости создавать новую
копию, как это было в случае со строками. В языке Python приходится
иметь дело только со ссылками на объекты, что обусловливает сущест
венные различия между непосредственным изменением объекта и соз
данием нового объекта – как обсуждалось в главе 6, непосредственное
изменение объекта может отражаться более чем на одной ссылке.
Присваивание по индексам и срезам
При использовании списков существует возможность изменять их со
держимое, выполняя присваивание значений элементам (по смеще
нию) или целым разделам (срезам) списка:
>>> L = ['spam', 'Spam', 'SPAM!']
>>> L[1] = 'eggs' # Присваивание по индексу элемента
>>> L
['spam', 'eggs', 'SPAM!']
Списки в действии 221
>>> L[0:2] = ['eat', 'more'] # Присваивание срезу: удаление+вставка
>>> L # Элементы 0 и 1 были заменены
['eat', 'more', 'SPAM!']
Обе операции присваивания – и отдельному элементу, и срезу – произ
водятся непосредственно в списке – они изменяют сам список, а не соз
дают новый список объектов. Операция присваивания по индексу
в языке Python работает практически так же, как в языке C и во мно
гих других языках программирования: интерпретатор замещает ста
рую ссылку на объект в указанном смещении на новую.
Присваивание срезу, последняя операция в предыдущем примере, за
мещает целый раздел списка за один прием. Поскольку это довольно
сложная операция, проще будет представить ее как последовательное
выполнение двух действий:
1. Удаление. Раздел списка, определяемый слева от оператора =, уда
ляется.
2. Вставка. Новые элементы, содержащиеся в объекте, расположен
ном справа от оператора =, вставляются в список, начиная с левого
края, где находился прежний удаленный срез.
В действительности это не совсем то, что происходит на самом деле, но
это достаточно точно объясняет, почему число вставляемых элементов
не должно соответствовать числу удаляемых элементов. Например,
представим, что список L имеет значение [1,2,3], тогда в результате
операции присваивания L[1:2]=[4,5] будет получен список [1,4,5,3].
Интерпретатор сначала удалит 2 (срез, состоящий из одного элемента),
а затем, начиная с позиции удаленного элемента 2, вставит элементы
4 и 5. Это также объясняет, почему операция L[1:2]=[] в действитель
ности является операцией удаления, – интерпретатор удалит срез
(элемент со смещением 1) и затем вставит пустой список.
В результате операция присваивания срезу замещает целый раздел
списка, или «столбец», за одно действие. Поскольку длина последова
тельности справа от оператора = не должна обязательно соответство
вать длине среза, которому выполняется присваивание, эта операция
может использоваться для замены (посредством перезаписи), расши
рения (посредством вставки) или сжатия (посредством удаления) тре
буемого списка. Это довольно мощная операция, но, честно говоря,
она достаточно редко используется на практике. Обычно используют
ся более простые способы замены, вставки и удаления (например, опе
рация конкатенация и методы списков insert, pop и remove), которые
программисты предпочитают использовать на практике.
Методы списков
Как и строки, объекты списков в языке Python поддерживают специ
фичные методы:
>>> L.append('please') # Вызов метода добавления элемента в конец списка
>>> L
222 Глава 8. Списки и словари
['eat', 'more', 'SPAM!', 'please']
>>> L.sort() # Сортировка элементов списка ('S' < 'e')
>>> L
['SPAM!', 'eat', 'more', 'please']
Методы были представлены в главе 7. Коротко напомню, что методы –
это функции (в действительности – атрибуты, ссылающиеся на функ
ции), которые связаны с определенным типом объектов. Методы обес
печивают выполнение специфических операций, например, методы
списков, представленные здесь, доступны только для списков.
Наиболее часто используемым методом, пожалуй, является метод ap
pend, который просто добавляет единственный элемент (ссылку на объ
ект) в конец списка. В отличие от операции конкатенации, метод ap
pend принимает единственный объект, а не список. По своему дейст
вию выражение L.append(X) похоже на выражение L+[X], но в первом
случае изменяется сам список, а во втором – создается новый список.1
Другой часто используемый метод – метод sort – выполняет переупо
рядочивание элементов в самом списке. По умолчанию он использует
стандартные операторы сравнения языка Python (в данном случае вы
полняется сравнение строк) и выполняет сортировку в порядке возрас
тания значений. Однако существует возможность передать методу sort
свою собственную функцию сравнения.
В Python версии 2.5 и более ранних сравнение выполняется пораз
ному для объектов разных типов (например, списков и строк) –
язык определяет способ упорядочения различных типов, который
является детерминистским и не всегда может выглядеть правиль
ным. Этот способ упорядочения основан на именах типов, вовле
ченных в операцию сравнения, например, любые целые числа все
гда меньше любых строк, потому что строка "int" меньше, чем
строка "str". При выполнении операции сравнения никогда не вы
полняется преобразование типов объектов, за исключением срав
нения объектов числовых типов.
В Python 3.0 такой порядок, возможно, будет изменен: планиру
ется, что в случае попытки сравнения объектов различных типов
вместо прежнего способа упорядочения будет возбуждаться ис
ключение. Так как метод сортировки использует операцию срав
нения, это означает, что инструкция [1, 2, 'spam'].sort() будет
успешно выполнена в Python 2.5, но будет возбуждать исключе
ние в Python 3.0. За дополнительной информацией обращайтесь
к примечаниям к выпуску Python 3.0.
1 В отличие от операции конкатенации (+), метод append не создает новый объ
ект, поэтому обычно он выполняется быстрее. Существует возможность
имитировать работу метода append с помощью операции присваивания сре
зу: выражение L[len(L):]=[X] соответствует вызову L.append(X), а выражение
L[:0]=[X] соответствует операции добавления в начало списка. В обоих слу
чаях удаляется пустой сегмент списка и вставляется элемент X, при этом из
меняется сам список L, так же быстро, как при использовании метода append.
Списки в действии 223
Важно заметить, что методы append и sort изменяют сам объект списка
и не возвращают список в виде результата (точнее говоря, оба метода
возвращают значение None). Если вы написали инструкцию вроде
L=L.append(X), вы не получите измененное значение L (в действительно
сти вы совсем потеряете ссылку на список) – использование таких ат
рибутов, как append и sort приводит к изменению самого объекта, по
этому нет никаких причин выполнять повторное присваивание.
Как и строки, списки обладают рядом других методов, выполняющих
специализированные операции. Например, метод reverse изменяет по
рядок следования элементов в списке на обратный, а методы extend
и pop вставляют несколько элементов в конец списка и удаляют эле
менты из конца списка, соответственно:
>>> L = [1, 2]
>>> L.extend([3,4,5]) # Добавление нескольких элементов в конец списка
>>> L
[1, 2, 3, 4, 5]
>>> L.pop() # Удаляет и возвращает последний элемент списка
5
>>> L
[1, 2, 3, 4]
>>> L.reverse() # Изменяет порядок следования элементов на обратный
>>> L
[4, 3, 2, 1]
В некоторых типах программ метод pop, показанный здесь, часто ис
пользуется в паре с методом append для реализации структур данных ти
па стек – «последний пришел, первый ушел» (LastInFirstOut, LIFO).
Конец списка служит вершиной стека:
>>> L = []
>>> L.append(1) # Втолкнуть на стек
>>> L.append(2)
>>> L
[1, 2]
>>> L.pop() # Вытолкнуть со стека
2
>>> L
[1]
Хотя это здесь и не показано, тем не менее, метод pop может принимать
необязательное смещение элемента, который удаляется из списка и воз
вращается (по умолчанию это последний элемент). Другие методы спи
сков позволяют удалять элементы с определенными значениями (re
move), вставлять элементы в определенную позицию (insert), отыски
вать смещение элемента по заданному значению (index) и т. д. Чтобы
поближе познакомиться с этими методами, обратитесь к имеющимся
источникам документации или поэкспериментируйте с этими метода
ми в интерактивной оболочке интерпретатора.
224 Глава 8. Списки и словари
Прочие часто используемые операции над списками
Так как списки относятся к категории изменяемых объектов, вы мо
жете использовать инструкцию del для удаления элемента или среза
непосредственно из списка:
>>> L
['SPAM!', 'eat', 'more', 'please']
>>> del L[0] # Удаление одного элемента списка
>>> L
['eat', 'more', 'please']
>>> del L[1:] # Удаление целого сегмента списка
>>> L # То же, что и L[1:] = []
['eat']
Так как операция присваивания срезу выполняется как удаление
и вставка, можно удалять срезы списка, присваивая им пустой список
(L[i:j]=[]) – интерпретатор сначала удалит срез, определяемый слева
от оператора =, а затем вставит пустой список. С другой стороны, при
сваивание пустого списка по индексу элемента приведет к сохранению
ссылки на пустой список в этом элементе, а не к его удалению:
>>> L = ['Already', 'got', 'one']
>>> L[1:] = []
>>> L
['Already']
>>> L[0] = []
>>> L
[[]]
Все только что рассмотренные операции используются достаточно час
то, однако существуют и другие дополнительные методы и операции
для списков, которые не были показаны здесь (включая методы встав
ки и поиска). Чтобы получить полный список существующих допол
нительных операций, всегда следует обращаться к руководствам по
языку Python, к функциям dir и help (с которыми мы впервые позна
комились в главе 4) или к книге «Python Pocket Reference» (O’Reilly)
и другим справочным руководствам, упоминавшимся в предисловии.
Кроме того, я хотел бы напомнить, что все операции непосредственно
го изменения объектов, обсуждавшиеся здесь, применимы только к из
меняемым объектам: они не будут работать со строками (или с корте
жами, которые рассматриваются в следующей главе) независимо от
прикладываемых вами усилий. Изменяемость или неизменяемость –
это исходное свойство, присущее каждому типу объектов.
Словари
После списков словари являются, пожалуй, самым гибким из встроен
ных типов данных в языке Python. Если считать списки упорядочен
ными коллекциями объектов, то в отличие от них элементы в слова
Словари 225
рях сохраняются и извлекаются с помощью ключа, а не с помощью
смещения, определяющего их позицию.
Будучи встроенным типом данных, словари могут заменить множест
во алгоритмов поиска и структур данных, которые приходится реали
зовывать вручную в низкоуровневых языках программирования, –
доступ к элементам словаря по их индексам представляет собой быст
рую операцию поиска. Кроме того, иногда словари могут играть роль
записей и таблиц символов, используемых в других языках, и способ
ны служить для представления разреженных (по большей части пус
тых) структур данных. Ниже приводятся основные характеристики
словарей в языке Python:
Доступ к элементам по ключу, а не по индексу
Иногда словари называют ассоциативными массивами, или хеша+
ми. Они определяют взаимосвязь между значениями и ключами,
поэтому для извлечения элементов словаря можно использовать
ключи, под которыми эти элементы были сохранены в словаре. Для
получения элементов словаря используется та же самая операция
доступа по индексу, как и в списке, только индекс приобретает фор
му ключа, а не смещения относительно начала.
Неупорядоченные коллекции произвольных объектов
В отличие от списков, элементы словарей хранятся в неопределен
ном порядке. В действительности, интерпретатор вносит элемент
случайности в порядок следования элементов для обеспечения бо
лее быстрого поиска. Ключи описывают символическое (не физиче
ское) местоположение элементов в словаре.
Переменная длина, гетерогенность и произвольное число уровней
вложенности
Подобно спискам словари могут увеличиваться и уменьшаться не
посредственно (то есть при этом не создаются новые копии). Они
могут содержать объекты любых типов и поддерживают возмож
ность создания произвольного числа уровней вложенности (они мо
гут содержать списки, другие словари и т. д.).
Относятся к категории изменяемых отображений
Словари могут изменяться непосредственно с использованием опе
рации индексирования (они являются изменяемыми), но они не
поддерживают операции над последовательностями, которые под
держиваются строками и списками. Словари представляют собой
неупорядоченные коллекции, поэтому операции, которые основа
ны на использовании фиксированного порядка следования элемен
тов (например, конкатенация, извлечение среза), не имеют смысла
для словарей. Словари – это единственный встроенный представи
тель объектовотображений (объекты, которые отображают ключи
на значения).
226 Глава 8. Списки и словари
Таблицы ссылок на объекты (хеш+таблицы)
Если списки – это массивы ссылок на объекты, которые поддержива
ют возможность доступа к элементам по их позициям, то словари –
это неупорядоченные таблицы ссылок на объекты, которые поддер
живают доступ к элементам по ключу. Внутри словари реализованы
как хештаблицы (структуры данных, которые обеспечивают очень
высокую скорость поиска), изначально небольшого размера и увели
чивающиеся по мере необходимости. Более того, интерпретатор Py
thon использует оптимизированные алгоритмы хеширования для
обеспечения максимально высокой скорости поиска ключей. Подоб
но спискам словари хранят ссылки на объекты (а не их копии).
В табл. 8.2 приводятся некоторые наиболее часто используемые опера
ции над словарями (опять же, чтобы получить полный перечень опера
ций, обращайтесь к руководству или воспользуйтесь функцией
dir(dict) или help(dict), где dict – это имя типа). При определении
в виде литералов словари записываются как последовательность пар
key:value, разделенных запятыми, заключенных в фигурные скобки.1
Пустой словарь в литеральном представлении – это пустая пара ско
бок. Словари могут вкладываться в литеральном представлении в виде
значений внутри других словарей, списков или кортежей.
Таблица 8.2. Литералы словарей и операции
1 Как и в случае со списками, вам нечасто придется встречать словари, сконст
руированные с использованием литералов. Однако списки и словари увели
чиваются в размерах поразному. Как будет показано в следующем разделе,
словари обычно дополняются с помощью операции присваивания по новым
ключам во время выполнения программы – такой подход совершенно не го
дится для списков (списки обычно расширяются с помощью метода append).
Операция Интерпретация
D1 = {} Пустой словарь
D2 = {'spam': 2, 'eggs': 3} Словарь из двух элементов
D3 = {'food': {'ham': 1, 'egg': 2}} Вложение
D2['eggs']
D3['food']['ham']
Доступ к элементу по ключу
D2.has_key('eggs')
'eggs' in D2
D2.keys()
D2.values()
D2.copy()
D2.get(key, default)
D2.update(D1)
D2.pop(key)
Методы: проверка на вхождение, спи
сок ключей, список значений, копиро
вание, получение значения по умолча
нию, слияние, удаление и т. д.
len(D1) Длина (количество элементов)
Словари в действии 227
Словари в действии
Согласно табл. 8.2 доступ к элементам словарей осуществляется по
ключу, а для доступа к элементам вложенных словарей осуществляет
ся путем объединения серии индексов (ключей в квадратных скобках)
в цепочку. Когда интерпретатор создает словарь, он сохраняет элемен
ты в произвольном порядке – чтобы получить значение обратно, необ
ходимо указать ключ, с которым это значение было ассоциировано.
Давайте вернемся в интерактивный сеанс работы с интерпретатором
и исследуем некоторые операции над словарями из табл. 8.2.
Базовые операции над словарями
В обычном случае сначала создается словарь, а затем выполняются опе
рации сохранения новых ключей и обращения к элементам по ключу:
% python
>>> d2 = {'spam': 2, 'ham': 1, 'eggs': 3} # Создание словаря
>>> d2['spam'] # Извлечение значения по ключу
2
>>> d2 # Случайный порядок следования
{'eggs': 3, 'ham': 1, 'spam': 2}
Здесь переменной d2 присваивается словарь, в котором ключу 'spam'
соответствует целочисленное значение 2, и т. д. Для доступа к элемен
там словаря используется тот же самый синтаксис с квадратными
скобками, что и при извлечении элементов списков, но в данном слу
чае доступ осуществляется по ключу, а не по позиции элемента.
Обратите внимание на последнюю инструкцию в этом примере: поря
док следования ключей в словари практически всегда отличается от
первоначального. Дело в том, что для обеспечения максимально высо
кой скорости поиска по ключу (для хеширования) необходимо случай
ное расположение ключей в памяти. Именно поэтому операции, кото
рые предполагают наличие установленного порядка следования эле
ментов слева направо (например, извлечение среза, конкатенация),
неприменимы к словарям – они позволяют извлекать значения только
по ключам, а не по индексам.
Встроенная функция len может работать и со словарями – она возвра
щает число элементов в словаре или, что то же самое, длину списка
ключей. Метод словаря has_key и оператор проверки вхождения in
D2[key] = 42
del D2[key]
Добавление/изменение ключей, удале
ние ключей
D4 = dict.fromvalues(['a', 'b'])
D5 = dict(zip(keyslist, valslist))
D6 = dict(name='Bob', age=42)
Альтернативные способы создания сло
варей
Операция Интерпретация
228 Глава 8. Списки и словари
позволяют проверить наличие ключа, а метод keys возвращает все
ключи, имеющиеся в словаре, в виде списка. Последний удобно ис
пользовать для последовательной обработки словарей, но при этом вы
не должны делать какиелибо предположения о порядке следования
ключей в списке. Поскольку результатом вызова метода keys является
список, он всегда может быть отсортирован:
>>> len(d2) # Число элементов словаря
3
>>> d2.has_key('ham') # Проверка на вхождение
True
>>> 'ham' in d2 # Проверка на вхождение, альтернативный способ
True
>>> d2.keys() # Создает новый список ключей
['eggs', 'ham', 'spam']
Обратите внимание на третье выражение в этом листинге. Как уже
упоминалось ранее, оператор проверки на вхождение in может исполь
зоваться для работы со строками и списками, но точно так же он мо
жет использоваться и для работы со словарями. Он проверяет наличие
указанного ключа в словаре точно так же, как и метод has_key строкой
выше. Это возможно благодаря тому, что словари определяют итера+
торы, которые обеспечивают пошаговый обход списков ключей. Су
ществуют и другие типы, которые поддерживают итераторы, отвечаю
щие обычному использованию типа; например, файлы имеют итерато
ры, которые позволяют выполнять построчное чтение данных. Итера
торы будут рассматриваться в главах 17 и 24.
Далее в этой главе и в книге вы узнаете о двух альтернативных спосо
бах создания словарей, которые демонстрируются в конце табл. 8.2:
можно передать функции dict (которая фактически является конст
руктором типа) упакованные списки ключей/значений в виде корте
жей или значения в виде именованных аргументов. Передача значе
ний в виде именованных аргументов будет рассматриваться в главе 16.
Использование функции zip, которая представляет собой способ кон
струирования словарей из списков ключей и значений, будет рассмат
риваться в главе 13. Если заранее невозможно предугадать, какие
ключи и значения будут получаться во время работы программы, вы
всегда сможете создавать их динамически в виде списков и затем упа
ковывать функцией zip.
Изменение словарей
Давайте продолжим работу в интерактивном сеансе. Словари, как
и списки, относятся к категории изменяемых объектов, поэтому их
можно изменять, увеличивать, уменьшать непосредственно, не созда
вая новые словари: чтобы изменить или создать новую запись в слова
ре, достаточно выполнить операцию присваивания по ключу. Здесь
также применима инструкция del – она удаляет значение, связанное
с ключом, который играет роль индекса. Обратите также внимание на
Словари в действии 229
наличие вложенного списка в следующем примере (значение для клю
ча 'ham'). Все типыколлекции в языке Python могут вкладываться
друг в друга в произвольном порядке:
>>> d2['ham'] = ['grill', 'bake', 'fry'] # Изменение элемента
>>> d2
{'eggs': 3, 'spam': 2, 'ham': ['grill', 'bake', 'fry']}
>>> del d2['eggs'] # Удаление элемента
>>> d2
{'spam': 2, 'ham': ['grill', 'bake', 'fry']}
>>> d2['brunch'] = 'Bacon' # Добавление нового элемента
>>> d2
{'brunch': 'Bacon', 'spam': 2, 'ham': ['grill', 'bake', 'fry']}
Как и в случае со списками, в словаре операция присваивания по суще
ствующему индексу приводит к изменению ассоциированного с ним
значения. Однако в отличие от списков, словари допускают выполне
ние присваивания по новому ключу (который ранее отсутствовал), в ре
зультате создается новый элемент словаря, как показано в предыду
щем примере для ключа 'brunch'. Этот прием не может применяться
к спискам, потому что в этом случае интерпретатор обнаруживает вы
ход за пределы списка и генерирует сообщение об ошибке. Чтобы уве
личить размер списка, необходимо использовать такие средства спи
сков, как метод append или присваивание срезу.
Дополнительные методы словарей
Методы словарей обеспечивают выполнение различных операций. На
пример, методы словарей values и items возвращают список значений
элементов словаря и кортежи пар (key, value), соответственно:
>>> d2 = {'spam': 2, 'ham': 1, 'eggs': 3}
>>> d2.values()
[3, 1, 2]
>>> d2.items()
[('eggs', 3), ('ham', 1), ('spam', 2)]
Такие списки удобно использовать в циклах, когда необходимо выпол
нить обход элементов словаря. Попытка извлечения несуществующе
го элемента словаря обычно приводит к появлению ошибки, однако ме
тод get в таких случаях возвращает значение по умолчанию (None или
указанное значение). С помощью этого метода легко можно реализо
вать получение значений по умолчанию и избежать появления ошибки
обращения к несуществующему ключу:
>>> d2.get('spam') # Ключ присутствует в словаре
2
>>> d2.get('toast') # Ключ отсутствует в словаре
None
>>> d2.get('toast', 88)
88
230 Глава 8. Списки и словари
Метод update реализует своего рода операцию конкатенации для слова
рей. Он объединяет ключи и значения одного словаря с ключами
и значениями другого, просто перезаписывая значения с одинаковы
ми ключами:
>>> d2
{'eggs': 3, 'ham': 1, 'spam': 2}
>>> d3 = {'toast':4, 'muffin':5}
>>> d2.update(d3)
>>> d2
{'toast': 4, 'muffin': 5, 'eggs': 3, 'ham': 1, 'spam': 2}
Наконец, метод pop удаляет ключ из словаря и возвращает его значе
ние. Он напоминает метод pop списков, только вместо необязательного
индекса элемента принимает ключ:
# удаление элементов словаря по ключу
>>> d2
{'toast': 4, 'muffin': 5, 'eggs': 3, 'ham': 1, 'spam': 2}
>>> d2.pop('muffin')
5
>>> d2.pop('toast') # Удаляет и возвращает значение заданного ключа
4
>>> d2
{'eggs': 3, 'ham': 1, 'spam': 2}
# удаление элементов списка по позиции
>>> L = ['aa', 'bb', 'cc', 'dd']
>>> L.pop() # Удаляет и возвращает последний элемент списка
'dd'
>>> L
['aa', 'bb', 'cc']
>>> L.pop(1) # Удаляет и возвращает элемент из заданной позиции
'bb'
>>> L
['aa', 'cc']
Кроме того, словари имеют метод copy, который мы рассмотрим в сле
дующей главе, как один из способов избежать побочных эффектов,
связанных с наличием нескольких ссылок на один и тот же словарь.
В действительности словари обладают гораздо большим числом мето
дов, чем перечислено в табл. 8.2. Чтобы получить полный список, об
ращайтесь к руководствам по языку Python.
Таблица языков
Давайте рассмотрим более жизненный пример словаря. В следующем
примере создается таблица, которая отображает названия языков про
граммирования (ключи) на имена их создателей (значения). С помо
щью этой таблицы можно по названию языка определить имя его соз
дателя:
Словари в действии 231
>>> table = {'Python': 'Guido van Rossum',
... 'Perl': 'Larry Wall',
... 'Tcl': 'John Ousterhout' }
...
>>> language = 'Python'
>>> creator = table[language]
>>> creator
'Guido van Rossum'
>>> for lang in table.keys():
... print lang, '\t', table[lang]
...
Tcl John Ousterhout
Python Guido van Rossum
Perl Larry Wall
В последней команде использован оператор цикла for, который мы еще
подробно не рассматривали. Для тех, кто не знаком с циклами for, за
мечу, что приведенная команда просто выполняет обход всех ключей
в таблице и выводит список ключей и их значений, разделенных симво
лом табуляции. Подробно о циклах for будет рассказываться в главе 13.
Так как словари не являются последовательностями, их нельзя напря
мую использовать в операторе цикла for, как это допускают строки
и списки. Но, если необходимо выполнить обход элементов словаря, это
легко сделать с помощью метода keys, возвращающего список всех клю
чей словаря, который может использоваться для выполнения итераций
в цикле for. В случае необходимости внутри цикла можно получать зна
чение элемента по его ключу, как это реализовано в данном примере.
Кроме того, Python в действительности позволяет выполнять обход
списка ключей словаря и без вызова метода keys в операторе цикла for.
Для любого словаря D цикл можно оформить как for key in D:, что рав
носильно полной форме записи for key in D.keys():. Это всего лишь еще
одна разновидность итераторов, упоминавшихся ранее, которая позво
ляет использовать оператор проверки вхождения in со словарями (под
робнее об итераторах далее в книге).
Замечания по использованию словарей
Словари окажутся достаточно просты в использовании, когда вы ос
воите работу с ними, но я хочу привести несколько соображений, кото
рые вам следует твердо знать:
• Операции над последовательностями неприменимы к словарям.
Словари – это отображения, а не последовательности. Вследствие
того, что словари не предусматривают никакого упорядочения эле
ментов, такие операции, как конкатенация (упорядоченное объеди
нение) и извлечение среза (извлечение непрерывного блока элемен
тов), просто неприменимы. В действительности, когда в программ
ном коде во время выполнения производится попытка сделать не
что подобное, интерпретатор выдает сообщение об ошибке.
232 Глава 8. Списки и словари
• Присваивание по несуществующему индексу приводит к созданию
нового элемента. Ключи можно создавать при определении слова
ря в виде литерала (в этом случае они встраиваются непосредствен
но в литерал) или при присваивании значения новому ключу суще
ствующего объекта словаря. Результат получается тот же самый.
• Ключи не обязательно должны быть строками. В наших примерах
в качестве ключей использовались строки, но могут использоваться
любые другие неизменяемые объекты (то есть не списки). Напри
мер, в качестве ключей допустимо использовать целые числа, что
превращает словарь в подобие списка (как минимум, в смысле ин
дексирования). В качестве ключей можно также использовать кор
тежи, что позволяет создавать составные ключи. Экземпляры клас
сов (обсуждаются в четвертой части книги) также могут играть
роль ключей при условии, что они поддерживают определенные ме
тоды, которые сообщат интерпретатору, что он имеет дело с неизме
няемым объектом, в противном случае они будут бесполезны, если
рассматривать их как фиксированные ключи.
Использование словарей для имитации гибких списков
Последнее замечание в предыдущем списке имеет настолько важное
значение, что имеет смысл продемонстрировать его применение на не
скольких примерах. Списки не допускают возможность присваивания
по индексам, находящимся за пределами списков:
>>> L = []
>>> L[99] = 'spam'
Traceback (most recent call last):
File "<stdin>", line 1, in ?
IndexError: list assignment index out of range
(Перевод: Диагностика (самого последнего вызова):
Файл "<stdin>", строка 1, позиция ?
IndexError: присваивание по индексу за пределами списка)
Можно, конечно, с помощью операции повторения создать список дос
таточно большой длины (например, [0]*100), но можно создать нечто,
что напоминает словарь, который не требует такого выделения про
странства. При использовании целочисленных ключей словари могут
имитировать списки, которые увеличиваются при выполнении опера
ции присваивания по смещению:
>>> D = {}
>>> D[99] = 'spam'
>>> D[99]
'spam'
>>> D
{99: 'spam'}
Результат выглядит так, как если бы D был списком из 100 элементов,
но на самом деле – это словарь с единственным элементом – значением
Словари в действии 233
ключа 99 является строка 'spam'. В такой структуре можно обращаться
по смещениям, как и в списке, но вам не требуется выделять простран
ство для всех позиций, которые могут когдалибо потребоваться при
выполнении программы. При использовании подобным образом сло
вари представляют собой более гибкие эквиваленты списков.
Использование словарей для структур разреженных данных
Похожим образом словари могут использоваться для реализации
структур разреженных данных, таких как многомерные массивы, где
всего несколько элементов имеют определенные значения:
>>> Matrix = {}
>>> Matrix[(2, 3, 4)] = 88
>>> Matrix[(7, 8, 9)] = 99
>>>
>>> X = 2; Y = 3; Z = 4 # ; отделяет инструкции
>>> Matrix[(X, Y, Z)]
88
>>> Matrix
{(2, 3, 4): 88, (7, 8, 9): 99}
Здесь словарь использован для представления трехмерного массива,
в котором только два элемента, (2,3,4) и (7,8,9), имеют определенные
значения. Ключами словаря являются кортежи, определяющие коор
динаты непустых элементов. Благодаря этому вместо трехмерной мат
рицы, объемной и по большей части пустой, оказалось достаточно ис
пользовать словарь из двух элементов. В такой ситуации попытка дос
тупа к пустым элементам будет приводить к возбуждению исключе
ния, так как эти элементы физически отсутствуют:
>>> Matrix[(2,3,6)]
Traceback (most recent call last):
File "<stdin>", line 1, in ?
KeyError: (2, 3, 6)
(Перевод: Диагностика (самого последнего вызова):
Файл "<stdin>", строка 1, позиция ?
KeyError: (2, 3, 6))
Как избежать появления ошибок обращения
к несуществующему ключу
Ошибки обращения к несуществующему ключу являются обычными
при работе с разреженными матрицами, но едва ли ктото захочет, что
бы они приводили к преждевременному завершению программы. Суще
ствует, по крайней мере, три способа получить значение по умолчанию
вместо возбуждения исключения – можно предварительно проверить
наличие ключа с помощью условного оператора if, воспользоваться
конструкцией try, чтобы перехватить и явно обработать исключение,
или просто использовать показанный ранее метод словаря get, способ
ный возвращать значение по умолчанию для несуществующих ключей:
234 Глава 8. Списки и словари
>>> if Matrix.has_key((2,3,6)): # Проверить наличие ключа перед обращением
... print Matrix[(2,3,6)]
... else:
... print 0
...
0
>>> try:
... print Matrix[(2,3,6)] # Попытаться обратиться по индексу
... except KeyError: # Перехватить исключение и обработать
... print 0
...
0
>>> Matrix.get((2,3,4), 0) # Существует; извлекается и возвращается
88
>>> Matrix.get((2,3,6), 0) # Отсутствует; используется аргумент default
0
Способ, основанный на применении метода get, является самым про
стым из приведенных, если оценивать объем программного кода, – ин
струкции if и try подробно будут рассматриваться далее в этой книге.
Использование словарей в качестве «записей»
Как видите, словари в языке Python способны играть множество ро
лей. Вообще говоря, они способны заменить реализацию алгоритмов
поиска (потому что операция индексирования по ключу уже является
операцией поиска), могут представлять самые разные типы структу
рированной информации. Например, словари представляют один из
многих способов описания свойств элементов в программах, то есть
они могут играть ту же роль, какую играют «структуры» и «записи»
в других языках программирования.
В следующем примере выполняется заполнение словаря путем при
сваивания значений новым ключам в виде нескольких инструкций:
>>> rec = {}
>>> rec['name'] = 'mel'
>>> rec['age'] = 45
>>> rec['job'] = 'trainer/writer'
>>>
>>> print rec['name']
mel
Встроенные типы языка Python позволяют легко представлять струк
турированную информацию; это особенно заметно, когда появляются
уровни вложенности. В следующем примере снова используется сло
варь для хранения свойств объекта, но на этот раз заполнение произво
дится в единственной инструкции (вместо того чтобы выполнять при
сваивание каждому ключу в отдельности), причем здесь присутствуют
вложенные список и словарь, чтобы обеспечить представление струк
турированных свойств объекта:
>>> mel = {'name': 'Mark',
Словари в действии 235
... 'jobs': ['trainer', 'writer'],
... 'web': 'www.rmi.net/~lutz',
... 'home': {'state': 'CO', 'zip':80513}}
...
Чтобы извлечь компоненты вложенных объектов, достаточно просто
объединить в цепочку операции индексирования:
>>> mel['name']
'Mark'
>>> mel['jobs']
['trainer', 'writer']
>>> mel['jobs'][1]
'writer'
>>> mel['home']['zip']
80513
Другие способы создания словарей
Наконец, обратите внимание, что благодаря практической ценности
словарей с течением времени появились и другие способы их создания.
В Python 2.3 и более поздних версиях, например, последние два вызова
конструктора dict в следующем ниже примере имеют тот же эффект,
что и литералы и форма присваивания по отдельным ключам в приме
ре выше:
{'name': 'mel', 'age': 45} # Традиционное литеральное выражение
D = {} # Динамическое присваивание по ключам
D['name'] = 'mel'
D['age'] = 45
dict(name='mel', age=45) # Форма именованных аргументов
dict([('name', 'mel'), ('age', 45)]) # Кортежи ключ/значение
Все четыре варианта создают один и тот же словарь, содержащий два
элемента:
• Первый вариант удобен, если содержимое всего словаря известно
заранее.
• Второй вариант удобно использовать, когда необходимо динамиче
ски создавать словарь по одному полю за раз.
• Третий вариант с использованием именованных аргументов даже
компактнее, чем литералы, но он требует, чтобы все ключи были
строками.
• Последний вариант удобен, когда ключи и значения во время выпол
нения программы необходимо хранить в виде последовательностей.
Как было показано в конце табл. 8.2, последний вариант также часто
используется в соединении с функцией zip, которая позволяет объеди
нить отдельные списки ключей и значений, создаваемые динамически
во время выполнения (например, при извлечении данных из столбцов
в файле).
236 Глава 8. Списки и словари
Если значения всех ключей словаря остаются все время одними и теми
же, существует специализированная форма инициализации словаря,
при использовании которой достаточно просто передать список клю
чей и начальное значение (по умолчанию используется значение None):
>>> dict.fromkeys(['a', 'b'], 0)
{'a': 0, 'b': 0}
В настоящее время вы вполне можете обойтись простыми литералами
и операцией присваивания по ключам, но вы наверняка найдете при
менение всем упомянутым вариантам создания словарей, как только
приступите к созданию настоящих, гибких и динамических программ
на языке Python.
Придется держать в уме: интерфейсы словарей
Помимо удобного способа хранения информации по ключам непо
средственно в программе некоторые расширения для Python так
же предоставляют интерфейсы, которые выглядят и действуют
как словари. Например, обращение к индексированным файлам
данных в формате DBM во многом напоминает обращение к слова
рю, который сначала требуется открыть. Строки сохраняются
и извлекаются с помощью операции индексирования по ключу:
import anydbm
file = anydbm.open("filename") # Ссылка на файл
file['key'] = 'data' # Сохранение данных по ключу
data = file['key'] # Извлечение данных по ключу
Позднее будет показано, как таким же способом можно сохранять
целые объекты Python, достаточно лишь заменить имя модуля
anydbm на shelve (shelves (хранилища) – это базы данных с дос
тупом к информации по ключу, предназначенные для постоян
ного хранения объектов Python). Для работы в Интернете под
держка CGIсценариев, предусмотренная в языке Python, также
обеспечивает интерфейс, напоминающий словарь. Вызов метода
cgi.FieldStorage возвращает объект, по своим характеристикам
напоминающий словарь, – с одной записью для каждого поля
ввода, находящегося на клиентской вебстранице:
import cgi
form = cgi.FieldStorage( ) # Parse form data
if form.has_key('name'):
showReply('Hello, ' + form['name'].value)
Все эти объекты (и словари в том числе) являются примерами
отображений. Как только вы овладеете словарными интерфейса
ми, вы обнаружите, что они имеют отношение ко множеству
встроенных инструментов языка Python.
В заключение 237
В заключение
В этой главе мы исследовали списки и словари – два, пожалуй, наибо
лее часто используемых, гибких и мощных типа коллекций, которые
можно увидеть в программах на языке Python. Мы узнали, что списки
представляют собой упорядоченные по позициям коллекции объектов
произвольных типов и что они могут иметь неограниченное число
уровней вложенности, могут увеличиваться и уменьшаться в размерах
по мере необходимости и многое другое. Словари представляют похо
жий тип данных, но в них элементы сохраняются по ключам, а не по
позициям; словари не обеспечивают какойлибо надежный способ под
держки упорядочения элементов слева направо. И списки, и словари
относятся к категории изменяемых объектов и поэтому поддерживают
различные операции непосредственного их изменения, недоступные
для строк, например, списки можно увеличивать в размерах с помо
щью метода append, а словари – за счет выполнения операции присваи
вания по новому ключу.
В следующей главе мы закончим подробное исследование базовых ти
пов объектов, рассмотрев кортежи и файлы. После этого мы перейдем
к инструкциям, которые реализуют логику обработки этих объектов,
что позволит нам еще больше приблизиться к написанию полноцен
ных программ. Но прежде чем заняться этими темами, ответьте на
контрольные вопросы главы.
Закрепление пройденного
Контрольные вопросы
1. Назовите два способа создания списка, содержащего пять целочис
ленных значений, равных нулю.
2. Назовите два способа создания словаря с двумя ключами 'a' и 'b',
каждый из которых ассоциирован со значением 0.
3. Назовите четыре операции, которые изменяют непосредственно
объект списка.
4. Назовите четыре операции, которые изменяют непосредственно
объект словаря.
Ответы
1. Литеральное выражение, такое как [0, 0, 0, 0, 0], и операция по
вторения, такая как [0]*5, создадут список с пятью элементами, со
держащими нули. Формально можно было бы построить список
с помощью цикла, начиная с пустого списка, к которому добавляет
ся значение 0 на каждой итерации: L.append(0). Генератор списков
([0 for i in range(5)]) сделал бы то же самое, но в этом случае при
шлось бы выполнить лишнюю работу.
238 Глава 8. Списки и словари
2. Литеральное выражение, например, {'a': 0, 'b': 0}, или последова
тельность операций присваивания, таких как D = []; D['a'] = 0,
D['b'] = 0, создадут требуемый словарь. Можно также использовать
более новый и более простой способ с использованием именованных
аргументов dict(a=0, b=0) или более гибкий вариант с указанием по
следовательностей пар ключ/значение dict([('a', 0), ('b', 0)]).
Или, поскольку все ключи известны заранее и не будут изменяться
в дальнейшем, можно использовать специализированную форму
dict.fromkeys(['a', 'b'], 0).
3. Методы append и extend увеличивают размер самого списка, методы
sort и reverse упорядочивают и изменяют порядок следования эле
ментов списка на обратный, метод insert вставляет элемент в ука
занную позицию, методы remove и pop удаляют элементы списка по
значениям и по смещению, инструкция del удаляет элемент списка
или срез, а операции присваивания по индексу или срезу замещают
элемент или целый сегмент списка. Для правильного ответа на во
прос выберите четыре любых метода из указанных.
4. Словари прежде всего изменяются с помощью инструкции присваи
вания по новому или по существующему ключу, что приводит к соз
данию или изменению записи в таблице. Кроме того, инструкция
del удаляет ключ, метод update вклеивает один словарь в другой,
а вызов D.pop(key) удаляет ключ и возвращает его значение. Словари
имеют и другие, более необычные методы изменения, которые не
были перечислены в этой главе, такие как setdefault. За дополни
тельной информацией обращайтесь к справочным руководствам.
9
Кортежи, файлы и все остальное
Эта глава завершает наше детальное исследование базовых типов объек
тов языка Python рассмотрением кортежей (коллекций объектов, кото
рые не могут изменяться) и файлов (интерфейсов к внешним файлам
в вашем компьютере). Как вы узнаете, кортежи – это относительно про
стые объекты, поддерживающие операции, которые по большей части
вам уже знакомы по строкам и спискам. Объектыфайлы – это широко
используемые многофункциональные инструменты для работы с фай
лами – краткий обзор файлов, что приводится здесь, будет дополнен
примерами их использования в последующих главах этой книги.
Кроме того, эта глава завершает данную часть книги рассмотрением
свойств, общих для объектов всех типов, с которыми мы познакоми
лись, – понятия равенства, сравнения, копий объекта и т. д. Мы также
кратко познакомимся и с другими типами объектов, присутствующи
ми в арсенале Python, – несмотря на то, что мы рассмотрели все основ
ные встроенные типы, спектр объектов в языке Python гораздо шире,
чем я давал вам основания полагать к этому моменту. В заключение
мы закроем эту часть книги изучением связанных с типами объектов
ловушек, в которые часто попадаются программисты, и исследуем не
которые примеры, которые позволят вам поэкспериментировать с ос
военными идеями.1
1 После детального изучения удобно пользоваться краткими справочника
ми, например, представленными в справочном разделе официального сай
та проекта Python. Особо стоить отметить Мастерскую отцаоснователя Py
thon (Python Workshop by Guido van Rossum). Презентация доступна по ад
ресу: http://www.python.org/doc/essays/ppt/acm+ws/. – Примеч. науч. ред.
240 Глава 9. Кортежи, файлы и все остальное
Кортежи
Последний тип коллекций в нашем обзоре – это кортежи. Кортежи
представляют собой простые группы объектов. Они работают точно так
же, как списки, за исключением того, что не допускают непосредствен
ного изменения (они являются неизменяемыми) и в литеральной фор
ме записываются как последовательность элементов в круглых, а не
в квадратных скобках. Кортежи не имеют методов, но они обладают
большинством свойств, присущим спискам. Ниже коротко рассматри
ваются их свойства. Кортежи:
Это упорядоченные коллекции объектов произвольных типов
Подобно строкам и спискам кортежи являются коллекциями объ
ектов, упорядоченных по позициям (т. е. они обеспечивают упоря
дочение своего содержимого слева направо). Подобно спискам они
могут содержать объекты любого типа.
Обеспечивают доступ к элементам по смещению
Подобно строками и спискам доступ к элементам кортежей осуще
ствляется по смещению (а не по ключу) – они поддерживают все
операции, которые основаны на использовании смещения, такие
как индексирование и извлечение среза.
Относятся к категории неизменяемых последовательностей
Подобно строкам кортежи являются неизменяемыми объектами –
они не поддерживают никаких операций непосредственного изме
нения, которые применяются к спискам. Подобно строкам и спи
скам кортежи являются последовательностями и поддерживают
многие операции над последовательностями.
Имеют фиксированную длину, гетерогенны и поддерживают
произвольное число уровней вложенности
Поскольку кортежи являются неизменяемыми объектами, вы не
можете изменить размер кортежа, минуя процедуру создания ко
пии. С другой стороны, кортежи могут хранить другие составные
объекты (т. е. списки, словари и другие кортежи), а следовательно,
поддерживают произвольное число уровней вложенности.
Массив ссылок на объекты
Подобно спискам кортежи проще представлять как массивы ссы
лок на объекты – кортежи хранят указатели (ссылки) на другие
объекты, а операция индексирования над кортежами выполняется
очень быстро.
В табл. 9.1 приводятся наиболее часто используемые операции над
кортежами. В программном коде кортежи записываются как последо
вательность объектов (точнее, выражений, которые создают объекты),
разделенных запятыми, заключенная в круглые скобки. Пустые кор
тежи определяются как пара пустых круглых скобок.
Кортежи в действии 241
Таблица 9.1. Литералы кортежей и операции
Кортежи в действии
Как обычно, запустите интерактивный сеанс работы с интерпретато
ром Python, чтобы приступить к исследованию кортежей в действии.
Обратите внимание: в табл. 9.1 отсутствуют методы кортежей (т. е. ме
тод append к кортежам неприменим). Это действительно так, зато кор
тежи поддерживают обычные операции над последовательностями,
которые применяются к строкам и к спискам:
>>> (1, 2) + (3, 4) # Конкатенация
(1, 2, 3, 4)
>>> (1, 2) * 4 # Повторение
(1, 2, 1, 2, 1, 2, 1, 2)
>>> T = (1, 2, 3, 4) # Индексирование, извлечение среза
>>> T[0], T[1:3]
(1, (2, 3))
Особенности синтаксиса определения кортежей:
запятые и круглые скобки
Вторая и четвертая строки в табл. 9.1 заслуживают дополнительных
пояснений. Поскольку круглые скобки могут также окружать выра
жения (глава 5), необходимо чтото предпринять, чтобы дать интер
претатору понять, что единственный объект в круглых скобках – это
кортеж, а не простое выражение. Если вам действительно необходимо
получить кортеж с единственным элементом, нужно просто добавить
запятую после этого элемента, перед закрывающей круглой скобкой:
Операция Интерпретация
() Пустой кортеж
t1 = (0,) Кортеж из одного элемента (не выражение)
t2 = (0, 'Ni', 1.2, 3) Кортеж из четырех элементов
t2 = 0, 'Ni', 1.2, 3 Еще один кортеж из четырех элементов (тот же
самый, что и строкой выше)
t3 = ('abc', ('def', 'ghi')) Вложенные кортежи
t1[i]
t3[i][j]
t1[i:j]
len(t1)
Индекс, индекс индекса, срез, длина
t1 + t2
t2 * 3
Конкатенация, повторение
for x in t
'spam' in t2
Обход в цикле, проверка вхождения
242 Глава 9. Кортежи, файлы и все остальное
>>> x = (40) # Целое число
>>> x
40
>>> y = (40,) # Кортеж, содержащий целое число
>>> y
(40,)
В виде исключения при определении кортежей интерпретатор позво
ляет опускать открывающую и закрывающую круглые скобки, если
синтаксически конструкция интерпретируется однозначно. Например,
в четвертой строке таблицы кортеж создается простым перечислением
четырех элементов, разделенных запятыми. В контексте операции
присваивания интерпретатор распознает, что это кортеж, даже при от
сутствии круглых скобок.
Ктото может посоветовать вам всегда использовать круглые скобки
в кортежах, а ктото – посоветовать никогда не использовать их (най
дутся и те, кто не скажет вам, что с кортежами делать!). Единственное
место, где круглые скобки являются обязательными, – при передаче
кортежей функциям в виде литералов (где круглые скобки имеют важ
ное значение) и при передаче их инструкции print (где важное значе
ние имеют запятые).
Начинающим программистам можно посоветовать следующее – веро
ятно, легче использовать круглые скобки, чем выяснять ситуации, ко
гда они могут быть опущены. Многие также считают, что круглые
скобки повышают удобочитаемость сценариев, делая кортежи в про
граммном коде более заметными, но у вас может быть свое собственное
мнение на этот счет.
Преобразования и неизменяемость
Хотя синтаксис литералов отличается, операции, выполняемые над
кортежами (последние три строки в табл. 9.1), идентичны операциям,
применяемым к строкам и спискам. Единственное отличие состоит
в том, что операции +, * и извлечения среза при применении к корте
жам возвращают новые кортежи, а также в том, что в отличие от
строк, списков и словарей, кортежи не имеют методов. Если, к приме
ру, необходимо отсортировать содержимое кортежа, его сначала сле
дует преобразовать в список, чтобы превратить его в изменяемый объ
ект и получить доступ к методу сортировки:
>>> T = ('cc', 'aa', 'dd', 'bb')
>>> tmp = list(T) # Создается список из элементов кортежа
>>> tmp.sort() # Сортировка списка
>>> tmp
['aa', 'bb', 'cc', 'dd']
>>> T = tuple(tmp) # Создается кортеж из элементов списка
>>> T
('aa', 'bb', 'cc', 'dd')
Кортежи в действии 243
Здесь list и tuple – это встроенные функции, которые используются
для преобразования в список и затем обратно в кортеж. В действитель
ности обе функции создают новые объекты, но благодаря им создается
эффект преобразования.
Для преобразования кортежей можно также использовать генераторы
списков (list comprehensions). Например, ниже из кортежа создается
список, причем попутно к каждому элементу прибавляется число 20:
>>> T = (1, 2, 3, 4, 5)
>>> L = [x + 20 for x in T]
>>> L
[21, 22, 23, 24, 25]
Генераторы списков в действительности являются операциями над по
следовательностями – они всегда создают новые списки, но они могут
использоваться для обхода содержимого любых объектов последователь
ностей, включая кортежи, строки и другие списки. Как будет показано
дальше, они могут применяться даже к программным компонентам, ко
торые физически не являются последовательностями, – к любым объек
там, поддерживающим возможность выполнения итераций, включая
файлы, которые автоматически читаются строка за строкой.
Кроме того, следует заметить, что правило неизменяемости кортежа
применимо только к самому кортежу, но не к объектам, которые он со
держит. Например, список внутри кортежа может изменяться как
обычно:
>>> T = (1, [2, 3], 4)
>>> T[1] = 'spam' # Ошибка: нельзя изменить сам кортеж
TypeError: object doesn't support item assignment
(Перевод: TypeError: объект не поддерживает операцию присваивания элементам)
>>> T[1][0] = 'spam' # Допустимо: вложенный изменяемый объект можно изменить
>>> T
(1, ['spam', 3], 4)
Для большинства программ такой одноуровневой неизменяемости для
обычного использования кортежей вполне достаточно. О чем, совер
шенно случайно, и рассказывается в следующем разделе.
Для чего нужны кортежи, когда уже имеются списки?
Похоже, что это самый первый вопрос, который задают начинающие
программисты, узнав о кортежах: «Зачем нам нужны кортежи, когда
у нас уже имеются списки?». Некоторые из причин корнями уходят
в прошлое – создатель языка Python является математиком по образо
ванию, который видел кортежи как простые ассоциации объектов,
а списки – как структуры данных, допускающие изменения в течение
всего времени своего существования.
Однако более правильным будет считать, что неизменяемость корте
жей обеспечивает своего рода поддержку целостности, – вы можете
244 Глава 9. Кортежи, файлы и все остальное
быть уверены, что кортеж не будет изменен посредством другой ссыл
ки из другого места в программе, чего нельзя сказать о списках. Тем
самым кортежи играют роль объявлений «констант», присутствую
щих в других языках программирования, несмотря на то, что в языке
Python это понятие связано с объектами, а не с переменными.
Кроме того, существуют ситуации, в которых кортежи можно исполь
зовать, а списки – нет. Например, в качестве ключей словаря (пример
с разреженными матрицами в главе 8). Некоторые встроенные опера
ции также могут требовать или предполагать использование корте
жей, а не списков. Следует запомнить, что списки должны выбирать
ся, когда требуются упорядоченные коллекции, которые может потре
боваться изменить. Кортежи могут использоваться и в остальных слу
чаях, когда необходимы фиксированные ассоциации объектов.
Файлы
Возможно, вы уже знакомы с понятием файла – так называются об
ласти постоянной памяти в вашем компьютере, которыми управляет
операционная система. Последний основной встроенный тип объек
тов, который мы исследуем в нашем обзоре, обеспечивает возможность
доступа к этим файлам из программ на языке Python.
Проще говоря, встроенная функция open создает объект файла, кото
рый обеспечивает связь с файлом, размещенным в компьютере. После
вызова функции open можно выполнять операции чтения и записи во
внешний файл, используя методы полученного объекта. Встроенное
имя file является синонимом имени open, поэтому файлы могут откры
ваться обращением к функции как по имени open, так и по имени file.
Обычно для выполнения операции открытия файла предпочтительнее
использовать функцию open, тогда как имя file в основном предназна
чено для обеспечения соответствия требованиям объектноориентиро
ванного программирования (описывается далее в этой книге).
По сравнению с типами, с которыми вы уже знакомы, объекты файлов
выглядят несколько необычно. Они не являются ни числами, ни по
следовательностями или отображениями – для задач работы с файла
ми они предоставляют одни только методы. Большинство методов
файлов связаны с выполнением операций вводавывода во внешние
файлы, ассоциированные с объектом, но существуют также методы,
которые позволяют переходить на другую позицию в файле, выталки
вать на диск буферы вывода и т. д.
Открытие файлов
В табл. 9.2 приводятся наиболее часто используемые операции над фай
лами. Чтобы открыть файл, программа должна вызвать функцию open,
передав ей имя внешнего файла и режим работы. Обычно в качестве
режима используется строка 'r', когда файл открывается для чтения
Файлы 245
(по умолчанию), 'w' – когда файл открывается для записи, или 'a' –
когда файл открывается на запись в конец. Существуют и другие воз
можности, но мы не будем упоминать о них здесь. В некоторых случа
ях в конец строки режима может добавляться символ b, что позволяет
работать с двоичными данными (интерпретация символов новой стро
ки отключена), а добавление символов a+ означает, что файл открыва
ется как для чтения, так и для записи (т. е. из файла можно читать
и записывать в него с помощью одного и того же объекта).
Таблица 9.2. Часто используемые операции над файлами
Оба аргумента функции open должны быть строками. Кроме того, мо
жет использоваться третий необязательный аргумент, управляющий
буферизацией выводимых данных, – значение ноль означает, что вы
ходная информация не будет буферизироваться (т. е. она будет записы
ваться во внешний файл сразу же, в момент вызова метода записи).
Имя внешнего файла может включать платформозависимые префиксы
абсолютного или относительного пути к файлу. Если путь к файлу не
указан, предполагается, что он находится в текущем рабочем каталоге
(т. е. в каталоге, где был запущен сценарий).
Операция Интерпретация
output = open('/tmp/spam', 'w') Открывает файл для записи ('w' означает write –
запись)
input = open('data', 'r') Открывает файл для чтения ('r' означает read –
чтение)
input = open('data') То же самое, что и в предыдущей строке (ре
жим 'r' используется по умолчанию)
aString = input.read() Чтение файла целиком в единственную строку
aString = input.read(N) Чтение следующих N байтов (одного или более)
в строку
aString = input.readline() Чтение следующей текстовой строки (включая
символ конца строки) в строку
aList = input.readlines() Чтение файла целиком в список строк
output.write(aString) Запись строки в файл
output.writelines(aList) Запись всех строк из списка в файл
output.close() Закрытие файла вручную (выполняется по
окончании работы с файлом)
output.flush() Выталкивает выходные буферы на диск, файл
остается открытым
anyFile.seek(N) Изменяет текущую позицию в файле для сле
дующей операции, смещая ее на N байтов от на
чала файла.
246 Глава 9. Кортежи, файлы и все остальное
Использование файлов
Как только будет получен объект файла, вы можете вызывать его ме
тоды для выполнения операций чтения или записи. В любом случае
содержимое файла в программах на языке Python принимает форму
строк – операция чтения возвращает текст в строках, а метод записи
принимает информацию в виде строк. Существует несколько разно
видностей методов чтения и записи, а в табл. 9.2 перечислены лишь
наиболее часто используемые из них.
Несмотря на то, что методы чтения и записи, перечисленные в табли
це, являются наиболее часто используемыми, имейте в виду, что са
мый лучший, пожалуй, способ чтения строк из файла на сегодняшний
день состоит в том, чтобы не читать файл вообще – как будет показано
в главе 13, файлы имеют итератор (iterator), который автоматически
читает информацию из файла строку за строкой в контексте цикла for,
в генераторах списков и в других итерационных контекстах.
Обратите внимание: данные, получаемые из файла, всегда попадают
в сценарий в виде строки, поэтому вам необходимо будет выполнять
преобразование данных в другие типы объектов языка Python, если
эта форма представления вам не подходит. Точно так же при выполне
нии операции записи данных в файл, в отличие от инструкции print,
интерпретатор Python не выполняет автоматическое преобразование
объектов в строки – вам необходимо передавать методам уже сформи
рованные строки. Поэтому при работе с файлами вам пригодятся рас
сматривавшиеся ранее инструменты преобразования данных из стро
кового представления в числовое и наоборот (например, int, float, str
и выражения форматирования строк). Кроме того, в состав Python
входят дополнительные стандартные библиотечные инструменты,
предназначенные для работы с универсальным объектом хранилища
данных (например, модуль pickle) и обработки упакованных двоич
ных данных в файлах (например, модуль struct). С действием обоих
модулей мы познакомимся ниже, в этой же главе.
Вызов метода close разрывает связь с внешним файлом. Как рассказы
валось в главе 6, интерпретатор Python немедленно освобождает па
мять, занятую объектом, как только в программе будет утеряна по
следняя ссылка на этот объект. Как только объект файла освобождает
ся, интерпретатор автоматически закрывает ассоциированный с ним
файл. Благодаря этому вам не требуется закрывать файл вручную, осо
бенно в небольших сценариях, которые выполняются непродолжи
тельное время. С другой стороны, вызов метода close не повредит, и его
рекомендуется использовать в крупных системах. Строго говоря, воз
можность автоматического закрытия файлов не является частью спе
цификации языка, и с течением времени такое поведение может изме
ниться. Следовательно, привычку вызывать метод close вручную мож
но только приветствовать.
Файлы 247
Файлы в действии
Давайте рассмотрим небольшие примеры, демонстрирующие основы
работы с файлами. В первом примере выполняется открытие нового
файла в режиме для записи, в него записывается строка (завершающая
ся символом новой строки \n), после чего файл закрывается. Далее этот
же файл открывается в режиме для чтения и выполняется чтение стро
ки из него. Обратите внимание, что второй вызов метода readline воз
вращает пустую строку – таким способом методы файла в языке Python
сообщают о том, что был достигнут конец файла (пустая строка в фай
ле возвращается как строка, содержащая единственный символ новой
строки, а не как действительно пустая строка). Ниже приводится пол
ный листинг сеанса:
>>> myfile = open('myfile', 'w') # Открывает файл для записи (создает файл)
>>> myfile.write('hello text file\n') # Записывает строку текста
>>> myfile.close() # Выталкивает выходные буферы на диск
>>> myfile = open('myfile') # Открывает файл для чтения: 'r' – по умолчанию
>>> myfile.readline() # Читает строку
'hello text file\n'
>>> myfile.readline() # Пустая строка: конец файла
''
Этот пример записывает единственную строку текста в файл, добавляя
в нее символ конца строки \n – методы записи не добавляют символ
конца строки, поэтому нам необходимо добавлять его в выводимые
строки (в противном случае следующая операция записи дополнит те
кущую строку в файле).
Сохранение и интерпретация объектов Python в файлах
Теперь создадим большой файл. Следующий пример записывает раз
личные объекты в текстовый файл. Обратите внимание на использова
ние средств преобразования объектов в строки. Напомню, что данные
всегда записываются в файл в виде строк, а методы записи не выпол
няют автоматического преобразования данных:
>>> X, Y, Z = 43, 44, 45 # Объекты языка Python должны
>>> S = 'Spam' # записываться в файл только в виде строк
>>> D = {'a': 1, 'b': 2}
>>> L = [1, 2, 3]
>>>
>>> F = open('datafile.txt', 'w') # Создает файл для записи
>>> F.write(S + '\n') # Строки завершаются символом \n
>>> F.write('%s,%s,%s\n' % (X, Y, Z)) # Преобразует числа в строки
>>> F.write(str(L) + '$' + str(D) + '\n') # Преобразует и разделяет символом $
>>> F.close()
Создав файл, мы можем исследовать его содержимое, открыв файл
и прочитав данные в строку (одной операцией). Обратите внимание,
что функция автоматического вывода в интерактивной оболочке дает
точное побайтовое представление содержимого, а инструкция print
248 Глава 9. Кортежи, файлы и все остальное
интерпретирует встроенные символы конца строки, чтобы обеспечить
более удобочитаемое отображение:
>>> bytes = open('datafile.txt').read() # Отображение bytes
>>> bytes # в неформатированном виде
"Spam\n43,44,45\n[1, 2, 3]${'a': 1, 'b': 2}\n"
>>> print bytes # Удобочитаемое представление
Spam
43,44,45
[1, 2, 3]${'a': 1, 'b': 2}
Теперь нам необходимо выполнить обратные преобразования, чтобы
получить действительные объекты языка Python из строк в текстовом
файле. Интерпретатор Python никогда автоматически не выполняет
преобразование строк в числа или в объекты других типов, поэтому
нам необходимо выполнить соответствующие преобразования, чтобы
можно было использовать операции над этими объектами, такие как
индексирование, сложение и т. д.:
>>> F = open('datafile.txt') # Открыть файл снова
>>> line = F.readline() # Прочитать одну строку
>>> line
'Spam\n'
>>> line.rstrip() # Удалить символ конца строки
'Spam'
Для этой первой строки был использован метод rstrip, чтобы удалить
завершающий символ конца строки. Тот же эффект можно было бы
получить с помощью извлечения среза line[:1], но такой подход мож
но использовать, только если мы уверены, что все строки завершаются
символом \n (последняя строка в файле иногда может не содержать
этого символа). Пока что мы прочитали ту часть файла, которая содер
жит строку. Теперь прочитаем следующий блок, в котором содержат
ся числа, и выполним разбор этого блока (т. е. извлечем объекты):
>>> line = F.readline() # Следующая строка из файла
>>> line # Это – строка
'43,44,45\n'
>>> parts = line.split(',') # Разбить на подстроки по запятым
>>> parts
['43', '44', '45\n']
Здесь был использован строковый метод split, чтобы разбить строку
на части по запятым, которые играют роль символовразделителей –
в результате мы получили список строк, каждая из которых содержит
отдельное число. Теперь нам необходимо преобразовать эти строки
в целые числа, чтобы можно было выполнять математические опера
ции над ними:
>>> int(parts[1]) # Преобразовать строку в целое число
44
>>> numbers = [int(P) for P in parts] # Преобразовать весь список
Файлы 249
>>> numbers
[43, 44, 45]
Как мы уже знаем, функция int преобразует строку цифр в объект це
лого числа, а генератор списков, представленный в главе 4, позволяет
применить функцию ко всем элементам списка в одной инструкции
(подробнее о генераторах списков читайте далее в этой книге). Обрати
те внимание: для удаления завершающего символа \n в конце послед
ней подстроки не был использован метод rstrip, потому что int и неко
торые другие функции преобразования просто игнорируют символы
разделители, окружающие цифры.
Для преобразования списка и словаря в третьей строке файла восполь
зуемся встроенной функцией eval, интерпретирущей строку как код
на Python (формально строка содержит выражение на языке Python):
>>> line = F.readline()
>>> line
"[1, 2, 3]${'a': 1, 'b': 2}\n"
>>> parts = line.split('$') # Разбить на строки по символу $
>>> parts
['[1, 2, 3]', "{'a': 1, 'b': 2}\n"]
>>> eval(parts[0]) # Преобразовать строку в объект
[1, 2, 3]
>>> objects = [eval(P) for P in parts] # То же самое для всех строк в списке
>>> objects
[[1, 2, 3], {'a': 1, 'b': 2}]
Поскольку теперь все данные представляют собой список обычных
объектов, а не строк, мы сможем применять к ним операции списков
и словарей.
Сохранение объектов Python с помощью модуля pickle
Функция eval, использованная в предыдущем примере для преобразо
вания строк в объекты, представляет собой мощный инструмент. И ино
гда даже слишком мощный. Функция eval без лишних вопросов вы
полнит любое выражение на языке Python, даже если в результате бу
дут удалены все файлы в компьютере, если передать в выражение со
ответствующие права доступа! Если вам действительно необходимо
извлекать объекты Python из файлов, но вы не можете доверять источ
нику этих файлов, идеальным решением будет использование модуля
pickle, входящего в состав стандартной библиотеки Python.
Модуль pickle позволяет сохранять в файлах практически любые объек
ты Python без необходимости с нашей стороны выполнять какиелибо
преобразования. Он напоминает суперуниверсальную утилиту форма
тирования и преобразования данных. Чтобы сохранить словарь в файле,
например, мы передаем его непосредственно в функцию модуля pickle:
>>> F = open('datafile.txt', 'w')
>>> import pickle
250 Глава 9. Кортежи, файлы и все остальное
>>> pickle.dump(D, F) # Модуль pickle запишет в файл любой объект
>>> F.close()
Чтобы потом прочитать словарь обратно, можно просто еще раз вос
пользоваться возможностями модуля pickle:
>>> F = open('datafile.txt')
>>> E = pickle.load(F) # Загружает любые объекты из файла
>>> E
{'a': 1, 'b': 2}
Нам удалось получить назад точно такой же объект словаря без необ
ходимости вручную выполнять какиелибо преобразования. Модуль
pickle выполняет то, что называется сериализацией объектов – преоб
разование объектов в строку и из строки байтов, не требуя от нас почти
никаких действий. В действительности, внутренняя реализация моду
ля pickle выполнила преобразование нашего словаря в строку, при
этом незаметно для нас (и может выполнить еще более замысловатые
преобразования при использовании модуля в других режимах):
>>> open('datafile.txt').read()
"(dp0\nS'a'\np1\nI1\nsS'b'\np2\nI2\ns."
Поскольку модуль pickle умеет реконструировать объекты из строково
го представления, нам не требуется самим возиться с этим. Дополни
тельную информацию о модуле pickle вы найдете в руководстве по
стандартной библиотеке языка Python или попробовав импортировать
модуль в интерактивном сеансе и передав его имя функции help. Когда
будете заниматься исследованием этого модуля, обратите также внима
ние на модуль shelve – инструмент, который использует модуль pickle
для сохранения объектов Python в файлах с доступом по ключу, описа
ние которых далеко выходит за рамки этой книги.
Сохранение и интерпретация упакованных
двоичных данных в файлах
Прежде чем двинуться дальше, необходимо рассмотреть еще один ас
пект работы с файлами: в некоторых приложениях приходится иметь
дело с упакованными двоичными данными, которые создаются, на
пример, программами на языке C. Для их сохранения и восстанов
ления можно воспользоваться модулем struct из стандартной библио
теки языка Python. В некотором смысле это совершенно другой инст
румент преобразования данных, интерпретирующий строки в файлах
как двоичные данные.
Например, чтобы создать файл с упакованными двоичными данными,
откройте его в режиме 'wb' (write binary – запись двоичных данных)
и передайте модулю struct строку форматирования и некоторый объект
Python. В следующем примере используется строка форматирования,
которая определяет пакет данных как содержащий 4байтовое целое
число, 4символьную строку и 2байтовое целое число, причем все пред
ставлены в формате bigendian – в порядке следования байтов «от стар
Файлы 251
шего к младшему» (существуют также спецификаторы форматов, кото
рые поддерживают наличие символов дополнения слева, числа с пла
вающей точкой и многие другие):
>>> F = open('data.bin', 'wb') # Открыть файл для записи в двоичном режиме
>>> import struct
>>> bytes = struct.pack('>i4sh', 7, 'spam', 8) # Создать пакет двоичных данных
>>> bytes
'\x00\x00\x00\x07spam\x00\x08'
>>> F.write(bytes) # Записать строку байтов
>>> F.close()
Интерпретатор Python создает строку двоичных данных, которая затем
записывается в файл обычным способом (строка состоит из экранирован
ных последовательностей, представляющих шестнадцатеричные значе
ния). Чтобы преобразовать эти значения в обычные объекты языка Py
thon, достаточно просто прочитать строку обратно и распаковать ее с ис
пользованием той же строки формата. Следующий фрагмент извлекает
значения, преобразуя их в обычные объекты (целые числа и строка):
>>> F = open('data.bin', 'rb')
>>> data = F.read() # Получить упакованные двоичные данные
>>> data
'\x00\x00\x00\x07spam\x00\x08'
>>> values = struct.unpack('>i4sh', data) # Преобразовать в объекты
>>> values
(7, 'spam', 8)
Файлы с двоичными данными относятся к категории низкоуровневых
средств, которые мы не будем рассматривать подробно. За дополни
тельной информацией обращайтесь к руководству по библиотеке язы
ка Python или импортируйте модуль struct в интерактивном сеансе
и передайте имя struct функции help. Обратите также внимание на то,
что режимы доступа к двоичным файлам 'wb' и 'rb' могут использо
ваться для обработки простейших двоичных файлов, таких как изо
бражения или аудиофайлы, без необходимости выполнять распаковку
их содержимого.
Другие инструменты для работы с файлами
Как показано в табл. 9.2, существуют более сложные инструменты для
работы с файлами, более того, существуют и другие инструменты, ко
торые отсутствуют в таблице. Например, функция seek переустанавли
вает текущую позицию в файле (которая будет использована в следую
щей операции чтения или записи), функция flush принудительно вы
талкивает содержимое выходных буферов на диск (по умолчанию фай
лы всегда буферизуются) и т. д.
Руководство по стандартной библиотеке и книги, упомянутые в преди
словии, содержат полный перечень методов для работы с файлами.
Чтобы кратко ознакомиться с ним, можно также воспользоваться
функцией dir или help в интерактивном сеансе, передав ей слово file
252 Глава 9. Кортежи, файлы и все остальное
(имя типа объектов). Дополнительные примеры работы с файлами вы
найдете во врезке «Придется держать в уме: сканирование файлов»
в главе 13. В ней приводятся типичные примеры организации циклов
для просмотра содержимого файлов и приводятся инструкции, кото
рые мы еще не рассматривали.
Следует также отметить, что функция open и объекты файлов, которые
она возвращает, являются в языке Python основным интерфейсом
к внешним файлам, однако в арсенале Python существуют и другие ин
струменты, напоминающие файлы. Кроме того, имеется возможность
взаимодействовать с дескрипторами файлов (целочисленные значения,
которые поддерживаются такими низкоуровневыми средствами, как
механизм блокировки файлов), реализованная в модуле os; сокетами,
каналами и файлами FIFO (объекты, по своим характеристикам напо
минающие файлы, используемые для синхронизации процессов или
организации взаимодействий по сети); с файлами с доступом по ключу,
известными как «хранилища» («shelves») и используемыми для хране
ния объектов языка Python по ключу; и многими другими. За получе
нием дополнительной информации обо всех этих инструментах обра
щайтесь к специализированной литературе по языку Python.
Пересмотренный перечень категорий типов
Теперь, когда мы познакомились со всеми встроенными базовыми ти
пами языка Python в действии, давайте завершим наше турне рассмот
рением некоторых общих для них свойств.
В табл. 9.3 приводится классификация всех рассмотренных типов по
категориям, которые были введены ранее. Над объектами одной кате
гории могут выполняться одни и те же операции, например, над стро
ками, списками и кортежами можно выполнять операции для последо
вательностей. Непосредственное изменение допускают только изменяе
мые объекты (списки и словари) – вы не сможете непосредственно из
менить числа, строки и кортежи. Файлы только экспортируют методы,
поэтому понятие изменяемости к ним понастоящему неприменимо –
хотя они могут изменяться при выполнении операции записи, но это не
имеет никакого отношения к ограничениям типов в языке Python.
Таблица 9.3. Классификация объектов
Тип объектов Категория Изменяемый?
Числа Числа Нет
Строки Последовательности Нет
Списки Последовательности Да
Словари Отображения Да
Кортежи Последовательности Нет
Файлы Расширения Понятие неприменимо
Гибкость объектов 253
Гибкость объектов
В этой части книги были представлены несколько составных типов
объектов (коллекции с компонентами). В общем случае:
• Списки, словари и кортежи могут хранить объекты любых типов.
• Списки, словари и кортежи допускают произвольную вложенность.
• Списки и словари могут динамически увеличиваться и уменьшаться.
Поскольку составные типы объектов в языке Python поддерживают
любые структуры данных, они прекрасно подходят для представления
в программах данных со сложной структурой. Например, значениями
элементов словарей могут быть списки, которые могут содержать кор
тежи, которые в свою очередь могут содержать словари, и т. д. Вло
женность может быть произвольной глубины, какая только потребует
ся, чтобы смоделировать структуру обрабатываемых данных.
Рассмотрим пример с вложенными компонентами. В следующем при
мере определяется три вложенных составных объекта последователь
ностей, как показано на рис. 9.1. Для обращения к отдельным элемен
там допускается использовать столько индексов, сколько потребуется.
В языке Python разыменование индексов производится слева направо
Придется держать в уме: перегрузка операторов
Позднее мы увидим, что объекты, реализованные с помощью
классов, могут свободно попадать в любую из этих категорий. На
пример, если нам потребуется реализовать новый тип объектов
последовательностей, который был бы совместим со встроенны
ми типами последовательностей, мы могли бы описать класс, ко
торый перегружает операторы индексирования и конкатенации:
class MySequence:
def __getitem__(self, index):
# Вызывается при выполнении операции self[index]
def __add__(self, other):
# Вызывается при выполнении операции self + other
и т. д. Точно так же можно было бы создать новый изменяемый
или неизменяемый объект, выборочно реализовав методы, вызы
ваемые для выполнения операций непосредственного изменения
(например, для выполнения операций присваивания self[index]
= value вызывается метод __setitem__). Существует также воз
можность выполнять реализацию новых объектов на других
языках программирования, таких как C, в виде расширений.
Чтобы определить выбор между множествами операций над чис
лами, последовательностями и отображениями, необходимо бу
дет подставить указатели на функции C в ячейки структуры.
254 Глава 9. Кортежи, файлы и все остальное
и на каждом шаге извлекается объект на более глубоком уровне. Струк
тура данных на рис. 9.1 может показаться излишне сложной, но она
иллюстрирует синтаксис, который используется для доступа к данным:
>>> L = ['abc', [(1, 2), ([3], 4)], 5]
>>> L[1]
[(1, 2), ([3], 4)]
>>> L[1][1]
([3], 4)
>>> L[1][1][0]
[3]
>>> L[1][1][0][0]
3
Ссылки и копии
В главе 6 говорилось, что при выполнении операции присваивания все
гда сохраняется ссылка на объект, а не копия самого объекта. В боль
шинстве случаев именно это нам и требуется. Однако в процессе выпол
нения операций присваиваний может быть создано несколько ссылок
на один и тот же объект, поэтому очень важно понимать, что измене
ния, произведенные в изменяемом объекте с помощью одной ссылки,
отразятся и на других ссылках, указывающих на этот же объект. Если
такой порядок вещей является нежелательным, вам необходимо явно
сообщить интерпретатору, чтобы он создал копию объекта.
Мы изучили это явление в главе 6, но ситуация может обостриться, ко
гда в игру вступят крупные объекты. Например, в следующем приме
Рис. 9.1. Дерево вложенных объектов со смещениями их компонентов,
созданное с помощью литерального выражения ['abc', [(1, 2), ([3], 4)], 5].
Синтаксически вложенные объекты внутри реализованы в виде ссылок
(т. е. в виде указателей) на отдельные участки памяти
abc 5
4
3
1 2
[0] [1] [2]
[0] [1]
[0] [1]
[0]
[0] [1]
Гибкость объектов 255
ре создается список, которому ставится в соответствие переменная X,
затем создается другой список, которому ставится в соответствие пере
менная L, который включает ссылку на список X. Далее создается сло
варь D, который содержит еще одну ссылку на список X:
>>> X = [1, 2, 3]
>>> L = ['a', X, 'b'] # Встроенная ссылка на объект X
>>> D = {'x':X, 'y':2}
В этот момент существует три ссылки на список, который был создан
первым: из переменной X, из элемента списка, соответствующего пере
менной L, и из элемента словаря, соответствующего переменной D. Эта
ситуация показана на рис. 9.2.
Так как списки относятся к категории изменяемых объектов, измене
ния в объекте списка, произведенные с помощью любой из трех ссы
лок, также отразятся на других двух ссылках:
>>> X[1] = 'surprise' # Изменяет все три ссылки!
>>> L
['a', [1, 'surprise', 3], 'b']
>>> D
{'x': [1, 'surprise', 3], 'y': 2}
Ссылки – это более высокоуровневый аналог указателей в других язы
ках программирования. И хотя вы не можете извлечь непосредствен
ное значение самой ссылки, тем не менее, одну и ту же ссылку можно
сохранить более чем в одном месте (в переменных, в списках и т. д.).
Это полезная особенность – вы можете передавать крупные объекты
между компонентами программы без выполнения дорогостоящей опе
рации копирования. Однако, когда действительно необходимо создать
копию объекта, вы можете запросить их:
Рис. 9.2. Разделяемые ссылки на объект: поскольку переменная X,
элемент списка L и элемент словаря D ссылаются на один и тот же список,
то изменения, произведенные с помощью X, отразятся также на L и D
Имена Объекты
1 ? 3
L
X
D
256 Глава 9. Кортежи, файлы и все остальное
• Выражение извлечения среза с пустыми пределами (L[:]) создает
копию последовательности.
• Метод словаря copy (D.copy()) создает копию словаря.
• Некоторые встроенные функции, такие как list (list(L)), создают
копию списка.
• Модуль copy, входящий в состав стандартной библиотеки, создает
полные копии объектов.
Например, предположим, что у нас имеются список и словарь, и для нас
нежелательно изменение их значений посредством других переменных:
>>> L = [1,2,3]
>>> D = {'a':1, 'b':2}
Чтобы предотвратить такую возможность, достаточно связать с други
ми переменными копии объектов вместо того, чтобы связать с ними са
ми объекты:
>>> A = L[:] # Вместо A = L (или list(L))
>>> B = D.copy() # Вместо B = D
В этом случае изменения, произведенные с помощью других перемен
ных, повлияют на копии, а не на оригиналы:
>>> A[1] = 'Ni'
>>> B['c'] = 'spam'
>>>
>>> L, D
([1, 2, 3], {'a': 1, 'b': 2})
>>> A, B
([1, 'Ni', 3], {'a': 1, 'c': 'spam', 'b': 2})
Если вернуться к первоначальному примеру, то избежать побочных
эффектов, связанных со ссылками, можно, использовав выражение
извлечения среза из оригинального списка:
>>> X = [1, 2, 3]
>>> L = ['a', X[:], 'b'] # Встроенные копии объекта X
>>> D = {'x':X[:], 'y':2}
Это меняет картину, представленную на рис. 9.2, – L и D теперь ссыла
ются на другие списки, отличные от X. Теперь изменения, выполнен
ные с помощью переменной X, отразятся только на самой переменной
X, но не на L и D; точно так же изменения в L или D никак не будут воз
действовать на X.
Одно замечание по поводу копий: выражение извлечения среза с пус
тыми значениями пределов и метод словаря copy создают поверхност+
ные копии – т. е. они не копируют вложенные структуры данных, да
же если таковые присутствуют. Если необходима полная копия струк
туры произвольной глубины вложенности, следует использовать стан
дартный модуль copy: добавьте инструкцию import copy и вставьте
выражение X = copy.deepcopy(Y), которое создаст полную копию объекта
Сравнения, равенство и истина 257
Y со сколь угодно большой глубиной вложенности. Эта функция вы
полняет рекурсивный обход объектов и копирует все составные части.
Однако такой подход используется намного реже (потому что для это
го приходится писать дополнительный программный код). Обычно
ссылки – это именно то, что нам требуется, в противном случае чаще
всего применяются такие способы копирования, как операция извле
чения среза и метод copy.
Сравнения, равенство и истина
Любые объекты языка Python поддерживают операции сравнения:
проверка на равенство, относительная величина и т. д. Операции срав
нения в языке Python всегда проверяют все части составных объектов,
пока результат не станет определенным. В действительности, для вло
женных объектов интерпретатор Python всегда автоматически выпол
няет обход структуры данных, чтобы применить операции сравнения
рекурсивно, слева направо и настолько глубоко, насколько это необхо
димо. Первое найденное различие определяет результат сравнения.
Например, при сравнении списков автоматически сравниваются все
их компоненты:
>>> L1 = [1, ('a', 3)] # Разные объекты с одинаковыми значениями
>>> L2 = [1, ('a', 3)]
>>> L1 == L2, L1 is L2 # Эквивалентны? Это один и тот же объект?
(True, False)
В данном случае L1 и L2 ссылаются на совершенно разные списки, но
с одинаковым содержимым. Изза природы ссылок в языке Python су
ществует два способа проверки на равенство:
• Оператор == проверяет равенство значений. Интерпретатор выпол
няет проверку на равенство, рекурсивно сравнивая все вложенные
объекты.
• Оператор is проверяет идентичность объектов. Интерпретатор про
веряет, являются ли сравниваемые объекты одним и тем же объек
том (т. е. расположены ли они по одному и тому же адресу в памяти).
В предыдущем примере L1 и L2 прошли проверку == на равенство (они
имеют одинаковое значение, потому что все их компоненты равны), но
не прошли проверку is на эквивалентность (они ссылаются на разные
объекты и, соответственно, на разные области памяти). Однако, обра
тите внимание, что происходит при сравнении двух коротких строк:
>>> S1 = 'spam'
>>> S2 = 'spam'
>>> S1 == S2, S1 is S2
(True, True)
Здесь у нас также присутствуют два различных объекта, имеющие
одинаковые значения: оператор == должна вернуть истину, а оператор
258 Глава 9. Кортежи, файлы и все остальное
is – ложь. Но так как интерпретатор с целью оптимизации кэширует
и повторно использует короткие строки, в действительности обе они
являются одной и той же строкой 'spam' в памяти, которая совместно
используется переменными S1 и S2, поэтому оператор is проверки
идентичности возвращает истину. Чтобы получить нормальное пове
дение, потребуется использовать более длинные строки:
>>> S1 = 'a longer string'
>>> S2 = 'a longer string'
>>> S1 == S2, S1 is S2
(True, False)
Разумеется, так как строки являются неизменяемыми, использование
механизма кэширования объектов не оказывает отрицательного влия
ния на ваш программный код – строки нельзя изменить непосредст
венно независимо от того, сколько переменных ссылаются на них. Ес
ли результат проверки на идентичность кажется вам обескураживаю
щим, вернитесь к главе 6, чтобы освежить в памяти концепцию ссы
лок на объекты.
Как правило, оператор == – это именно то, что требуется в большинстве
случаев проверки равенства; оператор is предназначен для особых
случаев. Мы рассмотрим случаи использования этих операторов далее
в книге.
Операторы отношений к вложенным структурам также применяются
рекурсивно:
>>> L1 = [1, ('a', 3)]
>>> L2 = [1, ('a', 2)]
>>> L1 < L2, L1 == L2, L1 > L2 # Меньше, равно, больше: кортеж результатов
(False, False, True)
Здесь L1 больше, чем L2, потому что вложенное число 3 больше, чем 2.
Результат последней строки в этом примере в действительности пред
ставляет собой кортеж из трех объектов – результатов трех выраже
ний (пример кортежа без объемлющих круглых скобок).
В общем случае Python сравнивает типы следующим образом:
• Числа сравниваются по величине.
• Строки сравниваются лексикографически, символ за символом
("abc" < "ac").
• При сравнении списков и кортежей сравниваются все компоненты
слева направо.
• Словари сравниваются как отсортированные списки (ключ, значе
ние).
Вообще сравнение структурированных объектов выполняется, как ес
ли бы сравнивались образующие их литералы, слева направо, по одно
му компоненту за раз. В последующих главах мы увидим другие типы
объектов, которые могут изменять способ сравнения.
Сравнения, равенство и истина 259
Смысл понятий «Истина» и «Ложь» в языке Python
Обратите внимание, что три значения в кортеже, возвращаемом по
следним примером из предыдущего раздела, – это логические значения
«истина» (true) и «ложь» (false). Они выводятся на экран как слова True
и False, но теперь, когда мы приступаем к использованию логических
проверок, мне следует более формально описать смысл этих названий.
В языке Python, как в большинстве языков программирования, «ложь»
представлена целочисленным значением 0, а «истина» – целочислен
ным значением 1. Кроме того, интерпретатор Python распознает лю
бую пустую структуру данных как «ложь», а любую непустую струк
тура данных – как «истину». В более широком смысле понятия исти
ны и лжи – это свойства, присущие всем объектам в Python, – каждый
объект может быть либо «истиной», либо «ложью»:
• Числа, отличные от нуля, являются «истиной».
• Другие объекты являются «истиной», если они непустые.
В табл. 9.4 приводятся примеры истинных и ложных значений объек
тов в языке Python.
Таблица 9.4. Примеры значений истинности объектов
В языке Python имеется также специальный объект с именем None (по
следняя строка в табл. 9.4), который всегда расценивается как «ложь».
Объект None был представлен в главе 4 – это единственный специаль
ный тип данных в языке Python, который играет роль пустого запол
нителя и во многом похож на указатель NULL в языке C.
Например, вспомните, что списки не допускают присваивание значе
ний отсутствующим элементам (списки не вырастают по волшебству,
когда вы выполняете присваивание некоторого значения несущест
вующему элементу). Чтобы можно было выполнять присваивание лю
бому из 100 элементов списка, обычно создается список из 100 элемен
тов, который заполняется объектами None:
>>> L = [None] * 100
>>>
>>> L
[None, None, None, None, None, None, None, ... ]
Объект Значение
"spam" True
"" False
[] False
{} False
1 True
0.0 False
None False
260 Глава 9. Кортежи, файлы и все остальное
Логический тип bool в языке Python (представленный в главе 5) просто
усиливает понятия «истина» и «ложь» в языке Python. Как вы могли
заметить, результаты операций проверок в этой главе выводятся в ви
де значений True и False. Как мы узнали в главе 5, эти значения явля
ются всего лишь разновидностями целых чисел 1 и 0. Этот тип реали
зован так, что он действительно является лишь незначительным рас
ширением к понятиям «истина» и «ложь», уже описанным, и предна
значенным для того, чтобы сделать значения истинности более
явными. При явном использовании слов True и False в операциях про
верки на истинность они интерпретируются как «истина» и «ложь»,
которые в действительности являются специализированными версия
ми целых чисел 1 и 0. Результаты операций проверок также выводят
ся как слова True и False, а не как значения 1 и 0.
Вам необязательно использовать только логические типы в логиче
ских инструкциях, таких как if, – любые объекты по своей природе
могут быть истинными или ложными, и все логические концепции,
упоминаемые в этой главе, работают, как описано, и с другими типа
ми. Мы займемся исследованием логического типа, когда будем рас
сматривать логические инструкции в главе 12.
Иерархии типов данных в языке Python
На рис. 9.3 приводятся все встроенные типы объектов, доступные в язы
ке Python, и отображены взаимоотношения между ними. Наиболее
значимые из них мы уже рассмотрели; большая часть других видов
объектов на рис. 9.3 соответствует элементам программ (таким как
функции и модули) или отражает внутреннее устройство интерпрета
тора (такие как кадры стека и скомпилированный программный код).
Главное, что следует учитывать, – в языке Python все элементы явля
ются объектами и могут быть использованы в ваших программах. На
пример, можно передать класс в функцию, присвоить его переменной,
заполнить им список или словарь и т. д.
Фактически даже сами типы в языке Python являются видом объектов:
вызов встроенной функции type(X) возвращает тип объекта X. Объекты
типов могут использоваться для сравнения типов вручную в инструк
ции if. Однако по причинам, изложенным в главе 4, ручная проверка
типа в языке Python обычно рассматривается как нечто неправильное.
Одно замечание по поводу имен типов: в версии Python 2.2 у каждого
базового типа появилось новое встроенное имя, добавленное для обес
печения поддержки настройки типов через объектноориентирован
ный механизм наследования классов: dict, list, str, tuple, int, long,
float, complex, unicode, type и file (file – это синоним для open). Эти
имена представляют не просто функции преобразования, а настоящие
конструкторы объектов, хотя при решении несложных задач вы може
те рассматривать их как простые функции.
Иерархии типов данных в языке Python 261
Модуль types, входящий в состав стандартной библиотеки, также пре
доставляет дополнительные имена типов (по большей части это сино
нимы встроенных типов) и предоставляет возможность проверять тип
объекта с помощью функции isinstance. Например, в Python 2.2 и вы
ше все следующие операции проверки возвращают истину:
isinstance([1],list)
type([1])==list
type([1])==type([])
type([1])==types.ListType
Поскольку в современных версиях Python от типов можно порождать
дочерние классы, рекомендуется не пренебрегать функцией isinstance.
Подробнее о создании дочерних классов от встроенных типов в версии
Python 2.2 рассказывается в главе 26.
Рис. 9.3. Основные встроенные типы в языке Python, организованные
по категориям. Все в языке Python является объектом, даже сами типы –
это объекты! Тип любого объекта – это объект типа «type»
Числа
Целoе
Целые Вещественное
Комплексное
Длинное целое Множество
Логическое C фиксированной
точностью
Коллекции
Последовательности Отображения
Неизменяемые Изменяемые
Строка Список
Словарь
Юникод
Кортеж
Вызываемые
Функции
Класс
Метод
Связанный
Несвязанный
Прочие Внутренние
Модуль Тип
Экземпляр Код
Файл Кадр
None Диагностика
262 Глава 9. Кортежи, файлы и все остальное
Другие типы в Python
Помимо базовых объектов, рассмотренных в этой части книги, в соста
ве Python обычно устанавливаются десятки других типов объектов,
доступных в виде связанных расширений на языке C или в виде клас
сов языка Python – объекты регулярных выражений, файлы DBM,
компоненты графического интерфейса, сетевые сокеты и т. д.
Главное отличие между этими и встроенными типами, которые мы до
сих пор рассматривали, состоит в том, что для встроенных типов язы
ком предоставляется специальный синтаксис создания объектов этих
типов (например, 4 – для целого числа, [1,2] – для списка и функция
open – для файла). Другие типы обычно доступны в виде модулей стан
дартной библиотеки, которые необходимо импортировать перед ис
пользованием. Например, чтобы создать объект регулярного выраже
ния, необходимо импортировать модуль re и вызвать re.compile().
Полное руководство по всем типам, доступным в программах на языке
Python, вы найдете в справочнике по библиотеке Python.
Ловушки встроенных типов
Это окончание нашего обзора базовых типов данных. Мы завершаем
эту часть книги обсуждением общих проблем, с которыми сталкива
ются новые пользователи (а иногда и эксперты), и их решений. Отчас
ти – это краткий обзор идей, которые мы уже рассматривали, но они
достаточно важны, чтобы вновь вернуться к ним.
Операция присваивания создает ссылку, а не копию
Поскольку это центральное понятие, я напомню о нем еще раз: вы
должны понимать, что может происходить с разделяемыми ссылками
в вашей программе. Например, ниже создается объект списка, связан
ный с именем L, на это имя также ссылается элемент списка M. Таким
образом, изменение списка с помощью имени L приведет к изменению
списка, на который ссылается и список M:
>>> L = [1, 2, 3]
>>> M = ['X', L, 'Y'] # Встраивает ссылку из L
>>> M
['X', [1, 2, 3], 'Y']
>>> L[1] = 0 # Список M также изменяется
>>> M
['X', [1, 0, 3], 'Y']
Обычно этот эффект обретает важность только в больших программах,
и, как правило, совместное использование ссылок – это именно то, что
необходимо. Если это является нежелательным, вы всегда можете соз
дать явно копию объекта. Для списков всегда можно создать поверх
Ловушки встроенных типов 263
ностную копию с помощью операции извлечения среза с незаданными
пределами:
>>> L = [1, 2, 3]
>>> M = ['X', L[:], 'Y'] # Встраивается копия L
>>> L[1] = 0 # Изменяется только L, но не M
>>> L
[1, 0, 3]
>>> M
['X', [1, 2, 3], 'Y']
Не забывайте, что значениями пределов по умолчанию являются 0
и длина последовательности, откуда извлекается срез. Если оба значе
ния опущены, в результате операции будут извлечены все элементы
последовательности, что создаст поверхностную копию (новый, не раз
деляемый ни с кем объект).
Операция повторения добавляет
один уровень вложенности
Операция повторения последовательности добавляет последователь
ность саму к себе заданное число раз. Это правда, но когда появляются
вложенные изменяемые последовательности, эффект может не всегда
получиться таким, как вы ожидаете. Например, в следующем примере
переменной X присваивается список L, повторенный четырежды, тогда
как переменной Y присваивается повторенный четырежды список, со+
держащий L:
>>> L = [4, 5, 6]
>>> X = L * 4 # Все равно, что [4, 5, 6] + [4, 5, 6] + ...
>>> Y = [L] * 4 # [L] + [L] + ... = [L, L,...]
>>> X
[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]
>>> Y
[[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]
Так как во второй операции повторения L является вложенным спи
ском, то в Y попадают ссылки на оригинальный список, связанный
с именем L, вследствие чего начинают проявляться те же побочные эф
фекты, о которых говорилось в предыдущем разделе:
>>> L[1] = 0 # Воздействует на Y, но не на X
>>> X
[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]
>>> Y
[[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]
Здесь можно применить то же решение, что и в предыдущем разделе,
так как это в действительности всего лишь другой способ получить
разделяемые ссылки на изменяемый объект. Если вы помните, опера
ции повторения, конкатенации и извлечения среза создают только по
верхностные копии объектов, что чаще всего и бывает необходимо.
264 Глава 9. Кортежи, файлы и все остальное
Избегайте создания циклических структур данных
На самом деле мы уже сталкивались с этим понятием в предыдущем
упражнении: если объектколлекция содержит ссылку на себя, он на
зывается циклическим объектом. Всякий раз, когда интерпретатор
Python обнаруживает циклическую ссылку, он выводит [...], чтобы
не попасть в бесконечный цикл:
>>> L = ['grail'] # Добавление ссылки на самого себя
>>> L.append(L) # Создает циклический объект: [...]
>>> L
['grail', [...]]
Кроме понимания того, что три точки в квадратных скобках означают
циклическую ссылку в объекте, это случай заслуживает внимания, т. к.
он может привести к сбоям – циклические структуры могут вызывать
неожиданное зацикливание программного кода, если вы не все преду
смотрели. Например, некоторые программы хранят список или словарь
уже посещенных элементов, с помощью которого обнаруживают попа
дание в цикл. Советы по устранению этих неполадок приводятся в уп
ражнениях к первой части книги, в главе 3; кроме того, решение про
блемы приводится также в конце главы 21, в программе reloadall.py.
Не создавайте циклические ссылки, если они действительно не нуж
ны. Иногда бывают серьезные основания для создания циклических
ссылок, но если ваш программный код не предусматривает их обработ
ку, вам не следует слишком часто заставлять свои объекты ссылаться
на самих себя.
Неизменяемые типы не могут изменяться
непосредственно
Наконец, вы не можете изменять неизменяемые объекты непосредст
венно. Вместо этого создайте новый объект – с помощью операций из
влечения среза, конкатенации и т. д., и присвойте, если это необходи
мо, первоначальной переменной:
T = (1, 2, 3)
T[2] = 4 # Ошибка!
T = T[:2] + (4,) # Все в порядке: (1, 2, 4)
Это может показаться лишней работой, но выигрыш в том, что неизме
няемые объекты, такие как кортежи и строки, не порождают приве
денных выше проблем, т. к. они не могут изменяться непосредственно
и не подвержены, как списки, побочным эффектам такого рода.
В заключение 265
В заключение
В этой главе были исследованы последние два базовых типа объектов –
кортежи и файлы. Мы узнали, что кортежи поддерживают все опера
ции, обычные для последовательностей, но не имеют методов и не по
зволяют выполнять изменения непосредственно в объекте, потому что
они относятся к категории неизменяемых объектов. Мы также узнали,
что объектыфайлы возвращаются функцией open и предоставляют ме
тоды чтения и записи данных. Мы исследовали проблему преобразова
ния объектов Python в строку и обратно, чтобы иметь возможность со
хранять их в файле, и познакомились с модулями pickle и struct, реа
лизующими дополнительные возможности (сериализация объектов
и работа с двоичными данными). В заключение мы рассмотрели неко
торые свойства, общие для всех типов объектов (например, разделяе
мые ссылки) и прошлись по списку часто встречающихся ошибок (ло
вушек), связанных с типами объектов.
В следующей части мы обратимся к теме синтаксиса операторов в язы
ке Python – здесь мы исследуем все основные процедурные операторы.
Следующая глава открывает эту часть книги с введения в общую син
таксическую модель языка Python, которая применима ко всем типам
операторов. Однако, прежде чем двинуться дальше, ознакомьтесь
с контрольными вопросами к главе, а затем проработайте упражнения
к этой части, чтобы коротко повторить основные понятия. Операторы
в основном всего лишь создают и обрабатывают объекты, поэтому,
прежде чем продолжать чтение, вам необходимо проверить владение
этой темой, выполнив упражнения.
Закрепление пройденного
Контрольные вопросы
1. Как определить размер кортежа?
2. Напишите выражение, которое изменит первый элемент в кортеже.
Кортеж со значением (4,5,6) должен стать кортежем со значением
(1,5,6).
3. Какое значение используется по умолчанию в аргументе режима
обработки файла в функции open?
4. Каким модулем можно воспользоваться для сохранения объектов
Python в файл, чтобы избежать выполнения преобразований объек
тов в строки вручную?
5. Как можно выполнить копирование всех частей вложенной струк
туры в одной инструкции?
6. В каких случаях интерпретатор рассматривает объект как «истину»?
7. В чем состоит ваша цель?
266 Глава 9. Кортежи, файлы и все остальное
Ответы
1. Встроенная функция len возвращает длину (количество содержа
щихся элементов) любого контейнерного объекта, включая и корте
жи. Это – встроенная функция, а не метод и потому может приме
няться к самым разным типам объектов.
2. Поскольку кортежи являются неизменяемыми, в действительно
сти их нельзя изменить непосредственно, но можно создать новый
кортеж с желаемым значением. Первый элемент заданного корте
жа T = (4,5,6) можно изменить, создав новый по частям с помощью
операций извлечения среза и конкатенации: T = (1,) + T[1:]. (Не за
бывайте, что в кортежах из одного элемента обязательно должна
присутствовать завершающая запятая.) Также можно было бы пре
образовать кортеж в список, выполнить необходимое изменение не
посредственно в списке и произвести обратное преобразование
в кортеж, но это более дорогостоящая последовательность дейст
вий, которая редко используется на практике; просто используйте
списки, если заранее известно, что может потребоваться изменить
объект непосредственно.
3. Аргумент режима открытия файла в функции open по умолчанию
имеет значение 'r', т. е. файл открывается для чтения. Чтобы от
крыть текстовый файл для чтения, достаточно передать функции
одно только имя файла.
4. Для сохранения объектов Python в файле можно воспользоваться
модулем pickle, что устранит необходимость явного преобразова
ния объектов в строки. Модуль struct позволяет выполнять похо
жие действия, но в предположении, что данные хранятся в файле
в упакованном двоичном формате.
5. Чтобы скопировать все вложенные части структуры X, можно им
портировать модуль copy и вызвать функцию copy.deepcopy(X). Одна
ко такой способ редко можно встретить на практике – ссылок обыч
но бывает достаточно и, как правило, в большинстве случаев доста
точно бывает создать поверхностную копию (например, aList[:],
aDict.copy()).
6. Объект рассматривается как «истина», если он является либо нену
левым числом, либо непустым объектом коллекции. Встроенные
слова True и False по сути являются предопределенными именами
числовых значений 1 и 0 соответственно.
7. В число допустимых ответов входят «Изучить язык Python», «Пе
рейти к следующей части книги» или «Найти святую чашу Грааля».
Упражнения ко второй части
В этом разделе вам предлагается снова пройтись по основам встроен
ных объектов. Как и прежде, вам попутно могут встретиться новые по
нятия, поэтому обязательно сверьтесь с ответами в приложении B, ко
Закрепление пройденного 267
гда закончите (и даже если еще не закончили). Если у вас не так много
свободного времени, я рекомендую начать с упражнений 10 и 11 (так
как они наиболее практичные), а затем, когда появится время, пройти
все упражнения – от первого до последнего. Во всех упражнениях не
обходимо знание фундаментальных сведений, поэтому постарайтесь
выполнить как можно большую их часть.
1. Основы. Поэкспериментируйте в интерактивной оболочке с наибо
лее часто используемыми операциями, которые вы найдете в табли
цах второй части. Для начала запустите интерактивный сеанс рабо
ты с интерпретатором Python, введите все нижеследующие выра
жения и попробуйте объяснить происходящее:
2 ** 16
2 / 5, 2 / 5.0
"spam" + "eggs"
S = "ham"
"eggs " + S
S * 5
S[:0]
"green %s and %s" % ("eggs", S)
('x',)[0]
('x', 'y')[1]
L = [1,2,3] + [4,5,6]
L, L[:], L[:0], L[2], L[2:]
([1,2,3] + [4,5,6])[2:4]
[L[2], L[3]]
L.reverse( ); L
L.sort( ); L
L.index(4)
{'a':1, 'b':2}['b']
D = {'x':1, 'y':2, 'z':3}
D['w'] = 0
D['x'] + D['w']
D[(1,2,3)] = 4
D.keys( ), D.values( ), D.has_key((1,2,3))
[[]], ["",[],( ),{},None]
2. Индексирование и извлечение среза. В интерактивной оболочке соз
дайте список с именем L, который содержит четыре строки или чис
ла (например, L = [0,1,2,3]). Затем исследуйте следующие случаи:
a. Что произойдет, если попытаться получить доступ к элементу,
индекс которого выходит за пределы списка (например, L[4])?
b. Что произойдет, если попытаться извлечь срез, выходящий за
пределы списка (например, L[-1000:100])?
c. Наконец, как отреагирует интерпретатор на попытку извлечь
последовательность в обратном порядке, когда нижняя грани
ца больше верхней (например, L[3:1])? Подсказка: попробуйте
268 Глава 9. Кортежи, файлы и все остальное
выполнить операцию присваивания такому срезу (L[3:1] =
['?']) и посмотреть, куда будет помещено значение. Как вы ду
маете, это то же самое явление, что и при попытке извлечь срез,
выходящий за пределы списка?
3. Индексирование, извлечение среза и инструкция del. Создайте дру
гой список L с четырьмя элементами и присвойте одному из элемен
тов пустой список (например, L[2] = []). Что произошло? Затем
присвойте пустой список срезу (L[2:3] = []). Что случилось на этот
раз? Не забывайте, что операция присваивания срезу сначала уда
ляет срез, а затем вставляет новое значение в заданную позицию.
Инструкция del удаляет элемент с указанным смещением, ключом,
атрибутом или именем. Используйте ее для удаления элемента ва
шего списка (например, del L[0]). Что произойдет, если попробовать
удалить целый срез (del L[1:])? Что произойдет, если срезу присво
ить объект, который не является последовательностью (L[1:2] = 1)?
4. Кортежи. Введите следующие строки:
>>> X = 'spam'
>>> Y = 'eggs'
>>> X, Y = Y, X
Как вы думаете, что произойдет с переменными после выполнения
этой последовательности действий?
5. Ключи словарей. Рассмотрите следующий фрагмент:
>>> D = {}
>>> D[1] = 'a'
>>> D[2] = 'b'
Вы знаете, что словари не поддерживают доступ к элементам по
смещениям; попробуйте объяснить происходящее здесь. Может
быть, следующий пример прояснит ситуацию? (Подсказка: к какой
категории типов относятся строки, целые числа и кортежи?)
>>> D[(1, 2, 3)] = 'c'
>>> D
{1: 'a', 2: 'b', (1, 2, 3): 'c'}
6. Индексирование словарей. Создайте словарь с именем D и с тремя
записями для ключей 'a', 'b' и 'c'. Что произойдет, если попытать
ся обратиться к элементу с несуществующим ключом (D{'d'})? Что
сделает интерпретатор, если попробовать присвоить значение несу
ществующему ключу (D['d'] = 'spam')? Как это согласуется с опера
циями доступа и присваивания элементам списков при использова
нии индексов, выходящих за их пределы? Не напоминает ли вам
такое поведение правила, применяемые к переменным?
7. Общие операции. Получите в интерактивной оболочке ответы на
следующие вопросы:
Закрепление пройденного 269
a. Что произойдет, если попытаться использовать оператор + с опе
рандами различных типов (например, строка+список, спи
сок+кортеж)?
b. Будет ли работать оператор +, когда один из операндов является
словарем?
c. Будет ли работать метод append со списками и со строками? Мож
но ли использовать метод keys со списками? (Подсказка: что
предполагает метод append о заданном объекте?)
d. Наконец, какой тип объекта будет получен, когда операция кон
катенации применяется к двум спискам или двум строкам?
8. Индексирование строк. Определите строку S из четырех символов:
S = "spam". Затем введите следующее выражение: S[0][0][0][0][0].
Можете ли вы объяснить, что произошло на этот раз? (Подсказка:
не забывайте, строки – это коллекции символов, а символы в языке
Python представлены односимвольными строками.) Будет ли это
выражение работать, если применить его к списку, такому как
['s', 'p', 'a', 'm']? Почему?
9. Неизменяемые типы. Определите еще раз строку S из четырех сим
волов: S = "spam". Напишите операцию присваивания, которая из
менила бы строку на "slam", используя только операции извлечения
среза и конкатенации. Возможно ли выполнить то же самое дейст
вие с использованием операций индексирования и конкатенации?
С помощью присваивания по индексу элемента?
10. Вложенные структуры. Создайте структуру данных для представ
ления вашей личной информации: имя (имя, фамилия, отчество),
возраст, должность, адрес, электронный адрес и номер телефона.
При построении структуры вы можете использовать любые комби
нации встроенных объектов (списки, кортежи, словари, строки,
числа). Затем попробуйте обратиться к отдельным элементам
структуры по индексам. Являются ли какиенибудь объекты более
предпочтительными для данной структуры?
11. Файлы. Напишите сценарий, который создает и открывает для за
писи новый файл с именем myfile.txt, и запишите в него строку "
Hello file world!". Затем напишите другой сценарий, который от
крывает файл myfile.txt, читает и выводит на экран его содержи
мое. Запустите поочередно эти сценарии из командной строки.
Появился ли новый файл в каталоге, откуда были запущены сцена
рии? Что произойдет, если указать другой каталог в имени файла,
которое передается функции open? Примечание: методы записи
в файлы не добавляют символ новой строки к записываемым стро
кам. Добавьте символ \n явно в конец вашей строки, если хотите по
лучить в файле полностью завершенную строку.
12. Функция dir. Попробуйте ввести следующие выражения в интерак
тивной оболочке. Начиная с версии 1.5, функция dir была обобщена
270 Глава 9. Кортежи, файлы и все остальное
так, что она выводит все атрибуты любого объекта, который вас мо
жет заинтересовать. Если вы пользуетесь более ранней версией ин
терпретатора, тот же эффект можно получить с использованием ме
тода __methods__. Если вы пользуетесь интерпретатором Python 2.2,
скорее всего функция dir окажется единственным работающим ин
струментом.
[]._ _methods_ _ # 1.4 или 1.5
dir([]) # 1.5 и более поздние версии
{}._ _methods_ _ # Словарь
dir({})
III
Инструкции и синтаксис

10
Введение в инструкции языка Python
Теперь, когда вы познакомились с базовыми встроенными типами объ
ектов языка Python, мы начинаем исследование фундаментальных
форм инструкций. Как и в предыдущей части книги, мы начнем с об
щего представления синтаксиса инструкций и затем, в нескольких сле
дующих главах, более подробно рассмотрим конкретные инструкции.
Выражаясь простым языком, инструкции – это то, что вы пишете,
чтобы сообщить интерпретатору, какие действия должна выполнять
ваша программа. Если программа «выполняет какието действия», то
инструкции – это способ указать, какие именно действия должна вы
полнять программа. Python – это процедурный язык программирова
ния, основанный на использовании инструкций; комбинируя инструк
ции, вы задаете процедуру, которую выполняет интерпретатор в соот
ветствии с целями программы.
Структура программы на языке Python
Другой способ понять роль инструкций состоит в том, чтобы вновь вер
нуться к иерархии понятий, представленной в главе 4, в которой рас
сказывалось о встроенных объектах и выражениях, управляющих
ими. Эта глава рассматривает следующую ступень иерархии:
1. Программы делятся на модули.
2. Модули содержат инструкции.
3. Инструкции состоят из выражений.
4. Выражения создают и обрабатывают объекты.
Синтаксис языка Python по сути построен на инструкциях и выраже
ниях. Выражения обрабатывают объекты и встраиваются в инструк
ции. Инструкции представляют собой более крупные логические блоки
274 Глава 10. Введение в инструкции языка Python
программы – они напрямую используют выражения для обработки
объектов, которые мы рассматривали в предыдущих главах. Кроме
того, инструкции – это место, где создаются объекты (например, в ин
струкциях присваивания), а в некоторых инструкциях создаются со
вершенно новые виды объектов (функции, классы и т. д.). Инструк
ции всегда присутствуют в модулях, которые сами управляются инст
рукциями.
Инструкции в языке Python
В табл. 10.1 приводится набор инструкций языка Python.1 В этой части
книги рассматриваются инструкции, которые в таблице расположены
от начала и до инструкций break и continue. Ранее неофициально вам
уже были представлены некоторые из инструкций, присутствующих
в табл. 10.1. В этой части книги будут описаны подробности, опущен
ные ранее; вашему вниманию будут представлены остальные процедур
ные инструкции языка Python, а также будет рассмотрена общая син
таксическая модель. Инструкции, расположенные в табл. 10.1 ниже,
имеют отношение к крупным блокам программы – функциям, клас
сам, модулям и исключениям и заключают в себе крупные понятия
программирования, поэтому каждой из них будет посвящен отдельный
раздел. Более экзотические инструкции, такие как exec (которая ком
пилирует и выполняет программный код в строке), раскрываются да
лее в книге или в стандартной документации по языку Python.
Таблица 10.1. Инструкции языка Python
1 Строго говоря, в Python 2.5 инструкция yield превратилась в выражение,
а инструкции try/except и try/finally были объединены (ранее это были от
дельные инструкции, теперь же допускается одновременно использовать
и except и finally в одной инструкции try). Кроме того, в Python 2.6 появи
лась новая инструкция управления контекстом with/as – грубо говоря, она
представляет собой альтернативу операциям try/finally, имеющим отно
шение к исключениям (в 2.5 инструкция with/as является необязательным
расширением, которое недоступно, пока явно не будет подключено инст
рукцией from __future__ import with_statement). За дополнительной инфор
мацией обращайтесь к руководству по языку Python. В будущей версии 3.0
инструкции print и exec превратятся в функции и появится новая инструк
ция nonlocal, назначение которой будет напоминать назначение сущест
вующей ныне инструкции global.
Инструкция Роль Пример
Присваивание Создание ссылок a, b, c = 'good', 'bad', 'ugly'
Вызовы Запуск функций log.write("spam, ham\n")
print Вывод объектов print 'The Killer', joke
if/elif/else Операция выбора if "python" in text:
print text
История о двух if 275
История о двух if
Прежде чем углубиться в детали какойлибо конкретной инструкции
из табл. 10.1, я хочу обратить ваше внимание на синтаксис инструк
ций в языке Python, показав, как не надо писать программный код,
чтобы у вас была возможность сравнить его с другими синтаксически
ми моделями, которые, возможно, вы видели ранее.
for/else Обход последовательности
в цикле
for x in mylist:
print x
while/else Циклы общего назначения while X > Y:
print 'hello'
pass Пустая инструкциязапол
нитель
while True:
pass
break, continue Переходы в циклах while True:
if not line: break
try/except/finally Обработка исключений try:
action()
except:
print 'action error'
raise Возбуждение исключений raise endSearch, location
import, from Доступ к модулям import sys
from sys import stdin
def, return, yield Создание функций def f(a, b, c=1, *d):
return a+b+c+d[0]
def gen(n):
for i in n, yield i*2
class Создание объектов class subclass(Superclass):
staticData = []
global Пространства имен def function( ):
global x, y
x = 'new'
del Удаление ссылок del data[k]
del data[i:j]
del obj.attr
del variable
exec Запуск фрагментов про
граммного кода
exec "import " + modName
exec code in gdict, ldict
assert Отладочные проверки assert X > Y
with/as Менеджеры контекста (2.6) with open('data') as myfile:
process(myfile)
Инструкция Роль Пример
276 Глава 10. Введение в инструкции языка Python
Рассмотрим следующую условную инструкцию на языке C:
if (x > y) {
x = 1;
y = 2;
}
Это могла бы быть инструкция на языке C, C++, Java, JavaScript или
Perl. А теперь взгляните на эквивалентную инструкцию на языке Py
thon:
if x > y:
x = 1
y = 2
Первое, что бросается в глаза, – инструкция на языке Python выгля
дит компактнее, точнее, в ней меньше синтаксических элементов. Это
соответствует основным принципам языка; так как Python – это язык
сценариев, его основная цель состоит в том, чтобы облегчить жизнь
программистам за счет меньшего объема ввода с клавиатуры.
Если быть более точным, то, сравнив две синтаксических модели,
можно заметить, что язык Python один новый элемент добавляет, а три
элемента, которые присутствуют в языках, подобных языку C, ликви
дирует.
Что добавляет язык Python
Один из новых синтаксических элементов в языке Python – это символ
двоеточия (:). Все составные инструкции в языке Python (т. е. инст
рукции, которые включают вложенные в них инструкции) записыва
ются в соответствии с одним и тем же общим шаблоном, когда основ
ная инструкция завершается двоеточием, вслед за которым располага
ется вложенный блок кода, обычно с отступом под строкой основной
инструкции, как показано ниже:
Основная инструкция:
Вложенный блок инструкций
Двоеточие является обязательным, а его отсутствие является самой рас
пространенной ошибкой, которую допускают начинающие программи
сты, – я встречал тысячи подтверждений этому в учебных классах.
Фактически, если вы плохо знакомы с языком Python, то вы почти на
верняка очень скоро забудете о символе двоеточия. Большинство тек
стовых редакторов, обладающих функцией подсветки синтаксиса, де
лают эту ошибку легко заметной, а с опытом вырабатывается привычка
вставлять двоеточие бессознательно (да так, что вы начинаете вводить
двоеточие в программный код на языке C++, что приводит к большому
числу весьма интересных сообщений об ошибках от компилятора C++!).
История о двух if 277
Что Python устраняет
Хотя Python требует ввода дополнительного символа двоеточия, суще
ствуют три элемента, обязательных для языков, подобных языку C,
которые языку Python не требуются.
Круглые скобки необязательны
Первый элемент – это пара круглых скобок, окружающих условное
выражение в основной инструкции:
if (x < y)
Круглые скобки здесь являются обязательными во многих Cподоб
ных языках. В языке Python это не так – мы просто можем опустить
скобки, и инструкция будет работать точно так же:
if x < y
Точнее говоря, так как каждое выражение может быть заключено
в скобки, присутствие их не будет противоречить синтаксису языка
Python, и они не будут считаться ошибкой. Но не делайте этого: вы
лишь понапрасну будете изнашивать свою клавиатуру, а окружаю
щим сразу будет видно, что вы – бывший программист, использовав
ший язык C, еще только изучающий язык Python (когдато и я был та
ким же). Стиль языка Python состоит в том, чтобы вообще опускать
скобки в подобных инструкциях.
Конец строки является концом инструкции
Второй, еще более важный синтаксический элемент, который вы не
найдете в программном коде на языке Python, – это точка с запятой.
В языке Python не требуется завершать инструкции точкой с запятой,
как это делается в Cподобных языках:
x = 1;
Общее правило в языке Python гласит, что конец строки автоматиче
ски считается концом инструкции, стоящей в этой строке. Другими
словами, вы можете отбросить точку с запятой и инструкция будет ра
ботать точно так же:
x = 1
Существует несколько способов обойти это правило, с которыми вы
вскоре познакомитесь. Но в общем случае большая часть программно
го кода на языке Python пишется по одной инструкции в строке, и то
гда точка с запятой не требуется.
В данном случае, если вы скучаете по тем временам, когда программи
ровали на языке C (если такое состояние вообще возможно…), можете
продолжать вставлять точки с запятой в конце каждой инструкции –
синтаксис языка допускает это. Но не делайте этого: потому что если
вы будете поступать так, окружающим сразу будет видно, что вы ос
таетесь программистом на языке C, который никак не может переклю
278 Глава 10. Введение в инструкции языка Python
читься на использование языка Python. Стиль языка Python состоит
в том, чтобы вообще опускать точки с запятой.1
Конец отступа – это конец блока
Теперь третий, и последний, синтаксический компонент, который уда
ляет Python, и возможно, самый необычный для недавних exСпро
граммеров (пока они не поработают с Python 10 минут и не поймут, что
в действительности это является достоинством языка), – вы не вводите
ничего специально в ваш код, чтобы синтаксически пометить начало
и конец вложенного блока кода. Вам не нужно вставлять begin/end,
then/endif или фигурные скобки вокруг вложенных блоков2, как это
делается в Cподобных языках:
if (x > y) {
x = 1;
y = 2;
}
Для этих целей в языке Python используются отступы, когда все инст
рукции в одном и том же вложенном блоке оформляются с одинако
выми отступами от левого края. По величине отступа интерпретатор
определяет, где находится начало блока и где – конец:
if x > y:
x = 1
y = 2
Под отступами (indentation) в данном примере я подразумеваю пус
тое пространство слева от двух вложенных инструкций. Интерпрета
тор не накладывает ограничений на то, как выполняются отступы (для
этого можно использовать символы пробела или символы табуляции),
и на величину отступов (допускается использовать любое число пробе
лов или символов табуляции). При этом отступ для одного вложенного
блока может существенно отличаться от отступа для другого блока.
Синтаксическое правило состоит лишь в том, что все инструкции в пре
делах одного блока должны иметь один и тот же отступ от левого края.
Если это не так, будет получена синтаксическая ошибка, и программ
ный код не будет работать, пока вы не исправите отступ.
Почему отступы являются частью синтаксиса?
Правило оформления отступов может показаться необычным на пер
вый взгляд для программистов, работавших с Cподобными языками
1 Кстати, в JavaScript также можно не ставить точку с запятой в конце стро
ки, но широко распространена традиция ставить такой ограничитель, де
монстрируя тем самым как раз хороший стиль оформления программного
кода. – Примеч. науч. ред.
2 Известна программистская шутка, уместная в этом контексте: это не bug,
это feature. – Примеч. науч. ред.
История о двух if 279
программирования, но это было сделано преднамеренно и является од
ним из основных способов, которыми язык Python вынуждает про
граммистов писать однородный и удобочитаемый программный код.
По существу это означает, что вы должны выстраивать свой программ
ный код вертикально, выравнивая его в соответствии с логической
структурой. В результате получается менее противоречивый и более
удобочитаемый программный код (в отличие от большей части кода,
написанного на Cподобных языках).
Требования к выравниванию программного кода в соответствии с его
логической структурой – это главная составляющая, способствующая
созданию удобочитаемого кода, и, следовательно, кода, пригодного
к многократному использованию и простого в сопровождении как ва
ми, так и другими. Фактически, даже если ранее вы никогда не ис
пользовали Python, после прочтения этой книги у вас должна вырабо
таться привычка оформлять отступы в программном коде для удобо
читаемости в любом языке программирования. Язык Python вносит
определенные ограничения, сделав отступы частью синтаксиса, но
они достаточно важны для любого языка программирования и оказы
вают огромное влияние на применимость вашего программного кода.
Ваш опыт может отличаться от моего, но когда я занимался разработ
кой полный рабочий день, мне платили зарплату за работу над круп
ными старыми программами, написанными на языке C++, над кото
рыми долгие годы трудились множество программистов. Практически
у каждого программиста был свой стиль оформления программного
кода. Например, мне часто приходилось изменять циклы while, напи
санные на языке C++, которые начинались примерно так:
while (x > 0) {
Даже еще не дойдя до отступов, мы можем столкнуться с тремя или
четырьмя способами расстановки фигурных скобок в Cподобных язы
ках. В организациях часто ведутся жаркие споры и пишутся стандар
ты по оформлению исходных текстов программ (обсуждение которых
сильно выходит за рамки проблем, которые решаются в процессе про
граммирования). Оставим этот вопрос в стороне, ниже приводится
пример оформления, с которым мне часто приходилось сталкиваться
в программном коде на языке C++. Первый программист, который по
работал над этим циклом, оформлял отступы четырьмя пробелами:
while (x > 0) {
;
;
Со временем этот программист был переведен на руководящую долж
ность, и его место занял другой, который предпочитал использовать
более широкие отступы:
while (x > 0) {
;
280 Глава 10. Введение в инструкции языка Python
;
;
;
Позднее и он ушел на другую работу, а его место занял третий, которо
му не нравилось делать отступы:
while (x > 0) {
;
;
;
;
;
;
}
И так далее. В конце блок завершается закрывающей фигурной скоб
кой (}), которая и делает этот фрагмент структурированным (о чем
можно говорить с определенной долей сарказма). В любом блочно
структурированном языке программирования, будь то Python или
другой язык, если вложенные блоки не имеют непротиворечивых от
ступов, их очень сложно читать, изменять и приспосабливать для мно
гократного использования. Отступ – это важная составляющая под
держки удобочитаемости.
Ниже приводится другой пример, на котором, возможно, вам прихо
дилось обжечься, если вы достаточно много программировали на Cпо
добном языке. Взгляните на следующие инструкции языка C:
if (x)
if (y)
statement1;
else
statement2;
К какому оператору if относится инструкция else? Это удивительно,
но инструкция else относится к вложенному оператору if – (if(y)), да
же при том, что визуально она выглядит так, как если бы относилась
к внешнему оператору if – (if(x)). Это классическая ловушка языка C
и она может привести к неправильному пониманию программного ко
да тем, кто его изменяет, и к появлению ошибок при его изменении,
которые будут обнаружены, только когда марсоход врежется в скалу!
Такого не может произойти в языке Python, потому что отступы для не
го имеют важное значение и программный код работает именно так,
как выглядит. Взгляните на эквивалентный фрагмент на языке Python:
if x:
if y:
statement1
else:
statement2
История о двух if 281
В этом примере инструкции if и else, расположенные на одной верти
кальной линии, связаны логически (внешний оператор if x). В некото
ром смысле Python – это язык типа WYSIWYG (What You See Is What
You Get – что видишь, то и получаешь) – что вы видите, то и получаете,
потому что порядок оформления программного кода определяет поря
док его выполнения независимо от предпочтений того, кто его пишет.
Если этого недостаточно, чтобы осознать преимущества синтаксиса
языка Python, приведу одну историю. В начале своей карьеры я рабо
тал в одной благополучной компании, занимавшейся разработкой про
граммных систем на языке C, который вообще не предъявляет ника
ких требований к оформлению отступов. Но, несмотря на это, когда
в конце рабочего дня мы отправляли свой программный код в репози
тарий, он автоматически проверялся сценарием, анализировавшим
оформление отступов. Если сценарий обнаруживал несоответствия, на
следующий день утром мы получали электронные письма с замеча
ниями – и такой порядок завели наши начальники!
По моему мнению, даже если язык программирования и не требует это
го, хороший программист должен понимать, какое важное значение
имеет выравнивание для удобочитаемости и высокого качества про
граммного кода. Тот факт, что в языке Python отступы были возведены
в ранг синтаксиса, по большей части выглядит как достоинство языка.
Наконец, имейте в виду, что практически любой текстовый редактор
с дружественным (для программистов) интерфейсом обладает встроен
ной поддержкой синтаксической модели языка Python. В Pythonсреде
разработки IDLE, например, отступы оформляются автоматически1,
когда начинается ввод вложенного блока; нажатие клавиши Backspace
(забой) возвращает на один уровень вложенности выше, а кроме того,
IDLE позволяет настроить величину отступов во вложенном блоке.
Нет никаких стандартных требований к оформлению отступов: чаще
всего используются четыре пробела или один символ табуляции на ка
ждый уровень вложенности; вам самим решать, какой ширины отсту
пы вы будете использовать. Выполняйте отступ вправо, чтобы открыть
вложенный блок, и возвращайтесь на предыдущий уровень, чтобы за
крыть его. Кроме того, на практике замена фигурных скобок символа
ми табуляции является достаточно простой задачей для инструмен
тальных средств, которые должны выводить программный код на язы
ке Python. Вообще, делайте все то же, что вы делаете на языке C, но
1 Напомним, IDLE – среда разработки, специально созданная Guido van Ros
sum в проекте Python. Первый релиз вышел вместе с версией Python 1.5.2.
Одно из объяснений использования такого слова (idle – бездействующий, ле
нивый), в отличие от принятого в других языковых средах термина IDE, объ
явлено на сайте python.org (http://www.python.org/idle/doc/idlemain.html)
и выглядит так: «IDLE – это акроним от Integrated DeveLopment Environ
ment». См. также главу 3. – Примеч. науч. ред.
282 Глава 10. Введение в инструкции языка Python
уберите фигурные скобки и ваш программный код будет удовлетво
рять правилам синтаксиса языка Python.
Несколько специальных случаев
Как уже упоминалось ранее, в синтаксической модели языка Python:
• Конец строки является концом инструкции, расположенной в этой
строке (точка с запятой не требуется).
• Вложенные инструкции объединяются в блоки по величине отсту
пов (без фигурных скобок).
Эти правила охватывают большую часть программного кода на языке
Python, который вы будете писать или с которым придется столкнуть
ся. Однако существуют некоторые специальные правила, которые каса
ются оформления как отдельных инструкций, так и вложенных блоков.
Специальные случаи оформления инструкций
Обычно на каждой строке располагается одна инструкция, но вполне
возможно для большей компактности записать несколько инструкций
в одной строке, разделив их точками с запятой:
a = 1; b = 2; print a + b # Три инструкции на одной строке
Это единственный случай, когда в языке Python необходимо использо
вать точки с запятой: как разделители инструкций. Однако такой
подход не может применяться к составным инструкциям. Другими
словами, в одной строке можно размещать только простые инструк
ции, такие как присваивание, print и вызовы функций. Составные ин
струкции попрежнему должны находиться в отдельной строке (иначе
всю программу можно было бы записать в одну строку, что, скорее все
го, не нашло бы понимания у ваших коллег!).
Другое специальное правило, применяемое к инструкциям, по сути
является обратным к предыдущему: допускается записывать одну ин
струкцию в нескольких строках. Для этого достаточно заключить
часть инструкции в пару скобок – круглых (()), квадратных ([]) или
фигурных ({}). Любой программный код, заключенный в одну из этих
конструкций, может располагаться на нескольких строках: инструк
ция не будет считаться законченной, пока интерпретатор Python не
достигнет строки с закрывающей скобкой. Например, литерал списка
можно записать так:
mlist = [111,
222,
333]
Так как программный код заключен в пару квадратных скобок, интер
претатор всякий раз переходит на следующую строку, пока не обнару
жит закрывающую скобку. Словари также могут располагаться в не
скольких строках, а с помощью круглых скобок можно оформить мно
История о двух if 283
гострочные кортежи, вызовы функций и выражения. Отступы в стро
ках, где продолжается инструкция, в учет не принимаются, хотя
здравый смысл диктует, что строки всетаки должны иметь некоторые
отступы для обеспечения удобочитаемости.
Круглые скобки являются самым универсальным средством, потому
что в них можно заключить любое выражение. Добавьте левую скоб
ку, и вы сможете перейти на следующую строку и продолжить свою
инструкцию:
X = (A + B +
C + D)
Между прочим, такой прием допускается применять и к составным
инструкциям. Если вам требуется записать длинное выражение, обер
ните его круглыми скобками и продолжите на следующей строке:
if (A == 1 and
B == 2 and
C == 3):
print 'spam' * 3
Еще одно старое правило также позволяет переносить инструкцию на
следующую строку: если предыдущая строка заканчивается символом
обратного слеша:
X = A + B + \
C + D
Но это устаревшее правило, которое не рекомендовано к использова
нию в новых программах, потому что символы обратного слеша мало
заметны и ненадежны (не допускается наличие какихлибо других
символов после символа обратного слеша). Кроме того, это рассматри
вается как пережиток языка C, где очень часто используются макро
определения #define; в Питонляндии нужно все делать так, как это де
лают питонисты, а не как программисты на языке C.
Специальный случай оформления блока
Как уже говорилось выше, инструкции во вложенном блоке обычно
объединяются по величине отступа. Специальный случай: тело состав
ной инструкции может располагаться в той же строке, что и основная
инструкция, после символа двоеточия:
if x > y: print x
Это позволяет записывать в одной строке условные операторы, циклы
и т. д. Однако такой прием будет работать, только если тело составной
инструкции не содержит других составных инструкций. То есть после
двоеточия могут следовать только простые инструкции – инструкции
присваивания, инструкции print, вызовы функций и подобные им.
Крупные инструкции попрежнему должны записываться в отдель
ных строках. Дополнительные части составных инструкций (такие
284 Глава 10. Введение в инструкции языка Python
как блоки else в условных инструкциях if, с которыми мы встретимся
ниже) также должны располагаться в отдельных строках. Тело инст
рукции может состоять из нескольких простых инструкций, разделен
ных точкой с запятой, но такой стиль оформления не приветствуется.
Вообще, хотя это не является обязательным требованием, но если вы
будете размещать инструкции в отдельных строках и всегда будете
оформлять отступы для вложенных блоков, ваш программный код бу
дет проще читать и вносить в него изменения. Чтобы увидеть одно из
этих правил в действии (когда однострочная инструкция if использует
ся для прерывания выполнения цикла), давайте перейдем к следующе
му разделу, где мы напишем и опробуем настоящий программный код.
Короткий пример: интерактивные циклы
Мы увидим все эти синтаксические правила в действии, когда будем
совершать турне по конкретным составным инструкциям языка Py
thon в нескольких следующих главах, но эти правила работают одина
ково везде в языке Python. Для начала рассмотрим короткий практи
ческий пример, который продемонстрирует способ применения син
таксических правил к оформлению инструкций и вложенных блоков
на практике и попутно познакомит вас с некоторыми инструкциями.
Простой интерактивный цикл
Предположим, что от нас требуется написать программу на языке Py
thon, которая взаимодействует с пользователем в окне консоли. Воз
можно, программа будет принимать информацию для дальнейшей пе
редачи в базу данных или числа для выполнения расчетов. Независи
мо от конечной цели вам необходимо написать цикл, который будет
считывать одну или более строк, введенных пользователем с клавиату
ры, и выводить их обратно на экран. Другими словами, вам нужно на
писать классический цикл, выполняющий операции чтения/вычисле
ния/вывода.
В языке Python для реализации таких интерактивных циклов исполь
зуется типичный шаблон, который выглядит, как показано ниже:
while True:
reply = raw_input('Enter text:')
if reply == 'stop': break
print reply.upper()
В этом фрагменте использованы несколько новых для вас идей:
• Программный код выполняется в цикле while, который в языке Py
thon является наиболее универсальной инструкцией цикла. Под
робнее об инструкции while мы будем говорить позднее, но в двух
словах замечу, что она состоит из слова while, за которым следует
условное выражение. Результат этого выражения интерпретирует
ся как истина или как ложь. Далее следует вложенный блок про
Короткий пример: интерактивные циклы 285
граммного кода, который продолжает выполняться в цикле, пока
условное выражение возвращает истину (слово True здесь всегда
возвращает значение истины).
• Встроенная функция raw_input, с которой мы уже встречались ранее
в этой книге, используется здесь как универсальное средство полу
чения ввода с клавиатуры – она выводит подсказку, текст которой
содержится в необязательном строковом аргументе, и возвращает
введенный пользователем ответ в виде строки.
• Однострочная инструкция if, которая оформлена в соответствии со
специальным правилом для вложенных блоков: тело инструкции
if располагается в той же строке, что и основная инструкция, после
символа двоеточия, а не на отдельной строке под ней с соответст
вующим отступом. Она одинаково хорошо работала бы при любом
из двух вариантов оформления, но при таком подходе нам удалось
сэкономить одну строку.
• Наконец, для немедленного выхода из цикла использована инст
рукция break – она просто выполняет выход за пределы инструкции
цикла и программа продолжает свою работу с первой инструкции,
которая расположена вслед за циклом. Без этой инструкции цикл
while работал бы вечно, поскольку его условное выражение всегда
возвращает истину.
В результате такая комбинация инструкций означает следующее: «чи
тать строки, введенные пользователем, и выводить их после преобра
зования всех символов в верхний регистр, пока пользователь не введет
строку "stop"». Существуют и другие способы записи такого цикла, но
данная форма очень часто встречается в программном коде на языке
Python.
Обратите внимание, что все три строки, вложенные в инструкцию цик
ла while, имеют одинаковые отступы, благодаря этому они визуально
образуют вертикальную линию блока программного кода, ассоцииро
ванного с инструкцией цикла while. Тело цикла завершается либо с кон
цом файла, либо с первой инструкцией, имеющей меньший отступ.
Запустив этот фрагмент, мы получили следующий порядок взаимо
действий с ним:
Enter text:spam
SPAM
Enter text:42
42
Enter text:stop
Математическая обработка данных пользователя
Итак, наш сценарий работает, а теперь предположим, что вместо пре
образования символов текстовой строки в верхний регистр нам необхо
димо выполнить некоторые математические действия над введенными
286 Глава 10. Введение в инструкции языка Python
пользователем числами, – например, вычислить квадраты чисел, что
может получиться не совсем так, как ожидают наиболее молодые и не
терпеливые пользователи. Для достижения желаемого эффекта мы
могли бы попробовать использовать следующие инструкции:
>>> reply = '20'
>>> reply ** 2
...текст сообщения об ошибке опущен...
TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'
(Перевод: TypeError: неподдерживаемые типы операндов для **
или pow():'str' и 'int')
Это не работает, потому что (как обсуждалось в предыдущей части
книги) интерпретатор выполняет преобразование типов объектов в вы
ражениях, только если они являются числами, а ввод пользователя
всегда передается сценарию в виде строки. Мы не можем возвести
строку цифр в степень, не преобразовав ее в целое число вручную:
>>> int(reply) ** 2
400
Вооружившись этой информацией, мы можем переделать наш цикл
для выполнения математических действий:
while True:
reply = raw_input('Enter text:')
if reply == 'stop': break
print int(reply) ** 2
print 'Bye'
В этом сценарии используется однострочная инструкция if, которая,
как и прежде, производит выход из цикла по получении от пользова
теля строки "stop", а кроме того, выполняется преобразование введен
ной строки для выполнения необходимой математической операции.
В данную версию сценария также было добавлено сообщение, которое
выводится в момент завершения работы сценария. Поскольку инст
рукция print в последней строке не имеет такого отступа, как инструк
ции вложенного блока, она не считается частью тела цикла и будет вы
полняться только один раз – после выхода из цикла:
Enter text:2
4
Enter text:40
1600
Enter text:stop
Bye
Обработка ошибок проверкой ввода
Пока все идет хорошо, но посмотрите, что произойдет, если пользова
тель введет неверную строку:
Enter text:xxx
Короткий пример: интерактивные циклы 287
...текст сообщения об ошибке опущен...
ValueError: invalid literal for int() with base 10: 'xxx'
(Перевод: ValueError: неверный литерал для int() по основанию 10: 'xxx')
Встроенная функция int возбуждает исключение, когда сталкивается
с ошибкой. Если нам необходимо обеспечить устойчивость сценария,
мы должны предварительно проверить содержимое строки с помощью
строкового метода isdigit:
>>> S = '123'
>>> T = 'xxx'
>>> S.isdigit(), T.isdigit()
(True, False)
Для этого в наш пример необходимо добавить вложенные операторы.
В следующей версии нашего интерактивного сценария используется
полная версия условного оператора if, с помощью которого предотвра
щается возможность появления исключений:
while True:
reply = raw_input('Enter text:')
if reply == 'stop':
break
elif not reply.isdigit( ):
print 'Bad!' * 8
else:
print int(reply) ** 2
print 'Bye'
Более подробно мы будем рассматривать инструкцию if в главе 12. Это
очень простой инструмент программирования логики выполнения
сценария. В своей полной форме инструкция содержит слово if, за ко
торым следуют выражение проверки условия и вложенный блок кода,
одну или более необязательных проверок elif ("else if") и соответст
вующих им вложенных блоков кода и необязательная часть else со
связанным с ней блоком кода, который выполняется при несоблюде
нии условия. Интерпретатор выполняет первый блок кода, для кото
рого проверка дает в результате истину, проходя инструкцию сверху
вниз, либо часть else, если все проверки дали в результате ложь.
Части if, elif и else в предыдущем примере принадлежат одной и той
же инструкции, так как вертикально они расположены на одной ли
нии (т. е. имеют одинаковые отступы). Инструкция if простирается до
начала инструкции print в последней строке. В свою очередь весь блок
инструкции if является частью цикла while, потому что вся она сме
щена вправо относительно основной инструкции цикла. Вложение ин
струкций станет для вас естественным, как только вы приобретете со
ответствующие навыки.
Теперь новый сценарий будет обнаруживать ошибки прежде, чем они
будут обнаружены интерпретатором, и выводить (возможно, глупое)
сообщение:
288 Глава 10. Введение в инструкции языка Python
Enter text:5
25
Enter text:xyz
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
Enter text:10
100
Enter text:stop
Обработка ошибок с помощью инструкции try
Предыдущее решение работает, но, как будет показано далее в книге,
в языке Python существует более универсальный способ, который со
стоит в том, чтобы перехватывать и обрабатывать ошибок с помощью
инструкции try. Эта инструкция подробно будет рассматриваться в по
следней части книги, но, использовав инструкцию try в качестве пред
варительного знакомства, мы можем упростить программный код пре
дыдущей версии сценария:
while True:
reply = raw_input('Enter text:')
if reply == 'stop': break
try:
num = int(reply)
except:
print 'Bad!' * 8
else:
print int(reply) ** 2
print 'Bye'
Эта версия работает точно так же, как и предыдущая, только здесь мы
заменили явную проверку наличия ошибки программным кодом, ко
торый предполагает, что преобразование будет выполнено, и выполня
ет обработку исключения, если такое преобразование невозможно. Эта
инструкция try состоит из слова try, вслед за которым следует основ
ной блок кода (действие, которые мы пытаемся выполнить), с после
дующей частью except, где располагается программный код обработки
исключения. Далее следует часть else, программный код которой вы
полняется, если в части try исключение не возникло. Интерпретатор
сначала выполняет часть try, затем выполняет либо часть except (если
возникло исключение), либо часть else (если исключение не возникло).
В терминах вложенности инструкций, так как слова try, except и else
имеют одинаковые отступы, все они считаются частью одной и той же
инструкции try. Обратите внимание, что в данном случае часть else
связана с инструкцией try, а не с условной инструкцией if. Как будет
показано далее в книге, ключевое слово else в языке Python может по
являться не только в инструкции if, но и в инструкции try и в циклах –
величина отступа наглядно показывает, частью какой инструкции оно
является.
В заключение 289
Напомню, что к инструкции try мы еще вернемся далее в этой книге.
А пока вам достаточно будет знать, что эта инструкция может исполь
зоваться для перехвата любых ошибок, уменьшения объема программ
ного кода, проверяющего наличие ошибок, и представляет собой доста
точно универсальный подход к обработке необычных ситуаций.
Три уровня вложенности программного кода
Теперь рассмотрим последнюю версию сценария. В случае необходи
мости мы могли бы создать еще один уровень вложенности, например,
чтобы выполнить проверку правильности ввода, основываясь на вели
чине введенного числа:
while True:
reply = raw_input('Enter text:')
if reply == 'stop':
break
elif not reply.isdigit( ):
print 'Bad!' * 8
else:
num = int(reply)
if num < 20:
print 'low'
else:
print num ** 2
print 'Bye'
В эту версию сценария добавлена еще одна инструкция if, вложенная
в выражение else другой условной инструкции if, которая в свою оче
редь вложена в цикл while. Когда код выполняется по некоторому ус
ловию или в цикле, как в данном случае, достаточно просто выпол
нить дополнительный отступ вправо. В результате сценарий работает
так же, как и предыдущая версия, но для чисел меньше 20 выводит
слово «low» (низкое значение):
Enter text:19
low
Enter text:20
400
Enter text:spam
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
Enter text:stop
Bye
В заключение
В этой главе мы коротко познакомились с синтаксисом инструкций
языка Python. Здесь были представлены основные правила записи ин
струкций и блоков программного кода. Как было сказано, в языке Py
thon обычно в каждой строке программы располагается единственная
290 Глава 10. Введение в инструкции языка Python
инструкция и все инструкции в одном и том же блоке имеют одинако
вые отступы (отступы являются частью синтаксиса языка Python).
Кроме того, мы рассмотрели несколько исключений из этих правил,
включая многострочные инструкции, однострочные условные инструк
ции и циклы, а также рассмотрели синтаксис инструкций в действии.
В следующей главе мы приступим к глубокому изучению основных
процедурных инструкций языка Python. Как будет показано далее,
все инструкции следуют тем же основным правилам, которые были
представлены здесь.
Закрепление пройденного
Контрольные вопросы
1. Какие три синтаксических элемента, обязательные в языках, по
добных языку C, опущены в языке Python?
2. Каким образом обычно завершаются инструкции в языке Python?
3. Как обычно определяется принадлежность инструкций к вложен
ному блоку в языке Python?
4. Как можно разместить одну инструкцию в нескольких строках?
5. Как можно разместить составную инструкцию в одной строке?
6. Существуют ли какиелибо объективные причины для завершения
инструкций точкой с запятой?
7. Для чего предназначена инструкция try?
8. Какую наиболее распространенную ошибку допускают начинаю
щие программисты на языке Python?
Ответы
1. Обязательными синтаксическими элементами в Сподобных языках
программирования являются круглые скобки, окружающие выра
жения проверки условий в некоторых инструкциях, точка с запя
той, завершающая каждую инструкцию, и фигурные скобки, окру
жающие вложенные блоки программного кода.
2. Конец строки является концом инструкции, расположенной в этой
строке. Если в одной строке располагается несколько инструкций,
они должны завершаться точками с запятой. Если инструкция рас
полагается в нескольких строках, она должна завершаться закры
вающей скобкой.
3. Все инструкции во вложенном блоке имеют одинаковые отступы,
состоящие из одинакового числа символов пробела или табуляции.
4. Инструкция может располагаться в нескольких строках, если за
ключить ее в пару круглых, квадратных или фигурных скобок. Ин
Закрепление пройденного 291
струкция заканчивается в строке, где интерпретатор Python встре
чает закрывающую парную скобку.
5. Тело составной инструкции может располагаться в той же строке,
что и основная инструкция, сразу после символа двоеточия, но при
условии, что тело не содержит других составных инструкций.
6. Только когда возникает потребность разместить несколько инст
рукций в одной строке, при условии, что ни одна из инструкций не
является составной. Однако такой способ размещения инструкций
приводит к снижению удобочитаемости программного кода.
7. Инструкция try используется для перехвата и обработки исключе
ний (ошибок), возникающих в сценариях на языке Python. Как
правило, она представляет альтернативу программному коду, кото
рый создается для выявления ошибочных ситуаций.
8. Наиболее распространенная ошибка среди начинающих програм
мистов состоит в том, что они забывают добавлять двоеточие в кон
це основной части составных инструкций.
11
Присваивание, выражения и print
Теперь, когда мы кратко ознакомились с синтаксисом инструкций
в языке Python, начиная с этой главы, мы приступим к более подроб
ному изучению конкретных инструкций языка Python. Сначала мы
рассмотрим самые основы – инструкции присваивания, инструкции
выражений и инструкцию вывода на экран. Мы уже видели все эти ин
струкции в действии, но здесь мы восполним подробности, которые
опускались ранее. Несмотря на всю простоту этих инструкций, в чем
вы могли убедиться ранее, каждая из них имеет дополнительные воз
можности, которые пригодятся, когда вы начнете писать настоящие
программы на языке Python.
Инструкции присваивания
Ранее мы уже использовали инструкции присваивания для назначе
ния имен объектам. В канонической форме цель присваивания записы
вается слева от знака равно, а объект, который присваивается, – спра
ва. Цель слева может быть именем или компонентом объекта, а объек
том справа может быть произвольное выражение, которое в результате
дает объект. В большинстве случаев присваивание выполняется доста
точно просто, однако оно обладает следующими особенностями, кото
рые вам следует иметь в виду:
• Инструкция присваивания создает ссылку на объект. Как говори
лось в главе 6, в языке Python инструкция присваивания сохраняет
ссылки на объекты в переменных или в элементах структур дан
ных. Они всегда создают ссылки на объекты и никогда не создают
копии объектов. Вследствие этого переменные в языке Python боль
ше напоминают указатели, чем области хранения данных.
• Переменные создаются при первом присваивании. Интерпретатор
Python создает переменные, когда им впервые присваиваются зна
Инструкции присваивания 293
чения (т. е. ссылка на объект), благодаря этому отсутствует необхо
димость предварительного объявления переменных. Иногда (но не
всегда) в результате операции присваивания создаются элементы
структур данных (например, элементы в словарях, некоторые атри
буты объектов). После выполнения операции присваивания всякий
раз, когда имя переменной будет встречено в выражении, оно заме
щается объектом, на который ссылается эта переменная.
• Прежде чем переменную можно будет использовать, ей должно
быть присвоено значение. Нельзя использовать переменную, кото
рой еще не было присвоено значение. В этом случае интерпретатор
возбуждает исключение вместо того, чтобы вернуть какоелибо зна
чение по умолчанию, – если бы он возвращал значение по умолча
нию, это только осложнило бы поиск опечаток в программном коде.
• Инструкции import, from, def, class, for, а также передача аргумен!
тов функциям являются неявными инструкциями присваивания.
В этом разделе мы сосредоточим все свое внимание на инструкции
=, однако в языке Python присваивание может выполняться в самых
разных контекстах. Например, далее мы увидим, что импорт моду
ля, определение функции или класса, указание переменной в цикле
for и передача аргументов функции неявно выполняют присваива
ние. Операция присваивания выполняется одинаково в любом мес
те, где бы она ни происходила, поэтому во всех этих контекстах про
сто выполняется связывание имен со ссылками на объекты.
Формы инструкции присваивания
Несмотря на то, что в языке Python присваивание является универсаль
ным и повсеместным понятием, в этой главе мы впервые сосредоточимся
на инструкциях присваивания. В табл. 11.1 приводятся различные фор
мы инструкции присваивания, которые встречаются в языке Python.
Таблица 11.1. Формы инструкции присваивания
Первая форма из табл. 11.1 является наиболее распространенной: она
связывает переменную (или элемент структуры данных) с единствен
ным объектом. Другие формы имеют особое назначение и являются
необязательными, хотя многие и находят их очень удобными:
Операция Интерпретация
spam = 'Spam' Каноническая форма
spam, ham = 'yum', 'YUM' Присваивание кортежей (позиционное)
[spam, ham] = ['yum', 'YUM'] Присваивание списков (позиционное)
a, b, c, d = 'spam' Присваивание последовательностей, обобщенное
spam = ham = 'lunch' Групповое присваивание одного значения
spams += 42 Комбинированная инструкция присваивания
(эквивалентно инструкции spams = spams + 42)
294 Глава 11. Присваивание, выражения и print
Присваивание кортежей и списков
Вторая и третья формы в таблице являются родственными. Когда
слева от оператора = указывается кортеж или список, интерпрета
тор связывает объекты справа с именами слева, согласно их место
положениям, выполняя присваивание слева направо. Например, во
второй строке таблицы с именем spam ассоциируется строка 'yum',
а с именем ham ассоциируется строка 'YUM'. Внутри интерпретатор
Python сначала создает элементы кортежа справа, поэтому часто
эта операция называется присваиванием неупакованного кортежа.
Присваивание последовательностей
В недавних версиях Python операции присваивания кортежей и спи
сков были обобщены в то, что теперь называется операцией при
сваивания последовательностей – любая последовательность имен
может быть связана с любой последовательностью значений, и ин
терпретатор свяжет элементы согласно их позициям. Фактически
в последовательностях мы можем смешивать разные типы. Инст
рукция присваивания в третьей строке табл. 11.1, например, свя
зывает кортеж имен со строкой символов: имени a присваивается
символ 's', имени b присваивается символ 'p' и т. д.
Групповое присваивание одного значения
Пятая строка в табл. 11.1 демонстрирует форму группового при
сваивания. В этой форме интерпретатор присваивает ссылку на
один и тот же объект (самый правый объект) всем целям, располо
женным левее. Инструкция в таблице присваивает обоим именам
spam и ham ссылку на один и тот же объект, строку 'lunch'. Результат
будет тот же, как если бы были выполнены две инструкции: ham =
'lunch' и spam = ham, поскольку здесь ham интерпретируется как ори
гинальный объектстрока (т. е. не отдельная копия этого объекта).
Комбинированное (дополняющее) присваивание
Последняя строка в табл. 11.1 – это пример комбинированной инст
рукции присваивания – краткая форма, которая объединяет в себе
выражение и присваивание. Например, инструкция spam += 42 дает
тот же результат, что и инструкция spam = spam + 42, единственное
отличие состоит в том, что комбинированная форма имеет более
компактный вид и обычно выполняется быстрее. Для каждого
двухместного оператора в языке Python существует своя комбини
рованная инструкция присваивания.
Присваивание последовательностей
В этой книге мы уже использовали инструкцию присваивания в кано
нической форме. Ниже приводится несколько примеров инструкций
присваивания последовательностей в действии:
% python
>>> nudge = 1
Инструкции присваивания 295
>>> wink = 2
>>> A, B = nudge, wink # Присваивание кортежей
>>> A, B # Что равносильно A = nudge; B = wink
(1, 2)
>>> [C, D] = [nudge, wink] # Присваивание списков
>>> C, D
(1, 2)
Обратите внимание: в третьей инструкции этого примера в действитель
ности присутствует два кортежа, просто мы опустили охватывающие их
круглые скобки. Интерпретатор Python сопоставляет значения элемен
тов кортежа справа от оператора присваивания с переменными в кор
теже слева и выполняет присваивание значений в одной инструкции.
Операция присваивания кортежей дает возможность использовать
прием, который представлен в упражнениях ко второй части книги.
Так как в процессе выполнения инструкции интерпретатор создает
временный кортеж, где сохраняются оригинальные значения пере
менных справа, данная форма присваивания может использоваться
для реализации обмена значений переменных без создания временной
переменной – кортеж справа автоматически запоминает предыдущие
значения переменных:
>>> nudge = 1
>>> wink = 2
>>> nudge, wink = wink, nudge # Кортежи: обмен значениями
>>> nudge, wink # То же, что и T = nudge; nudge = wink; wink = T
(2, 1)
В конечном итоге формы присваивания кортежей и списков были
обобщены, чтобы обеспечить возможность указывать любые типы по
следовательностей справа при условии, что они будут иметь ту же дли
ну. Допускается присваивать кортеж значений списку переменных,
строки символов – кортежу переменных и т. д. В любом случае интер
претатор свяжет элементы последовательности справа с переменными
в последовательности слева согласно их позициям в направлении сле
ва направо:
>>> [a, b, c] = (1, 2, 3) # Кортеж значений присваивается списку переменных
>>> a, c
(1, 3)
>>> (a, b, c) = "ABC" # Строка символов присваивается кортежу переменных
>>> a, c
('A', 'C')
С технической точки зрения в правой части инструкции присваивания
последовательностей допускается указывать не только последователь
ности, но и любые объекты, обеспечивающие возможность итераций
по элементам. Эту, еще более общую концепцию, мы будем рассматри
вать в главах 13 и 17.
296 Глава 11. Присваивание, выражения и print
Дополнительные варианты инструкции присваивания
последовательностей
Одно замечание – даже при том, что допускается смешивать разные
типы последовательностей по обе стороны оператора =, обе последова
тельности должны иметь одно и то же число элементов, в противном
случае мы получим сообщение об ошибке:
>>> string = 'SPAM'
>>> a, b, c, d = string # Одинаковое число элементов с обеих сторон
>>> a, d
('S', 'M')
>>> a, b, c = string # В противном случае выводится сообщение об ошибке
...текст сообщения об ошибке опущен...
ValueError: too many values to unpack
(Перевод: ValueError: слишком много распакованных значений)
В общем случае нам необходимо получить срез. Существует несколько
вариантов извлечения среза, чтобы исправить дело:
>>> a, b, c = string[0], string[1], string[2:] # Элементы и срез
>>> a, b, c
('S', 'P', 'AM')
>>> a, b, c = list(string[:2]) + [string[2:]] # Срезы и конкатенация
>>> a, b, c
('S', 'P', 'AM')
>>> a, b = string[:2] # То же самое, только проще
>>> c = string[2:]
>>> a, b, c
('S', 'P', 'AM')
>>> (a, b), c = string[:2], string[2:] # Вложенные последовательности
>>> a, b, c
('S', 'P', 'AM')
Последний пример демонстрирует, что мы можем присваивать даже
вложенные последовательности, и интерпретатор распаковывает их
части в соответствии с их представлением, как и ожидается. В данном
случае выполняется присваивание кортежа из двух элементов, где
первый элемент – это вложенная последовательность (строка), что точ
но соответствует следующему случаю:
>>> ((a, b), c) = ('SP', 'AM') # Связывание производится в соответствии
>>> a, b, c # с формой и местоположением
('S', 'P', 'AM')
Интерпретатор связывает первую строку справа ('SP') с первым корте
жем слева ((a, b)), присваивая каждому его элементу по одному сим
волу, а затем выполняет присваивание второй строки целиком ('AM')
переменной c. В этом случае вложенная последовательность слева,
имеющая форму объекта, должна соответствовать объекту справа.
Инструкции присваивания 297
Присваивание вложенных последовательностей – это достаточно
сложная операция, которая редко встречается на практике, но такой
способ присваивания может оказаться удобным для присваивания
части структуры данных известной формы. Например, данный прием
может также использоваться в списках аргументов функций, потому
что передача аргументов выполняется присваиванием (как будет пока
зано в следующей части книги).
Кроме того, операция присваивания последовательности с распаков
кой дает начало еще одному распространенному обороту программиро
вания на языке Python – присваиванию последовательности целых чи
сел множеству переменных:
>>> red, green, blue = range(3)
>>> red, blue
(0, 2)
В этом примере три переменные инициализируются целочисленными
значениями 0, 1 и 2 соответственно (это эквивалент перечислимых ти
пов данных в языке Python, которые, возможно, вам приходилось
встречать в других языках программирования). Чтобы понять проис
ходящее, вы должны знать, что встроенная функция range генерирует
список последовательных целых чисел:
>>> range(3) # Попробуйте list(range(3)) в Python 3.0
[0, 1, 2]
Поскольку функция range часто используется в циклах for, мы еще по
говорим о ней в главе 13. Другой случай применения операции при
сваивания кортежей – разделение последовательности на начальную
и остальную части в циклах, как показано ниже:
>>> L = [1, 2, 3, 4]
>>> while L:
... front, L = L[0], L[1:]
... print front, L
...
1 [2, 3, 4]
2 [3, 4]
3 [4]
4 []
Присваивание кортежа в цикле здесь можно было бы заменить двумя
следующими строками, но часто бывает удобнее объединить их в одну
строку:
... front = L[0]
... L = L[1:]
Обратите внимание: в этом примере список используется в качестве сте
ка – структуры данных, поведение которой реализуют методы списков
append и pop. В данном случае эффект, который дает операция присваи
вания кортежа, можно было бы получить инструкцией front = L.pop(0),
298 Глава 11. Присваивание, выражения и print
но это будет операция непосредственного изменения объекта. О циклах
while и о других (часто лучших) способах обхода последовательностей
с помощью циклов for вы узнаете больше в главе 13.
Групповое присваивание
При групповом присваивании объект, расположенный справа, при
сваивается всем указанным переменным. В следующем примере трем
переменным a, b и c присваивается строка 'spam':
>>> a = b = c = 'spam'
>>> a, b, c
('spam', 'spam', 'spam')
Эта инструкция эквивалентна (но записывается компактнее) следую
щим трем инструкциям присваивания:
>>> c = 'spam'
>>> b = c
>>> a = b
Групповое присваивание и разделяемые ссылки
Имейте в виду, что в этом случае существует всего один объект, разде
ляемый всеми тремя переменными (все они указывают на один и тот же
объект в памяти). Такой способ присваивания хорошо подходит для не
изменяемых объектов, например для инициализации нескольких счет
чиков нулевым значением (не забывайте, что в языке Python перемен
ная должна быть инициализирована, прежде чем к ней можно будет об
ратиться, поэтому вам всегда придется устанавливать начальные значе
ния в счетчиках, прежде чем они смогут использоваться для счета):
>>> a = b = 0
>>> b = b + 1
>>> a, b
(0, 1)
Здесь изменение переменной b затронет только переменную b, потому
что числа не допускают возможность непосредственного изменения.
Если присваиваемый объект является неизменяемым, совершенно не
важно, как много ссылок на него будет создано.
Но, как обычно, следует проявлять осторожность, выполняя присваива
ние переменным изменяемых объектов, таких как списки или словари:
>>> a = b = []
>>> b.append(42)
>>> a, b
([42], [42])
На этот раз, поскольку a и b ссылаются на один и тот же объект, непо
средственное добавление значения к объекту через переменную b будет
воздействовать и на переменную a. В действительности это всего лишь
другой пример взаимовлияния разделяемых ссылок, с которым мы
Инструкции присваивания 299
впервые встретились в главе 6. Чтобы избежать этой проблемы, ини
циализацию изменяемыми объектами следует производить в отдель
ных инструкциях, чтобы в каждой из них создавался новый пустой
объект с помощью отдельных литеральных выражений:
>>> a = []
>>> b = []
>>> b.append(42)
>>> a, b
([], [42])
Дополняющее присваивание
Начиная с версии Python 2.0, в языке появился набор дополнительных
инструкций присваивания, перечисленных в табл. 11.2. Известные
как инструкции дополняющего присваивания и заимствованные из
языка C, они по существу являются лишь более компактной формой за
писи. Они комбинируют в себе выражение и операцию присваивания.
Например, следующие две формы записи практически эквивалентны:
X = X + Y # Традиционная форма записи
X += Y # Новая, комбинированная форма записи
Таблица 11.2. Комбинированные инструкции присваивания
Комбинированные операции присваивания существуют для любого
поддерживаемого двухместного оператора. Например, ниже приводит
ся два способа прибавления 1 к переменной:
>>> x = 1
>>> x = x + 1 # Традиционная форма записи
>>> x
2
>>> x += 1 # Дополняющая
>>> x
3
Если дополняющую форму применить к строкам, будет выполнена
операция конкатенации. Таким образом, вторая строка ниже эквива
лентна более длинной инструкции S = S + "SPAM":
>>> S = "spam"
>>> S += "SPAM" # Выполняется операция конкатенации
>>> S
'spamSPAM'
Как показано в табл. 11.2, для каждого двухместного оператора (т. е.
для оператора, слева и справа от которого располагаются значения,
участвующие в операции) в языке Python существует своя инструкция
X += Y X &= Y X = Y X |= Y
X *= Y X ^= Y X /= Y X >>= Y
X %= Y X <<= Y X **= Y X //= Y
300 Глава 11. Присваивание, выражения и print
дополняющего присваивания. Например, инструкция X *= Y выполняет
умножение и присваивание, X >>= Y – сдвиг вправо и присваивание,
и т. д. Инструкция X //= Y (деление с округлением вниз) была добавле
на в версии Python 2.2.
Дополняющие присваивания обладают следующими преимуществами:1
• Уменьшается объем ввода с клавиатуры. Нужно ли мне продолжать?
• Левая часть инструкции должна быть получена всего один раз. В ин
струкции «X += Y» X может оказаться сложным выражением, которое
в комбинированной форме должно быть вычислено всего один раз.
В более длинной форме запись «X = X + Y» X появляется дважды и по
этому данное выражение должно быть вычислено дважды. Вследст
вие этого дополняющие присваивания выполняются обычно быстрее.
• Автоматически выбирается оптимальный алгоритм выполнения.
Для объектов, поддерживающих возможность непосредственного
изменения, дополняющие присваивания автоматически выполня
ются непосредственно на самих объектах вместо выполнения более
медленной операции копирования.
И последний момент, который требует дополнительных разъяснений.
Дополняющие присваивания в случае операций, выполняемых непо
средственно над объектами, могут служить для оптимизации изменяе
мых объектов. Вспомним, что списки могут расширяться разными
способами. Чтобы добавить в список единственный элемент, мы мо
жем выполнить операцию конкатенации или вызвать метод append:
>>> L = [1, 2]
>>> L = L + [3] # Конкатенация: более медленная
>>> L
[1, 2, 3]
>>> L.append(4) # Более быстрая, но изменяет сам объект
>>> L
[1, 2, 3, 4]
А чтобы добавить несколько элементов, мы можем либо снова выпол
нить операцию конкатенации, либо вызвать метод extend:2
>>> L = L + [5, 6] # Конкатенация: более медленная
>>> L
[1, 2, 3, 4, 5, 6]
>>> L.extend([7, 8]) # Более быстрая, но изменяет сам объект
1 Программисты C/C++, конечно, заметят, что несмотря на появление в языке
Python таких инструкций, как X +=Y, в нем до сих пор отсутствуют операто
ры инкремента и декремента (например, X++, X). Однако эти операторы во
обще не соответствуют модели языка Python, в котором отсутствует возмож
ность непосредственно изменять неизменяемые объекты, такие как числа.
2 Как предлагалось в главе 6, для этого также можно было бы использовать
операцию присваивания срезу (например, L[len(L):] = [11,12,13]), но этот
прием работает практически так же, как метод extend.
Инструкции присваивания 301
>>> L
[1, 2, 3, 4, 5, 6, 7, 8]
В обоих случаях операция конкатенации несет в себе меньше побочных
эффектов при работе с разделяемыми ссылками на объекты, но вообще
она выполняется медленнее, чем эквивалентные операции, воздейст
вующие на объект непосредственно. Операция конкатенации должна
создать новый объект, копию в списке слева, и затем копию в списке
справа. В противовес ей метод, воздействующий на объект непосредст
венно, просто добавляет новый элемент в конец блока памяти.
При использовании дополняющего присваивания для расширения
списка мы можем не думать об этих деталях – интерпретатор Python
автоматически вызовет более быстрый метод extend вместо использова
ния более медленной операции конкатенации, которую предполагает
оператор +:
>>> L += [9, 10] # Выполняется как L.extend([9, 10])
>>> L
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Дополняющее присваивание и разделяемые ссылки
Такой порядок вещей чаще всего именно то, что нам требуется, но не
обходимо учитывать – он предполагает, что применительно к спискам
операция += выполняет изменения непосредственно в объекте, а это да
леко не то же самое, что операция конкатенации +, в результате кото
рой всегда создается новый объект. Как всегда в случае использования
разделяемых ссылок, различия в поведении этих операций могут
иметь значение, если имеются другие ссылки на изменяемый объект:
>>> L = [1, 2]
>>> M = L # L и M ссылаются на один и тот же объект
>>> L = L + [3, 4] # Операция конкатенации создает новый объект
>>> L, M # Изменяется L, но не M
([1, 2, 3, 4], [1, 2])
>>> L = [1, 2]
>>> M = L
>>> L += [3, 4] # Операция += предполагает вызов метода extend
>>> L, M # Значение M тоже изменилось!
([1, 2, 3, 4], [1, 2, 3, 4])
Все это имеет значение только для изменяемых объектов, таких как
списки и словари, и к тому же это не совсем ясный случай (по крайней
мере, пока его влияние не скажется на вашем программном коде!). Ес
ли вам требуется избежать создания системы разделяемых ссылок,
создавайте копии изменяемых объектов.
Правила именования переменных
Теперь, когда мы исследовали инструкции присваивания, настало вре
мя более формально подойти к вопросу выбора имен переменных. В язы
302 Глава 11. Присваивание, выражения и print
ке Python имена появляются в момент, когда им присваиваются некото
рые значения, однако существует несколько правил, которым желатель
но следовать при выборе имен для всего сущего в ваших программах:
Синтаксис: (символ подчеркивания или алфавитный символ) +
(любое число символов, цифр или символов подчеркивания)
Имена переменных должны начинаться с символа подчеркивания
или с алфавитного символа, за которым может следовать произ
вольное число алфавитных символов, цифр или символов подчер
кивания. Допустимыми именами являются: _spam, spam и Spam_1,
а 1_Spam, spam$ и @#! – недопустимыми.
Регистр символов в именах имеет значение: имена SPAM и spam
считаются различными именами
В языке Python регистр символов всегда принимается во внимание,
как в именах, которые вы создаете, так и в зарезервированных сло
вах. Например, имена X и x – это две разные переменные. Для обес
печения переносимости регистр символов учитывается и в именах
импортируемых модулей, даже на платформах, где файловые сис
темы не учитывают регистр символов.
Запрещено использовать зарезервированные слова
Имена определяемых вами переменных не могут совпадать с заре
зервированными словами, имеющими в языке Python специальное
назначение. Например, если попытаться использовать переменную
с именем class, интерпретатор выведет сообщение о синтаксиче
ской ошибке, однако имена klass и Class являются вполне допусти
мыми. В табл. 11.3 перечислены слова, которые в настоящее время
зарезервированы языком Python (и, следовательно, запрещены для
использования в качестве имен переменных).
Таблица 11.3. Зарезервированные слова языка Python
В версии Python 2.2 слово yield было необязательным расширени
ем, но, начиная с версии 2.3, оно стало стандартным зарезервиро
ванным словом. Оно используется совместно с генераторами
and elif if pass
as (в 2.6 и более
поздних)
else import print
assert except in raise
break exec is return
class finally lambda try
continue for nonlocal (в 3.0) while
def from not with (в 2.6 и более
поздних)
del global or yield
Инструкции присваивания 303
функций – новой особенностью, которая будет обсуждаться в гла
ве 17. Это один из небольшого числа элементов языка, в котором
была нарушена обратная совместимость с прежними версиями.
Однако такое преобразование слова yield было выполнено не
вдруг – в версии 2.2 при его использовании генерировалось пре
дупреждение, и оно было недопустимым до версии 2.3.
Похожим образом в Python 2.6 появились новые зарезервирован
ные слова with и as для использования в менеджере контекстов
(новая форма обработки исключений). В версии 2.5 эти слова не
считаются зарезервированными, пока менеджер контекстов не
будет включен вручную (подробности приводятся в главе 27). При
использовании в версии 2.5 слова with и as вызывают появление
предупреждений о грядущих изменениях – исключение состав
ляет версия IDLE в Python 2.5, где эта особенность включается ав
томатически (т. е. использование этих слов в качестве имен пере
менных в версии 2.5 будет вызывать ошибку, но только в интер
фейсе IDLE).
Зарезервированные слова языка Python всегда записываются симво
лами нижнего регистра и они действительно зарезервированы – в от
личие от имен в области видимости по умолчанию, о которой будет
рассказываться в следующей части книги, вы не можете переопреде
лять зарезервированные слова посредством операции присваивания
(например, and = 1 приведет к появлению ошибки).1
Кроме того, поскольку имена модулей в инструкции import становятся
переменными в сценарии, это накладывает ограничения на имена фай
лов с модулями. Вы можете создать файлы с именами and.py и my+
code.py, но вы не сможете импортировать их, потому что их имена без
расширения «.py» в программном коде будут преобразованы в имена пе
ременных и поэтому должны следовать только что обозначенным пра
вилам (зарезервированные слова запрещены, а символы дефиса являют
ся недопустимыми, хотя можно использовать символы подчеркивания).
Соглашения по именованию
Помимо указанных правил существует еще целый ряд соглашений –
правил, которые не являются обязательными, но которым обычно сле
дуют на практике. Например, имена с двумя символами подчеркива
ния в начале и в конце (например, __name__) обычно имеют особый
смысл для интерпретатора, поэтому вам следует избегать их использо
вания для именования своих переменных. Ниже приводится список
соглашений, которым было бы желательно следовать:
• Имена, начинающиеся с одного символа подчеркивания (_X), не им
портируются инструкцией from module import * (см. главу 19).
1 Тем не менее, в Jython, реализации Python на языке Java, имена пользова
тельских переменных иногда могут совпадать с зарезервированными сло
вами языка Python.
304 Глава 11. Присваивание, выражения и print
• Имена, имеющие два символа подчеркивания в начале и в конце
(__X__), являются системными именами, которые имеют особый
смысл для интерпретатора.
• Имена, начинающиеся с двух символов подчеркивания и не окан
чивающиеся двумя символами подчеркивания (__X), являются ло
кальными (автоматически подменяются другими именами) для
объемлющего класса (как описывается в главе 26).
• Имя, состоящее из единственного символа подчеркивания (_), хра
нит результат последнего выражения при работе в интерактивной
оболочке.
В дополнение к этим соглашениям существует еще ряд других согла
шений, которым обычно стремятся следовать программисты. Напри
мер, далее в книге мы увидим, что имена классов обычно начинаются
с заглавного символа, а имена модулей – с прописного, и что имя self,
хотя и не является зарезервированным, играет особую роль в классах.
В четвертой части книги мы познакомимся с еще одной крупной кате
горией имен, которые называются встроенными, т. е. предопределен
ными, но не зарезервированными (вследствие чего они допускают пе
реопределение: инструкция open = 42 является вполне допустимой, но
иногда вы можете пожалеть, что это так!).
Имена не имеют типа, тип – это характеристика объектов
По большей части это лишь краткий обзор, но вы должны помнить, что
крайне важно сохранить четкое понимание различий между именами
и объектами в языке Python. Как говорилось в главе 6 «Интерлюдия
о динамической типизации», объекты имеют тип (например, целое чис
ло, список) и могут быть изменяемыми или нет. С другой стороны, име
на (они же переменные) всегда являются всего лишь ссылками на объ
екты – они не имеют информации об изменяемости или о типе отдельно
от типа объекта, на который они ссылаются в данный момент времени.
Это вполне нормально, когда в разные моменты времени одно и то же
имя связывается с объектами разных типов:
>>> x = 0 # Имя x связывается с целочисленным объектом
>>> x = "Hello" # Теперь оно представляет строку
>>> x = [1, 2, 3] # А теперь – список
В последующих примерах вы увидите, что такая универсальная при
рода имен может рассматриваться как существенное преимущество
при программировании на языке Python.1 В четвертой части книги вы
1 Если вам приходилось пользоваться языком C++, возможно, вас заинтере
сует, что в отличие от C++ в языке Python отсутствует объявление const.
Некоторые объекты могут быть неизменяемыми, но имена всегда допуска
ют выполнение операции присваивания. Кроме того, в языке Python име
ются средства сокрытия имен в классах и модулях, но они также не явля
ются аналогами объявлений в языке C++.
Инструкции выражений 305
узнаете, что имена находятся внутри области видимости, которая
определяет, где эти имена могут использоваться – место, где выполня
ется присваивание, определяет, где это имя будет видимо.
Инструкции выражений
В языке Python выражения также могут использоваться в качестве ин
струкций (т. е. в отдельной строке). Однако, поскольку результат вы
числения таких выражений не сохраняется, использовать такую воз
можность имеет смысл только в том случае, если выражение выполня
ет какието полезные действия в виде побочного эффекта. В качестве
инструкций выражения используются обычно в двух ситуациях:
Для вызова функций и методов
Некоторые функции и методы выполняют огромный объем работы,
не возвращая никакого значения. В других языках программирова
ния такие функции иногда называют процедурами. Поскольку они
не возвращают значений, которые могло бы потребоваться сохра
нить, вы можете вызывать эти функции в инструкциях выражений.
Для вывода значений в интерактивной оболоске
В ходе интерактивного сеанса интерпретатор автоматически выво
дит результаты вводимых выражений. С технической точки зрения
они также являются инструкциями выражений и играют роль со
кращенной версии инструкции print.
В табл. 11.4 перечислены некоторые наиболее часто используемые
в языке Python формы инструкций выражений. При вызове функций
и методов им передаются ноль или более объектов в виде аргументов
(в действительности – выражений, результатом вычисления которых
являются объекты) в круглых скобках, следующих за именем функ
ции или метода.
Таблица 11.4. Наиболее часто используемые в языке Python
инструкции выражений
Последняя строка в таблице представляет специальную форму: язык
Python позволяет объединять операции сравнения, чтобы выполнить
серию сравнений в таких операциях, как проверка на принадлежность
Операция Интерпретация
spam(eggs, ham) Вызов функции
spam.ham(eggs) Вызов метода
spam Вывод значения переменной в интерактивной
оболочке интерпретатора
spam < ham and ham != eggs Составное выражение
spam < ham < eggs Проверка на принадлежность диапазону
306 Глава 11. Присваивание, выражения и print
диапазону значений. Например, выражение (A < B < C) проверяет, при
надлежит ли B диапазону значений от A до C – оно эквивалентно логи
ческому выражению (A < B and B < C), но оно проще воспринимается ви
зуально (и его проще вводить). Составные выражения обычно не запи
сываются в виде самостоятельных инструкций, но с точки зрения син
таксиса являются вполне допустимыми и могут быть даже полезными
при работе в интерактивной оболочке, когда вы не уверены в результа
те выражения.
Несмотря на то, что выражения могут играть роль инструкций в языке
Python, сами инструкции не могут использоваться в качестве выраже
ний. Например, язык Python не допускает встраивание инструкции
присваивания (=) в выражения. Сделано это специально для того, что
бы помочь избежать ошибок – вы могли бы случайно изменить пере
менную, введя вместо оператора проверки равенства == оператор при
сваивания =. В главе 13 будет показано, как отсутствие такой возмож
ности может быть компенсировано в языке Python, когда мы будем об
суждать цикл while.
Инструкции выражений и непосредственное
изменение объектов
Инструкции выражений являются причиной распространенной ошиб
ки при программировании на языке Python. Инструкции выражений
часто используются для вызова методов списка, которые непосредст
венно изменяют сам список:
>>> L = [1, 2]
>>> L.append(3) # Метод append изменяет сам список
>>> L
[1, 2, 3]
Однако начинающие программисты нередко записывают такие опера
ции в виде инструкций присваивания, пытаясь связать имя L со спи
ском:
>>> L = L.append(4) # Но метод append возвращает значение None, а не L
>>> print L # Поэтому мы теряем весь список!
None
Такая операция дает неверный результат – такие методы списка, как
apend, sort и reverse, всегда выполняют непосредственное изменение
объекта, но они не возвращают список, который был изменен с их по
мощью.
В действительности они возвращают объект None. Если результат та
кой операции присвоить той же переменной, вы потеряете список
(скорее всего, он будет уничтожен в ходе процесса сборки мусора!).
Поэтому не делайте этого. Мы еще раз вернемся к этому явлению в раз
деле «Распространенные ошибки программирования» в конце этой
части книги, потому что подобные ситуации могут складываться в кон
Инструкция print 307
тексте выполнения некоторых операторов цикла, с которыми мы по
знакомимся в последующих главах.
Инструкция print
Инструкция print производит вывод на экран – это просто удобный
для программистов интерфейс к стандартному потоку вывода. С тех
нической точки зрения эта инструкция преобразует объекты в тексто
вое представление и посылает результат на устройство стандартного
вывода.
Поток стандартного вывода в языке Python – это то же самое, что
stdout в языке C; обычно он отображается на окно, в котором была за
пущена программа на языке Python (если стандартный вывод не был
перенаправлен в файл или в канал средствами системной командной
оболочки).
В главе 9 мы рассматривали некоторые методы для работы с файлами,
которые выводят текст. Инструкция print чемто похожа на них, но она
имеет более специализированное назначение: инструкция print записы
вает объекты в поток stdout (с соблюдением некоторого форматирования
по умолчанию), в то время как методы файлов записывают строки в про
извольные файлы. Так как поток стандартного вывода в языке Python
доступен в виде объекта stdout встроенного модуля sys (т. е., sys.stdout),
вполне возможно имитировать поведение инструкции print с помощью
методов записи в файл, хотя использование print выглядит проще.
Таблица 11.5. Перечень форм инструкции print
Мы уже видели инструкцию print в действии. По умолчанию она до
бавляет пробел между элементами, отделенными запятыми, и символ
конца строки в конце текущей строки вывода:
>>> x = 'a'
>>> y = 'b'
>>> print x, y
a b
Такое форматирование – всего лишь значение по умолчанию, которое
можно использовать или нет. Чтобы подавить вывод символа конца
строки (чтобы позднее можно было продолжить вывод текста в текущую
Операция Интерпретация
print spam, ham Вывод объектов в sys.stdout; добавляет пробел
между объектами и символ конца строки
print spam, ham, То же самое, только на этот раз символ конца
строки не добавляется
print >> myfile, spam, ham Текст передается методу myfile.write, а не
sys.stdout.write
308 Глава 11. Присваивание, выражения и print
строку), инструкцию print следует завершать символом запятой, как
показано во второй строке табл. 11.5. Чтобы подавить вывод пробела
между элементами, не следует производить вывод таким способом –
вместо этого нужно самостоятельно собрать строку с помощью средств
конкатенации и форматирования, о которых рассказывалось в главе 7,
и вывести эту строку:
>>> print x + y
ab
>>> print '%s...%s' % (x, y)
a...b
Программа «Hello World» на языке Python
Чтобы вывести сообщение «hello world», достаточно просто напечатать
строку:
>>> print 'hello world' # Вывести строковый объект
hello world
Поскольку результаты выражений в интерактивной оболочке выво
дятся автоматически, вы можете даже не использовать инструкцию
print – просто введите выражение, которое требуется вывести, и ре
зультат его вычисления немедленно будет выведен:
>>> 'hello world' # Интерактивная оболочка выводит автоматически
'hello world'
В действительности инструкция print – это всего лишь эргономичная
особенность языка Python – она обеспечивает простой интерфейс к объ
екту sys.stdout, добавляя незначительный объем форматирования.
Фактически, если вам нравится идти более трудным путем, вы можете
запрограммировать вывод таким способом:
>>> import sys # Вывод более сложным способом
>>> sys.stdout.write('hello world\n')
hello world
В этом фрагменте явно вызывается метод write объекта sys.stdout – ат
рибут, предустановленный интерпретатором Python во время откры
тия файла, связанного с потоком вывода. Инструкция print скрывает
большую часть этих подробностей, предоставляя простой инструмент
для решения простых задач вывода.
Перенаправление потока вывода
Итак, почему я показал пока единственный способ вывода? Как ока
зывается, объект sys.stdout обеспечивает возможность вывода, экви
валентную базовой методике, используемой в языке Python. Вообще
говоря, инструкция print и объект sys.stdout связаны между собой
следующим образом. Следующая инструкция:
print X
Инструкция print 309
является эквивалентом более длинной:
import sys
sys.stdout.write(str(X) + '\n')
которая вручную выполняет преобразование объекта в строку с помо
щью функции str, добавляет символ новой строки с помощью операто
ра + и вызывает метод write потока вывода. Более длинная форма сама
по себе не так удобна в использовании. Однако полезно знать, что она
является точным эквивалентом инструкции print, потому что сущест
вует возможность перенаправить sys.stdout в место, отличное от стан
дартного потока вывода. Другими словами, эта эквивалентность обеспе
чивает возможность заставить инструкцию print выводить текст в дру
гое место. Например:
import sys
sys.stdout = open('log.txt', 'a') # Перенаправить вывод в файл
...
print x, y, x # Текст появится в файле log.txt
Здесь мы вручную перенаправили объект sys.stdout в файл, открытый
вручную в режиме добавления. После этого все инструкции print в про
грамме будут выводить текст в конец файла log.txt, а не в стандартный
поток вывода. Инструкции print благополучно продолжают вызывать
метод write объекта sys.stdout независимо от того, куда он ссылается.
Поскольку в каждом процессе существует всего один модуль sys, пере
направление sys.stdout таким способом будет воздействовать на все
инструкции print в программе.
Фактически, как будет говориться в ближайшей врезке, описываю
щей инструкцию print и объект stdout, существует возможность пере
направить sys.stdout в объект, который даже не является файлом, при
условии, что он соответствует ожидаемому протоколу (метод write), –
в этом случае объект может быть классом, который может обрабаты
вать и перенаправлять выводимый текст произвольным образом.
Этот прием с перенаправлением потока вывода в первую очередь мо
жет оказаться полезен в программах, изначально рассчитанных на ис
пользование инструкции print. Если известно, что весь вывод должен
отправляться в файл, вы всегда сможете организовать вызов методов
записи в файл. При перенаправлении потока вывода в программах,
основанных на использовании инструкции print, настройка объекта
sys.stdout обеспечивает удобную альтернативу изменению поведения
всех инструкций print или применению перенаправления средствами
командной оболочки системы.
Расширение print >> file
Прием перенаправления вывода текста за счет назначения файла в объ
екте sys.stdout очень часто используется на практике. Однако в про
граммном коде предыдущего раздела имеется одна потенциальная
310 Глава 11. Присваивание, выражения и print
проблема – отсутствует прямой способ восстановления первоначально
го потока вывода, если вдруг после вывода данных в файл потребуется
вернуться обратно к выводу на экран. Но поскольку sys.stdout является
обычным объектом, вы всегда можете в случае необходимости сохра
нить его и восстановить позднее:1
>>> import sys
>>> temp = sys.stdout # Сохранить для последующего восстановления
>>> sys.stdout = open('log.txt', 'a') # Перенаправить вывод в файл
>>> print 'spam' # Вывести в файл, а не на экран
>>> print 1, 2, 3
>>> sys.stdout.close() # Вытолкнуть буферы на диск
>>> sys.stdout = temp # Восстановить первоначальный поток
>>> print 'back here' # Вывести на экран
back here
>>> print open('log.txt').read() # Результаты более ранних обращений
spam # к инструкции print
1 2 3
Потребность в таком перенаправлении возникает на удивление часто,
а ручное сохранение и восстановление оригинального потока вывода –
процедура достаточно сложная, что привело к появлению расширения
для инструкции print, которое делает такое перенаправление ненуж
ным. Когда инструкция print начинается с символов >>, вслед за кото
рыми указывается объект файла (или другой объект) для вывода, та
кая инструкция посылает текст методу write указанного объекта, но
при этом не происходит перенаправления объекта sys.stdout. Посколь
ку в этом случае перенаправление носит временный характер, обыч
ные инструкции print продолжают выводить текст в оригинальный
поток вывода:
log = open('log.txt', 'a')
print >> log, x, y, z # Вывести в объект, напоминающий файл
print a, b, c # Вывести в оригинальный поток вывода
Расширение >> удобно использовать, когда в одной и той же программе
необходимо организовать вывод и в файл, и в стандартный поток выво
да. Однако, если вы собираетесь использовать эту форму инструкции,
вам потребуется создать объектфайл (или объект, который имеет ме
тод write, как и объект файла) и передавать инструкции этот объект,
а не строку с именем файла:
1 Можно также использовать относительно новый атрибут __stdout__ объек
та sys.stdout, который ссылается на первоначальное значение sys.stdout,
имевшееся на момент запуска программы. Но вам и в этом случае необхо
димо вручную восстановить sys.stdout в первоначальное значение
__stdout__, чтобы вернуться к оригинальному потоку вывода. За дополни
тельными подробностями обращайтесь к описанию модуля sys в руково
дстве по стандартной библиотеке.
Инструкция print 311
>>> log = open('log.txt', 'w')
>>> print >> log, 1, 2, 3
>>> print >> log, 4, 5, 6
>>> log.close()
>>> print 7, 8, 9
7 8 9
>>> print open('log.txt').read()
1 2 3
4 5 6
Эта расширенная форма инструкции print нередко используется для
вывода сообщений об ошибках в стандартный поток ошибок, sys.stderr.
Вы можете либо использовать его метод write и форматировать выводи
мые строки вручную, либо использовать синтаксис перенаправления:
>>> import sys
>>> sys.stderr.write(('Bad!' * 8) + '\n')
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
>>> print >> sys.stderr, 'Bad!' * 8
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
Придется держать в уме: print и stdout
Эквивалентность инструкции print и метода write объекта
sys.stdout имеет большое значение. Она позволяет перенапра
вить объект sys.stdout в определяемый пользователем объект,
который поддерживает те же методы, что и файлы (например,
write). Так как инструкция print всего лишь передает текст мето
ду sys.stdout.write, вы можете перехватывать выводимый текст,
перенаправив sys.stdout в объект, обладающий методом write для
обработки текста.
Например, можно отправить текст в окно графического интер
фейса или отправить его в несколько мест, определив объект с ме
тодом write, который выполнит все необходимые действия. При
мер использования такой возможности вы увидите далее в кни
ге, когда мы будем изучать классы, но в общих чертах это выгля
дит примерно так:
class FileFaker:
def write(self, string):
# Выполнить какиелибо действия со строкой
import sys
sys.stdout = FileFaker()
print someObjects # Передает строку методу write класса
312 Глава 11. Присваивание, выражения и print
Предполагается, что в Python 3.0 инструкция print превратится
во встроенную функцию с эквивалентными возможностями, но
с несколько иным синтаксисом. Выходной файл и необходимость
вывода символа конца строки будут определяться аргументами
с зарезервированными именами. Например, инструкция print x,
y превратится в вызов print(x, y), а инструкция print >> f, x –
в вызов print(x, file=f, end='').
Но все это будет в будущем, поэтому за дополнительной информа
цией обращайтесь к примечаниям к выпуску 3.0. В настоящее
время предложено включить в версию 3.0 сценарий (с рабочим
названием «2to3»), который кроме всего прочего будет выпол
нять преобразование инструкций print в существующем про
граммном коде в вызовы функции print. Он должен помочь вам
в переходе с версии 2.x на версию 3.x (как и эта книга!).
В заключение
В этой главе мы начали детальный обзор инструкций языка Python,
исследовав инструкции присваивания, выражения и print. Несмотря
Этот прием возможен благодаря тому, что инструкция print яв
ляется тем, что в следующей части книги мы назовем полиморф+
ной операцией, – она не интересуется тем, что из себя представ
ляет объект sys.stdout, ей нужен всего лишь метод (т. е. интер
фейс) с именем write. В последних версиях Python перенаправле
ние в объекты реализовано еще проще, с помощью расширенной
формы >> инструкции print, благодаря чему нам не требуется яв
но перенаправлять объект sys.stdout:
myobj = FileFaker() # Перенаправление вывода для одной инструкции
print >> myobj, someObjects # Не влияет на объект sys.stdout
Встроенная функция raw_input() в языке Python читает данные
из файла sys.stdin, поэтому существует возможность перенапра
вить ввод аналогичным образом, используя классы, реализую
щие метод read. Смотрите примеры использования функции
raw_input и цикла while, которые приводятся в главе 10, чтобы
получить дополнительные начальные сведения по этой теме.
Обратите внимание: вывод текста осуществляется в поток stdout,
что обеспечивает возможность вывода документов HTML в CGI
сценариях. Кроме того, это позволяет выполнить перенаправле
ние ввода и вывода для сценария на языке Python обычными
средствами командной строки операционной системы:
python script.py < inputfile > outputfile
python script.py | filterProgram
Закрепление пройденного 313
на всю простоту использования этих инструкций, у них имеются аль
тернативные формы, которые являются необязательными, но порой
достаточно удобными в применении. Комбинированные инструкции
присваивания и форма инструкции print с перенаправлением, напри
мер, позволяют уменьшить объем программного кода. Кроме того, мы
изучили синтаксис имен переменных, приемы перенаправления пото
ков и различные часто встречающиеся ошибки, которых следует избе
гать, такие как обратное присваивание переменной значения, возвра
щаемого методом append.
В следующей главе мы продолжим наше знакомство с инструкциями,
подробно рассмотрев инструкцию if – основную инструкцию органи
зации выбора в языке Python. В этой главе мы еще раз вернемся к син
таксической модели языка и рассмотрим поведение логических выра
жений. Но прежде чем двинуться дальше, проверьте знания, получен
ные здесь, с помощью контрольных вопросов.
Закрепление пройденного
Контрольные вопросы
1. Назовите три способа, с помощью которых можно присвоить одно
и то же значение трем переменным.
2. Что требуется держать в уме, когда трем переменным присваивает
ся один и тот же изменяемый объект?
3. В чем заключается ошибка в инструкции L = L.sort()?
4. Как с помощью инструкции print вывести текст во внешний файл?
Ответы
1. Можно выполнить групповое присваивание (A = B = C = 0), при
сваивание последовательности (A, B, C = 0, 0, 0) или несколько ин
струкций присваивания в отдельных строках (A = 0, B = 0, C = 0).
И последний способ, как было показано в главе 10, заключается
в том, чтобы объединить инструкции в одной строке, разделив их
точкой с запятой (A = 0; B = 0; C = 0).
2. Если выполнить присваивание следующим образом:
A = B = C = []
то все три имени будут ссылаться на один и тот же объект, поэтому
непосредственное изменение объекта с помощью одной переменной
(например, A.append(99)) отразится на других. Это справедливо
только для изменений, производимых непосредственно в изменяе
мых объектах, таких как списки и словари. Для неизменяемых
объектов, таких как числа и строки, эта проблема не проявляется.
3. Метод списков sort, как и метод append, выполняет изменения непо
средственно в объекте и возвращает значение None, а не измененный
314 Глава 11. Присваивание, выражения и print
список. Обратное присваивание переменной L приведет к тому, что
в нее запишется значение None, а не отсортированный список. Как
будет показано далее в этой части книги, недавно в языке появи
лась новая функция sorted, которая выполняет сортировку любых
последовательностей и возвращает новый список с результатами
сортировки. Поскольку в этом случае изменения производятся не
в самом объекте, есть смысл сохранить возвращаемое значение.
4. Можно вручную перенаправить объект sys.stdout, открыв файл пе
ред вызовом инструкции print, или использовать расширенную
форму инструкции print >> file для вывода в файл единственной
инструкцией. Можно также перенаправить весь выводимый про
граммой текст в файл с помощью синтаксических конструкций сис
темной командной оболочки, но этот вариант к языку Python ника
кого отношения не имеет.
12
Условная инструкция if
Эта глава представляет условную инструкцию if, которая является ос
новной инструкцией, используемой для выбора среди альтернативных
операций на основе результатов проверки. Поскольку в нашем обзоре
это первая составная инструкция – инструкция, встроенная в другую
инструкцию, – мы заодно более подробно рассмотрим общие концеп
ции, на которых покоится синтаксическая модель инструкций в язы
ке Python. А так как условная инструкция вводит понятие проверки,
мы также будем иметь дело с логическими выражениями и остановим
ся на некоторых деталях относительно проверок истинности вообще.
Условные инструкции if
Если говорить простым языком, в Python инструкция if выбирает, ка
кое действие следует выполнить. Это основной инструмент выбора
в Python, который отражает большую часть логики программы на язы
ке Python. Кроме того, это наша первая составная инструкция. Как
и все составные инструкции языка Python, инструкция if может со
держать другие инструкции, в том числе другие условные инструкции
if. Фактически Python позволяет комбинировать инструкции в про
граммные последовательности (чтобы они выполнялись одна за дру
гой) и в произвольно вложенные конструкции (которые выполняются
только при соблюдении определенных условий).
Общая форма
Условная инструкция if в языке Python – это типичная условная инст
рукция, которая присутствует в большинстве процедурных языков
программирования. Синтаксически сначала записывается часть if с ус
ловным выражением, далее могут следовать одна или более необяза
тельных частей elif («else if») с условными выражениями и, наконец,
316 Глава 12. Условная инструкция if
необязательная часть else. Условные выражения и часть else имеют ас
социированные с ними блоки вложенных инструкций, с отступом отно
сительно основной инструкции. Во время выполнения условной инст
рукции if интерпретатор выполняет блок инструкций, ассоциирован
ный с первым условным выражением, только если оно возвращает ис
тину, в противном случае выполняется блок инструкций else. Общая
форма записи условной инструкции if выглядит следующим образом:
if <test1>: # Инструкция if с условным выражением test1
<statements1> # Ассоциированный блок
elif <test2>: # Необязательные части elif
<statements2>
else: # Необязательный блок else
<statements3>
Простые примеры
C целью демонстрации инструкции if в действии рассмотрим несколь
ко простых примеров. Все части этой инструкции, за исключением ос
новной части if с условным выражением и связанных с ней инструк
ций, являются необязательными. В простейшем случае остальные час
ти инструкции опущены:
>>> if 1:
... print 'true'
...
true
Обратите внимание, что приглашение к вводу изменяется на ... для
строк продолжения в базовом интерфейсе командной строки, исполь
зуемом здесь (в IDLE текстовый курсор просто перемещается на сле
дующую строку уже с отступом, а нажатие на клавишу Backspace воз
вращает на строку вверх). Ввод пустой строки завершает инструкцию
и приводит к ее выполнению. Вспомните, что число 1 является логиче
ской истиной, поэтому данная проверка всегда будет успешной. Чтобы
обработать ложный результат, добавьте часть else:
>>> if not 1:
... print 'true'
... else:
... print 'false'
...
false
Множественное ветвление
Теперь рассмотрим пример более сложной условной инструкции if,
в которой присутствуют все необязательные части:
>>> x = 'killer rabbit'
>>> if x == 'roger':
... print "how's jessica?"
Условные инструкции if 317
... elif x == 'bugs':
... print "what's up doc?"
... else:
... print 'Run away! Run away!'
...
Run away! Run away!
Эта многострочная инструкция простирается от строки if до конца
блока else. При выполнении этой инструкции интерпретатор выпол
нит вложенные инструкции после той проверки, которая даст в ре
зультате истину, или блок else, если все проверки дадут ложный ре
зультат (в этом примере так и происходит). На практике обе части elif
и else могут быть опущены и в каждой части может иметься более од
ной вложенной инструкции. Обратите внимание, что связь слов if,
elif и else определена тем, что они находятся на одной вертикальной
линии, с одним и тем же отступом.
Если вы знакомы с такими языками, как C или Pascal, вам будет инте
ресно узнать, что в языке Python отсутствует инструкция switch или
case, которая позволяет выбирать производимое действие на основе
значения переменной. Вместо этого множественное ветвление оформ
ляется либо в виде последовательности проверок if/elif, как в преды
дущем примере, либо индексированием словарей, либо поиском в спи
сках. Поскольку словари и списки могут создаваться во время выпол
нения, они иногда способны обеспечить более высокую гибкость, чем
жестко заданная логика инструкции if:
>>> choice = 'ham'
>>> print {'spam': 1.25, # Инструкция 'switch' на базе словаря
... 'ham': 1.99, # Используйте has_key или get для
... 'eggs': 0.99, # значения по умолчанию
... 'bacon': 1.10}[choice]
1.99
Тем, кто такой прием видит впервые, может потребоваться некоторое
время, чтобы осознать его; и тем не менее, данный словарь обеспечива
ет множественное ветвление через индексирование по ключу choice
для выбора одного из нескольких значений, почти так же, как это де
лает инструкция switch в языке C. Эквивалентная, но менее компакт
ная инструкция if в языке Python выглядит, как показано ниже:
>>> if choice == 'spam':
... print 1.25
... elif choice == 'ham':
... print 1.99
... elif choice == 'eggs':
... print 0.99
... elif choice == 'bacon':
... print 1.10
... else:
... print 'Bad choice'
318 Глава 12. Условная инструкция if
...
1.99
Обратите внимание на часть else, которая предназначена для обработ
ки ситуации, когда не найдено ни одного совпадения. Как было показа
но в главе 8, значение по умолчанию при использовании словарей мо
жет быть получено с помощью методов has_key и get или при перехвате
исключения. Те же самые приемы могут использоваться и здесь – для
определения действия по умолчанию в случае реализации множест
венного ветвления на базе словаря. Ниже приводится пример с ис
пользованием метода get для получения значения по умолчанию:
>>> branch = {'spam': 1.25,
... 'ham': 1.99,
... 'eggs': 0.99}
>>> print branch.get('spam', 'Bad choice')
1.25
>>> print branch.get('bacon', 'Bad choice')
Bad choice
Словари хорошо подходят для выбора значений, ассоциированных
с ключами, но как быть в случае более сложных действий, которые
можно запрограммировать в инструкциях if? В четвертой части книги
вы узнаете, что словари также могут содержать функции, выполняю
щие сложные действия при ветвлении, реализуя обычные таблицы пе
реходов. В этом случае функции играют роль значений в словаре, час
то создаются как лямбдафункции и вызываются добавлением круг
лых скобок. Подробнее об этом вы прочитаете далее.
Множественное ветвление на базе словаря довольно удобно использо
вать в программах, которые имеют дело с динамическими данными,
однако большинство программистов согласятся, что использование
инструкции if является наиболее простым способом организации мно
жественного ветвления. Обычно, при колебаниях при выборе того или
иного подхода предпочтение следует отдавать более простому и более
удобочитаемому.
Синтаксические правила языка Python
Первое знакомство с синтаксической моделью языка Python состоя
лось в главе 10. Теперь, когда мы подошли к таким крупным инструк
циям, как if, настало время пересмотреть и дополнить сведения о син
таксисе, введенные ранее. Вообще язык программирования Python об
ладает простым синтаксисом, основанным на применении инструк
ций. Однако он обладает некоторыми особенностями, о которых вам
необходимо знать:
• Инструкции выполняются последовательно, одна за другой, пока
не будет предусмотрено что!то другое. Обычно интерпретатор вы
полняет инструкции в файле или в блоке от начала до конца, но та
Синтаксические правила языка Python 319
кие инструкции, как if (и, как будет показано далее, циклы), за
ставляют интерпретатор выполнять переходы внутри программного
кода. Так как путь интерпретатора Python через текст программы
называется потоком управления, такие инструкции, как if, часто
называются инструкциями управления потоком выполнения.
• Границы блоков и инструкций определяются автоматически. Как
мы уже видели, в языке Python отсутствуют фигурные скобки или
разделители «begin/end», окружающие блоки программного кода.
Вместо этого принадлежность инструкций к вложенному блоку
определяется по величине отступов. Так же инструкции в языке Py
thon обычно не завершаются точкой с запятой; обычно признаком
конца инструкции служит конец строки с этой инструкцией.
• Составные инструкции = заголовок, «:», инструкции с отступами.
Все составные инструкции в языке Python оформляются одинако
во: строка с заголовком завершается двоеточием, далее следуют од
на или более вложенных инструкций, обычно с отступом относи
тельно заголовка. Эти инструкции с отступами называются блоком
(или иногда набором). В инструкции if предложения elif и else яв
ляются не только частями инструкции if, но и заголовками с собст
венными вложенными блоками.
• Пустые строки, пробелы и комментарии обычно игнорируются.
Пустые строки игнорируются в файлах (но не в интерактивной обо
лочке). Пробелы внутри инструкций и выражений игнорируются
практически всегда (за исключением строковых литералов, а так
же когда они используются для оформления отступов). Коммента
рии игнорируются всегда: они начинаются с символа # (не внутри
строковых литералов) и простираются до конца строки.
• Строки документирования игнорируются, но сохраняются и ото!
бражаются специализированными инструментами. В языке Py
thon поддерживается дополнительная форма комментариев, назы
ваемая строками документирования, которые в отличие от коммен
тариев, начинающихся с #, сохраняются для просмотра во время
выполнения. Строки документирования – это обычные строки, ко
торые располагаются в начале файлов с программами и в некото
рых инструкциях. Интерпретатор игнорирует их содержимое, но
они автоматически присоединяются к объектам во время выполне
ния и могут отображаться инструментами доступа к документации.
Строки документирования являются частью стратегии документи
рования в языке Python и будут рассматриваться в последней главе
этой части книги.
Как уже говорилось ранее, в языке Python отсутствует необходимость
объявлять типы переменных – только один этот факт упрощает син
таксис языка больше, чем любые другие особенности. Но для большин
ства новых пользователей самой необычной особенностью синтаксиса
языка Python кажется отсутствие фигурных скобок и точек с запятой,
320 Глава 12. Условная инструкция if
используемых в качестве разделителей блоков и инструкций во мно
гих других языках, поэтому давайте рассмотрим их поближе.
Разделители блоков
Интерпретатор автоматически определяет границы блоков по величи
не отступов – т. е. по ширине пустого пространства слева от программ
ного кода. Все инструкции, смещенные вправо на одинаковое расстоя
ние, принадлежат к одному и тому же блоку кода. Другими словами,
инструкции в блоке выстроены по вертикальной линии. Блок закан
чивается либо с концом файла, либо как только встретится строка
с меньшим отступом; более глубоко вложенные блоки имеют более
широкие отступы, чем инструкции в объемлющем блоке.
Например, на рис. 12.1 показана структура блоков следующего фраг
мента программного кода:
x = 1
if x:
y = 2
if y:
print 'block2'
print 'block1'
print 'block0'
Данный фрагмент содержит три блока: первый (программный код
верхнего уровня) вообще не имеет отступов, второй (внутри внешней
инструкции if) имеет отступ из четырех пробелов и третий (инструк
ция print внутри вложенной инструкции if) имеет отступ из восьми
пробелов.
Рис. 12.1. Вложенные блоки программного кода: вложенный блок начинается
с инструкции, имеющей больший отступ, и заканчивается либо когда будет
встречена инструкция с меньшим отступом, либо в конце файла
Заголовок:
Заголовок:
Блок 0
Блок 0
Блок 2
Блок 1
Блок 1
Синтаксические правила языка Python 321
Вообще программный код верхнего уровня (не вложенный) должен на
чинаться в строках с позиции 1. Вложенные блоки могут начинаться
с любой позиции – отступ может состоять из любого числа пробелов
и символов табуляции, главное, чтобы все инструкции в одном блоке
имели одинаковые отступы. То есть для интерпретатора неважно, как
будут оформляться отступы, главное, чтобы оформление было непроти
воречивым. С технической точки зрения считается, что символ табуля
ции смещает текущую позицию в строке на восемь пробелов, но обычно
не принято смешивать символы табуляции и пробелы внутри блока –
используйте чтото одно – или пробелы, или символы табуляции.
Единственное, где в языке Python пробелы имеют большое значение, –
это когда они находятся левее программного кода; в большей части
других случаев неважно, есть пробелы или нет. При этом отступы яв
ляются частью синтаксиса языка, а не просто оформлением: все инст
рукции внутри любого заданного блока должны иметь одинаковые от
ступы, в противном случае интерпретатор сообщит о синтаксической
ошибке. Так как вам не требуется явно отмечать начало и конец вло
женного блока, различные синтаксические элементы, которые можно
найти в других языках, в языке Python не нужны.
Отступы, как часть синтаксической модели, стали важным компонен
том обеспечения удобочитаемости в языках структурного программи
рования, таких как Python. Иногда синтаксис языка Python описыва
ют фразой «what you see is what you get» (что видишь, то и получаешь) –
отступ каждой строки однозначно говорит, к какому блоку она при
надлежит. Такой непротиворечивый внешний вид программного кода
на языке Python обеспечивает простоту его сопровождения и много
кратного использования.
Программный код, в котором отступы оформлены непротиворечивым
образом, всегда будет соответствовать правилам языка Python. Кроме
того, многие текстовые редакторы (включая IDLE) упрощают следова
ние модели отступов, автоматически выравнивая программный код по
мере его ввода.
Разделители инструкций
В языке Python инструкция обычно заканчивается в конце строки. Од
нако, если инструкция слишком велика, чтобы уместиться в одной
строке, можно использовать следующие специальные правила разме
щения инструкции в нескольких строках:
• Инструкции могут располагаться в нескольких строках, если они
окружены синтаксической парой скобок. Язык Python позволяет
продолжить ввод инструкции в следующей строке, когда содержи
мое инструкции заключено в пару скобок (), {} или []. Примерами
инструкций, которые могут располагаться в нескольких строках,
могут служить выражения в круглых скобках, литералы словарей
и списков – инструкция не считается законченной, пока интерпре
322 Глава 12. Условная инструкция if
татор Python не встретит строку с закрывающей скобкой (), } или ]).
Промежуточные строки могут иметь любые отступы и не обязатель
но должны быть выровнены по вертикали.
• Инструкции могут располагаться в нескольких строках, если они
завершаются символом обратного слеша. Это несколько устарев
шая особенность, но если необходимо разместить инструкцию в не
скольких строках, можно в конец каждой предшествующей строки
вставить символ обратного слеша, который будет служить призна
ком, что инструкция продолжается на следующей строке. Так как
существует возможность использовать круглые скобки для заклю
чения длинных конструкций, символы обратного слеша практиче
ски никогда не используются.
• Литералы строк в тройных кавычках могут располагаться в не!
скольких строках. Очень длинные строковые литералы можно раз
местить в нескольких строках – блоки строк в тройных кавычках,
с которыми мы встретились в главе 7, предназначены именно для
этих целей.
• Другие правила. Существует еще несколько моментов, которые хо
телось бы упомянуть. Хотя это и необычно, инструкции можно за
вершать точкой с запятой – иногда это соглашение используется,
чтобы компактно разместить несколько инструкций в одной стро
ке. Кроме того, в любом месте в файле могут присутствовать пустые
строки и комментарии. Комментарии (которые начинаются с сим
вола #) простираются до конца строки.
Несколько специальных случаев
Ниже показано, как выглядит инструкция при применении правила
использования скобок. Конструкции, заключенные в скобки, могут
занимать произвольное число строк:
L = ["Good",
"Bad",
"Ugly"] # Открытая пара скобок может охватывать несколько строк
Этот прием также можно использовать с круглыми скобками: выраже
ния, аргументы функций, заголовки функций (глава 15) и т. д. При
желании можно использовать символы обратного слеша, но этот при
ем редко используется на практике:
if a == b and c == d and \
d == e and f == g:
print 'olde' # Символы обратного слеша позволяют продолжить...
Поскольку любое выражение можно заключить в круглые скобки, то
лучше использовать их при необходимости расположить инструкцию
в нескольких строках:
if (a == b and c == d and
d == e and e == f):
Проверка истинности 323
print 'new' # Но круглые скобки позволяют то же самое
Еще один специальный случай: в языке Python допускается записы
вать в одной строке несколько несоставных инструкций (т. е. инструк
ций, которые не имеют вложенных инструкций), разделяя их точками
с запятой. Некоторые программисты используют эту возможность для
экономии пространства в файле, однако удобочитаемость будет выше,
если в каждой строке размещать только одну инструкцию:
x = 1; y = 2; print x # Несколько простых инструкций в одной строке
И, наконец, Python позволяет располагать тело составной инструкции
в одной строке с заголовком при условии, что тело образует простая
(несоставная) инструкция. Вам часто придется видеть следующий ва
риант использования простых инструкций с единственным условием
и действием:
if 1: print 'hello' # Простая инструкция в строке заголовка
Некоторые из этих специальных случаев можно комбинировать меж
ду собой, чтобы писать программный код, который будет сложно чи
тать, но я не рекомендую поступать так – старайтесь записывать по од
ной инструкции в строке и выравнивайте все блоки, кроме простей
ших. Когда вам придется вернуться к своей программе спустя полго
да, вы будете рады, что поступали именно так.
Проверка истинности
Понятия сравнения, равенства и значений истинности были введены
в главе 9. Инструкция if – это первая инструкция на нашем пути, ко
торая использует результаты проверки, поэтому здесь мы подробнее
поговорим о некоторых из этих идей. В частности о том, что логиче
ские операторы в языке Python несколько отличаются от аналогичных
операторов в таких языках как C. В языке Python:
• Любое число, не равное нулю, или непустой объект интерпретиру
ется как истина.
• Числа, равные нулю, пустые объекты и специальный объект None
интерпретируются как ложь.
• Операции сравнения и равенства применяются к структурам дан
ных рекурсивно.
• Операции сравнения и равенства возвращают значение True или
False (которые представляют собой версии чисел 1 и 0).
• Логические операторы and и or возвращают истинный или ложный
объектоперанд.
В двух словах, логические операторы используются для объединения
результатов других проверок. В языке Python существует три логиче
ских оператора:
324 Глава 12. Условная инструкция if
X and Y
Истина, если оба значения X и Y истинны.
X or Y
Истина, если любое из значений X или Y истинно.
not X
Истина, значение X ложно (выражение возвращает значение True
или False)
Здесь X и Y могут быть любыми значениями истинности или выраже
ниями, которые возвращают значения истинности (например, выра
жение проверки равенства, сравнение с диапазоном значений и т. д.).
В языке Python логические операторы имеют вид слов (вместо обозна
чений &&, || и !, как это реализовано в языке C). Кроме того, логиче
ские операторы and и or возвращают истинный или ложный объект,
а не значение True или False. Рассмотрим несколько примеров, чтобы
понять, как они работают:
>>> 2 < 3, 3 < 2 # Меньше чем: возвращает 1 или 0
(True, False)
Операция сравнения величин, как в данном случае, возвращает в ка
честве результата значение True или False, которые, как мы узнали
в главах 5 и 9, в действительности являются особыми версиями целых
чисел 1 и 0 (выводятся они особым образом, а во всем остальном явля
ются обычными числами).
С другой стороны, операторы and и or всегда возвращают объект – объ
ект либо слева от оператора, либо справа. Если действие этих операто
ров проверяется инструкцией if или другими инструкциями, они бу
дут иметь ожидаемый результат (не забывайте, что каждый объект мо
жет интерпретироваться как истина или как ложь), но это не будут
простые значения True или False.
В случае оператора or интерпретатор начинает вычислять значения
объектовоперандов слева направо и возвращает первый, имеющий ис
тинное значение. Кроме того, интерпретатор прекратит дальнейшие
вычисления, как только будет найден первый объект, имеющий ис
тинное значение. Это обычно называют вычислением по короткой схе+
ме, так как конечный результат становится известен еще до вычисле
ния остальной части выражения:
>>> 2 or 3, 3 or 2 # Вернет левый операнд, если он имеет истинное значение
(2, 3) # Иначе вернет правый операнд (истинный или ложный)
>>> [ ] or 3
3
>>> [ ] or { }
{ }
В первой строке предыдущего примера оба операнда (2 и 3) имеют ис
тинные (т. е. ненулевые) значения, поэтому интерпретатор всегда бу
Проверка истинности 325
дет останавливать вычисления и возвращать операнд слева. В других
двух операциях левый операнд имеет ложное значение (пустой объ
ект), поэтому интерпретатор просто вычисляет и возвращает объект
справа (который может иметь как истинное, так и ложное значение).
Вычисление оператора and также останавливается, как только резуль
тат станет известен, однако в этом случае интерпретатор вычисляет
операнды слева направо и возвращает первый объект, имеющий лож+
ное значение:
>>> 2 and 3, 3 and 2 # Вернет левый операнд, если он имеет ложное значение
(3, 2) # Иначе вернет правый операнд (истинный или ложный)
>>> [ ] and { }
[ ]
>>> 3 and [ ]
[ ]
Здесь в первой строке оба операнда имеют истинные значения, поэто
му интерпретатор вычислит оба операнда и вернет объект справа. Во
второй проверке левый операнд имеет ложное значение ([]), поэтому
интерпретатор останавливает вычисления и возвращает его в качестве
результата проверки. В последней проверке левый операнд имеет ис
тинное значение (3), поэтому интерпретатор вычисляет и возвращает
объект справа (который имеет ложное значение []).
Конечный результат будет тот же, что и в языке C и во многих других
языках, – вы получаете значение, которое логически интерпретирует
ся как истина или ложь при использовании в инструкции if или while.
Однако в языке Python логические операторы возвращают либо ле
вый, либо правый объект, а не простое целочисленное значение.
Такое поведение операторов and и or может показаться странным на
первый взгляд, поэтому загляните во врезку «Придется держать в уме:
логические значения», где вы найдете примеры, как иногда эта осо
бенность может использоваться программистами на языке Python.
Трехместное выражение if/else
Одна из основных ролей логических операторов в языке Python заклю
чается в образовании выражений, которые выполняются так же, как
условная инструкция if. Рассмотрим следующую инструкцию, кото
рая записывает в A значение Y или Z в зависимости от истинности зна
чения X:
if X:
A = Y
else:
A = Z
Иногда, как в данном примере, элементы инструкции настолько про
сты, что кажется излишеством тратить на них четыре строки. В неко
торых случаях у нас может появиться желание вложить такую конст
326 Глава 12. Условная инструкция if
рукцию внутрь другой инструкции вместо того, чтобы выполнять при
сваивание переменной. По этим причинам (и, откровенно говоря, пото
му что в языке C имеется похожая возможность1) в версии Python 2.5
появилась новая конструкция, позволяющая записать те же действия
в виде единственного выражения:
A = Y if X else Z
Данное выражение дает тот же результат, что и предыдущая инструк
ция if, но выглядит она проще. Как и в предыдущей инструкции, ин
терпретатор выполняет выражение Y, только если проверка if X дает
истинное значение, а выражение Z выполняется, только если проверка
if X дает ложное значение. То есть вычисления здесь также выполня
ются по сокращенной схеме. Ниже приводятся несколько примеров
выражения в действии:
>>> A = 't' if 'spam' else 'f' # Непустая строка – это истина
>>> A
't'
>>> A = 't' if '' else 'f'
>>> A
'f'
До версии Python 2.5 (да и после) тот же эффект можно было получить
за счет комбинирования операторов and и or благодаря тому, что они
возвращают объект слева или справа:
A = ((X and Y) or Z)
Этот прием работает, но он скрывает в себе ловушку – он предполага
ет, что Y будет иметь истинное значение. В этом случае эффект будет
тот же самый: оператор and выполнится первым и вернет Y, если X име
ет истинное значение. В противном случае оператор or просто вернет Z.
Другими словами, мы получаем: «if X then Y else Z».
Эта комбинация операторов and/or требует некоторого времени, чтобы
осознать ее при первом знакомстве, но, начиная с версии 2.5, надоб
ность в таком приеме отпала, так как существует более наглядная кон
струкция Y if X else Z, которую можно использовать в качестве выра
жения. Если же составляющие достаточно сложны, лучше использо
вать полноценную инструкцию if.
В качестве дополнительного примечания: в языке Python следующее
выражение дает похожий эффект – благодаря тому, что функция bool
1 В действительности, порядок следования операндов в выражении X if Y
else Z в языке Python несколько отличается от выражения Y ? X : Z в язы
ке C. Такой порядок был выбран в соответствии с анализом наиболее рас
пространенных шаблонов программирования в языке Python, а также от
части, чтобы помочь бывшим программистам на языке C избавиться от
привычки злоупотреблять этим выражением. Не забывайте, что в языке
Python исповедуется принцип – чем проще, тем лучше.
Проверка истинности 327
преобразует X в соответствующее целое число 1 или 0, которое затем
используется для выбора требуемого значения из списка:
A = [Z, Y][bool(X)]
Придется держать в уме: логические значения
В языке Python часто используется прием выбора одного объек
та из множества, основанный на необычном поведении логиче
ских операторов. Следующая инструкция:
X = A or B or C or None
присвоит переменной X первый непустой (имеющий истинное
значение) объект из множества объектов A, B и C или None, если
все эти объекты окажутся пустыми. Этот прием стал возможен
благодаря тому, что оператор or возвращает один из двух объек
тов и, как оказывается, это весьма распространенная парадигма
программирования на языке Python: чтобы выбрать непустой
объект из фиксированного множества, достаточно просто объ
единить их в выражение с помощью оператора or.
Также важно осознать, как выполняются вычисления по сокра
щенной схеме, потому что справа от логического оператора мо
жет находиться функция, выполняющая важную работу или
оказывающая побочное влияние, вызов которой не произойдет
изза действия правила вычисления по сокращенной схеме:
if f1() or f2(): ...
В данном случае, если функция f1 вернет истинное (или непус
тое) значение, интерпретатор никогда не вызовет функцию f2.
Чтобы гарантировать вызов обеих функций, можно вызвать их
до применения оператора or:
tmp1, tmp2 = f1(), f2()
if tmp1 or tmp2: ...
Вы уже видели другой вариант использования такого поведе
ния: благодаря особенностям работы логических операторов вы
ражение ((A and B) or C) может использоваться для имитации
инструкции if/else.
Кроме того, обратите внимание: вследствие того, что все объекты
могут расцениваться как истинные или ложные значения, в язы
ке Python легко и просто выполнить проверку объекта напрямую
(if X:) вместо того, чтобы сравнивать его с пустым значением
(if X != '':). В случае строк эти две проверки равнозначны.
328 Глава 12. Условная инструкция if
Например:
>>> ['f', 't'][bool('')]
'f'
>>> ['f', 't'][bool('spam')]
't'
Однако это далеко не то же самое, потому что в данном случае интер
претатор не использует сокращенную схему вычисления – он всегда
будет вычислять оба значения Z и Y независимо от значения X. Изза
всех этих сложностей лучше использовать более простое и более по
нятное выражение if/else, появившееся в версии Python 2.5. Кроме
того, этим выражением не следует злоупотреблять и следует использо
вать его, только если части выражения достаточно просты, в против
ном случае лучше использовать обычную инструкцию if, что облегчит
модификацию программного кода в будущем. Ваши коллеги будут
благодарны вам за это.
Однако вы попрежнему можете встретить конструкцию на основе
комбинации and/or в программном коде, написанном до появления
версии Python 2.5 (и в программном коде, написанном программиста
ми, использовавшими язык C, и не сумевшими избавиться от про
шлых привычек).
В заключение
В этой главе мы познакомились с инструкцией if языка Python. Так
как это была первая составная инструкция на нашем пути, мы попут
но рассмотрели общие синтаксические правила языка Python и побли
же познакомились с операциями проверки истинности. Кроме того,
мы также узнали, как в языке Python реализуется множественное
ветвление, и изучили форму выражений if/else, которая впервые по
явилась в версии Python 2.5.
В следующей главе мы продолжим изучение процедурных инструк
ций и рассмотрим циклы while и for. Там будет рассказано об альтер
нативных способах программирования циклов в языке Python, каж
дый из которых имеет свои преимущества. Но перед этим вас ждут
обычные контрольные вопросы главы.
Закрепление пройденного
Контрольные вопросы
1. Как в языке Python можно оформить множественное ветвление?
2. Как в языке Python можно оформить инструкцию if/else в виде вы
ражения?
3. Как можно разместить одну инструкцию в нескольких строках?
Закрепление пройденного 329
4. Что означают слова True и False?
Ответы
1. Самый простой, хотя и не самый краткий способ организации мно
жественного ветвления заключается в использовании инструкции
if с несколькими частями elif. Нередко того же результата можно
добиться с помощью операции индексации в словаре, особенно если
учесть, что словари могут содержать функции, созданные с помо
щью инструкций def или выражений lambda.
2. В версии Python 2.5 выражение Y if X else Z возвращает Y, если X
имеет истинное значение, или Z – в противном случае. Это выраже
ние эквивалентно инструкции if из четырех строк. Комбинация
операторов and/or ((X and Y) or Z) может действовать точно так же,
но она менее понятна и требует, чтобы часть Y имела истинное зна
чение.
3. Обернув инструкцию синтаксически уместной парой скобок ((), [],
или {}), можно расположить ее на нескольких строках – инструк
ция будет считаться законченной, когда интерпретатор обнаружит
правую закрывающую скобку.
4. True и False – это всего лишь версии целых чисел 1 и 0, соответствен
но. В языке Python они обозначают истинные и ложные значения.
13
Циклы while и for
В этой главе мы встретимся с двумя основными конструкциями орга
низации циклов в языке Python – инструкциями, которые выполняют
одну и ту же последовательность действий снова и снова. Первая из
них, инструкция while, обеспечивает способ организации универсаль
ных циклов; вторая, инструкция for, предназначена для обхода эле
ментов в последовательностях и выполнения блока программного кода
для каждого из них.
В языке Python существуют и другие способы организации циклов, но
две инструкции, которые описываются здесь, являются основными
синтаксическими элементами, предоставляющими возможность про
граммирования повторяющихся действий. Кроме того, мы попутно
рассмотрим необычные инструкции (такие как break и continue), пото
му что они используются внутри циклов. Дополнительно в этой главе
мы исследуем родственные концепции протокола итераций в языке
Python и рассмотрим некоторые подробности о генераторах списков –
близких родственниках цикла for.
Циклы while
Инструкция while является самой универсальной конструкцией орга
низации итераций в языке Python. Проще говоря, она продолжает вы
полнять блок инструкций (обычно с отступами) до тех пор, пока услов
ное выражение продолжает возвращать истину. Она называется «цик
лом», потому что управление циклически возвращается к началу ин
струкции, пока условное выражение не вернет ложное значение. Как
только в результате проверки будет получено ложное значение, управ
ление будет передано первой инструкции, расположенной сразу же за
вложенным блоком тела цикла while. В результате тело цикла продол
жает выполняться снова и снова, пока условное выражение возвраща
Циклы while 331
ет истинное выражение, а если условное выражение сразу вернет лож
ное значение, тело цикла никогда не будет выполнено.
Как я только что заметил, инструкция while – это одна из двух инст
рукций циклов в языке Python, кроме нее существует еще инструкция
for. Помимо этих инструкций в языке Python существует несколько
способов неявной организации циклов (итераций): функции map, reduce
и filter; оператор in проверки на вхождение; генераторы списков
и многие другие. Некоторые из них мы рассмотрим в главе 17, потому
что они имеют отношение к функциям.
Общий формат
В своей наиболее сложной форме инструкция while состоит из строки
заголовка с условным выражением, тела цикла, содержащего одну
или более инструкций с отступами, и необязательной части else, кото
рая выполняется, когда управление передается за пределы цикла без
использования инструкции break. Интерпретатор продолжает вычис
лять условное выражение в строке заголовка и выполнять вложенные
инструкции в теле цикла, пока условное выражение не вернет ложное
значение:
while <test>: # Условное выражение test
<statements1> # Тело цикла
else: # Необязательная часть else
<statements2> # Выполняется, если выход из цикла производится
# не инструкцией break
Примеры
Для иллюстрации рассмотрим несколько простых циклов while в дейст
вии. Первый, который содержит инструкцию print, вложенную в цикл
while, просто выводит сообщение до бесконечности. Не забывайте, что
True – это всего лишь особая версия целого числа 1, и оно обозначает
истинное значение, поэтому результатом этого условного выражения
всегда будет истина и интерпретатор бесконечно будет выполнять тело
цикла, пока вы не прервете его выполнение. Такие циклы обычно на
зываются бесконечными:
>>> while True:
... print 'Type Ctrl
C to stop me!'
Следующий фрагмент продолжает вырезать из строки первый символ,
пока она не опустеет и в результате не превратится в ложное значение.
Это обычная практика – проверка истинности объектов осуществляется
непосредственно вместо использования более растянутого эквивалента
(while x != '':). Далее в этой главе мы рассмотрим другие способы обхо
да элементов строки с помощью цикла for. Обратите внимание на за
вершающий символ запятой в инструкции print – как рассказывалось
в главе 11, такой прием обеспечивает вывод значений в одну строку:
332 Глава 13. Циклы while и for
>>> x = 'spam'
>>> while x: # Пока x не пустая строка
... print x,
... x = x[1:] # Вырезать первый символ из x
...
spam pam am m
Следующий фрагмент перебирает значения от a до b, не включая зна
чение b. Ниже мы рассмотрим более простой способ выполнения этих
же действий с помощью цикла for и встроенной функции range:
>>> a=0; b=10
>>> while a < b: # Один из способов организации циклов перечисления
... print a, # 0r, a = a + 1
... a += 1
...
0 1 2 3 4 5 6 7 8 9
Наконец, обратите внимание, что в языке Python отсутствует цикл
«do until», имеющийся в других языках программирования. Однако
его можно имитировать, добавив в конец тела цикла условную инст
рукцию и инструкцию break:
while True:
...тело цикла...
if exitTest( ): break
Чтобы окончательно понять, как эта структура работает, нам необхо
димо перейти к следующему разделу и поближе познакомиться с инст
рукцией break.
break, continue, pass и else
Теперь, когда мы познакомились с несколькими циклами в действии,
настало время обратить внимание на две простые инструкции, кото
рые могут использоваться только внутри циклов – инструкции break
и continue. Раз уж мы занялись изучением необычных инструкций, за
одно рассмотрим здесь часть else, потому что она некоторым образом
связана с инструкцией break, и заодно пустую инструкциюзаполни
тель pass.
break
Производит переход за пределы объемлющего цикла (всей инструк
ции цикла).
continue
Производит переход в начало цикла (в строку заголовка).
pass
Ничего не делает: это пустая инструкция, используемая как запол
нитель.
break, continue, pass и else 333
Блок else
Выполняется, только если цикл завершился обычным образом (без
использования инструкции break).
Общий формат цикла
С учетом инструкций break и continue цикл while в общем виде выгля
дит, как показано ниже:
while <test1>:
<statements1>
if <test2>: break # Выйти из цикла, пропустив часть else
if <test3>: continue # Перейти в начало цикла, к выражению test1
else:
<statements2> # Выполняется, если не была использована
# инструкция 'break'
Инструкции break и continue могут появляться в любом месте внутри
тела цикла while (или for), но как правило, они используются в услов
ных инструкциях if, чтобы выполнить необходимое действие в ответ
на некоторое условие.
Примеры
Обратимся к нескольким простым примерам, чтобы увидеть, как эти
инструкции используются на практике.
pass
Инструкция pass не выполняет никаких действий и используется в слу
чаях, когда синтаксис языка требует наличия инструкции, но ника
ких полезных действий в этой точке программы выполнить нельзя.
Она часто используется в качестве пустого тела составной инструкции.
Например, если потребуется создать бесконечный цикл, который ни
чего не делает, сделать это можно будет следующим образом:
while 1: pass # Нажмите CtrlC, чтобы прервать цикл!
Поскольку тело цикла – это всего лишь пустая инструкция, интерпре
татор «застрянет» в этом цикле. Грубо говоря, pass в мире инструкций –
это то же, что None в мире объектов – явное ничто. Обратите внимание,
что тело этого цикла while находится в той же строке, что и заголовок,
после двоеточия. Как и в случае с инструкцией if, такой прием можно
использовать только в случае, когда тело цикла образует несоставная
инструкция.
Этот пример вечно делает «ничто». Вероятно это самая бесполезная
программа (если только вы не хотите погреться у своего ноутбука в хо
лодный зимний день!), которая когдалибо была написана на языке
Python, и, тем не менее, я не смог придумать лучший пример примене
ния инструкции pass. Далее мы увидим, где эта инструкция может ис
пользоваться с большим смыслом, например, для определения пустых
334 Глава 13. Циклы while и for
классов, реализующих объекты, которые ведут себя подобно структу
рам и записям в других языках. Иногда инструкция pass используется
как заполнитель, вместо того, «что будет написано позднее», и в каче
стве временного фиктивного тела функций:
def func1():
pass # Настоящий программный код будет добавлен позже
def func2():
pass
continue
Инструкция continue вызывает немедленный переход в начало цикла.
Она иногда позволяет избежать использования вложенных инструк
ций. В следующем примере инструкция используется для пропуска не
четных чисел. Этот фрагмент выводит четные числа меньше 10 и боль
ше или равные 0. Вспомним, что число 0 означает ложь, а оператор %
вычисляет остаток от деления, поэтому данный цикл выводит числа
в обратном порядке, пропуская значения, не кратные 2 (он выводит
8 6 4 2 0):
x = 10
while x:
x = x1 # Или, x = 1
if x % 2 != 0: continue # Нечетное? – пропустить вывод
print x,
Так как инструкция continue выполняет переход в начало цикла, нам
не потребовалось вкладывать инструкцию print в инструкцию if – она
будет задействована, только если инструкция continue не будет выпол
нена. Если она напоминает вам инструкцию «goto», имеющуюся в дру
гих языках, то это справедливо. В языке Python нет инструкции goto,
но так как инструкция continue позволяет выполнять переходы внутри
программы, большинство замечаний, касающихся удобочитаемости
и простоты сопровождения, которые вы могли слышать в отношении
инструкции goto, применимы и к инструкции continue. Не злоупотреб
ляйте использованием этой инструкции, особенно когда вы только на
чинаете работать с языком Python. Например, последний пример вы
глядел бы понятнее, если бы инструкция print была вложена в инст
рукцию if:
x = 10
while x:
x = x1
if x % 2 == 0: # Четное?  вывести
print x,
break
Инструкция break вызывает немедленный выход из цикла. Так как
программный код, следующий в цикле за этой инструкцией, не вы
break, continue, pass и else 335
полняется, если эта инструкция запущена, то ее также можно исполь
зовать, чтобы избежать вложения. Например, ниже приводится про
стой интерактивный цикл (вариант более крупного примера, рассмат
ривавшегося в главе 10), где производится ввод данных с помощью
функции raw_input и выход из цикла, если в ответ на запрос имени бу
дет введена строка «stop»:
>>> while 1:
... name = raw_input('Enter name:')
... if name == 'stop': break
... age = raw_input('Enter age: ')
... print 'Hello', name, '=>', int(age) ** 2
...
Enter name:mel
Enter age: 40
Hello mel => 1600
Enter name:bob
Enter age: 30
Hello bob => 900
Enter name:stop
Обратите внимание, как в этом примере выполняется преобразование
строки age в целое число с помощью функции int, перед тем как воз
вести его во вторую степень. Как вы помните, это совершенно необхо
димо, потому что функция raw_input возвращает ввод пользователя
в виде строки. В главе 29 вы увидите, что функция raw_input также воз
буждает исключение при получении символа конца файла (например,
когда пользователь нажимает комбинацию клавиш CtrlZ или CtrlD).
Если это может иметь влияние, оберните вызов функции инструкцией
try.
else
При объединении с частью else инструкция break часто позволяет из
бавиться от необходимости сохранять флаг состояния поиска, как это
делается в других языках программирования. Например, следующий
фрагмент определяет, является ли положительное целое число y про
стым числом, выполняя поиск делителей больше 1:
x = y / 2 # Для значений y > 1
while x > 1:
if y % x == 0: # Остаток
print y, 'has factor', x
break # Перешагнуть блок else
x = x1
else: # Нормальное завершение цикла
print y, 'is prime'
Вместо того чтобы устанавливать флаг, который будет проверен по окон
чании цикла, достаточно вставить инструкцию break в месте, где будет
найден делитель. При такой реализации в блоке else цикла, который
336 Глава 13. Циклы while и for
будет выполнен, только если инструкция break не была запущена,
можно с уверенностью сказать, что число является простым.1
Блок else цикла выполняется также в том случае, когда тело цикла ни
разу не выполнялось, поскольку в этой ситуации инструкция break так
же не выполняется. В циклах while это происходит, когда первая же
проверка условия в заголовке дает ложное значение. Вследствие этого
в предыдущем примере будет получено сообщение «is prime» (простое
число), если изначально x меньше или равно 1 (т. е., когда y равно 2).
Еще о блоке else в цикле
Так как блок else в цикле является уникальной особенностью языка
Python, он нередко становится источником недопонимания для тех,
кто только начинает осваивать его. В общих чертах, блок else в циклах
обеспечивает явный синтаксис представления распространенной си
туации – эта программная структура позволяет обработать «другой»
способ выхода из цикла, без необходимости устанавливать и прове
рять флаги или условия.
Предположим, например, что вы создаете цикл поиска некоторого зна
чения в списке и после выхода из цикла вам необходимо узнать, было
ли найдено значение. Эту задачу можно решить следующим способом:
found = False
while x and not found:
if match(x[0]): # Искомое значение является первым?
print 'Ni'
found = True
else:
x = x[1:] # Вырезать первое значение и повторить
if not found:
print 'not found'
Здесь мы инициализируем, устанавливаем и проверяем флаг, чтобы
определить, увенчался поиск успехом или нет. Это вполне корректный
программный код для языка Python, и он работает, однако это именно
тот случай, когда можно использовать блок else в цикле. Ниже приво
дится эквивалентный фрагмент:
while x: # Выйти, когда x опустеет
if match(x[0]):
1 Более или менее. Числа, меньшие 2, не считаются простыми в соответствии
со строгим математическим определением. Если быть более точным, этот
программный код также будет терпеть неудачу при отрицательных значе
ниях и при использовании чисел с плавающей точкой, и в будущем утратит
работоспособность изза грядущих изменений в поведении оператора /, ко
торый будет выполнять операцию «истинного деления», как описано в гла
ве 5. Если вы захотите поэкспериментировать с этим фрагментом, загляните
в упражнения к четвертой части книги, где этот пример обернут в функцию.
Циклы for 337
print 'Ni'
break # Выход, в обход блока else
x = x[1:]
else:
print 'Not found' # Этот блок отработает, только если строка x исчерпана
Эта версия более компактна. Нам удалось избавиться от флага и заме
нить инструкцию if за циклом на блок else (по вертикали находится
на одной линии со словом while). Так как выход из цикла while по инст
рукции break минует блок else, его можно рассматривать как более
удобный способ обработки случая неудачного поиска.
Некоторые из вас могли бы заметить, что в предыдущем примере блок
else можно заменить проверкой строки x после выхода из цикла (напри
мер, if not x:). Для данного примера это вполне возможно, но часть else
обеспечивает явный синтаксис реализации этого шаблона программи
рования (здесь – это более очевидный блок обработки ситуации неудач
ного поиска), и кроме того, подобная проверка не всегда возможна.
Часть else в циклах становится еще более полезной, когда используется
в сочетании с инструкцией цикла for – темой следующего раздела, пото
му что обход последовательностей выполняется неподконтрольно вам.
Циклы for
Цикл for является универсальным итератором последовательностей
в языке Python: он может выполнять обход элементов в любых упоря
доченных объектах последовательностей. Инструкция for способна ра
ботать со строками, списками, кортежами, с другими встроенными объ
ектами, поддерживающими возможность выполнения итераций, и с но
выми объектами, которые создаются с помощью классов, как будет по
казано позже.
Общий формат
Циклы for в языке Python начинаются со строки заголовка, где указы
вается переменная для присваивания (или – цель), а также объект, об
ход которого будет выполнен. Вслед за заголовком следует блок
(обычно с отступами) инструкций, которые требуется выполнить:
for <target> in <object>: # Связывает элементы объекта с переменной цикла
<statements> # Повторяющееся тело цикла: использует переменную цикла
else:
<statements> # Если не попали на инструкцию 'break'
Когда интерпретатор выполняет цикл for, он поочередно, один за дру
гим, присваивает элементы объекта последовательности переменной
цикла и выполняет тело цикла для каждого из них. Для обращения
к текущему элементу последовательности в теле цикла обычно ис
пользуется переменная цикла, как если бы это был курсор, шагающий
от элемента к элементу.
338 Глава 13. Циклы while и for
Имя, используемое в качестве переменной цикла (возможно, новой),
которое указывается в заголовке цикла for, обычно находится в облас
ти видимости, где располагается сама инструкция for. О ней почти не
чего сказать; хотя она может быть изменена в теле цикла, тем не менее,
ей автоматически будет присвоен следующий элемент последователь
ности, когда управление вернется в начало цикла. После выхода из
цикла эта переменная обычно все еще ссылается на последний элемент
последовательности, если цикл не был завершен инструкцией break.
Инструкция for также поддерживает необязательную часть else, кото
рая работает точно так же, как и в циклах while, – она выполняется, ес
ли выход из цикла производится не инструкцией break (т. е., если в цик
ле был выполнен обход всех элементов последовательности). Инструк
ции break и continue, представленные выше, в циклах for работают точ
но так же, как и в циклах while. Полная форма цикла for имеет
следующий вид:
for <target> in <object>: # Связывает элементы объекта с переменной цикла
<statements>
if <test>: break # Выход из цикла, минуя блок else
if <test>: continue # Переход в начало цикла
else:
<statements> # Если не была вызвана инструкция 'break'
Придется держать в уме:
имитация циклов while языка C
В разделе главы 11, где рассматривались инструкции выраже
ний, утверждалось, что язык Python не предусматривает воз
можность выполнять присваивание там, где ожидается выраже
ние. Это означает, что следующий, широко используемый шаб
лон программирования языка C неприменим в языке Python:
while ((x = next( )) != NULL) {...обработка x...}
Операции присваивания в языке C возвращают присвоенное зна
чение, но в языке Python присваивание – это всего лишь инст
рукция, а не выражение. Благодаря этому ликвидируется об
ширный класс ошибок, свойственных языку C (в языке Python
невозможно по ошибке оставить знак = там, где подразумевается
==). Но в случае необходимости в циклах while языка Python по
добное поведение можно реализовать как минимум тремя спосо
бами, без встраивания инструкции присваивания в условное вы
ражение. Операцию присваивания можно переместить в тело
цикла вместе с инструкцией break:
Циклы for 339
Примеры
Рассмотрим несколько интерактивных циклов for, чтобы вы могли
увидеть, как они используются на практике.
Типичные варианты использования
Как упоминалось ранее, цикл for может выполнять обход элементов
в любых объектах последовательностей. В нашем первом примере, на
пример, мы поочередно, слева направо, присвоим переменной x каж
дый из трех элементов списка и выведем каждый из них с помощью
инструкции print. Внутри инструкции print (в теле цикла), имя x ссы
лается на текущий элемент списка:
>>> for x in ["spam", "eggs", "ham"]:
... print x,
...
spam eggs ham
Как отмечалось в главе 11, завершающая запятая в инструкции print
подавляет вывод символа конца строки, в результате все элементы вы
водятся в одной строке.
while True:
x = next()
if not x: break
...обработка x...
или вместе с инструкцией if:
x = 1
while x:
x = next()
if x:
...обработка x...
или вынести первое присваивание за пределы цикла:
x = next()
while x:
...обработка x...
x = next()
Из этих трех вариантов первый, как могут полагать некоторые, –
наименее структурированный, но он же представляется наибо
лее простым и наиболее часто используемым. (Простейший цикл
for в языке Python также может заменить некоторые циклы
языка C.)
340 Глава 13. Циклы while и for
В следующих двух примерах вычисляется сумма и произведение всех
элементов в списке. В этой главе и далее в книге мы познакомимся
с инструментами, которые применяют такие операции, как + и *,
к элементам списка автоматически, но обычно для этого используется
цикл for:
>>> sum = 0
>>> for x in [1, 2, 3, 4]:
... sum = sum + x
...
>>> sum
10
>>> prod = 1
>>> for item in [1, 2, 3, 4]: prod *= item
...
>>> prod
24
Другие типы данных
Цикл for, будучи универсальным инструментом, может применяться
к любым последовательностям. Например, цикл for может применять
ся к строкам и кортежам:
>>> S = "lumberjack"
>>> T = ("and", "I'm", "okay")
>>> for x in S: print x, # Обход строки
...
l u m b e r j a c k
>>> for x in T: print x, # Обход элементов кортежа
...
and I'm okay
Фактически, как будет показано чуть ниже, циклы for могут приме
няться даже к объектам, которые вообще не являются последователь
ностями!
Присваивание кортежа в цикле for
Если выполнить обход последовательности кортежей, переменная
цикла сама фактически будет кортежем. Это лишь еще один случай
операции присваивания кортежа. Не забывайте, что инструкция цик
ла for присваивает элементы объекта последовательности переменной
цикла, а операция присваивания везде выполняется одинаково:
>>> T = [(1, 2), (3, 4), (5, 6)]
>>> for (a, b) in T: # Операция присваивания кортежа в действии
... print a, b
...
1 2
3 4
5 6
Циклы for 341
Здесь первый проход цикла действует сходно инструкции (a, b) = (1, 2),
второй проход – инструкции (a, b) = (3, 4) и т. д. Это не какойто осо
бый случай – синтаксически после слова for выполняется присваива
ние переменной цикла любого вида.
Вложенные циклы for
Теперь рассмотрим нечто более сложное. Следующий пример иллюст
рирует использование блока else в цикле for и вложенные инструк
ции. Имея список объектов (items) и список ключей (tests), этот фраг
мент пытается отыскать каждый ключ в списке объектов и сообщает
о результатах поиска:
>>> items = ["aaa", 111, (4, 5), 2.01] # Множество объектов
>>> tests = [(4, 5), 3.14] # Ключи, которые требуется отыскать
>>>
>>> for key in tests: # Для всех ключей
... for item in items: # Для всех элементов
... if item == key: # Проверить совпадение
... print key, "was found"
... break
... else:
... print key, "not found!"
...
(4, 5) was found
3.14 not found!
Поскольку вложенная инструкция if вызывает инструкцию break, ко
гда совпадение обнаружено, то можно утверждать, что блок else будет
выполняться только в случае, когда поиск завершится неудачей. Об
ратите внимание на вложение инструкций. Если запустить этот фраг
мент, одновременно будут выполняться два цикла: внешний цикл бу
дет выполнять обход списка ключей, а внутренний будет выполнять
обход списка элементов в поисках каждого ключа. Уровень вложенно
сти блока else имеет большое значение – он находится на уровне стро
ки заголовка внутреннего цикла for, поэтому он соответствует внут
реннему циклу (не инструкции if и не внешнему циклу for).
Примечательно, что этот пример можно упростить, если использовать
оператор in для проверки вхождения ключа. Поскольку оператор in
неявно выполняет обход списка в поисках совпадения, он заменяет со
бой внутренний цикл:
>>> for key in tests: # Для всех ключей
... if key in items: # Позволить интерпретатору отыскать совпадение
... print key, "was found"
... else:
... print key, "not found!"
...
(4, 5) was found
3.14 not found!
342 Глава 13. Циклы while и for
Вообще, ради компактности кода и скорости вычислений всегда пра
вильнее будет переложить на плечи интерпретатора как можно боль
ше работы, как это сделано в данном примере.
Следующий пример с помощью цикла for решает типичную задачу об
работки данных – выборка одинаковых элементов из двух последова
тельностей (из строк). Это достаточно простая задача поиска пересече
ния двух множеств. После того как цикл for выполнится, переменная
res будет ссылаться на список, содержащий все одинаковые элементы,
обнаруженные в seq1 и seq2:
>>> seq1 = "spam"
>>> seq2 = "scam"
>>>
>>> res = [] # Изначально список пуст
>>> for x in seq1: # Выполнить обход первой последовательности
... if x in seq2: # Общий элемент?
... res.append(x) # Добавить в конец результата
...
>>> res
['s', 'a', 'm']
К сожалению, этот фрагмент работает только с двумя определенными
переменными: seq1 и seq2. Было бы замечательно, если бы этот цикл
можно было привести к более универсальному виду, тогда его можно
было бы использовать многократно. Эта простая идея ведет нас к функ
циям, теме следующей части книги.
Итераторы: первое знакомство
В предыдущем разделе упоминалось, что цикл for может работать с по
следовательностями любого типа в языке Python, включая списки,
кортежи и строки, например:
>>> for x in [1, 2, 3, 4]: print x ** 2,
...
1 4 9 16
>>> for x in (1, 2, 3, 4): print x ** 3,
...
1 8 27 64
>>> for x in 'spam': print x * 2,
...
ss pp aa mm
Фактически цикл for имеет еще более универсальную природу, чем
было показано, – он способен работать с любыми объектами, поддержи
вающими возможность выполнения итераций. На самом деле это вер
но для всех средств выполнения итераций, которые выполняют скани
рование объектов слева направо, включая циклы for, генераторы спи
сков, оператор in проверки на вхождение и встроенную функцию map.
Итераторы: первое знакомство 343
Понятие «итерируемого объекта» является относительно новым в язы
ке Python. По существу оно является обобщением понятия последова
тельности – объект считается итерируемым либо если он физически
является последовательностью, либо если он является объектом, кото
рый воспроизводит по одному результату за раз в контексте инстру
ментов выполнения итераций, таких как цикл for. В некотором смыс
ле в категорию итерируемых объектов входят как физические после
Придется держать в уме: сканирование файлов
Вообще циклы удобно использовать везде, где необходимо повтор
но выполнять некоторые действия или многократно обрабатывать
данные. Файлы содержат множество символов и строк, поэтому
они могут рассматриваться как один из типичных объектов при
менения циклов. Чтобы просто загрузить содержимое файла
в строку одной инструкцией, достаточно вызвать метод read:
file = open('test.txt', 'r')
print file.read()
Но для загрузки файла по частям обычно используется либо
цикл while, завершающийся инструкцией break по достижении
конца файла, либо цикл for. Чтобы выполнить посимвольное
чтение, достаточно любого из следующих фрагментов:
file = open('test.txt')
while True:
char = file.read(1) # Читать по одному символу
if not char: break
print char,
for char in open('test.txt').read():
print char
Здесь цикл for выполняет обработку каждого отдельного симво
ла, но загрузка содержимого файла в память производится одно
кратно. Чтение строками или блоками с помощью цикла while
можно реализовать следующим образом:
file = open('test.txt')
while True:
line = file.readline() # Читать строку за строкой
if not line: break
print line,
file = open('test.txt', 'rb')
while True:
chunk = file.read(10) # Читать блоками по 10 байтов
if not chunk: break
print chunk,
344 Глава 13. Циклы while и for
довательности, так и последовательности виртуальные, которые вы
числяются по требованию.
Итераторы файлов
Один из самых простых способов понять, что такое итераторы, – это
посмотреть, как они работают со встроенными типами, такими как
файлы. Напомню, что объекты открытых файлов имеют метод с име
нем readline, который читает по одной строке текста из файла за одно
обращение – каждый раз, вызывая метод readline, мы перемещаемся
к следуюшей строке. По достижении конца файла возвращается пус
тая строка, что может служить сигналом для выхода из цикла:
>>> f = open('script1.py')
>>> f.readline()
'import sys\n'
>>> f.readline()
'print sys.path\n'
>>> f.readline()
'x = 2\n'
>>> f.readline()
'print 2 ** 33\n'
>>> f.readline()
''
Однако при использовании цикла for реализация построчного
чтения выглядит проще и работает быстрее:
for line in open('test.txt').readlines():
print line
for line in open('test.txt').xreadlines():
print line
for line in open('test.txt'):
print line
Функция readlines загружает файл целиком в список строк, то
гда как функция xreadlines загружает очередную строку по тре
бованию, благодаря чему исключается вероятность переполне
ния памяти при попытке загрузить большой файл. Последний
пример основан на использовании файлового итератора, кото
рый является эквивалентом использования функции xreadlines
(итераторы будут рассматриваться в следующем разделе). Имя
open во всех примерах выше можно также заменить именем file,
начиная с версии Python 2.2. Более подробную информацию
о методах, использованных здесь, вы найдете в руководстве по
библиотеке. Как правило, чем больше данных читается на каж
дом шаге, тем быстрее работает ваша программа.
Итераторы: первое знакомство 345
Теперь файлы имеют также метод next, который производит практиче
ски тот же эффект – всякий раз, когда его вызывают, он возвращает
следующую строку. Единственное значимое различие состоит в том,
что по достижении конца файла метод next возбуждает встроенное ис
ключение StopIteration вместо того, чтобы возвращать пустую строку:
>>> f = open('script1.py')
>>> f.next()
'import sys\n'
>>> f.next()
'print sys.path\n'
>>> f.next()
'x = 2\n'
>>> f.next()
'print 2 ** 33\n'
>>> f.next()
Traceback (most recent call last):
File "<pyshell#330>", line 1, in <module>
f.next()
StopIteration
Такое поведение в точности соответствует тому, что мы в языке Python
называем итерационным протоколом, – объект реализует метод next,
который возбуждает исключение StopIteration в конце серии результа
тов. Любой такой объект в языке Python считается итерируемым. Лю
бой такой объект доступен для сканирования с помощью цикла for
или других итерационных инструментов, потому что все инструменты
выполнения итераций вызывают метод next в каждой итерации и опре
деляют момент выхода по исключению StopIteration.
Следствие всего вышесказанного: лучший способ построчного чтения
текстового файла, как уже упоминалось в главе 9, состоит не в том,
чтобы прочитать его целиком, а в том, чтобы позволить циклу for авто
матически вызывать метод next для перемещения к следующей строке
в каждой итерации. Например, следующий фрагмент читает содержи
мое файла строку за строкой (попутно приводит символы к верхнему
регистру и выводит их) без явного обращения к методам файла:
>>> for line in open('script1.py'): # Использовать итератор файла
... print line.upper(),
...
IMPORT SYS
PRINT SYS.PATH
X = 2
PRINT 2 ** 33
Такой способ построчного чтения текстовых файлов считается луч
шим по трем причинам: программный код выглядит проще, он выпол
няется быстрее и более экономно использует память. Более старый
способ достижения того же эффекта с помощью цикла for состоит
в том, чтобы вызвать метод readlines для загрузки содержимого файла
в память в виде списка строк:
346 Глава 13. Циклы while и for
>>> for line in open('script1.py').readlines():
... print line.upper(),
...
IMPORT SYS
PRINT SYS.PATH
X = 2
PRINT 2 ** 33
Способ, основанный на использовании метода readlines, попрежнему
может использоваться, но на сегодня он проигрывает изза подхода
к использованию памяти. Изза того что в этом случае файл загружа
ется целиком, этот способ не позволит работать с файлами, слишком
большими, чтобы поместиться в память компьютера. При этом вер
сия, основанная на применении итераторов, не подвержена таким про
блемам с памятью, так как содержимое файла считывается по одной
строке за раз. Более того, итераторы были существенно оптимизирова
ны, поэтому способ на базе итераторов должен иметь более высокую
производительность.
Как упоминалось во врезке «Придется держать в уме: сканирование
файлов», существует возможность построчного чтения файлов с помо
щью цикла while:
>>> f = open('script1.py')
>>> while True:
... line = f.readline()
... if not line: break
... print line.upper(),
...
...вывод тот же самый...
Однако такой вариант наверняка будет работать медленнее версии, ос
нованной на использовании итератора в цикле for, потому что итера
торы внутри интерпретатора выполняются со скоростью, присущей
программам, написанным на языке C, тогда как версия на базе цикла
while работает со скоростью интерпретации байткода виртуальной ма
шиной Python. Всякий раз, когда код на языке Python подменяется
кодом на языке C, скорость его выполнения увеличивается.
Другие итераторы встроенных типов
С технической точки зрения итерационный протокол имеет еще одну
сторону. В самом начале цикл for получает итератор из итерируемого
объекта, передавая его встроенной функции iter, которая возвращает
объект, имеющий требуемый метод next. Это станет более очевидным,
если посмотреть на то, как внутренние механизмы циклов for обраба
тывают такие встроенные типы последовательностей, как списки:
>>> L = [1, 2, 3]
>>> I = iter(L) # Получить объектитератор
>>> I.next() # Вызвать next, чтобы перейти к следующему элементу
Итераторы: первое знакомство 347
1
>>> I.next()
2
>>> I.next()
3
>>> I.next()
Traceback (most recent call last):
File "<pyshell#343>", line 1, in <module>
I.next()
StopIteration
Кроме файлов и фактических последовательностей, таких как списки,
удобные итераторы также имеют и другие типы. Классический способ
выполнить обход всех ключей словаря, например, состоит в том, что
бы явно запросить список ключей:
>>> D = {'a':1, 'b':2, 'c':3}
>>> for key in D.keys():
... print key, D[key]
...
a 1
c 3
b 2
В последних версиях Python вообще не обязательно использовать ме
тод keys – словари имеют итератор, который автоматически возвраща
ет по одному ключу за раз в контексте итераций, поэтому больше не
требуется создавать в памяти сразу полный список ключей. В резуль
тате применения этого итератора скорость выполнения возрастает, па
мять используется экономнее, а программный код выглядит проще:
>>> for key in D:
... print key, D[key]
...
a 1
c 3
b 2
Другие контексты итераций
До настоящего момента я демонстрировал итераторы в контексте ин
струкции цикла for, которая является одной из основных обсуждае
мых тем этой главы. Однако, имейте в виду, что каждый инструмент,
который выполняет обход объектов слева направо, использует итера
ционный протокол. В число этих инструментов входят и циклы for,
как уже было показано выше:
>>> for line in open('script1.py'): # Использовать итератор файла
... print line.upper(),
...
IMPORT SYS
PRINT SYS.PATH
348 Глава 13. Циклы while и for
X = 2
PRINT 2 ** 33
Генераторы списков, оператор in, встроенная функция map и другие
встроенные средства, такие как функции sorted и sum, также основаны
на применении итерационного протокола:
>>> uppers = [line.upper() for line in open('script1.py')]
>>> uppers
['IMPORT SYS\n', 'PRINT SYS.PATH\n', 'X = 2\n', 'PRINT 2 ** 33\n']
>>> map(str.upper, open('script1.py'))
['IMPORT SYS\n', 'PRINT SYS.PATH\n', 'X = 2\n', 'PRINT 2 ** 33\n']
>>> 'y = 2\n' in open('script1.py')
False
>>> 'x = 2\n' in open('script1.py')
True
>>> sorted(open('script1.py'))
['import sys\n', 'print 2 ** 33\n', 'print sys.path\n', 'x = 2\n']
Используемая здесь функция map, которую мы будем рассматривать
в следующей части книги, представляет собой инструмент, вызываю
щий заданную функцию для каждого элемента итерируемого объекта,
напоминая тем самым генераторы списков, хотя и с ограниченными
возможностями, потому что ей можно передать только функцию и нель
зя указать произвольное выражение. Так как генераторы списков свя
заны с циклами for, мы займемся их исследованием ниже в этой главе,
а затем еще раз вернемся к ним в следующей части книги.
Функцию sorted, задействованную здесь, мы уже видели в работе в гла
ве 4. Функция sorted – это относительно новая встроенная функция,
которая использует итерационный протокол, – она напоминает метод
списка sort, но в качестве результата возвращает новый отсортирован
ный список и способна работать с любым итерируемым объектом. Су
ществуют и другие, более новые встроенные функции, поддерживаю
щие итерационный протокол. Например, функция sum вычисляет сум
му всех чисел в любом итерируемом объекте, а встроенные функции
any и all возвращают True, если любой (any) или все (all) элементы ите
рируемого объекта являются истинными значениями, соответственно:
>>> sorted([3, 2, 4, 1, 5, 0]) # Другие контексты итераций
[0, 1, 2, 3, 4, 5]
>>> sum([3, 2, 4, 1, 5, 0])
15
>>> any(['spam', '', 'ni'])
True
>>> all(['spam', '', 'ni'])
False
Интересно, что область влияния итерационного протокола в языке Py
thon в настоящее время гораздо шире, чем было продемонстрировано
Приемы программирования циклов 349
в примерах – любые встроенные инструменты в языке Python, которые
выполняют обход объектов слева направо, по определению используют
итерационный протокол при работе с объектами. Сюда относятся даже
такие замысловатые инструменты, как встроенные функции list и tuple
(которые создают новые объекты из итерируемых объектов), строковый
метод join (который вставляет подстроку между строками, содержащи
мися в итерируемом объекте) и даже операция присваивания последова
тельностей. Благодаря этому все они могут применяться к открытому
файлу и автоматически выполнять чтение по одной строке за раз:
>>> list(open('script1.py'))
['import sys\n', 'print sys.path\n', 'x = 2\n', 'print 2 ** 33\n']
>>> tuple(open('script1.py'))
('import sys\n', 'print sys.path\n', 'x = 2\n', 'print 2 ** 33\n')
>>> '&&'.join(open('script1.py'))
'import sys\n&&print sys.path\n&&x = 2\n&&print 2 ** 33\n'
>>> a, b, c, d = open('script1.py')
>>> a, d
('import sys\n', 'print 2 ** 33\n')
Итераторы, определяемые пользователем
Итераторы мы еще будем рассматривать в главе 17, вместе с функция
ми, и в главе 24, когда будем изучать классы. Как будет показано позд
нее, существует возможность превратить пользовательскую функцию
в итерируемый объект с помощью инструкции yield. Генераторы спи
сков также поддерживают протокол с помощью выраженийгенерато
ров, а пользовательские классы можно сделать итерируемыми за счет
методов перегрузки операторов __iter__ и __getitem__. Итераторы,
определяемые пользователем, позволяют использовать любые объек
ты и операции в любом из итерационных контекстов, с которыми мы
встретились здесь.
Приемы программирования циклов
Цикл for относится к категории счетных циклов. Обычно он выглядит
проще и работает быстрее, чем цикл while, поэтому его нужно рассмат
ривать в самую первую очередь, когда возникает необходимость выпол
нить обход последовательности. Однако существуют такие ситуации,
когда необходимо выполнять обход какимто особенным способом. На
пример, как быть, когда необходимо выполнить обход каждого второго
или каждого третьего элемента в списке, или попутно выполнить изме
нения в списке? Или когда необходимо реализовать параллельный об
ход более чем одной последовательности в одном и том же цикле for?
Такие уникальные ситуации всегда можно запрограммировать с помо
щью цикла while и извлечения элементов вручную, но Python предос
350 Глава 13. Циклы while и for
тавляет две встроенные возможности, позволяющие управлять обхо
дом элементов в цикле for:
• Встроенная функция range возвращает список последовательно уве
личивающихся целых чисел, которые можно использовать в каче
стве индексов внутри цикла for.1
• Встроенная функция zip возвращает список кортежей, составлен
ных из элементов входных списков с одинаковыми индексами, ко
торый может использоваться для одновременного обхода несколь
ких последовательностей в цикле for.
Обычно циклы for выполняются быстрее, чем аналогичные им счет
ные циклы на базе инструкции while, поэтому везде, где только воз
можно, лучше пользоваться такими инструментами, которые позво
лят использовать цикл for. Рассмотрим каждый из этих встроенных
инструментов по очереди.
Счетные циклы: while и range
Функция range является понастоящему универсальным инструмен
том, который может использоваться в самых разных ситуациях. Чаще
всего она используется для генерации индексов в цикле for, но вы мо
жете использовать ее везде, где необходимы списки целых чисел:
>>> range(5), range(2, 5), range(0, 10, 2)
([0, 1, 2, 3, 4], [2, 3, 4], [0, 2, 4, 6, 8])
Функция range с одним аргументом генерирует список целых чисел
в диапазоне от нуля до указанного в аргументе значения, не включая
его. Если функции передать два аргумента, первый будет рассматри
ваться как нижняя граница диапазона. Необязательный третий аргу
мент определяет шаг – в этом случае интерпретатор будет добавлять
величину шага при вычислении каждого последующего значения (по
умолчанию шаг равен 1). Существует возможность воспроизводить по
следовательности чисел в диапазоне отрицательных значений и в по
рядке убывания:
>>> range(
5, 5)
[5, 4, 3, 2, 1, 0, 1, 2, 3, 4]
1 Современные версии Python предоставляют также встроенную функцию
xrange, которая генерирует индексы по одному вместо того, чтобы создавать
их сразу все и сохранять в списке, как это делает функция range. Функция
xrange не дает никакого преимущества в скорости, но она удобна в смысле
экономии памяти, если приходится генерировать огромное число значе
ний. На момент написания этих строк ходят слухи, что в версии Python 3.0
функция xrange исчезнет, а функция range будет преобразована в объектге
нератор, поддерживающий итерационный протокол для воспроизведения
одного элемента за раз. Дополнительную информацию вы найдете в приме
чаниях к выпуску Python 3.0.
Приемы программирования циклов 351
>>> range(5, 
5, 
1)
[5, 4, 3, 2, 1, 0, 1, 2, 3, 4]
Такое использование функции range само по себе может быть полезным,
однако чаще всего она используется в циклах for. Прежде всего она
обеспечивает простой способ повторить действие определенное число
раз. Например, чтобы вывести три строки, можно использовать функ
цию range для создания соответствующего количества целых чисел:
>>> for i in range(3):
... print i, 'Pythons'
...
0 Pythons
1 Pythons
2 Pythons
Функция range также часто используется для косвенного обхода после
довательностей. Самый простой и самый быстрый способ выполнить
обход последовательности заключается в использовании цикла for,
когда основную работу выполняет интерпретатор :
>>> X = 'spam'
>>> for item in X: print item, # Простейший цикл
...
s p a m
При таком использовании все задачи, касающиеся выполнения итера
ций, решаются внутренними механизмами цикла for. Если вам дейст
вительно необходимо явно управлять логикой доступа к элементам,
вы можете использовать цикл while:
>>> i = 0
>>> while i < len(X): # Обход с помощью цикла while
... print X[i],; i += 1
...
s p a m
Однако управлять индексами вручную можно и в цикле for, если ис
пользовать функцию range для воспроизведения списка индексов:
>>> X
'spam'
>>> len(X) # Длина строки
4
>>> range(len(X)) # Все допустимые смещения в X
[0, 1, 2, 3]
>>>
>>> for i in range(len(X)): print X[i], # Извлечение элементов вручную
...
s p a m
В этом примере выполняется обход списка смещений в строке X, а не
фактических элементов строки – нам пришлось внутри цикла обра
щаться к строке X, чтобы извлечь каждый элемент.
352 Глава 13. Циклы while и for
Обход части последовательности: range
Последний пример в предыдущем разделе вполне работоспособен, но
он выполняется гораздо медленнее, чем мог бы. Кроме того, нам при
шлось выполнить больше работы, чем требуется для решения такой
задачи. Если вы не предъявляете особых требований к индексам, все
гда лучше использовать простейшую форму цикла for – используйте
цикл for вместо while везде, где только возможно, и используйте функ
цию range в циклах for, только если это действительно необходимо.
Следующее простое решение является лучшим:
>>> for item in X: print item, # Простейшая итерация
...
Однако прием, представленный в предшествующем примере, позволя
ет нам управлять порядком обхода последовательности, например
пропускать элементы:
>>> S = 'abcdefghijk'
>>> range(0, len(S), 2)
[0, 2, 4, 6, 8, 10]
>>> for i in range(0, len(S), 2): print S[i],
...
a c e g i k
Здесь в цикле выбирается каждый второй элемент строки S при обходе
списка значений, сгенерированных функцией range. Чтобы извлечь ка
ждый третий элемент, достаточно изменить третий аргумент функции
range, передав в нем значение 3, и т. д. Таким образом, функция range
позволяет пропускать элементы, сохраняя при этом простоту цикла for.
Однако на сегодняшний день это, пожалуй, не самый лучший способ.
Если вам действительно необходимо пропустить элементы последова
тельности, можно использовать расширенную форму операции извле
чения среза с тремя пределами, представленную в главе 7, которая
обеспечивает более простой путь к достижению цели. Чтобы получить
каждый второй символ из строки S, можно извлечь срез с шагом 2:
>>> for x in S[::2]: print x
...
Изменение списков: range
Еще одно место, где можно использовать комбинацию функции range
и цикла for, – это циклы, изменяющие список в процессе его обхода.
Например, предположим, что по тем или иным причинам нам необхо
димо прибавить 1 к каждому элементу списка. Можно попытаться ис
пользовать для этой цели простейшую форму цикла for, но скорее все
го это не то, что нам нужно:
>>> L = [1, 2, 3, 4, 5]
Приемы программирования циклов 353
>>> for x in L:
... x += 1
...
>>> L
[1, 2, 3, 4, 5]
>>> x
6
Такое решение вообще ничего не дает – здесь изменяется переменная
цикла x, а не список L. Причину такого поведения трудно заметить.
Всякий раз, когда цикл выполняет очередную итерацию, переменная
x ссылается на очередное целое число, которое уже было извлечено из
списка. В первой итерации, например, переменная x является целым
числом 1. На следующей итерации в переменную x будет записана
ссылка на другой объект – целое число 2, но это никак не повлияет на
список, откуда было взято число 1.
Чтобы действительно изменить список во время его обхода, нам необ
ходимо использовать операцию присваивания по индексу и изменить
значения во всех позициях, по которым осуществляется цикл. Необ
ходимые нам индексы можно воспроизвести с помощью комбинации
функций range/len:
>>> L = [1, 2, 3, 4, 5]
>>> for i in range(len(L)): # Прибавить 1 к каждому элементу в списке L
... L[i] += 1 # Or L[i] = L[i] + 1
...
>>> L
[2, 3, 4, 5, 6]
При такой реализации список изменяется в процессе обхода. Простой
цикл for x in L: такого результата дать не может, потому что в таком
цикле выполняется обход фактических элементов, а не позиций в спи
ске. А возможно ли создать эквивалентный цикл while? Для этого нам
потребуется приложить немного больше усилий, и такой цикл навер
няка будет работать медленнее:
>>> i = 0
>>> while i < len(L):
... L[i] += 1
... i += 1
...
>>> L
[3, 4, 5, 6, 7]
В данном случае решение на базе функции range может быть неидеаль
ным. Генератор списка в виде [x+1 for x in L] также даст желаемый ре
зультат, но первоначальный список при этом не изменится (мы могли
бы присвоить получившийся новый список обратно переменной L, но
это выражение не изменит другие ссылки на первоначальный список).
Поскольку эта концепция циклов занимает такое важное положение,
354 Глава 13. Циклы while и for
мы еще раз вернемся к ней, когда будем рассматривать генераторы спи
сков ниже в этой главе.
Параллельный обход: zip и map
Как было показано выше, встроенная функция range позволяет выпол
нять обход отдельных частей последовательностей. В том же духе
встроенная функция zip позволяет использовать цикл for для обхода
нескольких последовательностей параллельно. Функция zip принима
ет одну или несколько последовательностей в качестве аргументов
и возвращает список кортежей, составленных из соответствующих
элементов этих последовательностей. Например, предположим, что
мы выполняем обработку двух списков:
>>> L1 = [1,2,3,4]
>>> L2 = [5,6,7,8]
Для объединения элементов этих списков можно использовать функ
цию zip, которая создаст список кортежей из пар элементов:
>>> zip(L1,L2)
[(1, 5), (2, 6), (3, 7), (4, 8)]
Такой результат может пригодиться в самых разных ситуациях, но
применительно к циклу for он обеспечивает возможность выполнения
параллельных итераций:
>>> for (x, y) in zip(L1, L2):
... print x, y, '

', x+y
...
1 5  6
2 6  8
3 7  10
4 8 – 12
Здесь выполняется обход результата обращения к функции zip, т. е.
пар, составленных из элементов двух списков. Обратите внимание, что
в этом цикле используется операция присваивания кортежей для по
лучения элементов каждого кортежа, полученного от функции zip. На
первой итерации она будет выглядеть, как если бы была выполнена
инструкция (x, y) = (1, 5).
Благодаря этому мы можем сканировать оба списка L1 и L2 в одном
цикле. Тот же эффект можно получить с помощью цикла while, в кото
ром доступ к элементам производится вручную, но такой цикл будет
сложнее в реализации и наверняка медленнее, чем прием, основанный
на использовании for/zip.
Функция zip на самом деле более универсальна, чем можно было бы
представить на основе этого фрагмента. Например, она принимает по
следовательности любого типа (в действительности – любые итерируе
мые объекты, включая и файлы) и позволяет указывать более двух ар
гументов:
Приемы программирования циклов 355
>>> T1, T2, T3 = (1,2,3), (4,5,6), (7,8,9)
>>> T3
(7, 8, 9)
>>> zip(T1,T2,T3)
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
Длина списка, возвращаемого функцией zip, равна длине кратчайшей
из последовательностей, если аргументы имеют разную длину:
>>> S1 = 'abc'
>>> S2 = 'xyz123'
>>>
>>> zip(S1, S2)
[('a', 'x'), ('b', 'y'), ('c', 'z')]
Родственная (и более старая) встроенная функция map объединяет эле
менты последовательностей похожим образом, но она дополняет не
достающие элементы значениями None, если аргументы имеют разную
длину:
>>> map(None, S1, S2)
[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None,'3')]
В этом примере фактически используется простейшая форма обраще
ния к встроенной функции map. Обычно она принимает функцию и од
ну или более последовательностей и собирает результаты вызова функ
ции с соответствующими элементами, извлеченными из последова
тельностей.
Когда в первом аргументе передается значение None (как в данном слу
чае), она просто объединяет элементы подобно функции zip. Функция
map и прочие родственные ей инструменты будут рассматриваться в гла
ве 17.
Конструирование словаря с помощью функции zip
В главе 8 я говорил, что функцию zip, используемую здесь, удобно при
менять для создания словарей, когда ключи и значения вычисляются
во время выполнения программы. Теперь, когда мы поближе познако
мились с этой функцией, я объясню, какое отношение она имеет к кон
струированию словарей. Как вы уже знаете, словарь всегда можно соз
дать с помощью литерала словаря или присваивая значения ключам:
>>> D1 = {'spam':1, 'eggs':3, 'toast':5}
>>> D1
{'toast': 5, 'eggs': 3, 'spam': 1}
>>> D1 = {}
>>> D1['spam'] = 1
>>> D1['eggs'] = 3
>>> D1['toast'] = 5
Но как быть, если программа получает ключи и значения для словаря
в виде списков во время выполнения, уже после того, как сценарий
356 Глава 13. Циклы while и for
был написан? Например, предположим, что имеются следующие спи
ски ключей и значений:
>>> keys = ['spam', 'eggs', 'toast']
>>> vals = [1, 3, 5]
Один из способов превратить их в словарь состоит в том, чтобы пере
дать списки функции zip и затем выполнить обход полученного ре
зультата в цикле for:
>>> zip(keys, vals)
[('spam', 1), ('eggs', 3), ('toast', 5)]
>>> D2 = {}
>>> for (k, v) in zip(keys, vals): D2[k] = v
...
>>> D2
{'toast': 5, 'eggs': 3, 'spam': 1}
Однако, начиная с версии Python 2.2, можно обойтись без цикла for
и просто передать результат вызова функции zip встроенному конст
руктору dict:
>>> keys = ['spam', 'eggs', 'toast']
>>> vals = [1, 3, 5]
>>> D3 = dict(zip(keys, vals))
>>> D3
{'toast': 5, 'eggs': 3, 'spam': 1}
Встроенное имя dict в языке Python в действительности является име
нем типа (больше об именах типов и о создании подтипов вы узнаете
в главе 26). Этот вызов производит преобразование списка в словарь,
но в действительности это вызов конструктора объекта. Далее в этой
главе мы рассмотрим родственное, но более широкое понятие генера+
торов списков, которые позволяют создавать списки с помощью един
ственного выражения.
Генерирование индексов и элементов: enumerate
Ранее мы рассматривали использование функции range для генерации
индексов (смещений) элементов в строке вместо получения самих эле
ментов с этими индексами. Однако в некоторых программах необходи
мо получить и то, и другое: и элемент, и его индекс. При традицион
ном подходе можно было бы использовать простой цикл for, в котором
вести счетчик текущего индекса:
>>> S = 'spam'
>>> offset = 0
>>> for item in S:
... print item, 'appears at offset', offset
... offset += 1
...
s appears at offset 0
Генераторы списков: первое знакомство 357
p appears at offset 1
a appears at offset 2
m appears at offset 3
Этот способ вполне работоспособен, но в последних версиях языка Py
thon те же самые действия можно выполнить с помощью встроенной
функции с именем enumerate:
>>> S = 'spam'
>>> for (offset, item) in enumerate(S):
... print item, 'appears at offset', offset
...
s appears at offset 0
p appears at offset 1
a appears at offset 2
m appears at offset 3
Функция enumerate возвращает объект+генератор – разновидность
объекта, который поддерживает итерационный протокол, с которым
мы встретились выше в этой главе и более подробно будем осуждать
в следующей части книги. Он имеет метод next, возвращающий кор
теж (index, value) для каждого элемента списка, который мы можем
использовать для присваивания кортежей в цикле for (точно так же,
как и в случае с функцией zip):
>>> E = enumerate(S)
>>> E.next()
(0, 's')
>>> E.next()
(1, 'p')
Обычно мы не видим всю эту механику, потому что во всех контекстах
итераций (включая генераторы списков – тема следующего раздела)
итерационный протокол выполняется автоматически:
>>> [c * i for (i, c) in enumerate(S)]
['', 'p', 'aa', 'mmm']
Генераторы списков: первое знакомство
В предыдущем разделе мы узнали о возможности использовать функ
цию range для изменения списков в ходе выполнения итераций:
>>> L = [1, 2, 3, 4, 5]
>>> for i in range(len(L)):
... L[i] += 10
...
>>> L
[11, 12, 13, 14, 15]
Этот способ работает, но, как я уже упоминал, он может быть далеко
не самым оптимальным в языке Python. В наши дни выражения гене
раторы списков переводят многое из того, что использовалось раньше,
358 Глава 13. Циклы while и for
в разряд устаревших приемов. Например, в следующем фрагменте
цикл был заменен единственным выражением, которое в результате
воспроизводит требуемый список:
>>> L = [x + 10 for x in L]
>>> L
[21, 22, 23, 24, 25]
Конечный результат получается тем же самым, но от нас потребова
лось меньше усилий и, скорее всего, этот вариант работает быстрее.
Выражения генераторов списков нельзя считать равнозначной заме
ной инструкции цикла for, потому что они создают новые объекты
списков (что может иметь значение при наличии нескольких ссылок
на первоначальный список), но это подходящая замена для большин
ства применений, к тому же распространенная и достаточно удобная,
чтобы заслужить внимательного изучения здесь.
Основы генераторов списков
Впервые с генераторами списков мы встретились в главе 4. Синтаксис
генераторов списков происходит от конструкций, используемых в тео
рии множеств для описания операций над каждым элементом множе
ства, но вам совсем необязательно знать теорию множеств, чтобы ис
пользовать их. Многие считают, что генераторы списков в языке Py
thon напоминают цикл for, записанный задом наперед.
Давайте рассмотрим пример из предыдущего раздела более подробно.
Генераторы списков записываются в квадратных скобках, потому что
это, в конечном счете, способ создания нового списка. Генератор спи
ска начинается с некоторого составленного нами выражения, которое
использует введенную нами переменную цикла (x + 10). Далее следует
то, что вы без труда опознаете как заголовок цикла for, в котором объ
является переменная цикла и итерируемый объект (for x in L).
Чтобы найти значение выражения, Python выполняет обход списка L,
присваивая переменной x каждый очередной элемент, и собирает ре
зультаты пропускания всех элементов через выражение слева. Полу
ченный в результате список является точным отражением того, что
«говорит» генератор списков, – новый список, содержащий x+10 для
каждого x в L.
С технической точки зрения всегда можно обойтись без генераторов
списков, потому что существует возможность создавать список резуль
татов выражения вручную, с помощью цикла for:
>>> res = []
>>> for x in L:
... res.append(x + 10)
...
>>> res
[21, 22, 23, 24, 25]
Генераторы списков: первое знакомство 359
Фактически это точное представление внутреннего механизма генера
тора списков.
Но генераторы списков записываются компактнее, и данный способ
сборки списков получил широкое распространение в языке Python,
поэтому они оказываются очень удобными во многих ситуациях. Бо
лее того, генераторы списков могут выполняться значительно быстрее
(зачастую почти в два раза), чем инструкции циклов for, потому что
итерации выполняются со скоростью языка C, а не со скоростью про
граммного кода на языке Python. Такое преимущество в скорости осо
бенно важно для больших объемов данных.
Использование генераторов списков
для работы с файлами
Рассмотрим еще один распространенный случай использования гене
раторов списков, исследуя в деталях их работу. Вспомним, что у объ
екта файла имеется метод readlines, который загружает файл целиком
в список строк:
>>> f = open('script1.py')
>>> lines = f.readlines()
>>> lines
['import sys\n', 'print sys.path\n', 'x = 2\n', 'print 2 ** 33\n']
Этот фрагмент работает, но все строки в списке оканчиваются симво
лом новой строки (\n). Символ новой строки является препятствием
для многих программ – приходится быть осторожным, чтобы избе
жать появления пустых строк при выводе и т. д. Было бы совсем не
плохо, если бы мы могли одним махом избавиться от этих символов
новой строки.
Всякий раз, когда мы заговариваем о выполнении операций над каж
дым элементом последовательности, мы попадаем в сферу действий ге
нераторов списков. Например, предположим, что переменная lines на
ходится в том же состоянии, в каком она была оставлена в предыду
щем примере. Тогда следующий фрагмент обработает каждую строку
в списке функцией rstrip, чтобы удалить завершающие пробельные
символы (также можно было бы использовать выражение извлечения
среза line[:1], но только если бы мы были абсолютно уверены, что все
строки завершаются символом новой строки):
>>> lines = [line.rstrip() for line in lines]
>>> lines
['import sys', 'print sys.path', 'x = 2', 'print 2 ** 33']
Этот метод работает, генераторы списков – это другой итерационный
контекст, но точно так же, как и в простом цикле for, нам не требуется
даже открывать файл заранее. Если открыть его внутри выражения,
генератор списков автоматически будет использовать итерационный
протокол, с которым мы познакомились выше в этой главе. То есть он
360 Глава 13. Циклы while и for
будет читать из файла по одной строке за раз – вызовом метода next
файла, пропускать строку через функцию rstrip и добавлять результат
в список. И снова мы получаем именно то, что запрашиваем, – резуль
тат работы метода rstrip для каждой строки в файле:
>>> lines = [line.rstrip() for line in open('script1.py')]
>>> lines
['import sys', 'print sys.path', 'x = 2', 'print 2 ** 33']
Это выражение значительную часть работы выполняет неявно – ин
терпретатор сканирует файл и автоматически собирает список резуль
татов выполнения операции. Кроме того, это наиболее эффективный
способ, потому что большая часть действий выполняется внутри ин
терпретатора Python, который работает наверняка быстрее, чем экви
валентная инструкция for. Напомню еще раз, что при работе с боль
шими файлами выигрыш в скорости от применения генераторов спи
сков может оказаться весьма существенным.
Синтаксис расширенного генератора списков
В действительности генераторы списков могут иметь еще более слож
ный вид. Например, в цикл for, вложенный в выражение, можно доба
вить оператор if для отбора результатов, для которых условное выра
жение дает истинное значение.
Например, предположим, что нам требуется повторить предыдущий
пример, но при этом необходимо отобрать только строки, начинаю
щиеся с символа p (возможно, первый символ в каждой строке – код
действия некоторого вида). Достичь поставленной цели можно, если
добавить фильтрующий оператор if:
>>> lines = [line.rstrip() for line in open('script1.py') if line[0] == 'p']
>>> lines
['print sys.path', 'print 2 ** 33']
В этом примере оператор if проверяет, является ли первый символ
в строке символом p. Если это не так, строка не включается в список
результатов. Это достаточно длинное выражение, но его легко понять,
если преобразовать в эквивалентный простой цикл for (вообще любой
генератор списков можно перевести в эквивалентную реализацию на
базе инструкции for, добавляя отступы к каждой последующей части):
>>> res = []
>>> for line in open('script1.py'):
... if line[0] == 'p':
... res.append(line.rstrip())
...
>>> res
['print sys.path', 'print 2 ** 33']
Эта инструкция for выполняет эквивалентные действия, но занимает
четыре строки вместо одной и работает существенно медленнее.
В заключение 361
В случае необходимости генераторы списков могут иметь еще более
сложный вид. Например, они могут содержать вложенные циклы,
оформленные в виде серии операторов for. На самом деле полный син
таксис допускает указывать любое число операторов for, каждый из
которых может иметь ассоциированный с ним оператор if (подробнее
о синтаксисе генераторов выражений рассказывается в главе 17).
Например, следующий фрагмент создает список результатов операции
конкатенации x+y для всех x в одной строке и для всех y – в другой.
В результате получаются сочетания символов в двух строках:
>>> [x + y for x in 'abc' for y in 'lmn']
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
Чтобы проще было понять это выражение, его также можно преобра
зовать в форму инструкции, добавляя отступы к каждой последующей
части. Следующий фрагмент представляет собой эквивалентную, но
более медленную реализацию:
>>> res = []
>>> for x in 'abc':
... for y in 'lmn':
... res.append(x + y)
...
>>> res
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
Даже с повышением уровня сложности выражения генераторов спи
сков могут иметь очень компактный вид. Вообще они предназначены
для реализации простых итераций – для реализации сложных дейст
вий более простая инструкция for наверняка будет проще и для пони
мания, и для изменения в будущем. Обычно, если чтото в программи
ровании для вас оказывается слишком сложным, возможно это не са
мое лучшее решение.
Мы еще вернемся к итераторам и генераторам списков в главе 17, где
будем рассматривать их в контексте функций, где вы увидите, что они
связаны с функциями не менее тесно, чем с инструкциями циклов.
В заключение
В этой главе мы исследовали инструкции циклов языка Python, а так
же некоторые концепции, имеющие отношение к циклам. Мы рас
смотрели инструкции while и for во всех подробностях и узнали о свя
занных с ними блоках else. Мы также изучили инструкции break
и continue, которые могут использоваться только внутри циклов.
Дополнительно мы познакомились с итерационным протоколом в язы
ке Python, обеспечивающим возможность выполнять итерации по объ
ектам, не являющимся последовательностями, и с генераторами спи
сков. Как было показано, генераторы списков, применяющие заданные
362 Глава 13. Циклы while и for
выражения ко всем элементам любого итерируемого объекта, напоми
нают циклы for.
Эта глава завершает наш обзор процедурных инструкций. Следующая
глава, завершающая эту часть книги, обсуждает возможности доку
ментирования программного кода на языке Python. Документация
также является частью синтаксической модели, и кроме того, она яв
ляется важным компонентом хорошо написанных программ. В сле
дующей главе мы также рассмотрим ряд упражнений к этой части
книги, прежде чем перенесем свое внимание к более крупным структу
рам, таким как функции. Однако, как обычно, прежде чем двинуться
дальше, попробуйте ответить на контрольные вопросы.
Закрепление пройденного
Контрольные вопросы
1. Когда выполняется блок else в циклах?
2. Как в языке Python можно запрограммировать счетный цикл?
3. Как взаимосвязаны циклы for и итераторы?
4. Как взаимосвязаны циклы for и генераторы списков?
5. Назовите четыре разных контекста итераций в языке Python.
6. Какой способ построчного чтения содержимого файлов считается
наиболее оптимальным?
7. Какое оружие вы ожидали бы увидеть в руках испанской инквизи
ции?
Ответы
1. Блок else в циклах while или for выполняется один раз после выхо
да из цикла при условии, что цикл завершается обычным образом
(без использования инструкции break). Инструкция break осуществ
ляет немедленный выход из цикла и пропускает блок else (если та
ковой присутствует).
2. Счетные циклы могут быть реализованы на базе инструкции while
при условии, что вычисление индексов будет производиться вруч
ную, или на базе инструкции for, которая использует встроенную
функцию range для генерирования последовательности целых чи
сел. Ни один из этих способов не является предпочтительным в язы
ке Python; если вам необходимо просто обойти все элементы в по
следовательности, везде, где только возможно, используйте про
стой цикл for, без функции range или счетчиков. Такая реализация
и выглядит проще, и обычно работает быстрее.
3. Цикл for использует итерационный протокол для обхода элементов
объекта. На каждой итерации он вызывает метод next объекта и пе
Закрепление пройденного 363
рехватывает исключение StopIteration, по которому определяет мо
мент окончания итераций.
4. Оба они являются инструментами итераций. Генераторы списков
представляют простой и эффективный способ выполнения задачи,
типичной для циклов for: сбор результатов применения выражения
ко всем элементам итерируемого объекта. Генераторы списков всегда
можно преобразовать в цикл for, а кроме того, генераторы списков
по своему внешнему виду напоминают заголовок инструкции for.
5. В число итерационных контекстов языка Python входят: цикл for,
генераторы списков, встроенная функция map, оператор in проверки
вхождения, а также встроенные функции sorted, sum, any и all. В эту
категорию также входят встроенные функции list и tuple, строко
вый метод join и операции присваивания последовательностей – все
они следуют итерационному протоколу (метод next) для обхода ите
рируемых объектов.
6. Рекомендуемый в настоящее время способ чтения строк из тексто
вого файла – не читать файл явно вообще. Вместо этого предлагает
ся открыть файл в итерационном контексте, например в цикле for
или в генераторе списков, и позволить итерационному инструменту
на каждой итерации автоматически извлекать по одной строке из
файла с помощью метода next. Такой подход считается более опти
мальным в смысле простоты программирования, скорости выпол
нения и использования памяти.
7. Любой из следующих вариантов я приму как правильный ответ:
устрашение, шантаж, хорошие красные униформы, удобная ку
шетка и мягкие подушки.
14
Документация
Эта глава завершает третью часть книги изучением приемов и инстру
ментов, используемых для документирования программного кода на
языке Python. Несмотря на то, что программный код Python изначаль
но обладает высокой удобочитаемостью, некоторый объем уместно
расположенных, внятных комментариев может существенно облег
чить другим людям понимание принципа действия ваших программ.
Язык Python включает синтаксические конструкции и инструменты,
облегчающие документирование программ.
Эта тема в большей степени связана с инструментальными средствами
и, тем не менее, она рассматривается здесь, отчасти потому что она
имеет некоторое отношение к синтаксической модели языка Python,
а отчасти как источник сведений для тех, кто изо всех сил пытается
понять возможности языка Python. Преследуя эту последнюю цель,
я дополню указания о документировании, которые были даны в главе 4.
Как обычно, эта глава завершается предупреждениями о наиболее час
то встречающихся ловушках, контрольными вопросами к главе и уп
ражнениями к этой части книги.
Источники документации в языке Python
К настоящему моменту вы уже наверняка начинаете понимать, что
Python изначально включает в себя удивительно широкие функцио
нальные возможности – встроенные функции и исключения, предо
пределенные атрибуты и методы объектов, модули стандартной биб
лиотеки и многое другое. Более того, на самом деле мы лишь слегка
коснулись каждой из этих категорий.
Один из первых вопросов, который часто задают удивленные новички:
«Как мне найти информацию обо всех встроенных возможностях?».
Источники документации в языке Python 365
Этот раздел рассказывает о различных источниках документации,
доступных в языке Python. Здесь также будут представлены строки
документирования (docstrings) и система PyDoc, которая использует
их. Эти темы мало связаны с самим языком программирования, но
они будут иметь большое значение, как только вы подойдете к приме
рам и упражнениям в этой части книги.
Как показано в табл. 14.1, существует множество мест, где можно оты
скать информацию о Python, и объем этой информации все увеличива
ется. Поскольку документация играет важную роль в практическом
программировании, мы исследуем каждую из этих категорий в сле
дующих разделах.
Таблица 14.1. Источники документации в языке Python
Комментарии #
Комментарии, начинающиеся с символа решетки, представляют собой
самый элементарный способ документирования программного кода.
Интерпретатор просто игнорирует весь текст, который следует за сим
волом # (при условии, что он находится не внутри строкового литера
ла), поэтому вы можете помещать вслед за этими символами слова
и описания, предназначенные для программистов. Впрочем, такие ком
ментарии доступны только в файлах с исходными текстами – для за
писи комментариев, которые будут доступны более широко, следует
использовать строки документирования.
В настоящее время считается, что строки документирования лучше
подходят для создания функционального описания (например, «мой
файл делает тото и тото»), а комментарии, начинающиеся с символа
#, лучше подходят для описания некоторых особенностей программ
ного кода (например, «это странное выражение делает тото и тото»).
О строках документирования мы поговорим чуть ниже.
Форма Назначение
Комментарии # Документация внутри файла
Функция dir Получение списка атрибутов объектов
Строки документирования:
__doc__
Документация внутри файла, присоединяе
мая к объектам
PyDoc: функция help Интерактивная справка по объектам
PyDoc: отчеты в формате HTML Документация к модулям для просмотра
в броузере
Стандартный набор руководств Официальное описание языка и библиотеки
Вебресурсы Интерактивные учебные руководства, при
меры и т. д.
Печатные издания Руководства, распространяемые на коммер
ческой основе
366 Глава 14. Документация
Функция dir
Функция dir – это простой способ получить список всех атрибутов объ
екта (т. е. методов и элементов данных). Она может быть вызвана для
любого объекта, который имеет атрибуты. Например, чтобы узнать,
что имеется в стандартном библиотечном модуле sys, просто импорти
руйте его и передайте имя модуля функции dir:
>>> import sys
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__',
'__stderr__', '__stdin__', '__stdout__', '_getframe', 'argv',
'builtin_module_names', 'byteorder', 'copyright', 'displayhook',
'dllhandle', 'exc_info', 'exc_type', 'excepthook',
...остальные имена опущены...]
Здесь показаны только некоторые из имен; чтобы получить полный
список, выполните эти инструкции на своей машине.
Чтобы узнать, какие атрибуты содержат объекты встроенных типов,
передайте функции dir литерал требуемого типа. Например, чтобы
увидеть атрибуты списков и строк, можно передать функции пустой
объект:
>>> dir([])
['__add__', '__class__', ...остальные имена опущены...
'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove',
'reverse', 'sort']
>>> dir('')
['__add__', '__class__', ...остальные имена опущены...
'capitalize', 'center', 'count', 'decode', 'encode', 'endswith',
'expandtabs', 'find', 'index', 'isalnum', 'isalpha', 'isdigit',
'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust',
...остальные имена опущены...]
Результаты работы функции dir для любого встроенного типа включа
ют набор атрибутов, которые имеют отношение к реализации этого ти
па (методы перегруженных операторов); все они начинаются и закан
чиваются двумя символами подчеркивания, чтобы сделать их отлич
ными от обычных имен, и вы можете пока просто игнорировать их.
Того же эффекта можно добиться, передав функции dir имя типа вме
сто литерала:
>>> dir(str) == dir('') # Результат тот же, что и в предыдущем примере
True
>>> dir(list) == dir([])
True
Такой прием работает по той простой причине, что имена функций
преобразования, такие как str и list, в языке Python фактически яв
ляются именами типов – вызов любого из этих конструкторов приво
дит к созданию экземпляра этого типа. Подробнее о конструкторах
Источники документации в языке Python 367
и о перегрузке операторов мы будем говорить в шестой части книги,
когда будем обсуждать классы.
Функция dir служит своего рода «кратким напоминанием» – она пре
доставляет список имен атрибутов, но ничего не сообщает о том, что
эти имена означают. За этой информацией необходимо обращаться
к следующему источнику документации.
Строки документирования: __doc__
Помимо комментариев, начинающихся с символа #, язык Python под
держивает возможность создания документации, которая автоматиче
ски присоединяется к объектам и доступна во время выполнения. Син
таксически такие строки располагаются в начале файлов модулей,
функций и классов, перед исполняемым программным кодом (перед
ними вполне могут располагаться комментарии #). Интерпретатор ав
томатически помещает строки документирования в атрибут __doc__ со
ответствующего объекта.
Строки документирования, определяемые пользователем
В качестве примера рассмотрим файл docstrings.py. Строки докумен
тирования в нем располагаются в самом его начале, а также в начале
функции и класса. Здесь для создания многострочных описаний фай
ла и функции я использовал строки в тройных кавычках, но допуска
ется использовать строки любого типа. Мы еще не познакомились
с инструкциями def и class, поэтому вы можете просто игнорировать
все, что находится после них, за исключением строк в самом начале:
"""
Module documentation
Words Go Here
"""
spam = 40
def square(x):
"""
function documentation
can we have your liver then?
"""
return x **2
class employee:
"class documentation"
pass
print square(4)
print square.__doc__
Самое важное в протоколе документирования заключается в том, что
ваши комментарии становятся доступны для просмотра в виде атрибу
тов __doc__ после того, как файл будет импортирован. Поэтому, чтобы
отобразить строки документирования, связанные с модулем и его объ
368 Глава 14. Документация
ектами, достаточно просто импортировать файл и вывести значения
их атрибутов __doc__, где интерпретатор сохраняет текст:
>>> import docstrings
16
function documentation
can we have your liver then?
>>> print docstrings.__doc__
Module documentation
Words Go Here
>>> print docstrings.square.__doc__
function documentation
can we have your liver then?
>>> print docstrings.employee.__doc__
class documentation
Обратите внимание, что для вывода строк документирования необходи
мо явно использовать инструкцию print, в противном случае будет выво
диться единственная строка со встроенными символами новой строки.
Кроме того, существует возможность присоединять строки документи
рования к методам классов (эта возможность описывается ниже), но
так как они представлены инструкциями def, вложенными в классы,
это не является особым случаем. Чтобы извлечь строку с описанием
метода класса, определяемого внутри модуля, необходимо указать
имя модуля, класса и метода: module.class.method.__doc__ (примеры
строк документирования методов приводятся в главе 26).
Стандарты оформления строк документирования
Не существует какогото общепринятого стандарта, который регламен
тировал бы, что должно входить в строки документирования (хотя в не
которых компаниях существуют свои внутренние стандарты). В свое
время предлагались различные шаблоны и языки разметки (например,
HTML или XML), но они не завоевали популярность в мире Python.
И, положа руку на сердце, едва ли мы дождемся появления программи
стов, которые захотят писать документацию на языке разметки HTML!
Вообще, среди программистов документация обычно отходит на зад
ний план. Если вы увидите хоть какието комментарии в файле, счи
тайте, что вам повезло. Однако я настоятельно рекомендую тщательно
документировать свой программный код – это действительно очень
важная часть хорошо написанного программного кода. Замечу, что
нет никаких стандартов на структуру строк документирования, поэто
му, если вы хотите использовать их, чувствуйте себя свободными.
Встроенные строки документирования
Как оказывается, во встроенных модулях и объектах языка Python ис
пользуется сходная методика присоединения документации – до и по
Источники документации в языке Python 369
сле списка атрибутов, возвращаемых функцией dir. Например, чтобы
увидеть удобочитаемое описание встроенного модуля, его надо импор
тировать и вывести строку __doc__:
>>> import sys
>>> print sys.__doc__
This module provides access to some objects
used or maintained by the interpreter and to
...остальной текст опущен...
Dynamic objects:
argv  command line arguments; argv[0] is the script pathname if known
path  module search path; path[0] is the script directory, else ''
modules  dictionary of loaded modules
...остальной текст опущен...
Описание функций, классов и методов внутри встроенных модулей
присоединено к их атрибутам __doc__:
>>> print sys.getrefcount.__doc__
getrefcount(object) > integer
Return the current reference count for the object.
...остальной текст опущен...
Кроме того, можно прочитать описание встроенных функций, находя
щееся в их строках документирования:
>>> print int.__doc__
int(x[, base]) > integer
Convert a string or number to an integer, if possible.
...остальной текст опущен...
>>> print open.__doc__
file(name[, mode[, buffering]]) > file object
Open a file. The mode can be 'r', 'w' or 'a' for reading
...остальной текст опущен...
Просматривая таким способом строки документирования встроенных
инструментов, вы можете получить богатый объем информации, одна
ко вам не требуется этого делать – эту информацию функция help, тема
следующего раздела, предоставляет вам автоматически.
PyDoc: функция help
Методика использования строк документирования оказалась настоль
ко удобной, что теперь в состав Python входит инструмент, который
упрощает их отображение. Стандартный инструмент PyDoc написан
на языке Python, он умеет извлекать строки документирования вместе
с информацией о структуре программных компонентов и формировать
из них удобно отформатированные отчеты различных типов.
Существуют различные способы запуска PyDoc, включая сценарий ко
мандной строки (за дополнительной информацией обращайтесь к ру
370 Глава 14. Документация
ководству по библиотеке Python). Два, пожалуй, самых заметных ин
терфейса к PyDoc – это встроенная функция help и графический интер
фейс к PyDoc для воспроизводства отчетов в формате HTML. Функция
help вызывает PyDoc для создания простых текстовых отчетов (кото
рые выглядят как страницы руководства в UNIXподобных системах):
>>> import sys
>>> help(sys.getrefcount)
Help on builtin function getrefcount:
getrefcount(...)
getrefcount(object) > integer
Return the current reference count for the object.
...остальной текст опущен...
Обратите внимание: чтобы вызывать функцию help, не обязательно
импортировать модуль sys, но его необходимо импортировать, чтобы
получить справку по модулю sys – функция ожидает получить ссылку
на объект. Для крупных объектов, таких как модули и классы, функ
ция help делит выводимую информацию на множество разделов, часть
из которых показана здесь. Запустите следующую команду в интерак
тивном сеансе, чтобы получить полный отчет:
>>> help(sys)
Help on builtin module sys:
NAME
sys
FILE
(builtin)
DESCRIPTION
This module provides access to some objects used
or maintained by the interpreter and to functions
...остальной текст опущен...
FUNCTIONS
__displayhook__ = displayhook(...)
displayhook(object) > None
Print an object to sys.stdout and also save it
...остальной текст опущен...
DATA
__name__ = 'sys'
__stderr__ = <open file '<stderr>', mode 'w' at 0x0082BEC0>
...остальной текст опущен...
Часть информации в этом отчете извлечена из строк документирова
ния, а часть этих сведений (например, сигнатуры функций) – это ин
формация о структуре программных компонентов, которую PyDoc из
влекает автоматически, в результате анализа внутреннего устройства
объектов. Кроме того, функция help может использоваться для полу
Источники документации в языке Python 371
чения сведений о встроенных функциях, методах и типах. Чтобы по
лучить справку о встроенном типе, нужно просто передать функции
имя типа (например, dict – для словарей, str – для строк, list – для
списков). Вам будет предоставлен большой объем информации с опи
саниями всех методов, доступных для этого типа:
>>> help(dict)
Help on class dict in module __builtin__:
class dict(object)
| dict( ) > new empty dictionary.
...остальной текст опущен...
>>> help(str.replace)
Help on method_descriptor:
replace(...)
S.replace (old, new[, maxsplit]) > string
Return a copy of string S with all occurrences
...остальной текст опущен...
>>> help(ord)
Help on builtin function ord:
ord(...)
ord(c) > integer
Return the integer ordinal of a onecharacter string.
Наконец, функция help может извлекать информацию не только из
встроенных, но и из любых других модулей. Ниже приводится отчет,
полученный для файла docstrings.py, представленного выше. Здесь
снова часть информации представлена строками документирования,
а часть была получена автоматически, в результате исследования
структуры объектов:
>>> help(docstrings.square)
Help on function square in module docstrings:
square(x)
function documentation
can we have your liver then?
>>> help(docstrings.employee)
...остальной текст опущен...
>>> help(docstrings)
Help on module docstrings:
NAME
docstrings
FILE
c:\python22\docstrings.py
DESCRIPTION
372 Глава 14. Документация
Module documentation
Words Go Here
CLASSES
employee
...остальной текст опущен...
FUNCTIONS
square(x)
function documentation
can we have your liver then?
DATA
__file__ = 'C:\\PYTHON22\\docstrings.pyc'
__name__ = 'docstrings'
spam = 40
PyDoc: отчеты в формате HTML
Функция help прекрасно подходит для извлечения информации при ра
боте в интерактивной оболочке. Однако для PyDoc существует и графи
ческий интерфейс (простой и переносимый сценарий Python/Tkinter),
с помощью которого можно создавать отчеты в формате HTML, доступ
ные для просмотра в любом вебброузере. В этом случае PyDoc может
выполняться как локально, так и удаленно, в режиме клиент/сервер.
Внутри отчетов автоматически создаются гиперссылки, которые по
зволят щелчком мыши перемещаться к описаниям взаимосвязанных
компонентов в вашем приложении.
Чтобы запустить PyDoc в этом режиме, сначала необходимо запустить
поисковый механизм, графический интерфейс которого представлен
на рис. 14.1. Сделать это можно, выбрав пункт меню Module Docs в меню
Рис. 14.1. Главное окно графического интерфейса PyDoc: введите имя
требуемого модуля, нажмите клавишу Enter, выберите модуль и затем
щелкните на кнопке «go to selected» (или, не вводя имя модуля, щелкните
на кнопке «open browser», чтобы увидеть список всех доступных модулей)
Источники документации в языке Python 373
Python кнопки Пуск в Windows или запустив сценарий pydocgui.pyw
в каталоге Tools, где был установлен Python (также можно запустить
сценарий pydoc.py с ключом g). Введите имя интересующего вас моду
ля и нажмите клавишу Enter – PyDoc обойдет каталоги в пути поиска
модулей (sys.path) и отыщет ссылки на указанный модуль.
Отыскав нужную запись, выберите ее и щелкните на кнопке «go to se
lected» (перейти к выбранному элементу). PyDoc откроет вебброузер
и отобразит отчет в формате HTML. На рис. 14.2 показано, как выгля
дит информация, представленная PyDoc, для встроенного модуля glob.
Обратите внимание на гиперссылки в разделе «Modules» (модули) на
этой странице – вы можете щелкать на них мышью и перемещаться на
страницы с описаниями этих (импортированных) модулей. Для боль
ших страниц PyDoc также генерирует гиперссылки на различные раз
делы на этой странице.
Рис. 14.2. Отыскав требуемый модуль в окне, представленном на рис. 14.1,
щелкните на кнопке «go to selected», и описание модуля в формате HTML
будет отображено в веб+броузере, как в данном случае, где отображено
описание модуля из стандартной библиотеки
374 Глава 14. Документация
Подобно функции help графический интерфейс может извлекать ин
формацию и из пользовательских модулей. На рис. 14.3 показана
страница с информацией, извлеченной из нашего файла docstrings.py.
PyDoc можно настраивать и запускать разными способами, но мы не
будем рассматривать эти возможности здесь – за дополнительной ин
формацией обращайтесь к руководству по стандартной библиотеке
языка Python. Главное, что вы должны запомнить, – PyDoc по сути
создает отчеты о реализации на основе той информации, что имеется,
– если вы использовали строки документирования в своих файлах, Py
Doc сделает все необходимое, чтобы собрать и отформатировать их со
ответствующим образом. PyDoc – это всего лишь средство получения
справки об объектах, таких как функции и модули, но он обеспечивает
Рис. 14.3. PyDoc может служить источником документации как для встро+
енных, так и для пользовательских модулей. Здесь приводится страница
с описанием пользовательского модуля, где можно видеть все строки доку+
ментирования (docstrings), извлеченные из файла с исходными текстами
Источники документации в языке Python 375
простой доступ к документации с описанием этих компонентов. Его
отчеты более полезны, чем просто списки атрибутов, хотя и менее ис
черпывающи, чем стандартные руководства.
Совет дня: если поле ввода имени модуля в окне на рис. 14.1 оста
вить пустым и щелкнуть на кнопке «open browser» (открыть бро
узер), PyDoc воспроизведет вебстраницу с гиперссылками на все
модули, доступные для импорта на данном компьютере. Сюда
входят модули стандартной библиотеки, расширения сторонних
производителей, пользовательские модули, расположенные в пу
ти поиска импортируемых модулей, и даже модули, написанные
на языке C, скомпонованные статически или динамически. Та
кую информацию сложно получить иными путями, если не пи
сать свой программный код, который будет заниматься исследо
ванием исходных текстов набора модулей.
Кроме того, PyDoc может сохранять документацию в формате
HTML для последующего просмотра или вывода на печать; указа
ния о том, как это сделать, вы найдете в документации. Следует
отметить, что PyDoc может не совсем корректно работать со сцена
риями, которые читают данные из потока стандартного ввода, –
PyDoc импортирует целевой модуль для последующего исследо
вания, но при работе в режиме с графическим интерфейсом может
отсутствовать связь с потоком стандартного ввода. Однако моду
ли, которые не требуют немедленного ввода информации в мо
мент импортирования, будут обслуживаться корректно.
Стандартный набор руководств
Стандартные руководства играют роль наиболее полного и самого све
жего описания языка Python и набора инструментальных средств. Ру
ководства распространяются в формате HTML и в других форматах
и вWindows устанавливаются вместе системой Python – они доступны
в виде пунктов подменю Python, в меню кнопки Пуск (Start), а также в ме
ню Help (Cправка) среды разработки IDLE. Набор руководств можно как
получить отдельно, в различных форматах, по адресу http://www.py+
thon.org, так и читать непосредственно на сайте (следуйте по ссылке
Documentation (Документация)). Руководства в системе Windows оформле
ны в виде файлов справки, поддерживающих возможность поиска;
электронная версия на сайте Python.org также имеет страницу поиска.
После открытия руководства в операционной системе Windows оно
отображает начальную страницу, как показано на рис. 14.4. Двумя са
мыми важными, пожалуй, здесь являются ссылки «Library Referen
ce» (справочное руководство по библиотеке, где описываются встроен
ные типы, функции, исключения и модули стандартной библиотеки)
и «Language Reference» (справочное руководство по языку, где приво
дится формальное описание языковых конструкций). На этой странице
имеется также ссылка «Tutorial» (самоучитель), которая ведет к крат
кому введению для начинающих изучение языка.
376 Глава 14. Документация
Вебресурсы
На официальном вебсайте проекта Python (http://www.python.org) вы
найдете ссылки на различные ресурсы, посвященные этому языку про
граммирования, часть которых охватывает специализированные темы
и области применения языка. Щелкнув по ссылке «Documentation»,
можно получить доступ к электронному учебнику и к «Beginners Guide
to Python» (руководство по языку Python для начинающих). На сайте
также имеются ссылки на другие ресурсы на других языках.
Массу информации о языке Python можно отыскать в Интернетэн
циклопедии, в блогах, на вебсайтах и других ресурсах в Сети. Чтобы
получить перечень ссылок на такие ресурсы, попробуйте поискать по
строке «Python programming» в поисковой системе Google.
Печатные издания
Последний источник информации – это огромная коллекция печат
ных справочных пособий по языку Python. Однако учтите, что обычно
Рис. 14.4. Стандартный набор руководств по языку Python, доступный
на сайте www.python.org в меню Help (Справка) среды разработки IDLE
и в меню кнопки Пуск (Start) в операционной системе Windows. В Windows
набор руководств оформлен в виде файла справки, поддерживающего
возможность поиска; электронная версия на веб+сайте также имеет
страницу поиска. Из всех предлагаемых руководств самым востребованным
является Library reference (справочное руководство по библиотеке)
Типичные ошибки программирования 377
книги немного отстают от развития языка Python, частично изза то
го, что для написания книги необходимо время, частично изза естест
венных задержек, свойственных самому процессу издания. Обычно
книга выходит в свет с отставанием на три или более месяцев от теку
щего состояния дел. В отличие от стандартных руководств, книги ред
ко распространяются бесплатно.
Однако для многих удобство и качество профессионального издания
с лихвой окупает потраченные деньги. Более того, язык Python изме
няется настолько медленно, что книги сохраняют свою актуальность
в течение еще нескольких лет после их издания, особенно если их ав
торы публикуют дополнения в Сети. Ссылки на другие книги о Python
вы найдете в предисловии.
Типичные ошибки программирования
Прежде чем перейти к упражнениям этой части книги, рассмотрим не
которые наиболее распространенные ошибки, которые допускают на
чинающие программисты в инструкциях и программах на языке Py
thon. Многие из этих ошибок, уже упоминавшиеся ранее в этой части
книги, я привел здесь для полноты картины. С ростом опыта использо
вания языка Python вы научитесь избегать их, но несколько слов, ска
занных сейчас, помогут вам избегать их с самого начала:
• Не забывайте про двоеточия. Никогда не забывайте вводить сим
вол двоеточия в конце заголовков составных инструкций (первая
строка таких инструкций, как if, while, for и других). Сначала вы
наверняка будете забывать об этом (как я и большинство из 3000
моих студентов), но вскоре это превратится для вас в привычку.
• Начинайте с первой позиции в строке. Программный код верхнего
уровня (не вложенный) должен начинаться с первой позиции в стро
ке. Сюда относится как не вложенный программный код в моду
лях, так и программный код, который вводится в интерактивной
оболочке.
• Пустые строки имеют особый смысл в интерактивной оболочке.
Пустые строки в теле составных инструкций внутри файлов моду
лей всегда игнорируются, но когда программный код вводится в ин
терактивной оболочке, они завершают составные инструкции. Дру
гими словами, ввод пустой строки сообщает интерактивной ко
мандной оболочке, что вы закончили ввод составной инструкции –
если вам необходимо продолжить ввод такой инструкции, не нажи
майте клавишу Enter, когда отображается строка приглашения
к вводу ..., пока вы действительно не закончите ее ввод.
• Используйте отступы непротиворечивым способом. Старайтесь не
смешивать символы табуляции и пробелы при оформлении отсту
пов в блоке, если вы не знаете точно, как текстовый редактор интер
претирует символы табуляции. В противном случае интерпретатор
378 Глава 14. Документация
Python будет видеть совсем не то, что вы видите на экране, когда он
будет выполнять преобразование символов табуляции в пробелы.
Это справедливо не только для Python, но и для любого другого язы
ка программирования с блочноструктурированным оформлением
программного кода – если у другого программиста в текстовом ре
дакторе ширина символов табуляции настроена иначе, он не смо
жет понять структуру вашего программного кода. Для оформления
отступов лучше использовать чтото одно – или символы табуля
ции, или пробелы.
• Не пишите на языке C. Напоминаю программистам, использую
щим C/C++: нет никакой необходимости заключать условные вы
ражения в круглые скобки в инструкциях if и while (например, if
(X == 1):). Это допустимо (любое выражение можно заключить
в круглые скобки), но в данном контексте они совершенно излиш
ни. Кроме того, не заканчивайте все инструкции точками с запятой –
это также вполне допустимо в языке Python, но они совершенно
бесполезны, если в каждой строке находится всего одна инструк
ция (конец строки обычно обозначает конец инструкции). И помни
те – не встраивайте инструкции присваивания в условные выраже
ния циклов while и не заключайте блоки в фигурные скобки {} (вло
женные блоки оформляются с помощью отступов).
• Вместо циклов while и функции range старайтесь использовать про!
стые циклы for. Еще одно напоминание: простые циклы for (напри
мер, for x in seq) практически всегда проще и выполняются быст
рее, чем счетные циклы while или основанные на использовании
функции range. Так как в простых циклах for извлечение элементов
последовательностей производится внутренними механизмами ин
терпретатора, они выполняются, порой, в два раза быстрее, чем эк
вивалентные циклы while. Избегайте искушения считать чтолибо
в циклах на языке Python!
• Будьте внимательны, выполняя присваивание изменяемых объек!
тов. Об этом уже говорилось в главе 11: следует быть особенно вни
мательным при использовании изменяемых объектов в инструкци
ях множественного присваивания (a = b = []), а также в расширен
ных инструкциях присваивания (a += [1, 2]). В обоих случаях не
посредственные изменения могут затронуть другие переменные.
Более подробно об этом рассказывается в главе 11.
• Не ожидайте получения результатов от функций, выполняющих
непосредственные изменения в объектах. Мы уже сталкивались
с этим ранее: операции, выполняющие непосредственное изменение,
такие как методы list.append и list.sort, представленные в главе 8,
не имеют возвращаемых значений (отличных от None), поэтому их
следует вызывать без присваивания возвращаемого значения. На
чинающие программисты часто допускают ошибку, используя при
мерно такой программный код: mylist = mylist.append(X), пытаясь
получить результат метода append, но в действительности в этом
В заключение 379
случае в переменную mylist записывается ссылка на объект None,
а не на измененный список (фактически такая инструкция ведет
к полной потере ссылки на список).
Менее явный пример такой ошибки – когда выполняется попытка
обойти элементы словаря в порядке сортировки. Очень часто можно
увидеть, например, такой программный код: for k in D.keys().sort():.
Он почти работает – метод keys создает список ключей, а метод sort
упорядочивает его, но, так как метод sort возвращает объект None,
цикл for терпит неудачу, потому что, в конечном счете, выполняется
попытка обойти элементы объекта None (который не является после
довательностью). Этот алгоритм можно реализовать либо с помощью
новой встроенной функции sorted, которая возвращает отсортирован
ный список, либо необходимо разделить вызовы методов на инструк
ции: Ks = D.keys(), затем Ks.sort(), и наконец for k in Ks:. Это один из
случаев, когда может потребоваться явный вызов метода keys для ор
ганизации обхода элементов словаря в цикле вместо использования
итераторов словарей, так как итераторы не выполняют сортировку.
• Всегда используйте круглые скобки при вызове функций. При вы
зове функций после их имен всегда следует добавлять круглые
скобки независимо от наличия входных аргументов (например, вы
зов функции должен выглядеть как function(), а не function). В чет
вертой части книги вы узнаете, что функции – это простые объек
ты, которые могут выполнять специальную операцию – вызов –
при обращении к имени с круглыми скобками.
Похоже, что эта проблема наиболее часто возникает в классах при
работе с файлами – нередко можно увидеть, как начинающие про
граммисты пытаются оформить вызов метода как file.close, а не
как file.close(). Поскольку обращение к имени метода без круг
лых скобок в языке Python считается допустимым, такая попытка
не приводит к появлению ошибки, но файл остается открытым!
• Не используйте расширения имен файлов в инструкциях import
и reload. Не указывайте полные пути к файлам и расширения в ин
струкциях import (например, следует писать import mod, а не import
mod.py). (Начальные сведения о модулях приводились в главе 3, и мы
будем еще обсуждать их в пятой части книги.) Так как помимо .py
имена файлов модулей могут иметь другие расширения (например,
.pyc), указание расширения не только является нарушением син
таксиса, но и вообще не имеет смысла. Синтаксис определения пути
зависит от типа платформы и определяется настройками параметра
пути поиска модулей, а не инструкцией import.
В заключение
В этой главе мы рассмотрели вопросы документирования программ, ко
торые касаются как документации, которую мы пишем для наших соб
ственных программ, так и документации к встроенным инструментам.
380 Глава 14. Документация
Мы познакомились со строками документирования, с ресурсами, со
держащими справочные руководства по языку Python, и узнали, как с
помощью функции help и вебинтерфейса PyDoc получить доступ к до
полнительной документации. Так как это последняя глава в этой час
ти книги, мы также рассмотрели наиболее часто встречающиеся
ошибки, что должно помочь вам избежать их.
В следующей части книги мы начнем применять полученные знания
к более крупным программным конструкциям: к функциям. Однако,
прежде чем двинуться дальше, проработайте упражнения к этой час
ти, которые приводятся в конце главы. Но перед этим ответьте на кон
трольные вопросы к главе.
Закрепление пройденного
Контрольные вопросы
1. Когда вместо комментариев, начинающихся с символа решетки,
следует использовать строки документирования?
2. Назовите три способа извлечения строк документирования.
3. Как получить перечень всех атрибутов объекта?
4. Как можно получить перечень всех модулей, доступных на компь
ютере?
5. Какие книги о Python, после этой, следует приобрести?
Ответы
1. Строки документирования считаются более удобными для создания
функционального описания, где поясняются принципы использова
ния модулей, функций, классов и методов. Комментарии, начинаю
щиеся с символа решетки, лучше подходят для пояснений к выра
жениям и инструкциям. Такой порядок принят не только потому,
что строки документирования проще отыскать в файле с исходными
текстами, но и потому, что они могут извлекаться и просматривать
ся с помощью системы PyDoc.
2. Получить содержимое строк документирования можно с помощью
атрибута __doc__ объекта, передав его функции help, или выбирая мо
дули в поисковой системе PyDoc с графическим интерфейсом, в ре
жиме клиент/сервер. Дополнительно PyDoc обладает возможно
стью сохранять описание модулей в файлах HTML для последую
щего просмотра.
3. Список всех атрибутов, имеющихся у любого объекта, можно полу
чить с помощью функции dir(X).
4. Запустите графический интерфейс PyDoc, оставьте пустым поле
ввода имени модуля и щелкните на кнопке «open browser» (открыть
Закрепление пройденного 381
броузер). В результате будет открыта вебстраница, содержащая
ссылки на описания всех модулей, доступных вашей программе.
5. Мои, конечно. (А если серьезно, в предисловии имеется перечень
некоторых книг, как справочных пособий, так и учебников, реко
мендуемых для дальнейшего прочтения.)
Упражнения к третьей части
Теперь, когда вы узнали, как описывается логика работы программы,
в следующих упражнениях вам будет предложено реализовать реше
ние некоторых простых задач с использованием инструкций. Самым
большим является упражнение 4, где вам будет предложено рассмот
реть альтернативные варианты реализации. Одна и та же задача всегда
может быть решена разными способами и отчасти изучение языка Py
thon заключается в том, чтобы находить более оптимальные решения.
Решения приводятся в приложении B, в разделе «Часть III, Инструк
ции и синтаксис».
1. Основы циклов.
a. Напишите цикл for, который выводит ASCIIкоды всех символов
в строке с именем S. Для преобразования символов в целочислен
ные ASCIIкоды используйте встроенную функцию ord(character).
(Поэкспериментируйте с ней в интерактивной оболочке, чтобы
понять, как она работает.)
b. Затем измените цикл так, чтобы он вычислял сумму кодов ASCII
всех символов в строке.
c. Наконец, измените свой программный код так, чтобы он возвра
щал новый список, содержащий ASCIIкоды всех символов в стро
ке. Дает ли выражение map(ord, S) похожий результат? (Подсказ
ка: прочитайте четвертую часть.)
2. Символы обратного слеша. Что произойдет, если в интерактивной
оболочке ввести следующий программный код?
for i in range(50):
print 'hello %d\n\a' % i
Будьте осторожны при запуске этого примера не в среде IDLE, он
может сгенерировать звуковой сигнал, что может не понравиться
окружающим. Среда разработки IDLE вместо этого выводит мало
понятные символы (символы, экранированные обратным слешем,
приводятся в табл. 7.2).
3. Сортировка словарей. В главе 8 мы видели, что словари представ
ляют собой неупорядоченные коллекции. Напишите цикл for, ко
торый выводит элементы словаря в порядке возрастания. Подсказ
ка: используйте метод keys словаря и метод списка sort или новую
встроенную функцию sorted.
382 Глава 14. Документация
4. Программирование альтернативной логики. Изучите следующий
фрагмент, где для поиска числа 2 в пятой степени (32) в списке сте
пеней числа 2, используются цикл while и флаг found. Этот фраг
мент хранится в файле power.py.
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
found = i = 0
while not found and i < len(L):
if 2 ** X == L[i]:
found = 1
else:
i = i+1
if found:
print 'at index', i
else:
print X, 'not found'
C:\book\tests> python power.py
at index 5
В этом примере не используются обычные приемы программирова
ния, принятые в языке Python. Следуя указаниям ниже, попробуй
те улучшить его (вы можете вносить изменения в интерактивной
оболочке или сохранять в файле сценария и запускать его из ко
мандной строки системы – использование файла существенно упро
стит это упражнение):
a. Сначала добавьте в цикл while блок else, чтобы избавиться от
флага found и последней инструкции if.
b. Затем перепишите пример с циклом for и блоком else, чтобы из
бавиться от логики вычисления индексов в списке. Подсказка:
получить индекс элемента можно с помощью метода index (L.in
dex(X)), возвращающего смещение первого элемента со значени
ем X в списке.
c. Затем вообще избавьтесь от цикла, реализовав решение на осно
ве оператора in проверки вхождения. (Подробности вы найдете
в главе 8 или попробуйте ввести такое выражение: 2 in [1,2,3].)
d. Наконец, вместо литерала списка L используйте цикл for и метод
append для заполнения списка степеней двойки.
Более глубокие улучшения:
e. Как вы думаете, повысится ли производительность, если выраже
ние 2 ** X вынести за пределы циклов? Как это можно сделать?
f. Как мы видели в упражнении 1, Python включает в себя функ
цию map(function, list), которая может создать список степеней
числа 2: map(lambda x: 2 ** x, range(7)). Попробуйте выполнить
этот программный код в интерактивной оболочке; с инструкци
ей lambda мы познакомимся в главе 17.
IV
Функции

15
Основы функций
В третьей части книги мы рассмотрели основные процедурные инст
рукции языка Python. В этой части мы переходим к исследованию на
бора дополнительных инструкций, которые используются при созда
нии функций.
Если говорить просто, то функция – это устройство, которое группи
рует набор инструкций так, что в программе они могут запускаться
неоднократно. Функции могут вычислять некоторый результат и по
зволять указывать входные параметры, отличающиеся по своим зна
чениям от вызова к вызову. Возможность оформления операций в виде
функций – это очень удобный инструмент, который мы можем исполь
зовать в самых разных ситуациях.
С принципиальной точки зрения функции устраняют необходимость
вставлять в программу избыточные копии блоков одного и того же
программного кода, так как они могут быть заменены единственной
функцией. Благодаря функциям можно существенно уменьшить тру
дозатраты на программирование: если операцию необходимо будет ви
доизменить, достаточно будет внести изменения всего в одном месте,
а не во многих.
Функции – это самые основные программные структуры в языке Py
thon, обеспечивающие многократное использование программного
кода и уменьшающие его избыточность. Как будет показано далее,
функции – это еще и средство проектирования, которое позволяет раз
бить сложную систему на достаточно простые и легко управляемые
части. В табл. 15.1 приводятся основные инструменты, имеющие от
ношение к функциям, которые мы будем изучать в этой части книги.
386 Глава 15. Основы функций
Таблица 15.1. Инструкции и выражения, имеющие отношение к функциям
Зачем нужны функции?
Прежде чем перейти к обсуждению деталей, мы нарисуем себе четкую
картину, что из себя представляют функции. Функции – это практиче
ски универсальное средство структурирования программы. Возможно,
раньше вам уже приходилось сталкиваться с ними в других языках
программирования, где они могли называться подпрограммами или про+
цедурами. В процессе разработки функции играют две основные роли:
Максимизировать многократное использование программного кода
и минимизировать его избыточность
Как и в большинстве других языков программирования, функции
в языке Python представляют собой простейший способ упаковки
логики выполнения, которая может использоваться в разных мес
тах программы и более чем один раз. До сих пор весь программный
код, который нам приходилось писать, выполнялся немедленно.
Функции позволяют группировать и обобщать программный код,
который может позднее использоваться произвольное число раз.
Так как функции позволяют поместить реализацию операции в од
но место и использовать ее в разных местах, они являются самым
основным инструментом структуризации: они дают возможность
уменьшить избыточность программного кода и тем самым умень
шить трудозатраты на его сопровождение.
Процедурная декомпозиция
Функции также обеспечивают возможность разбить сложную сис
тему на части, каждая из которых играет вполне определенную
роль. Например, чтобы испечь пиццу, сначала нужно замесить тес
то, раскатать его, добавить начинку, испечь и т. д. Если бы мы пи
сали программу для машины по выпечке пиццы, мы могли бы об
щую задачу «испечь пиццу» разбить на мелкие части – по одной
функции для каждого из этапов. Гораздо проще создать решение
маленьких задач по отдельности, чем реализовать весь процесс це
ликом. Вообще функции описывают «как делать», а не «зачем де
лать». В шестой части книги мы увидим, почему это различие име
ет такое большое значение.
Инструкция Примеры
Вызов myfunc("spam", "eggs", meat=ham)
def, return, yield def adder(a, b=1, *c):
return a+b+c[0]
global def changer():
global x; x = 'new'
lambda Funcs = [lambda x: x**2, lambda x: x*3]
Создание функций 387
В этой части книги мы исследуем понятия языка Python, используе
мые при создании функций: основы функций, правила области види
мости и передача аргументов, а также ряд сопутствующих концепций,
таких как генераторы и функциональные инструменты. Мы также
еще раз вернемся к понятию полиморфизма, введенному ранее в этой
книге, поскольку на данном уровне его важность становится еще более
очевидной. Как вы увидите, функции привносят не так много новых
синтаксических конструкций, но они ведут нас к более существенным
идеям программирования.
Создание функций
Несмотря на то, что функции еще не были представлены формально,
тем не менее, мы уже использовали некоторые из них в предыдущих
главах. Например, для создания объекта файла мы вызывали функ
цию open; точно так же мы использовали встроенную функцию len, ко
гда нам необходимо было узнать число элементов в объекте коллекции.
В этой главе мы узнаем, как создаются новые функции в языке Py
thon. Функции, которые мы пишем сами, ведут себя точно так же, как
и встроенные функции, которые нам уже приходилось встречать: они
могут вызываться в выражениях, получать значения и возвращать ре
зультаты. Но для того чтобы создавать новые функции, необходимо
ввести дополнительные понятия. Кроме того, в языке Python функции
ведут себя иначе, чем в компилирующих языках программирования,
таких как C. Ниже приводится краткое введение в основные концеп
ции, составляющие основу функций в языке Python, каждую из кото
рых мы будем изучать в этой части книги:
• def – это исполняемый программный код. Функции в языке Python
создаются с помощью новой инструкции def. В отличие от функций
в компилирующих языках программирования, таких как C, def отно
сится к классу исполняемых инструкций – функция не существует,
пока интерпретатор не доберется до инструкции def и не выполнит ее.
Фактически, вполне допустимо (а иногда даже полезно) вкладывать
инструкции def внутрь инструкций if, циклов while и даже в другие
инструкции def. В случае наиболее типичного использования инст
рукции def вставляются в файлы модулей и генерируют функции
при выполнении во время первой операции импортирования.
• def создает объект и присваивает ему имя. Когда интерпретатор Py
thon встречает и выполняет инструкцию def, он создает новый объ
ектфункцию и связывает его с именем функции. Как и в любой
другой операции присваивания, имя становится ссылкой на объ
ектфункцию. В имени функции нет ничего необычного – как будет
показано далее, объектфункция может быть связан с несколькими
именами, сохраняться в списке и т. д. Кроме того, функции могут
создаваться с помощью выражения lambda (более сложная концеп
ция, которая будет рассматриваться в одной из последующих глав).
388 Глава 15. Основы функций
• return передает объект результата вызывающей программе. Когда
функция вызывается, вызывающая программа приостанавливает
свою работу, пока функция не завершит работу и не вернет управ
ление. Функции, вычисляющие какоелибо значение, возвращают
его с помощью инструкции return – возвращаемое значение стано
вится результатом обращения к функции. Функции, известные как
генераторы, для передачи возвращаемого значения могут также
использовать инструкцию yield и сохранять свое состояние так,
чтобы работа функции могла быть возобновлена позднее, – это еще
одна из сложных тем, которые будут рассматриваться позже.
• Аргументы передаются посредством присваивания (в виде ссылок
на объекты). В языке Python аргументы передаются функциям по
средством выполнения операции присваивания (что, как мы уже
знаем, означает – в виде ссылок на объекты). Как будет показано
далее, модель, принятая в языке Python, в действительности не эк
вивалентна правилам передачи аргументов по ссылке в языке C или
C++ – и вызывающая программа, и функция совместно используют
ссылку на объект, но здесь нет никакого совмещения имен. Измене
ние имени аргумента также не изменяет имени в вызывающей про
грамме, но модификация изменяемых объектов внутри функции
может приводить к изменению объектов в вызывающей программе.
• global объявляет переменные, глобальные для модуля, без при!
сваивания им значений. По умолчанию все имена, присваивание
которым производится внутри функций, являются локальными
для этих функций и существуют только во время выполнения
функций. Чтобы присвоить значение имени в объемлющем модуле,
функция должна объявить его с помощью инструкции global. Гово
ря в более широком смысле, поиск имен всегда производится в об+
ласти видимости – там, где хранятся переменные, – а операция
присваивания связывает имена с областями видимости.
• Аргументы, возвращаемые значения и переменные не объявляют!
ся. Как и повсюду в языке Python, на функции также не накладыва
ется никаких ограничений по типу. Фактически никакие элементы
функций не требуют предварительного объявления: вы можете пе
редавать функции аргументы любых типов, возвращать из функции
объект любого типа и т. д. Как следствие этого одна и та же функция
может применяться к объектам различных типов – допустимыми
считаются любые объекты, поддерживающие совместимые интер
фейсы (методы и выражения), независимо от конкретного типа.
Если чтото из сказанного выше вам показалось непонятным, не вол
нуйтесь – в этой части книги мы исследуем все эти концепции на при
мерах программного кода. А теперь начнем изучение некоторых из
этих идей и рассмотрим несколько примеров.
Создание функций 389
Инструкция def
Инструкция def создает объект функции и связывает его с именем.
В общем виде инструкция имеет следующий формат:
def <name>(arg1, arg2,... argN):
<statements>
Как и все составные инструкции в языке Python, инструкция def со
стоит из строки заголовка и следующего за ней блока инструкций,
обычно с отступами (или простая инструкция вслед за двоеточием).
Блок инструкций образует тело функции, т. е. программный код, ко
торый выполняется интерпретатором всякий раз, когда производится
вызов функции.
В строке заголовка инструкции def определяются имя функции, с ко
торым будет связан объект функции, и список из нуля или более аргу+
ментов (иногда их называют параметрами) в круглых скобках. Имена
аргументов в строке заголовка будут связаны с объектами, передавае
мыми в функцию, в точке вызова.
Тело функции часто содержит инструкцию return:
def <name>(arg1, arg2,... argN):
...
return <value>
Инструкция return может располагаться в любом месте в теле функ
ции – она завершает работу функции и передает результат вызываю
щей программе. Инструкция return содержит объектное выражение,
которое дает результат функции. Инструкция return является необя
зательной – если она отсутствует, работа функции завершается, когда
поток управления достигает конца тела функции. С технической точ
ки зрения, функция без инструкции return автоматически возвращает
объект None, однако это значение обычно просто игнорируется.
Функции могут также содержать инструкции yield, которые исполь
зуются для воспроизведения серии значений с течением времени, од
нако их рассмотрение мы отложим до главы 17, где обсуждаются рас
ширенные темы, касающиеся функций.
Инструкции def исполняются во время выполнения
Инструкция def в языке Python – это настоящая исполняемая инструк
ция: когда она исполняется, она создает новый объект функции и при
сваивает этот объект имени. (Не забывайте, все, что имеется в языке
Python, относится ко времени выполнения, здесь нет понятия времени
компиляции.) Будучи инструкцией, def может появляться везде, где
могут появляться инструкции, – даже внутри других инструкций. На
пример, даже при том, что инструкции def обычно исполняются, когда
выполняется импорт вмещающего их модуля, допускается вкладывать
390 Глава 15. Основы функций
определения функций внутрь инструкций if, что позволяет произво
дить выбор между альтернативами:
if test:
def func(): # Определяет функцию таким способом
...
else:
def func(): # Или таким способом
...
...
func() # Вызов выбранной версии
Чтобы понять этот фрагмент программного кода, обратите внимание,
что инструкция def напоминает инструкцию присваивания =: она про
сто выполняет присваивание во время выполнения. В отличие от ком
пилирующих языков, таких как C, функции в языке Python не долж
ны быть полностью определены к моменту запуска программы. Други
ми словами, инструкции def не интерпретируются, пока они не будут
достигнуты и выполнены потоком выполнения, а программный код
внутри инструкции def не выполняется, пока функция не будет вызва
на позднее.
Так как определение функции происходит во время выполнения, имя
функции не является однозначно определенным. Важен только объ
ект, на который ссылается имя:
othername = func # Связывание объекта функции с именем
othername() # Вызов функции
В этом фрагменте функция была связана с другим именем и вызвана
уже с использованием нового имени. Как и все остальное в языке Py
thon, функции – это обычные объекты; они явно записываются в па
мять во время выполнения программы.
Первый пример: определения и вызовы
Кроме таких концепций времени выполнения (которые кажутся наи
более уникальными для программистов, имеющих опыт работы с тра
диционными компилирующими языками программирования) в ис
пользовании функций нет ничего сложного. Давайте напишем первый
пример, в котором продемонстрируем основы. Как видите, функции
имеют две стороны: определение (инструкция def, которая создает
функцию) и вызов (выражение, которое предписывает интерпретатору
выполнить тело функции).
Определение
Ниже приводится определение в интерактивной оболочке, которое
определяет функцию с именем times. Эта функция возвращает резуль
тат обработки двух аргументов:
Первый пример: определения и вызовы 391
>>> def times(x, y): # Создать функцию и связать ее с именем
... return x * y # Тело, выполняемое при вызове функции
...
Когда интерпретатор достигает эту инструкцию def и выполняет ее, он
создает новый объект функции, в который упаковывает программный
код функции и связывает объект с именем times. Как правило, такие
инструкции размещаются в файлах модулей и выполняются во время
импортирования модулей, однако такую небольшую функцию можно
определить и в интерактивной оболочке.
Вызов
После выполнения инструкции def вы сможете вызывать функцию
в своей программе, добавляя круглые скобки после ее имени. В круг
лых скобках можно указать один или более аргументов, значения ко
торых будут присвоены именам, указанным в заголовке функции:
>>> times(2, 4) # Аргументы в круглых скобках
8
Данное выражение передает функции times два аргумента. Как уже
упоминалось ранее, передача аргументов осуществляется за счет вы
полнения операции присваивания, таким образом, имени x в заголов
ке функции присваивается значение 2, а имени y – значение 4, после
чего запускается тело функции. В данном случае тело функции состав
ляет единственная инструкция return, которая отправляет обратно ре
зультат выражения. Возвращаемый объект был выведен интерактив
ной оболочкой автоматически (как и в большинстве языков, 2 * 4
в языке Python равно 8), однако, если бы результат потребовался бы
нам позднее, мы могли бы присвоить его переменной. Например:
>>> x = times(3.14, 4) # Сохранить объект результата
>>> x
12.56
Теперь посмотрим, что произойдет, если функции передать объекты
совершенно разных типов:
>>> times('Ni', 4) # Функции не имеют типа
'NiNiNiNi'
На этот раз функция выполнила нечто совершенно иное. Вместо двух
чисел в аргументах x и y функции были переданы строка и целое чис
ло. Вспомните, что оператор * может работать как с числами, так и
с последовательностями; поскольку в языке Python не требуется объ
являть типы переменных, аргументов или возвращаемых значений,
мы можем использовать функцию times для умножения чисел
и повторения последовательностей.
Другими словами, смысл функции times и тип возвращаемого значе
ния определяются аргументами, которые ей передаются. Это основная
392 Глава 15. Основы функций
идея языка Python (и, возможно, ключ к использованию языка), кото
рую мы рассмотрим в следующем разделе.
Полиморфизм в языке Python
Как мы только что видели, смысл выражения x * y в нашей простой
функции times полностью зависит от типов объектов x и y – одна и та
же функция может выполнять умножение в одном случае и повторе
ние в другом. В языке Python именно объекты определяют синтакси
ческий смысл операции. В действительности оператор * – это всего
лишь указание для обрабатываемых объектов.
Такого рода зависимость от типов известна как полиморфизм – термин,
впервые встретившийся нам в главе 4, который означает, что смысл опе
рации зависит от типов обрабатываемых объектов. Поскольку Python –
это язык с динамической типизацией, полиморфизм в нем проявляется
повсюду. Фактически все операции в языке Python являются полимор
фическими: вывод, извлечение элемента, оператор * и многие другие.
Такое поведение заложено в язык изначально и объясняет в большой
степени его краткость и гибкость. Например, единственная функция
может автоматически применяться к целой категории типов объектов.
Пока объекты поддерживают ожидаемый интерфейс (или протокол),
функция сможет обрабатывать их. То есть, если объект, передаваемый
функции, поддерживает ожидаемые методы и операторы выражений,
он будет совместим с логикой функции.
Даже в случае с нашей простой функцией это означает, что любые два
объекта, поддерживающие оператор *, смогут обрабатываться функ
цией, и неважно, что они из себя представляют и когда были созданы.
Эта функция будет работать с числами (выполняя операцию умноже
ния), с двумя строками или со строкой и числом (выполняя операцию
повторения) и с любыми другими комбинациями объектов, поддержи
вающими ожидаемый интерфейс – даже с объектами, порожденными
на базе классов, которые мы еще пока не создали.
Кроме того, если функции будут переданы объекты, которые не под
держивают ожидаемый интерфейс, интерпретатор обнаружит ошибку
при выполнении выражения * и автоматически возбудит исключение.
Поэтому для нас совершенно бессмысленно предусматривать проверку
на наличие ошибок в программном коде. Фактически, добавив такую
проверку, мы ограничим область применения нашей функции, так
как она сможет работать только с теми типами объектов, которые мы
предусмотрели.
Это важнейшее отличие философии языка Python от языков програм
мирования со статической типизацией, таких как C++ и Java: про
граммный код на языке Python не делает предположений о конкрет
ных типах данных. В противном случае он сможет работать только
с теми типами данных, которые ожидались на момент его написания,
и он не будет поддерживать объекты других совместимых типов, кото
Второй пример: пересечение последовательностей 393
рые могут быть созданы в будущем. Проверку типа объекта можно вы
полнить с помощью таких средств, как встроенная функция type, но
в этом случае программный код потеряет свою гибкость. Вообще гово
ря, при программировании на языке Python во внимание принимают
ся интерфейсы объектов, а не типы данных.
Конечно, такая модель полиморфизма предполагает необходимость
тестирования программного кода на наличие ошибок, так как изза от
сутствия объявлений типов нет возможности с помощью компилятора
выявить некоторые виды ошибок на ранней стадии. Однако в обмен на
незначительное увеличение объема отладки мы получаем существен
ное уменьшение объема программного кода, который требуется напи
сать, и существенное увеличение его гибкости. На практике это озна
чает чистую победу.
Второй пример: пересечение
последовательностей
Рассмотрим второй пример функции, которая делает немного больше,
чем простое умножение аргументов, и продолжает иллюстрацию ос
нов функций.
В главе 13 мы написали цикл for, который выбирал элементы, общие
для двух строк. Там было замечено, что полезность этого программно
го кода не так велика, как могла бы быть, потому что он может рабо
тать только с определенными переменными и не может быть использо
ван повторно. Безусловно, можно было бы просто скопировать этот
блок кода и вставлять его везде, где потребуется, но такое решение
нельзя признать ни удачным, ни универсальным – нам попрежнему
придется редактировать каждую копию, изменяя имена последова
тельностей; изменение алгоритма также влечет за собой необходи
мость вносить изменения в каждую копию.
Определение
К настоящему моменту вы уже наверняка поняли, что решение этой
дилеммы заключается в том, чтобы оформить этот цикл for в виде
функции. Такой подход несет нам следующие преимущества:
• Оформив программный код в виде функции, мы получаем возмож
ность использовать его столько раз, сколько потребуется.
• Так как вызывающая программа может передавать функции про
извольные аргументы, функция сможет использоваться с любыми
двумя последовательностями (или итерируемыми объектами) для
получения их пересечения.
• Когда логика работы оформлена в виде функции, достаточно изме
нить программный код всего в одном месте, чтобы изменить способ
получения пересечения.
394 Глава 15. Основы функций
• Поместив функцию в файл модуля, ее можно будет импортировать
и использовать в любой программе на вашем компьютере.
В результате программный код, обернутый в функцию, превращается
в универсальную утилиту нахождения пересечения:
def intersect(seq1, seq2):
res = [] # Изначально пустой результат
for x in seq1: # Обход последовательности seq1
if x in seq2: # Общий элемент?
res.append(x) # Добавить в конец
return res
В том, чтобы преобразовать фрагмент кода из главы 13 в функцию, нет
ничего сложного – мы просто вложили оригинальную реализацию
в инструкцию def и присвоили имена объектам, с которыми она рабо
тает. Поскольку эта функция возвращает результат, мы также добави
ли инструкцию return, которая возвращает полученный объект ре
зультата вызывающей программе.
Вызов
Прежде чем функцию можно будет вызвать, ее необходимо создать.
Для этого нужно выполнить инструкцию def, либо введя ее в интерак
тивной оболочке, либо поместив файл модуля и выполнив операцию
импорта. Как только инструкция def будет выполнена, можно будет
вызывать функцию и передать ей два объекта последовательностей
в круглых скобках:
>>> s1 = "SPAM"
>>> s2 = "SCAM"
>>> intersect(s1, s2) # Строки
['S', 'A', 'M']
В данном примере мы передали функции две строки и получили спи
сок общих символов. Алгоритм работы функции можно выразить про
стой фразой: «Для всех элементов первого аргумента, если этот эле
мент присутствует и во втором аргументе, добавить его в конец резуль
тата». Этот алгоритм на языке Python описывается немного короче,
чем на естественном языке, но работает он точно так же.
Еще о полиморфизме
Как и любая другая функция в языке Python, функция intersect так
же является полиморфной. То есть она может обрабатывать объекты
произвольных типов при условии, что они поддерживают ожидаемый
интерфейс:
>>> x = intersect([1, 2, 3], (1, 4)) # Смешивание типов
>>> x # Сохраненный объект с результатом
[1]
Второй пример: пересечение последовательностей 395
На этот раз функции были переданы объекты разных типов – список
и кортеж – и это не помешало ей отыскивать общие элементы. Так как
отсутствует необходимость предварительного объявления типов аргу
ментов, функция intersect благополучно будет выполнять итерации
по объектам последовательностей любых типов при условии, что они
будут поддерживать ожидаемые интерфейсы.
Для функции intersect это означает, что первый объект должен обла
дать поддержкой циклов for, а второй – поддержкой оператора in, вы
полняющего проверку на вхождение. Любые два объекта, отвечающие
этим условиям, будут обработаны независимо от их типов, включая
как сами последовательности, такие как строки и списки, так и любые
итерируемые объекты, с которыми мы встречались в главе 13, вклю
чая файлы, словари и даже объекты, созданные на основе классов
и использующие перегрузку операторов (эту тему мы будем рассмат
ривать в шестой части книги).1
И снова, если функции передать объекты, которые не поддерживают
эти интерфейсы (например, числа), интерпретатор автоматически об
наружит несоответствие и возбудит исключение, т. е. именно то, что
нам требуется, и это лучше, чем добавление явной проверки типов ар
гументов. Отказываясь от реализации проверки типов и позволяя ин
терпретатору самому обнаруживать несоответствия, мы тем самым
уменьшаем объем программного кода и повышаем его гибкость.
Локальные переменные
Переменная res внутри функции intersect – это то, что в языке Python
называется локальной переменной, – имя, которое доступно только
программному коду внутри инструкции def и существует только во
время выполнения функции. Фактически, любые имена, которым тем
или иным способом были присвоены некоторые значения внутри функ
ции, по умолчанию классифицируются как локальные переменные.
1 Два важных замечания. Первое: с технической точки зрения файл может
использоваться только в качестве первого аргумента функции intersect, по
тому что во время первого же применения оператора in файл будет проска
нирован до конца. Например, такой вызов, как intersect(open('data1.txt'),
['line1\n', 'line2\n', 'line3\n']), будет работать, но вызов intersect(open
('data1.txt), open('data2.txt')) – нет, за исключением случая, когда пер
вый файл содержит единственную строку. Для настоящих последователь
ностей итерационный контекст вызывает метод iter для получения итера
тора, который всегда переустанавливается в начало последовательности,
но операции открытия и чтения файла приводят к исчерпанию итератора.
Второе: в случае с классами нам, возможно, пришлось бы использовать ме
тод перегрузки операторов __iter__ или более старый __getitem__, которые
будут описаны в главе 24, чтобы обеспечить поддержку ожидаемого итера
ционного протокола. В этом случае мы можем определить, что означает по
нятие итерации для наших данных.
396 Глава 15. Основы функций
Почти все имена в функции intersect являются локальными перемен
ными:
• Переменная res явно участвует в операции присваивания, поэтому
она – локальная переменная.
• Аргументы передаются через операцию присваивания, поэтому
seq1 и seq2 тоже локальные переменные.
• Цикл for присваивает элементы переменной, поэтому имя x также
является локальным.
Все эти локальные переменные появляются только в момент вызова
функции и исчезают, когда функция возвращает управление – инст
рукция return, стоящая в конце функции intersect, возвращает объ+
ект результата, а имя res исчезает. Однако, чтобы полностью исследо
вать понятие локальности, нам необходимо перейти к главе 16.
В заключение
В этой главе были представлены основные идеи, на которых основано
определение функции, – синтаксис и принцип действия инструкций
def и return, выражений вызова функций, а также суть и преимущест
ва полиморфизма в функциях языка Python. Как было показано, инст
рукция def – это исполняемый программный код, который создает
объект функции. Когда позднее производится вызов функции, переда
ча объектов производится за счет выполнения операции присваивания
(вспомните, в главе 6 говорилось, что присваивание в языке Python оз
начает передачу ссылок на объекты, которые фактически реализова
ны в виде указателей), а вычисленные значения возвращаются обрат
но с помощью инструкции return. В этой главе мы также приступили
к изучению таких понятий, как локальные переменные и области ви
димости, но более подробно эти темы будут рассматриваться в главе
16. Сначала всетаки ответьте на контрольные вопросы.
Закрепление пройденного
Контрольные вопросы
1. Какие преимущества несет использование функций?
2. В какой момент времени интерпретатор Python создает функции?
3. Что возвращает функция, если в ней отсутствует инструкция return?
4. Когда выполняется программный код, вложенный в инструкцию
определения функции?
5. Почему нежелательно выполнять проверку типов объектов, переда
ваемых функции?
Закрепление пройденного 397
Ответы
1. Функции представляют собой основной способ избежать избыточ
ности программного кода – выделение программного кода в виде
функции означает, что в будущем нам потребуется изменить един
ственную копию действующего кода. Кроме того, функции – это ос
новные блоки программного кода многократного пользования – за
ключение программного кода в функции превращает его в инстру
мент многократного пользования, который может вызываться раз
личными программами. Наконец, функции позволяют разбить
сложную систему на небольшие и легко управляемые части, каж
дая из которых может разрабатываться отдельно.
2. Функция создается, когда интерпретатор достигает инструкции
def и выполняет ее; эта инструкция создает объект функции и свя
зывает его с именем функции. Обычно это происходит, когда файл
модуля, включающего функцию, импортируется другим модулем
(вспомните, что во время импорта программный код файла выпол
няется от начала до конца, включая и инструкции def), но это мо
жет происходить, когда инструкция def вводится в интерактивной
оболочке или во время выполнения вложенного блока другой инст
рукции, такой как if.
3. Когда поток управления достигает конца тела функции, не встре
тив на своем пути инструкцию return, по умолчанию функция воз
вращает объект None. Такие функции обычно вызываются как инст
рукции выражений, так как присваивание объекта None перемен
ной в целом бессмысленно.
4. Тело функции (программный код, вложенный в инструкцию опре
деления функции) выполняется, когда позднее производится вызов
функции. Тело функции выполняется всякий раз, когда происхо
дит вызов.
5. Проверка типов объектов, передаваемых функции, – это надежный
способ ограничить их гибкость, потому что в этом случае функция
сможет работать только с объектами определенных типов. Без та
кой проверки функция наверняка сможет обрабатывать целую ка
тегорию типов объектов – любые объекты, поддерживающие интер
фейс, ожидаемый функцией, смогут быть обработаны. (Термин ин+
терфейс означает набор методов и операций, которые используют
ся функцией.)
16
Области видимости и аргументы
В главе 15 были описаны основы определения и вызова функций. Как
мы видели, базовая модель функций в языке Python достаточно проста
в использовании. В этой главе будут представлены подробности, лежа
щие в основе областей видимости – мест, где определяются перемен
ные и где выполняется их поиск, – и механизма передачи аргумен+
тов – способа передачи объектов в функции.
Правила видимости
Теперь, когда вы готовы приступить к созданию своих собственных
функций, нам необходимо более формально определить, что означают
имена в языке Python. Всякий раз, когда в программе используется
некоторое имя, интерпретатор создает, изменяет или отыскивает это
имя в пространстве имен – в области, где находятся имена. Когда мы
говорим о поиске значения имени применительно к программному ко
ду, под термином область видимости подразумевается пространство
имен: т. е. место в программном коде, где имени было присвоено зна
чение, определяет область видимости этого имени для программного
кода.
Практически все, что имеет отношение к именам, включая классифи
кацию областей видимости, в языке Python связано с операциями при
сваивания. Как мы уже видели, имена появляются в тот момент, когда
им впервые присваиваются некоторые значения, и прежде чем имена
смогут быть использованы, им необходимо присвоить значения. По
скольку имена не объявляются заранее, интерпретатор Python по ме
стоположению операции присваивания связывает имя с конкретным
пространством имен. Другими словами, место, где выполняется при
Правила видимости 399
сваивание, определяет пространство имен, в котором будет находиться
имя, а, следовательно, и область его видимости.
Помимо упаковки программного кода функции привносят в програм
мы еще один слой пространства имен – по умолчанию все имена, зна
чения которым присваиваются внутри функции, ассоциируются с про
странством имен этой функции и никак иначе. Это означает, что:
• Имена, определяемые внутри инструкции def, видны только про
граммному коду внутри инструкции def. К этим именам нельзя об
ратиться за пределами функции.
• Имена, определяемые внутри инструкции def, не вступают в кон
фликт с именами, находящимися за пределами инструкции def, да
же если и там и там присутствуют одинаковые имена. Имя X, кото
рому присвоено значение за пределами данной инструкции def (на
пример, в другой инструкции def или на верхнем уровне модуля)
полностью отлично от имени X, которому присвоено значение внут
ри инструкции def.
В любом случае область видимости переменной (где она может исполь
зоваться) всегда определяется местом, где ей было присвоено значение,
и никакого отношения не имеет к месту, откуда была вызвана функ
ция. Если присваивание переменной выполняется внутри инструкции
def, переменная является локальной для этой функции; если присваи
вание производится за пределами инструкции def, она является гло+
бальной для всего файла. Мы называем это лексической областью ви+
димости, потому что области видимости переменных целиком опреде
ляются местоположением этих переменных в исходных текстах про
граммы, а не местом, откуда вызываются функции.
Например, в следующем файле модуля инструкция присваивания X = 99
создает глобальную переменную с именем X (она видима из любого мес
та в файле), а инструкция X = 88 создает локальную переменную X (она
видима только внутри инструкции def):
X = 99
def func():
X = 88
Даже при том, что обе переменные имеют имя X, области видимости де
лают их различными. Таким образом, области видимости функций по
зволяют избежать конфликтов имен в программах и превращают
функции в самостоятельные элементы программ.
Основы видимости имен в языке Python
До того как мы начали писать функции, весь программный код разме
щался на верхнем уровне модуля (например, он не был вложен в инст
рукции def), поэтому все имена, которые мы использовали, либо нахо
400 Глава 16. Области видимости и аргументы
дились на верхнем уровне в модуле, либо относились к предопределен
ным именам языка Python (например, open).1 Функции образуют вло
женные пространства имен (области видимости), которые ограничивают
доступ к используемым в них именам, благодаря чему имена внутри
функций не вступают в конфликт с именами за их пределами (внутри
модуля или внутри других функций). Повторю еще раз, функции обра
зуют локальную область видимости, а модули – глобальную. Эти две
области взаимосвязаны между собой следующим образом:
• Объемлющий модуль – это глобальная область видимости. Каж
дый модуль – это глобальная область видимости, т. е. пространство
имен, в котором создаются переменные на верхнем уровне в файле
модуля. Глобальные переменные для внешнего мира становятся ат
рибутами объекта модуля, но внутри модуля могут использоваться
как простые переменные.
• Глобальная область видимости охватывает единственный файл.
Не надо заблуждаться насчет слова «глобальный» – имена на верх
нем уровне файла являются глобальными только для программного
кода в этом файле. На самом деле в языке Python не существует та
кого понятия, как всеобъемлющая глобальная для всех файлов об
ласть видимости. Имена всегда относятся к какомунибудь модулю
и всегда необходимо явно импортировать модуль, чтобы иметь воз
можность использовать имена, определяемые в нем. Когда вы слы
шите слово «глобальный», подразумевайте «модуль».
• Каждый вызов функции создает новую локальную область види!
мости. Всякий раз, когда вызывается функция, создается новая ло
кальная область видимости – т. е. пространство имен, в котором на
ходятся имена, определяемые внутри функции. Каждую инструк
цию def (и выражение lambda) можно представить себе как определе
ние новой локальной области видимости. Но так как язык Python
позволяет функциям вызывать самих себя в цикле (этот прием из
вестен как рекурсия), локальная область видимости с технической
точки зрения соответствует вызову функции – другими словами,
каждый вызов создает новое локальное пространство имен. Рекур
сию удобно использовать, когда выполняется обработка данных,
структура которых заранее неизвестна.
• Операция присваивания создает локальные имена, если они не бы!
ли объявлены глобальными. По умолчанию все имена, которым
присваиваются значения внутри функции, помещаются в локаль
ную область видимости (пространство имен, ассоциированное с вы
зовом функции). Если необходимо присвоить значение имени верх
1 Программный код, который вводится в интерактивной оболочке, в дейст
вительности находится на уровне модуля __main__, поэтому имена, созда
ваемые в интерактивной оболочке, также находятся внутри модуля и сле
дуют обычным правилам видимости. Подробнее о модулях будет рассказы
ваться в пятой части книги.
Правила видимости 401
него уровня в модуле, который вмещает функцию, это имя необхо
димо объявить внутри функции глобальным с помощью инструк
ции global.
• Все остальные имена являются локальными в объемлющей облас!
ти видимости, глобальными или встроенными. Предполагается,
что имена, которым не присваивались значения внутри определе
ния функции, находятся в объемлющей локальной области види
мости (внутри объемлющей инструкции def), глобальной (в про
странстве имен модуля) или встроенной (предопределенные имена
в модуле __builtin__).
Обратите внимание, что любые операции присваивания, выполняемые
внутри функции, классифицируют имена как локальные: инструкция
=, инструкция import, инструкция def, передача аргументов и т. д. Сле
дует также заметить, что операции непосредственного изменения объ
ектов не рассматривают имена как локальные – это свойственно толь
ко операциям присваивания. Например, если имени L присвоен спи
сок, определенный на верхнем уровне в модуле, то такая инструкция,
как L.append(X), внутри функции не будет классифицировать имя L как
локальное, тогда как инструкция L = X будет. В первом случае список L
будет найден в глобальной области видимости и инструкция изменит
глобальный список.
Разрешение имен: правило LEGB
Если предыдущий раздел показался вам запутанным, спешу успоко
ить – в действительности все сводится к трем простым правилам. Для
инструкции def:
• Поиск имен ведется самое большее в четырех областях видимости:
локальной, затем в объемлющей функции (если таковая имеется),
затем в глобальной и, наконец, во встроенной.
• По умолчанию операция присваивания создает локальные имена.
• Глобальные объявления отображают имена на область видимости
вмещающего модуля.
Другими словами, все имена, которым присваиваются значения внут
ри инструкции def (или внутри выражения lambda, с которым мы позна
комимся позже), по умолчанию являются локальными; функции могут
использовать имена в лексически (т. е., физически) объемлющих функ
циях и в глобальной области видимости, но чтобы иметь возможность
изменять их, они должны быть объявлены глобальными. Схема разре
шения имен в языке Python иногда называется правилом LEGB, назва
ние которого состоит из первых букв названий областей видимости:
• Когда внутри функции выполняется обращение к неизвестному
имени, интерпретатор пытается отыскать его в четырех областях
видимости – в локальной (local, L), затем в локальной области лю
бой объемлющей инструкции def (enclosing, E) или в выражении
402 Глава 16. Области видимости и аргументы
lambda, затем в глобальной (global, G) и, наконец, во встроенной
(builtin, B). Поиск завершается, как только будет найдено первое
подходящее имя.
• Когда внутри функции выполняется операция присваивания (а не
обращение к имени внутри выражения), интерпретатор всегда соз
дает или изменяет имя в локальной области видимости, если в этой
функции оно не было объявлено глобальным.
• Когда выполняется присваивание имени за пределами функции (т. е.
на уровне модуля или в интерактивной оболочке), локальная область
видимости совпадает с глобальной – с пространством имен модуля.
На рис. 16.1 показаны четыре области видимости в языке Python. При
мечательно, что второй области видимости E – в области видимости
объемлющей инструкции def или выражения lambda, с технической
точки зрения может находиться несколько вложенных друг в друга об
ластей. Но они появляются, только когда имеются вложенные друг
в друга функции.1
1 В первом издании этой книги правило поиска в областях видимости было
названо «правилом LGB». Уровень объемлющей инструкции def был добав
лен в язык Python позднее, чтобы ликвидировать необходимость явной пе
редачи объемлющей области видимости. Но эта тема едва ли представляет
интерес для начинающих, поэтому мы рассмотрим ее позднее в этой главе.
Рис. 16.1. Правило LEGB поиска имен в областях видимости.
Когда производится обращение к переменной, интерпретатор Python
начинает искать ее в следующее порядке: в локальной области видимости,
во всех локальных областях видимости объемлющих функций, в глобальной
области видимости и, наконец, во встроенной области видимости.
Поиск завершается, как только будет найдено первое подходящее имя.
Место, где в программном коде производится присваивание значения
переменной, обычно определяет ее область видимости
Имена, определяемые тем или иным способом внутри функции
(инструкция def или lambda), которые не были объявлены как глобальные.
Встроенная область видимости (Python)
Глобальная область видимости (модуль)
Предопределенные имена в модуле встроенных имен:
open, range, SyntaxError…
Имена, определяемые на верхнем уровне модуля
или объявленные внутри инструкций def как глобальные.
Локальные области видимости объемлющих функций
Имена в локальной области видимости любой и всех объемлющих
функций (инструкция def или lambda), изнутри наружу.
Локальная область видимости (функция)
Правила видимости 403
Кроме того, имейте в виду, что эти правила применяются только к про
стым именам переменных (таким как spam). В пятой и шестой частях
книги мы увидим, что полные имена атрибутов (такие как object.spam)
принадлежат определенным объектам и к ним применяются иные пра
вила поиска, отличные от правил поиска в областях видимости, кото
рые мы только что рассмотрели. При обращении к атрибутам (имя, сле
дующее за точкой) поиск производится в одном или более объектах, а не
в областях видимости, что связано с механизмом, который называется
«наследованием» (рассматривается в шестой части книги).
Пример области видимости
Рассмотрим более крупный пример, демонстрирующий суть областей
видимости. Предположим, что следующий фрагмент составляет содер
жимое файла модуля:
# Глобальная область видимости
X = 99 # X и func определены в модуле: глобальная область
def func(Y): # Y и Z определены в функции: локальная область
# Локальная область видимости
Z = X + Y # X – глобальная переменная
return Z
func(1) # func в модуле: result=100
В этом примере функция и модуль используют в своей работе несколь
ко имен. Применяя правила области видимости языка Python, можно
классифицировать эти имена следующим образом:
Глобальные имена: X и func
X – это глобальное имя, так как она объявлена на верхнем уровне
модуля. К ней можно обращаться внутри функции, не объявляя ее
глобальной. func – это глобальное имя по тем же причинам. Инст
рукция def связывает объект функции с именем func на верхнем
уровне модуля.
Локальные имена: Y и Z
Имена Y и Z являются локальными (и существуют только во время
выполнения функции), потому что присваивание значений обеим
именам осуществляется внутри определения функции: присваива
ние переменной Z производится с помощью инструкции =, а Y – пото
му что аргументы всегда передаются через операцию присваивания.
Суть такого разделения имен заключается в том, что локальные пере
менные играют роль временных имен, которые необходимы только на
время исполнения функции. Например, в предыдущем примере аргу
мент Y и результат сложения Z существуют только внутри функции –
эти имена не пересекаются с вмещающим пространством имен модуля
(или с пространствами имен любых других функций).
404 Глава 16. Области видимости и аргументы
Разделение имен на глобальные и локальные также облегчает понима
ние функций, так как большинство имен, используемых в функции,
появляются непосредственно в самой функции, а не в какомто дру
гом, произвольном месте внутри модуля. Кроме того, можно быть уве
ренным, что локальные имена не будут изменены любой другой уда
ленной функцией в программе, а это в свою очередь упрощает отладку
программ.
Встроенная область видимости
Встроенная область видимости, уже упоминавшаяся выше, немного
проще, чем можно было бы подумать. В действительности, встроенная
область видимости – это всего лишь встроенный модуль с именем
__builtin__, но для того, чтобы использовать имя builtin, необходимо
импортировать модуль __builtin__, потому что это имя само по себе не
является встроенным.
Я вполне серьезен! Встроенная область видимости реализована как мо
дуль стандартной библиотеки с именем __builtin__, но само имя не на
ходится во встроенной области видимости, поэтому, чтобы исследо
вать его, необходимо импортировать модуль. После этого можно будет
воспользоваться функцией dir, чтобы получить список предопреде
ленных имен:
>>> import __builtin__
>>> dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError',
'DeprecationWarning', 'EOFError', 'Ellipsis',
...множество других имен опущено...
'str', 'super', 'tuple', 'type', 'unichr', 'unicode',
'vars', 'xrange', 'zip']
Имена в этом списке составляют встроенную область видимости языка
Python. Примерно первая половина списка – это встроенные исключе
ния, а вторая – встроенные функции. Согласно правилу LEGB интер
претатор выполняет поиск имен в этом модуле в последнюю очередь.
Все имена из этого списка вы получаете в свое распоряжение по умол
чанию, т. е., чтобы их использовать, не требуется импортировать ка
киелибо модули. Благодаря этому существует два способа вызвать
встроенную функцию – используя правило LEGB или импортируя мо
дуль __builtin__ вручную:
>>> zip # Обычный способ
<встроенная функция zip>
>>> import __builtin__ # Более сложный способ
>>> __builtin__.zip
<встроенная функция zip>
Второй способ иногда удобно использовать при выполнении сложных
действий. Внимательный читатель может заметить, что согласно пра
вилу LEGB поиск имени прекращается, когда будет найдено первое
Правила видимости 405
подходящее имя, откуда следует, что имена в локальной области види
мости могут переопределять переменные с теми же самыми именами,
как в глобальной, так и во встроенной области видимости, а глобальные
имена могут переопределять имена во встроенной области видимости.
Например, внутри функции можно создать переменную с именем open:
def hider():
open = 'spam' # Локальная переменная, переопределяет встроенное имя
...
open('data.txt') # В этой области видимости файл не будет открыт!
Однако в результате этого встроенная функция с именем open, которая
располагается во встроенной области видимости, окажется скрытой.
Обычно это считается ошибкой, и самое неприятное, что интерпретатор
Python не выведет сообщения с предупреждением (иногда в програм
мировании возникают ситуации, когда действительно бывает необхо
димо подменить встроенные имена, переопределив их в своем коде).1
Таким же способом функции могут переопределять имена глобальных
переменных, определяя локальные переменные с теми же именами:
X = 88 # Глобальная переменная X
def func():
X = 99 # Локальная переменная X: переопределяет глобальную
func()
print X # Выведет 88: значение не изменилось
В этом примере операция присваивания создает локальную перемен
ную X, которая совершенно отлична от глобальной переменной X, опре
деленной в модуле, за пределами функции. Вследствие этого внутри
функции нет никакой возможности изменить переменную, располо
женную за пределами функции, если не добавить объявление global
в инструкцию def (как описано в следующем разделе).
1 Вот вам еще один пример того, что допустимо в языке Python, но чего не
следует делать: имена True и False – это всего лишь переменные во встроен
ной области видимости и вполне возможно их переопределить с помощью
такой инструкции: True = False. При этом вы не нарушите общую логиче
скую целостность! Эта инструкция всего лишь переопределит значение сло
ва True в единственной области видимости. Что еще интереснее, можно вы
полнить даже такую инструкцию: __builtin__.True = False, и тогда истина
станет ложью для всей программы! Такая возможность в будущем, скорее
всего, будет ликвидирована (кстати, она отправляет среду IDLE в странное
состояние, когда пользовательский процесс сбрасывается). Однако такой
прием удобен для создателей инструментальных средств, которые вынуж
дены переопределять встроенные имена, такие как open, для нужд специа
лизированных функций. Кроме того, следует отметить, что инструменты
сторонних производителей, такие как PyChecker, выводят предупрежде
ния о типичных ошибках программирования, включая случайное пере
определение встроенных имен (эта возможность, встроенная в PyChecker,
известна как «shadowing» (сокрытие)).
406 Глава 16. Области видимости и аргументы
Инструкция global
Инструкция global – это единственное, что в языке Python отдаленно
напоминает инструкцию объявления. Однако это не объявление типа
или размера – это объявление пространства имен. Она сообщает интер
претатору, что функция будет изменять одно или более глобальных
имен, т. е. имен, которые находятся в области видимости (в простран
стве имен) вмещающего модуля. Инструкция global уже упоминалась
выше, а ниже приводится общая информация о ней:
• Глобальные имена – это имена, которые определены на верхнем
уровне вмещающего модуля.
• Глобальные имена должны объявляться, только если им будут при
сваиваться значения внутри функций.
• Обращаться к глобальным именам внутри функций можно и без
объявления их глобальными.
Инструкция global состоит из слова global и следующих за ним одного
или более имен, разделенных запятыми, которые будут отображены на
область видимости вмещающего модуля при обращении к ним или при
выполнении операции присваивания внутри тела функции. Например:
X = 88 # Глобальная переменная X
def func():
global X
X = 99 # Глобальная переменная X: за пределами инструкции def
func()
print X # Выведет 99
В этом примере было добавлено объявление global, поэтому имя X внут
ри инструкции def теперь ссылается на переменную X за ее пределами.
На этот раз оба имени представляют одну и ту же переменную. Ниже
приводится более сложный пример использования инструкции global:
y, z = 1, 2 # Глобальные переменные в модуле
def all_global():
global x # Объявляется глобальной для присваивания
x = y + z # Объявлять y, z не требуется: применяется правило LEGB
Здесь все три переменные x, y и z, используемые внутри функции
all_global, являются глобальными. Переменные y и z глобальными
считаются потому, что внутри функции им не присваиваются значе
ния. Переменная x считается глобальной потому, что она перечислена
в инструкции global, которая явно отображает ее в область видимости
модуля. Без инструкции global переменная x считалась бы локальной,
так как ей присваивается значение внутри функции.
Обратите внимание: переменные y и z не были объявлены как глобаль
ные, однако, следуя правилу LEGB, интерпретатор автоматически
отыщет их в области видимости модуля. Кроме того, следует отметить,
Инструкция global 407
что переменная x может не существовать в модуле на момент вызова
функции – в этом случае операция присваивания в функции создаст
переменную x в области видимости модуля.
Минимизируйте количество глобальных переменных
По умолчанию имена, значения которым присваиваются внутри функ
ций, являются локальными, поэтому, если необходимо изменять име
на за пределами функций, необходимо использовать инструкцию glo
bal. Это сделано в соответствии с общей идеологией языка Python –
чтобы сделать чтото «неправильное», необходимо писать дополни
тельный программный код. Иногда бывает удобно использовать гло
бальные переменные, однако по умолчанию, если переменной при
сваивается значение внутри инструкции def, она становится локаль
ной, потому что это, как правило, наилучшее решение. Изменение
глобальных переменных может привести к появлению проблем, хоро
шо известных в разработке программного обеспечения: когда значе
ния переменных зависят от порядка, в каком вызываются функции,
это может осложнить отладку программы.
Рассмотрим следующий пример модуля:
X = 99
def func1():
global X
X = 88
def func2():
global X
X = 77
Теперь представим, что перед нами стоит задача модифицировать этот
модуль или использовать его в другой программе. Каким будет значе
ние переменной X? На самом деле этот вопрос не имеет смысла, если не
указывать момент времени – значение переменной X зависит от вы
бранного момента времени, так как оно зависит от того, какая функ
ция вызывалась последней (этого нельзя сказать только по одному
файлу модуля).
В результате, чтобы понять этот программный код, необходимо знать
путь потока выполнения всей программы. И если возникнет необходи
мость изменить этот модуль или использовать его в другой программе,
необходимо будет удерживать в своей памяти всю программу. В этой си
туации невозможно использовать одну функцию, не принимая во вни
мание другую. От них зависит значение глобальной переменной. Это
типичная проблема глобальных переменных – они вообще делают про
граммный код более сложным для понимания и использования, в отли
чие от кода, состоящего только из независимых функций, логика вы
полнения которых построена на использовании локальных имен.
408 Глава 16. Области видимости и аргументы
С другой стороны, за исключением случаев использования классов
и принципов объектноориентированного программирования, глобаль
ные переменные являются едва ли не самым удобным способом хране
ния информации о состоянии (информации, которую необходимо хра
нить между вызовами функции) – локальные переменные исчезают,
когда функция возвращает управление, а глобальные – нет. Это мож
но реализовать с помощью других приемов, таких как использование
изменяемых аргументов по умолчанию и области видимости объемлю
щих функций, но они слишком сложны по сравнению с глобальными
переменными.
Некоторые программы определяют отдельный глобальный модуль для
хранения всех глобальных имен – если это предусмотрено заранее, это
не так вредно. Кроме того, программы на языке Python, использую
щие многопоточную модель выполнения для параллельной обработки
данных, тесно связаны с глобальными переменными – они играют
роль памяти, совместно используемой функциями, исполняющимися
в параллельных потоках, и выступают в качестве средств связи (опи
сание многопоточной модели выполнения выходит далеко за рамки
данной книги, поэтому за дополнительной информацией обращайтесь
к книгам, упомянутым в предисловии).
А пока, особенно если вы не имеете достаточного опыта программиро
вания, по мере возможности избегайте искушения использовать гло
бальные переменные (старайтесь организовать обмен данными через
параметры и возвращаемые значения). Шесть месяцев спустя вы и ва
ши коллеги будете рады, что поступали таким образом.
Минимизируйте количество изменений
в соседнихфайлах
В этом разделе описывается еще одна проблема, связанная с областя
ми видимости: несмотря на то, что существует возможность непо
средственно изменять переменные в другом файле, этого следует избе
гать. Рассмотрим следующие два модуля:
# first.py
X = 99
# second.py
import first
first.X = 88
Первый модуль определяет переменную X, а второй – изменяет ее зна
чение в инструкции присваивания. Обратите внимание, что для этого
во втором модуле необходимо импортировать первый модуль. Как вы
уже знаете, каждый модуль представляет собой отдельное пространст
во имен (где размещаются переменные), поэтому, чтобы увидеть содер
жимое одного модуля во втором, его необходимо импортировать. В тер
минах этой главы глобальная область видимости модуля после импор
Инструкция global 409
тирования превращается в пространство имен атрибутов объекта мо
дуля – импортирующий модуль автоматически получает доступ ко
всем глобальным переменным импортируемого модуля, поэтому при
импортировании глобальная область видимости модуля, по сути,
трансформируется в пространство имен атрибутов.
После импортирования первого модуля второй модуль присваивает его
переменной новое значение. Проблема состоит в том, что эта операция
выполняется слишком неявно: для любого, кто занимается сопровож
дением или использует первый модуль, будет сложно догадаться, что
какойто другой модуль, далеко отстоящий в цепочке импорта, может
изменить значение переменной X. В конце концов, второй модуль мо
жет находиться вообще в другом каталоге, изза чего его сложно будет
найти. Здесь также устанавливается слишком тесная зависимость ме
жду этими двумя модулями, потому что оба они зависят от значения
переменной X, будет трудно понять или повторно использовать один
модуль без другого.
И этом случае лучшая рекомендация – не использовать такую возмож
ность; лучше организовать взаимодействие между модулями через вы
зовы функций, передавая им аргументы и получая возвращаемые зна
чения. В данном конкретном случае было бы лучше добавить функ
цию доступа, которая будет выполнять изменения:
# first.py
X = 99
def setX(new):
global X
X = new
# second.py
import first
first.setX(88)
Для этого потребуется добавить дополнительный программный код,
но он имеет огромное значение в смысле обеспечения удобочитаемости
и удобства в сопровождении – когда тот, кто впервые будет знакомить
ся с модулем, увидит функцию, он будет знать, что это часть интер
фейса модуля и поймет, что переменная X может изменяться. Мы не
можем полностью избавиться от изменений в соседних файлах, однако
здравый смысл диктует необходимость минимизировать их число, ес
ли это не является широко распространенным явлением в программе.
Другие способы доступа к глобальным переменным
Интересно, что благодаря трансформации глобальных переменных в ат
рибуты объекта загруженного модуля существует возможность имити
ровать инструкцию global, импортируя вмещающий модуль и выпол
няя присваивание его атрибутам, как показано в следующем примере
модуля. Программный код в этом файле в одном случае импортирует
вмещающий модуль по имени, а в другом использует таблицу загру
410 Глава 16. Области видимости и аргументы
женных модулей sys.modules (подробнее об этой таблице рассказывает
ся в главе 21):
# thismod.py
var = 99 # Глобальная переменная == атрибут модуля
def local():
var = 0 # Изменяется локальная переменная
def glob1():
global var # Глобальное объявление (обычное)
var += 1 # Изменяется глобальная переменная
def glob2():
var = 0 # Изменяется локальная переменная
import thismod # Импорт самого себя
thismod.var += 1 # Изменяется глобальная переменная
def glob3():
var = 0 # Изменяется локальная переменная
import sys # Импорт системной таблицы
glob = sys.modules['thismod'] # Получить объект модуля
# (или использовать __name__)
glob.var += 1 # Изменяется глобальная переменная
def test():
print var
local(); glob1(); glob2(); glob3()
print var
После запуска будут добавлены 3 глобальные переменные (только пер
вая функция ничего не добавляет):
>>> import thismod
>>> thismod.test()
99
102
>>> thismod.var
102
Этот пример иллюстрирует эквивалентность глобальных имен и атри
бутов модуля, однако, чтобы явно выразить свои намерения, нам по
требовалось написать немного больше, чем при использовании инст
рукции global.
Области видимости и вложенные функции
До сих пор мы не еще рассматривали одну часть правила области види
мости в языке Python (просто потому, что с нею редко сталкиваются на
практике). Однако пришло время более пристально посмотреть на E
в правиле LEGB. Уровень E появился относительно недавно (он был
добавлен в Python 2.2) – это локальные области видимости объемлю
щих инструкций def. Иногда объемлющие области видимости называ
Области видимости и вложенные функции 411
ют статически вложенными областями видимости. В действитель
ности вложение является лексическим – вложенные области видимо
сти соответствуют физически вложенным блокам программного кода
в исходных текстах программы.
В Python 3.0 предполагается появление инструкции nonlocal, ко
торая позволит получать доступ на запись к переменным в облас
тях видимости объемлющих функций, так же, как нынешняя
инструкция global позволяет получить доступ на запись к облас
ти видимости объемлющего модуля. Синтаксически эта инструк
ция будет выглядеть так же, как инструкция global, только в ней
будет использоваться слово nonlocal. Однако это в будущем, по
этому дополнительную информацию ищите в примечаниях к вы
пуску 3.0.
Вложенные области видимости
С появлением областей видимости вложенных функций правила поис
ка переменных стали немного более сложными. Внутри функции:
• Операция присваивания (X = value) создает или изменяет имя X в те
кущей локальной области видимости по умолчанию. Если имя X объ
явлено глобальным внутри функции, операция присваивания созда
ет или изменяет имя X в области видимости объемлющего модуля.
• При обращении к переменной (X) поиск имени X сначала произво
дится в локальной области видимости (функции); затем в локаль
ных областях видимости всех лексически объемлющих функций,
изнутри наружу; затем в текущей глобальной области видимости
(в модуле); и, наконец, во встроенной области видимости (модуль
__builtin__). Поиск имен, объявленных в инструкции global, начи
нается сразу с глобальной области видимости.
Обратите внимание, что инструкция global отображает имена в область
видимости объемлющего модуля. Когда имеются вложенные функ
ции, можно получить значения переменных в объемлющих функциях,
но их нельзя изменить. Чтобы пояснить эти положения, рассмотрим
их на примере программного кода.
Примеры вложенных областей видимости
Ниже приводится пример вложенной области видимости:
def f1():
x = 88
def f2():
print x
f2()
f1() # Выведет 88
Прежде всего – это вполне допустимый программный код на языке Py
thon: инструкция def – это обычная исполняемая инструкция, которая
412 Глава 16. Области видимости и аргументы
может появляться в любом месте программы, где могут появляться
любые другие инструкции, включая вложение в другую инструкцию
def. В этом примере вложенная инструкция def исполняется в момент
вызова функции f1 – она создает функцию и связывает ее с именем f2,
которое является локальным и размещается в локальной области ви
димости функции f1. В некотором смысле f2 – это временная функция,
которая существует только во время работы (и видима только для про
граммного кода) объемлющей функции f1.
Однако, обратите внимание, что происходит внутри функции f2: когда
производится вывод переменной x, она ссылается на переменную x
в локальной области видимости объемлющей функции f1. Функции
имеют возможность обращаться к именам, которые физически распо
лагаются в любых объемлющих инструкциях def, и имя x в функции
f2 автоматически отображается на имя x в функции f1 в соответствии
с правилом поиска LEGB.
Это правило поиска в объемлющих областях видимости выполняется,
даже если объемлющая функция фактически уже вернула управле
ние. Например, следующий фрагмент определяет функцию, которая
создает и возвращает другую функцию:
def f1():
x = 88
def f2():
print x
return f2
action = f1() # Создает и возвращает функцию
action() # Вызов этой функции: выведет 88
В этом фрагменте при вызове action фактически запускается функция,
созданная во время исполнения функции f1. Функция f2 помнит пере
менную x в области видимости объемлющей функции f1, которая уже
неактивна.
Фабричные функции
В зависимости от того, кому задается вопрос о том, как называется та
кое поведение, можно услышать такие термины, как замыкание или
фабричная функция, – объект функции, который сохраняет значения
в объемлющих областях видимости, даже тогда, когда эти области мо
гут прекратить свое существование. Классы (описываются в шестой
части книги) обычно лучше подходят для сохранения состояния, пото
му что они позволяют делать это явно, посредством присваивания зна
чений атрибутам, тем не менее, подобные функции обеспечивают дру
гую альтернативу.
Например, фабричные функции иногда используются в программах,
когда необходимо создавать обработчики событий прямо в процессе
исполнения, в соответствии со сложившимися условиями (например,
Области видимости и вложенные функции 413
когда желательно запретить пользователю вводить данные). Рассмот
рим в качестве примера следующую функцию:
>>> def maker(N):
... def action(X):
... return X ** N
... return action
...
Здесь определяется внешняя функция, которая просто создает и воз
вращает вложенную функцию, не вызывая ее. Если вызвать внешнюю
функцию:
>>> f = maker(2) # Запишет 2 в N
>>> f
<function action at 0x014720B0>
она вернет ссылку на созданную ею внутреннюю функцию, созданную
при выполнении вложенной инструкции def. Если теперь вызвать то,
что было получено от внешней функции:
>>> f(3) # Запишет 3 в X, в N попрежнему хранится число 2
9
>>> f(4) # 4 ** 2
16
будет вызвана вложенная функция, с именем action внутри функции
maker. Самое необычное здесь то, что вложенная функция продолжает
хранить число 2, значение переменной N в функции maker даже при
том, что к моменту вызова функции action функция maker уже завер
шила свою работу и вернула управление. В действительности имя N из
объемлющей локальной области видимости сохраняется как информа
ция о состоянии, присоединенная к функции action, и мы получаем об
ратно значение аргумента, возведенное в квадрат.
Теперь, если снова вызвать внешнюю функцию, мы получим новую
вложенную функцию уже с другой информацией о состоянии, присо
единенной к ней, – в результате вместо квадрата будет вычисляться
куб аргумента, но ранее сохраненная функция попрежнему будет воз
вращать квадрат аргумента:
>>> g = maker(3)
>>> g(3) # 3 ** 3
27
>>> f(3) # 3 ** 2
9
Это довольно сложный прием, который вам вряд ли часто придется час
то встречать на практике, впрочем, он распространен среди программи
стов, обладающих опытом работы с функциональными языками про
граммирования (и иногда его можно встретить в выражениях lambda,
как будет описано далее). Вообще классы, которые будут обсуждаться
позднее, лучше подходят на роль «памяти», как в данном случае, пото
414 Глава 16. Области видимости и аргументы
му что они обеспечивают явное сохранение информации. Помимо клас
сов основными средствами хранения информации о состоянии функ
ций в языке Python являются глобальные переменные, объемлющие
области видимости, как в данном случае, и аргументы по умолчанию.
Сохранение состояния объемлющей области видимости
с помощью аргументов по умолчанию
В предыдущих версиях Python такой программный код, как в преды
дущем разделе, терпел неудачу изза отсутствия вложенных областей
видимости в инструкциях def – при обращении к переменной внутри
функции f2 поиск производился сначала в локальной области видимо
сти (f2), затем в глобальной (программный код за пределами f1) и за
тем во встроенной области видимости. Области видимости объемлю
щих функций не просматривались, что могло приводить к ошибке.
Чтобы разрешить ситуацию, программисты обычно использовали зна
чения аргументов по умолчанию для передачи (сохранения) объектов,
расположенных в объемлющей области видимости:
def f1():
x = 88
def f2(x=x):
print x
f2()
f1() # Выведет 88
Этот фрагмент будет работать во всех версиях Python, и такой подход
попрежнему можно встретить в существующих программах на языке
Python. Аргументы со значениями по умолчанию мы рассмотрим ниже,
в этой же главе. А пока в двух словах замечу, что конструкция arg = val
в заголовке инструкции def означает, что аргумент arg по умолчанию
будет иметь значение val, если функции не передается какоголибо
другого значения.
В измененной версии f2 запись x=x означает, что аргумент x по умолча
нию будет иметь значение переменной x объемлющей области видимо
сти. Поскольку значение для второго имени x вычисляется еще до то
го, как интерпретатор Python войдет во вложенную инструкцию def,
оно все еще ссылается на имя x в функции f1. В результате в значении
по умолчанию запоминается значение переменной x в функции f1 (т. е.
объект 88).
Все это довольно сложно и полностью зависит от того, когда вычисля
ется значение по умолчанию. Фактически поиск во вложенных облас
тях видимости был добавлен в Python, чтобы избавиться от такого спо
соба использования значений по умолчанию – сейчас Python автома
тически сохраняет любые значения в объемлющей области видимости
для последующего использования во вложенных инструкциях def.
Безусловно, наилучшей рекомендацией будет просто избегать вложе
ния инструкций def в другие инструкции def, так как это существенно
Области видимости и вложенные функции 415
упростит программы. Ниже приводится фрагмент, который является
эквивалентом предшествующего примера, в котором просто отсутству
ет понятие вложенности. Обратите внимание, что вполне допустимо
вызывать функцию, определение которой в тексте программы нахо
дится ниже функции, откуда производится вызов, как в данном слу
чае, при условии, что вторая инструкция def будет исполнена до того,
как первая функция попытается вызвать ее, – программный код внут
ри инструкции def не выполняется, пока не будет произведен фактиче
ский вызов функции:
>>> def f1():
... x = 88
... f2(x)
...
>>> def f2(x):
... print x
...
>>> f1()
88
При использовании такого способа можно забыть о концепции вложен
ных областей видимости в языке Python, если вам не потребуется соз
давать фабричные функции, обсуждавшиеся выше, – по крайней мере
при использовании инструкций def. Выражения lambda, которые прак
тически всегда вкладываются в инструкции def, часто используют вло
женные области видимости, как описывается в следующем разделе.
Вложенные области видимости и lambdaвыражения
Несмотря на то, что вложенные области видимости на практике редко
используются непосредственно для инструкций def, вам наверняка
придется столкнуться с областями видимости вложенных функций,
когда вы начнете использовать выражения lambda. Мы не будем под
робно рассматривать эти выражения до главы 17, но в двух словах за
мечу, что это выражение генерирует новую функцию, которая будет
вызываться позднее, и оно очень похоже на инструкцию def. Посколь
ку lambda – это выражение, оно может использоваться там, где не до
пускается использование инструкции def, например, в литералах спи
сков и словарей.
Подобно инструкции def, выражение lambda сопровождается появлени
ем новой локальной области видимости. Благодаря наличию возмож
ности поиска имен в объемлющей области видимости выражения
lambda способны обращаться ко всем переменным, которые присутст
вуют в функциях, где находятся эти выражения. Таким образом, в на
стоящее время следующий программный код будет работать исключи
тельно благодаря тому, что в настоящее время действуют правила по
иска во вложенных областях видимости:
def func():
x = 4
416 Глава 16. Области видимости и аргументы
action = (lambda n: x ** n) # Запоминается x из объемлющей
# инструкции def
return action
x = func()
print x(2) # Выведет 16, 4 ** 2
До того как появилось понятие областей видимости вложенных функ
ций, программисты использовали значения по умолчанию для переда
чи значений из объемлющей области видимости в выражения lambda
точно так же, как и в случае с инструкциями def. Например, следую
щий фрагмент будет работать во всех версиях Python:
def func():
x = 4
action = (lambda n, x=x: x ** n) # Передача x вручную
Поскольку lambda – это выражения, они естественно (и даже обычно)
вкладываются внутрь инструкций def. Следовательно, именно они из
влекли наибольшую выгоду от добавления областей видимости объем
лющих функций в правила поиска имен – в большинстве случаев отпа
дает необходимость передавать в выражения lambda аргументы со зна
чениями по умолчанию.
Области видимости и значения по умолчанию
применительно к переменным цикла
Существует одно известное исключение из правила, которое я только
что дал: если lambdaвыражение или инструкция def вложены в цикл
внутри другой функции и вложенная функция ссылается на перемен
ную из объемлющей области видимости, которая изменяется в цикле,
все функции, созданные в этом цикле, будут иметь одно и то же значе
ние – значение, которое имела переменная на последней итерации.
Например, ниже предпринята попытка создать список функций, каж
дая из которых запоминает текущее значение переменной i из объем
лющей области видимости:
>>> def makeActions():
... acts = []
... for i in range(5): # Сохранить каждое значение i
... acts.append(lambda x: i ** x) # Все запомнят последнее значение i!
... return acts
...
>>> acts = makeActions()
>>> acts[0]
<function <lambda> at 0x012B16B0>
Такой подход не дает желаемого результата, потому что поиск пере
менной в объемлющей области видимости производится позднее, при
вызове вложенных функций, в результате все они получат одно и то
же значение (значение, которое имела переменная цикла на последней
итерации). То есть каждая функция в списке будет возвращать 4 во
Области видимости и вложенные функции 417
второй степени, потому что во всех них переменная i имеет одно и то
же значение:
>>> acts[0](2) # Все возвращают 4 ** 2, последнее значение i
16
>>> acts[2](2) # Здесь должно быть 2 ** 2
16
>>> acts[4](2) # Здесь должно быть 4 ** 2
16
Это один из случаев, когда необходимо явно сохранять значение из объ
емлющей области видимости в виде аргумента со значением по умолча
нию вместо использования ссылки на переменную из объемлющей об
ласти видимости. То есть, чтобы этот фрагмент заработал, необходимо
передать текущее значение переменной из объемлющей области види
мости в виде значения по умолчанию. Значения по умолчанию вычис
ляются в момент создания вложенной функции (а не когда она вызыва
ется), поэтому каждая из них сохранит свое собственное значение i:
>>> def makeActions():
... acts = []
... for i in range(5): # Использовать значения по умолчанию
... acts.append(lambda x, i=i: i ** x) # Сохранить текущее значение i
... return acts
...
>>> acts = makeActions()
>>> acts[0](2) # 0 ** 2
0
>>> acts[2](2) # 2 ** 2
4
>>> acts[4](2) # 4 ** 2
16
Это достаточно замысловатый случай, но с ним можно столкнуться на
практике, особенно в программном коде, который генерирует функции
обработчики событий для элементов управления в графическом интер
фейсе (например, обработчики нажатия кнопок). Подробнее о значениях
по умолчанию и lambdaвыражениях мы поговорим в следующей главе,
поэтому позднее вам может потребоваться вернуться к этому разделу.1
1 В разделе «Ошибки при работе с функциями» к этой части книги, в конце
следующей главы, мы также увидим, что существуют определенные про
блемы с использованием изменяемых объектов, таких как списки и слова
ри, при использовании их в качестве значений по умолчанию для аргумен
тов (например, def f(a=[])). Так как значения по умолчанию реализованы
в виде единственных объектов, изменяемые объекты по умолчанию сохра
няют свое состояние от вызова к вызову, а не инициализируются заново
при каждом вызове. В зависимости от того, кому задается вопрос, эта осо
бенность может рассматриваться или как особенность, поддерживающая
возможность сохранения состояния, или как недостаток языка. Подробнее
об этом будет говориться в следующей главе.
418 Глава 16. Области видимости и аргументы
Произвольное вложение областей видимости
Прежде чем закончить это исследование, я должен заметить, что об
ласти видимости могут вкладываться произвольно, но поиск будет
производиться только в объемлющих функциях (не в классах, кото
рые описываются в шестой части книги):
>>> def f1():
... x = 99
... def f2():
... def f3():
... print x # Будет найдена в области видимости f1!
... f3()
... f2()
...
>>> f1()
99
Интерпретатор будет искать переменную в локальных областях видимо
сти всех объемлющих инструкций def, начиная от внутренних к внеш
ним, выше локальной области видимости и ниже глобальной области
видимости модуля. Однако такой программный код едва ли может по
лучиться на практике. В языке Python считается, что плоское лучше
вложенного – ваша жизнь и жизнь ваших коллег будет проще, если вы
сведете к минимуму количество вложенных определений функций.
Передача аргументов
Раньше уже говорилось, что передача аргументов производится по
средством операции присваивания. Здесь имеется несколько момен
тов, не всегда очевидных для начинающих, о которых будет говорить
ся в этом разделе. Ниже приводится несколько важных замечаний, ка
сающихся передачи аргументов в функции:
• Аргументы передаются через автоматическое присваивание объ!
ектов локальным именам. Аргументы функции – ссылки на объек
ты, которые (возможно) используются совместно с вызывающей
программой – это всего лишь результат еще одной из разновидно
стей операции присваивания. Ссылки в языке Python реализованы
в виде указателей, поэтому все аргументы фактически передаются
по указателям. Объекты, которые передаются в виде аргументов,
никогда не копируются.
• Операция присваивания именам аргументов внутри функции не
оказывает влияния на вызывающую программу. При вызове
функции имена аргументов, указанные в ее заголовке, становятся
новыми локальными именами в области видимости функции. Это
не является совмещением имен между именами аргументов и име
нами в вызывающей программе.
Передача аргументов 419
• Изменение внутри функции аргумента, который является изме!
няемым объектом, может оказывать влияние на вызывающую
программу. C другой стороны, так как аргументы – это всего лишь
результат операции присваивания полученных объектов, функции
могут воздействовать на полученные изменяемые объекты и тем са
мым оказывать влияние на вызывающую программу. Изменяемые
объекты могут рассматриваться функциями, как средство ввода,
так и вывода информации.
За дополнительной информацией о ссылках обращайтесь к главе 6 –
все, что там говорится, вполне применимо и к аргументам функций
несмотря на то, что присваивание именам аргументов выполняется ав
томатически и неявно.
Схема передачи аргументов посредством присваивания, принятая в язы
ке Python, это далеко не то же самое, что передача аргументов по ссыл
ке в языке C++, но она очень близка к модели передачи аргументов
в языке C:
• Неизменяемые объекты передаются «по значению». Такие объек
ты, как целые числа и строки, передаются в виде ссылок на объек
ты, а не в виде копий объектов, но, так как неизменяемые объекты
невозможно изменить непосредственно, передача таких объектов
очень напоминает копирование.
• Изменяемые объекты передаются «по указателю». Такие объекты,
как списки и словари, также передаются в виде ссылок на объекты,
что очень похоже на то, как в языке C передаются указатели на мас
сивы – изменяемые объекты допускают возможность непосредствен
ного изменения внутри функции так же, как и массивы в языке C.
Конечно, если вы никогда ранее не использовали язык C, модель пере
дачи аргументов в языке Python буде казаться вам еще проще – со
гласно этой модели выполняется присваивание объектов именам аргу
ментов, и она одинаково работает с любыми объектами, как с изменяе
мыми, так и с неизменяемыми.
Аргументы и разделяемые ссылки
Ниже приводится пример, который иллюстрирует работу этих поло
жений:
>>> def changer(a, b): # Функция
... a = 2 # Изменяется только значение локального имени
... b[0] = 'spam' # Изменяется непосредственно разделяемый объект
...
>>> X = 1
>>> L = [1, 2] # Вызывающая программа
>>> changer(X, L) # Передаются изменяемый и неизменяемый объекты
>>> X, L # X – не изменилась, L  изменилась
(1, ['spam', 2])
420 Глава 16. Области видимости и аргументы
В этом фрагменте функция changer присваивает значения аргументу a
и компоненту объекта, на который ссылается аргумент b. Две опера
ции присваивания в функции имеют незначительные синтаксические
различия, но дают совершенно разные результаты:
• Так как a – это локальное имя в области видимости функции, пер
вая операция присваивания не имеет эффекта для вызывающей
программы – она всего лишь изменяет локальную переменную a
и не изменяет связанное с ней имя X в вызывающей программе.
• b – также локальное имя, но в нем передается изменяемый объект
(список, с именем L в вызывающей программе). Поскольку вторая
операция присваивания воздействует непосредственно на изменяе
мый объект, результат присваивания элементу b[0] в функции ока
зывает влияние на значение имени L после выхода из функции.
В действительности эта операция не изменяет объект b, она изменя
ет часть объекта, на который ссылается аргумент b, и это изменение
оказывает влияние на вызывающую программу.
Рис. 16.2 иллюстрирует связи имя/объект, которые имеют место непо
средственно сразу после вызова функции, но перед тем, как будет за
пущено ее тело.
Если этот пример все еще кажется вам непонятным, попробуйте пред
ставить себе автоматическое присваивание переданным аргументам,
Рис. 16.2. Ссылки: аргументы. Так как аргументы передаются посредством
операции присваивания, имена аргументов могут ссылаться на объекты,
на которые ссылаются переменные, участвующие в вызове функции.
Следовательно, непосредственные воздействия на изменяемые аргументы
внутри функции могут оказывать влияние на вызывающую программу.
В данном случае a и b внутри функции изначально ссылаются на те же
объекты, на которые ссылаются переменные X и L при первом вызове
функции. Изменение списка, выполненное через переменную b, можно
наблюдать в переменной L после того, как функция вернет управление
функция
Имена Объекты
вызывающая программа
X
L
a
b
1
[1,2]
Передача аргументов 421
как последовательность простых инструкций присваивания. Для пер
вого аргумента операции присваивания не оказывают влияния на вы
зывающую программу:
>>> X = 1
>>> a = X # Разделяют один и тот же объект
>>> a = 2 # Изменяется только 'a', значение 'X' остается равным 1
>>> print X
1
Но для второго аргумента операция присваивания сказывается на зна
чении переменной, участвующей в вызове, так как она производит не
посредственное изменение объекта:
>>> L = [1, 2]
>>> b = L # Разделяют один и тот же объект
>>> b[0] = 'spam' # Непосредственное изменение: 'L' также изменяется
>>> print L
['spam', 2]
Вспомните обсуждение вопросов совместного использования изменяе
мых объектов в главах 6 и 9, и вы узнаете это явление: непосредствен
ное воздействие на изменяемый объект может сказываться на других
ссылках на этот объект. В данном случае один из параметров функции
играет роль средства вывода информации.
Как избежать воздействий на изменяемые аргументы
В языке Python по умолчанию аргументы передаются в функции по
ссылкам (т. е. по указателям), потому что в большинстве случаев
именно это и требуется – это означает, что мы можем передавать круп
ные объекты в любые точки программы без создания множества копий
и легко изменять эти объекты в процессе работы. Однако, если нам
требуется избежать влияния непосредственных изменений объектов,
производимых в функциях, на вызывающую программу, мы можем
просто явно копировать изменяемые объекты, как описывалось в гла
ве 6. В случае с аргументами функций мы всегда можем скопировать
список в точке вызова:
L = [1, 2]
changer(X, L[:]) # Передается копия, поэтому переменная 'L' не изменится
Можно также создать копию внутри функции, если нам не требуется
изменять полученный объект независимо от того, как была вызвана
функция:
def changer(a, b):
b = b[:] # Входной список копируется, что исключает
# воздействие на вызывающую программу
a = 2
b[0] = 'spam' # Изменится только копия списка
422 Глава 16. Области видимости и аргументы
Оба варианта копирования не мешают функции изменять объект, они
лишь препятствуют воздействию этих изменений на вызывающую
программу. Чтобы действительно предотвратить изменения, мы все
гда можем преобразовать изменяемые объекты в неизменяемые, что
позволит выявить источники проблем. Например, при попытке изме
нения кортежа будет возбуждено исключение:
L = [1, 2]
changer(X, tuple(L)) # Передается кортеж, поэтому попытка изменения
# возбудит исключение
Здесь используется встроенная функция tuple, которая создает новый
кортеж из всех элементов последовательности (в действительности –
любого итерируемого объекта). Это особенно важно, потому что выну
ждает писать функцию так, чтобы она никогда не пыталась изменять
передаваемые ей аргументы. Однако такое решение накладывает на
функцию больше ограничений, чем следует, поэтому его вообще следу
ет избегать. Нельзя знать заранее, когда изменение аргументов ока
жется необходимым. Кроме того, при таком подходе функция теряет
возможность применять к аргументу методы списков, включая мето
ды, которые не производят непосредственных изменений.
Главное, что следует запомнить, – функции могут оказывать воздейст
вия на передаваемые им изменяемые объекты (например, на списки
и словари). Это не всегда является проблемой и часто может приносить
пользу. Но вам действительно необходимо знать об этой особенности –
если изменения в объектах происходят неожиданно для вас, проверьте
вызываемые функции и в случае необходимости передавайте им копии
объектов.
Имитация выходных параметров
Мы уже обсудили инструкцию return и использовали ее в нескольких
примерах. Эта инструкция может возвращать объект любого типа, по
этому с ее помощью можно возвращать сразу несколько значений,
упаковав их в кортеж или в коллекцию любого другого типа. В языке
Python фактически отсутствует такое понятие, которое в некоторых
других языках называется «передача аргументов по ссылке», однако
мы можем имитировать такое поведение, возвращая кортеж и выпол
няя присваивание результатов оригинальным именам аргументов в вы
зывающей программе:
>>> def multiple(x, y):
... x = 2 # Изменяется только локальное имя
... y = [3, 4]
... return x, y # Новые значения возвращаются в виде кортежа
...
>>> X = 1
>>> L = [1, 2]
>>> X, L = multiple(X, L) # Результаты присваиваются именам
Специальные режимы сопоставления аргументов 423
>>> X, L # в вызывающей программе
(2, [3, 4])
Выглядит так, как будто функция возвращает два значения, но на са
мом деле – это единственный кортеж, состоящий из двух элементов,
а необязательные окружающие скобки просто опущены. После возвра
та из функции можно использовать операцию присваивания кортежа,
чтобы извлечь отдельные элементы. (Если вы забыли, как это работа
ет, вернитесь к разделу «Кортежи» в главе 4 и «Инструкции присваи
вания» в главе 11.) Такой прием позволяет имитировать выходные па
раметры, имеющиеся в других языках программирования, за счет ис
пользования явной операции присваивания. Переменные X и L изме
нятся после вызова функции, но только потому, что мы явно это
запрограммировали.
Специальные режимы сопоставления аргументов
Как только что было показано, в языке Python аргументы всегда пере
даются через операцию присваивания – передаваемые объекты при
сваиваются именам, указанным в заголовке инструкции def. Однако
на основе этой модели язык Python обеспечивает дополнительные воз
можности влиять на способ, которым объекты аргументов сопоставля
ются с именами аргументов в заголовке функции. Эти возможности
можно и не использовать, но они позволяют писать функции, поддер
живающие более гибкие схемы вызова.
По умолчанию сопоставление аргументов производится в соответствии
с их позициями, слева направо, и функции должно передаваться столь
ко аргументов, сколько имен указано в заголовке функции. Но кроме
этого существует возможность явно указывать соответствия между ар
гументами и именами, определять значения по умолчанию и переда
вать дополнительные аргументы.
Это достаточно сложный раздел, и прежде чем окунуться в обсуждение
синтаксиса, я хотел бы подчеркнуть, что эти специальные режимы не
являются обязательными и имеют отношение только к сопоставлению
объектов и имен – основным механизмом передачи аргументов по
прежнему остается операция присваивания. Фактически некоторые из
этих режимов предназначены в первую очередь для разработчиков биб
лиотек, а не для разработчиков приложений. Но, так как вы можете
столкнуться с этими режимами, даже не используя их в своих про
граммах, я коротко опишу их:
Сопоставление по позиции: значения и имена ставятся в соответст+
вие по порядку, слева направо
Обычный случай, который мы использовали до сих пор: значения
и имена аргументов ставятся в соответствие в порядке их следова
ния слева направо.
424 Глава 16. Области видимости и аргументы
Сопоставление по ключам: соответствие определяется
по указанным именам аргументов
Вызывающая программа имеет возможность указать соответствие
между аргументами функции и их значениями в момент вызова,
используя синтаксис name=value.
Значения по умолчанию: указываются значения аргументов,
которые могут не передаваться
Функции могут определять значения аргументов по умолчанию на
тот случай, если вызывающая программа передаст недостаточное ко
личество значений. Здесь также используется синтаксис name=value.
Переменное число аргументов: прием произвольного числа
аргументов, позиционных или в виде ключей
Функции могут использовать специальный аргумент, имени кото
рого предшествует символ *, для объединения произвольного числа
дополнительных аргументов в коллекцию (эта особенность часто
называется varargs, как в языке C, где также поддерживаются спи
ски аргументов переменной длины).
Переменное число аргументов: передача произвольного числа
аргументов, позиционных или в виде ключей
Вызывающая программа также может использовать символ * для пе
редачи коллекции аргументов в виде отдельных аргументов. В дан
ном случае символ * имеет обратный смысл по отношению к символу
* в заголовке функции – в заголовке он означает коллекцию произ
вольного числа аргументов, тогда как в вызывающей программе –
передачу коллекции в виде произвольного числа отдельных аргу
ментов.
В табл. 16.1 приводится синтаксис использования специальных режи
мов сопоставления.
Таблица 16.1. Виды сопоставления аргументов функций
Синтаксис Местоположение Интерпретация
func(value) Вызывающая
программа
Обычный аргумент: сопоставление про
изводится по позиции
func(name=value) Вызывающая
программа
По ключу: сопоставление производится
по указанному имени
func(*name) Вызывающая
программа
Все объекты в указанном имени пере
даются как отдельные позиционные ар
гументы
func(**name) Вызывающая
программа
Все пары ключ/значение в указанном
имени передаются как отдельные аргу
менты по ключевым словам
def func(name) Функция Обычный аргумент: сопоставление про
изводится по позиции или по имени
Специальные режимы сопоставления аргументов 425
В вызывающей программе (первые четыре строки таблицы) при ис
пользовании простых значений соответствие именам аргументов опре
деляется по позиции, но при использовании формы name=value соответ
ствие определяется по именам аргументов – это называется передачей
аргументов по ключам. Использование символов * и ** в вызывающей
программе позволяет передавать произвольное число объектов по по
зиции или по ключам в виде последовательностей и словарей соответ
ственно.
В заголовке функции при использовании простых значений соответст
вие определяется по позиции или по имени (в зависимости от того, как
вызывающая программа передает значения), но при использовании
формы name=value определяются значения по умолчанию. При исполь
зовании формы *name все дополнительные аргументы объединяются
в кортеж, а при использовании формы **name – в словарь.
Наиболее часто в программном коде на языке Python используются
форма передачи аргументов по ключам и по умолчанию. Возможность
передачи аргументов по ключам позволяет указывать значения аргу
ментов вместе с их именами, чтобы придать вызову функции больше
смысла. Со значениями по умолчанию мы уже встречались, когда рас
сматривали способы передачи значений из объемлющей области види
мости, но на самом деле эта форма имеет более широкую область при
менения – она позволяет определять необязательные аргументы и ука
зывать значения по умолчанию в определении функции.
Специальные режимы сопоставления позволяют обеспечить свободу вы
бора числа аргументов, которые должны передаваться функции в обяза
тельном порядке. Если функция определяет значения по умолчанию,
они будут использоваться, когда функции передается недостаточное
число аргументов. Если функция использует форму * определения спи
ска аргументов переменной длины, она сможет принимать большее чис
ло аргументов – дополнительные аргументы будут собраны в структуру
данных под именем с символом *.
def func(name=value) Функция Значение аргумента по умолчанию, на
случай, если аргумент не передается
функции
def func(*name) Функция Определяет и объединяет все допол
нительные аргументы в коллекцию
(в кортеж)
def func(**name) Функция Определяет и объединяет все дополни
тельные аргументы по ключам (в сло
варь)
Синтаксис Местоположение Интерпретация
426 Глава 16. Области видимости и аргументы
Примеры использования ключей и значений
по умолчанию
Предыдущие пояснения в программном коде выглядят гораздо проще.
В языке Python по умолчанию сопоставление значений и имен аргу
ментов производится по позиции, как и в большинстве других языков.
Например, если определена функция, которая требует передачи трех
аргументов, она должна вызываться с тремя аргументами:
>>> def f(a, b, c): print a, b, c
...
Здесь значения передаются по позиции – имени a соответствует значе
ние 1, имени b соответствует значение 2 и т. д.:
>>> f(1, 2, 3)
1 2 3
Ключи
В языке Python существует возможность явно определить соответствия
между значениями и именами аргументов при вызове функции. Клю
чи позволяют определять соответствие по именам, а не по позициям:
>>> f(c=3, b=2, a=1)
1 2 3
В этом вызове c=3, например, означает, что значение 3 передается
функции в аргументе с именем c. Говоря более формальным языком,
интерпретатор сопоставляет имя с в вызове функции с именем аргу
мента с в заголовке определения функции и затем передает значение 3
в этот аргумент. Результат этого вызова будет тем же, что и предыду
щего. Обратите внимание, что при использовании ключей порядок
следования аргументов не имеет никакого значения, потому что сопос
тавление производится по именам, а не по позициям. Существует даже
возможность объединять передачу аргументов по позициям и по клю
чам в одном вызове. В этом случае сначала будут сопоставлены все по
зиционные аргументы, слева направо, а потом будет выполнено сопос
тавление ключей с именами:
>>> f(1, c=3, b=2)
1 2 3
Большинство из тех, кто впервые сталкивается с такой возможностью,
задаются вопросом: где такая возможность может пригодиться? В язы
ке Python ключи обычно играют две роли. Первая: они делают вызовы
функций более описательными (представьте, что вы используете имена
аргументов более осмысленные, чем простые a, b и c). Например, такой
вызов:
func(name='Bob', age=40, job='dev')
Специальные режимы сопоставления аргументов 427
несет больше смысла, чем вызов с тремя простыми значениями, разде
ленными запятыми, – ключи играют роль меток для данных, участ
вующих в вызове. Вторая: ключи используются вместе со значениями
по умолчанию, о которых мы поговорим далее.
Значения по умолчанию
О значениях по умолчанию мы немного говорили ранее, когда обсуж
дали области видимости вложенных функций. Если коротко, значе
ния по умолчанию позволяют сделать отдельные аргументы функции
необязательными – если значение не передается при вызове, аргумент
получит значение по умолчанию, перед тем как будет запущено тело
функции. Например, ниже приводится функция, в которой один аргу
мент является обязательным, а два имеют значения по умолчанию:
>>> def f(a, b=2, c=3): print a, b, c
...
При вызове такой функции мы обязаны передать значение для аргу
мента a, по позиции или по ключу, а значения для аргументов b и с
можно опустить. Если значения аргументов b и с будут опущены, они
примут значения по умолчанию 2 и 3, соответственно:
>>> f(1)
1 2 3
>>> f(a=1)
1 2 3
Если функции передать только два значения, аргумент с примет зна
чение по умолчанию, а если три – ни одно из значений по умолчанию
не будет использовано:
>>> f(1, 4)
1 4 3
>>> f(1, 4, 5)
1 4 5
Наконец, ниже приводится пример взаимодействия режимов переда
чи значений по ключу и по умолчанию. Поскольку ключи могут нару
шать обычный порядок отображения аргументов слева направо, они,
по сути, позволяют «перепрыгивать» через аргументы со значениями
по умолчанию:
>>> f(1, c=6)
1 2 6
Здесь значение 1 будет сопоставлено с аргументом по позиции, аргу
мент c получит значение 6, а аргумент b, в середине, – значение по
умолчанию 2.
Не путайте синтаксические конструкции name=value в заголовке функ
ции и в вызове функции – в вызове она означает использование режима
сопоставления значения с именем аргумента по ключу, а в заголовке
428 Глава 16. Области видимости и аргументы
определяет значение по умолчанию для необязательного аргумента.
В обоих случаях это не инструкция присваивания – это особая синтак
сическая конструкция для этих двух случаев, которая модифицирует
механику сопоставления значений с именами аргументов, используе
мую по умолчанию.
Примеры произвольного числа аргументов
Последние два расширения * и ** механизма сопоставления аргумен
тов и их значений предназначены для поддержки возможности пере
дачи произвольного числа аргументов функциям. Оба варианта могут
появляться как в определениях функций, так и в их вызовах, и в обо
их случаях они имеют сходные назначения.
Сбор аргументов в коллекцию
В первом случае, в определении функции, выполняется сборка лиш
них позиционных аргументов в кортеж:
>>> def f(*args): print args
...
При вызове этой функции интерпретатор Python соберет все позици
онные аргументы в новый кортеж и присвоит этот кортеж переменной
args. Это будет обычный объект кортежа, поэтому из него можно из
влекать элементы по индексам, выполнять обход в цикле for и т. д.:
>>> f()
()
>>> f(1)
(1,)
>>> f(1,2,3,4)
(1, 2, 3, 4)
Комбинация ** дает похожий результат, но применяется при передаче
аргументов по ключам – в этом случае аргументы будут собраны в но
вый словарь, который можно обрабатывать обычными инструмента
ми, предназначенными для работы со словарями. В определенном
смысле форма ** позволяет преобразовать аргументы, передаваемые
по ключам, в словари, которые можно будет обойти с помощью метода
keys, итераторов словарей и т. д.:
>>> def f(**args): print args
...
>>> f()
{ }
>>> f(a=1, b=2)
{'a': 1, 'b': 2}
Наконец, в заголовках функций можно комбинировать обычные аргу
менты, * и ** для реализации чрезвычайно гибких сигнатур вызова:
>>> def f(a, *pargs, **kargs): print a, pargs, kargs
Специальные режимы сопоставления аргументов 429
...
>>> f(1, 2, 3, x=1, y=2)
1 (2, 3) {'y': 2, 'x': 1}
Фактически все эти формы передачи аргументов можно объединять
в еще более сложные комбинации, которые на первый взгляд могут по
казаться неоднозначными – к этой идее мы еще вернемся ниже, в этой
главе. А сейчас посмотрим, как используются формы * и ** в вызовах
функций.
Извлечение аргументов из коллекции
В последних версиях Python форму * можно также использовать в вы
зовах функций. В этом случае данная форма передачи аргументов име
ет противоположный смысл по сравнению с применением этой формы
в определениях функций – она распаковывает, а не создает коллекцию
аргументов. Например, можно передать в функцию четыре аргумента
в виде кортежа и позволить интерпретатору распаковать их в отдель
ные аргументы:
>>> def func(a, b, c, d): print a, b, c, d
...
>>> args = (1, 2)
>>> args += (3, 4)
>>> func(*args)
1 2 3 4
Точно также форма ** в вызовах функций распаковывает словари пар
ключ/значение в отдельные аргументы, которые передаются по ключу:
>>> args = {'a': 1, 'b': 2, 'c': 3}
>>> args['d'] = 4
>>> func(**args)
1 2 3 4
Здесь также можно очень гибко комбинировать в одном вызове обыч
ные позиционные аргументы и аргументы по ключу:
>>> func(*(1, 2), **{'d': 4, 'c': 4})
1 2 4 4
>>> func(1, *(2, 3), **{'d': 4})
1 2 3 4
>>> func(1, c=3, *(2,), **{'d': 4})
1 2 3 4
Такого рода программный код удобно использовать, когда заранее не
возможно предсказать число аргументов, которые могут быть переда
ны функции – вы можете собирать коллекцию аргументов во время ис
полнения и вызывать функцию таким способом. Не путайте синтакси
ческие конструкции */** в заголовках функций и в их вызовах – в за
головке они означают сбор всех лишних аргументов в коллекцию,
а в вызове выполняют распаковку коллекций в отдельные аргументы.
430 Глава 16. Области видимости и аргументы
Мы еще вернемся к этим формам в следующей главе, когда будем рас
сматривать встроенную функцию apply (для замены которой, в значи
тельной степени, предназначены эти конструкции).
Комбинирование ключей и значений по умолчанию
Ниже приводится немного больший по объему пример, демонстрирую
щий передачу аргументов по ключам и по умолчанию в действии. В этом
примере вызывающая программа всегда должна передавать функции
как минимум два аргумента (spam и eggs), два других аргумента явля
ются необязательными. В случае их отсутствия интерпретатор присво
ит именам toast и ham значения по умолчанию, указанные в заголовке:
def func(spam, eggs, toast=0, ham=0): # Первые 2 являются обязательными
print (spam, eggs, toast, ham)
func(1, 2) # Выведет: (1, 2, 0, 0)
func(1, ham=1, eggs=0) # Выведет: (1, 0, 0, 1)
func(spam=1, eggs=0) # Выведет: (1, 0, 0, 0)
func(toast=1, eggs=2, spam=3) # Выведет: (3, 2, 1, 0)
func(1, 2, 3, 4) # Выведет: (1, 2, 3, 4)
Обращаю снова ваше внимание: когда в вызовах используются ключи
аргументов, порядок следования аргументов не имеет значения, пото
му что сопоставление выполняется по именам, а не по позициям. Вы
зывающая программа обязана передать значения для аргументов spam
и eggs, а сопоставление может выполняться как по позиции, так и по
ключам. Обратите также внимание на то, что форма name=value имеет
разный смысл в вызове функции и в инструкции def (ключ – в вызове
и значение по умолчанию – в заголовке).
Функция поиска минимума
Чтобы придать обсуждению больше конкретики, выполним упражне
ние, которое демонстрирует практическое применение механизмов со
поставления аргументов. Предположим, что вам необходимо написать
функцию, которая способна находить минимальное значение из про
извольного множества аргументов с произвольными типами данных.
То есть функция должна принимать ноль или более аргументов –
столько, сколько вы пожелаете передать. Более того, функция должна
работать со всеми типами объектов, имеющимися в языке Python: чис
лами, строками, списками, списками словарей, файлами и даже None.
Первое требование представляет собой обычный пример того, как мож
но найти применение форме * – мы можем собирать аргументы в кор
теж и выполнять их обход с помощью простого цикла for. Второе тре
бование тоже не представляет никакой сложности: все типы объектов
поддерживают операцию сравнения, поэтому нам не требуется учиты
вать типы объектов в функции (полиморфизм в действии) – мы можем
просто слепо сравнивать объекты и позволить интерпретатору само
стоятельно выбрать корректную операцию сравнения.
Специальные режимы сопоставления аргументов 431
Основное задание
Ниже представлены три способа реализации этой функции, из кото
рых, по крайней мере, один был предложен студентом:
• Первая версия функции извлекает первый аргумент (args – это кор
теж) и обходит остальную часть коллекции, отсекая первый эле
мент (нет никакого смысла сравнивать объект сам с собой, особен
но, если это довольная крупная структура данных).
• Вторая версия позволяет интерпретатору самому выбрать первый
аргумент и остаток, благодаря чему отсутствует необходимость из
влекать первый аргумент и получать срез.
• Третья версия преобразует кортеж в список с помощью встроенной
функции list и использует метод списка sort.
Метод sort написан на языке C, поэтому иногда он может обеспечивать
более высокую производительность по сравнению с другими версиями
функции, но линейный характер сканирования в первых двух версиях
в большинстве случаев обеспечивает им более высокую скорость.1 Файл
mins.py содержит реализацию всех трех решений:
def min1(*args):
res = args[0]
for arg in args[1:]:
if arg < res:
res = arg
return res
def min2(first, *rest):
for arg in rest:
if arg < first:
first = arg
return first
1 В действительности все очень не просто. Функция sort в языке Python на
писана на языке C и реализует высокоэффективный алгоритм, который
пытается использовать существующий порядок следования сортируемых
элементов. Этот алгоритм называется «timsort» в честь его создателя Тима
Петерса (Tim Peters), а в его документации говорится, что время от време
ни он показывает «сверхъестественную производительность» (очень не
плохую для сортировки!). Однако сортировка по своей природе является
экспоненциальной операцией (в процессе сортировки необходимо делить
последовательность на составляющие и снова объединять их много раз),
тогда как другие версии используют линейные алгоритмы сканирования
слева направо. В результате сортировка выполняется быстрее, когда эле
менты последовательности частично упорядочены, и медленнее в других
случаях. Даже при всем при этом производительность самого интерпрета
тора может изменяться по времени и тот факт, что сортировка реализована
на языке C, может существенно помочь. Для более точного анализа произ
водительности вы можете использовать модули time и timeit, с которыми
мы познакомимся в следующей главе.
432 Глава 16. Области видимости и аргументы
def min3(*args):
tmp = list(args) # Или, в Python 2.4+: return sorted(args)[0]
tmp.sort()
return tmp[0]
print min1(3,4,1,2)
print min2("bb", "aa")
print min3([2,2], [1,1], [3,3])
Все три решения дают одинаковые результаты. Попробуйте несколько
раз вызвать функции в интерактивной оболочке, чтобы поэксперимен
тировать с ними самостоятельно:
% python mins.py
1
aa
[1, 1]
Обратите внимание, что ни один из этих трех вариантов не выполняет
проверку ситуации, когда функции не передается ни одного аргумен
та. Такую проверку можно было бы предусмотреть, но в этом нет ника
кой необходимости – во всех трех решениях интерпретатор автомати
чески возбудит исключение, если та или иная функция не получит ни
одного аргумента. В первом случае исключение будет возбуждено при
попытке получить нулевой элемент; во втором – когда обнаружится
несоответствие списка аргументов; и в третьем – когда функция попы
тается вернуть нулевой элемент.
Это именно то, что нам нужно, потому что эти функции поддерживают
поиск среди данных любого типа и не существует какогото особого зна
чения, которое можно было бы вернуть в качестве признака ошибки.
Из этого правила есть свои исключения (например, когда приходится
выполнить дорогостоящие действия, прежде чем появится ошибка), но
вообще лучше исходить из предположения, что аргументы не будут вы
зывать ошибок в работе программного кода функции, и позволить ин
терпретатору возбуждать исключения, когда этого не происходит.
Дополнительные баллы
Студенты и читатели могут получить дополнительные баллы, если из
менят эти функции так, что они будут отыскивать не минимальное,
а максимальное значение. Сделать это достаточно просто: в первых
двух версиях достаточно заменить < на >, а третья версия должна воз
вращать не элемент tmp[0], а элемент tmp[1]. Дополнительные баллы
будут начислены тем, кто догадается изменить имя функции на «max»
(хотя это совершенно необязательно).
Кроме того, вполне возможно обобщить функцию так, что она будет
отыскивать либо минимальное, либо максимальное значение, опреде
ляя отношения элементов за счет интерпретации строки выражения
с помощью таких средств, как встроенная функция eval (подробности
в руководстве к библиотеке), или передавая произвольную функцию
Специальные режимы сопоставления аргументов 433
сравнения. В файле minmax.py содержится реализация последнего ва
рианта:
def minmax(test, *args):
res = args[0]
for arg in args[1:]:
if test(arg, res):
res = arg
return res
def lessthan(x, y): return x < y # См. также: lambda
def grtrthan(x, y): return x > y
print minmax(lessthan, 4, 2, 1, 5, 6, 3) # Тестирование
print minmax(grtrthan, 4, 2, 1, 5, 6, 3)
% python minmax.py
1
6
Функции – это одна из разновидностей объектов, которые могут пере
даваться в функции, как в этом случае. Например, чтобы заставить
функцию отыскивать максимальное (или любое другое) значение, мы
могли бы просто передать ей нужную функцию test. На первый взгляд
может показаться, что мы делаем лишнюю работу, однако главное
преимущество такого обобщения функций (вместо того, чтобы содер
жать две версии, отличающиеся единственным символом) заключает
ся в том, что в будущем нам может потребоваться изменить одну функ
цию, а не две.
Заключение
Конечно, это было всего лишь упражнение. В действительности нет
никаких причин создавать функции min и max, потому что обе они уже
имеются в языке Python! Встроенные версии функций работают прак
тически так же, как и наши, но они написаны на языке C для получе
ния более высокой скорости работы.
Более полезный пример: универсальные функции
Теперь рассмотрим более полезный пример использования специаль
ных режимов сопоставления аргументов. В конце предыдущей главы
мы написали функцию, которая возвращала пересечение двух после
довательностей (она отбирала элементы, общие для обеих последова
тельностей). Ниже приводится версия функции, которая возвращает
пересечение произвольного числа последовательностей (одной или бо
лее), где используется механизм передачи произвольного числа аргу
ментов в форме *args для сбора всех передаваемых аргументов в виде
коллекции. Все аргументы передаются в тело функции в составе корте
жа, поэтому для их обработки можно использовать простой цикл for.
Ради интереса мы напишем функцию, возвращающую объединение,
434 Глава 16. Области видимости и аргументы
которая также принимает произвольное число аргументов и собирает
вместе все элементы, имеющиеся в любом из операндов:
def intersect(*args):
res = []
for x in args[0]: # Сканировать первую последовательность
for other in args[1:]: # Во всех остальных аргументах
if x not in other: break # Общий элемент?
else: # Нет: прервать цикл
res.append(x) # Да: добавить элемент в конец
return res
def union(*args):
res = []
for seq in args: # Для всех аргументов
for x in seq: # Для всех элементов
if not x in res:
res.append(x) # Добавить новый элемент в результат
return res
Поскольку эти функции могут использоваться многократно (и они
слишком большие, чтобы вводить их в интерактивной оболочке), мы
сохраним их в модуле с именем inter2.py (подробнее о модулях расска
зывается в пятой части книги). В обе функции аргументы передаются
в виде кортежа args. Как и оригинальная версия intersect, обе они ра
ботают с любыми типами последовательностей. Ниже приводится при
мер обработки строк, последовательностей разных типов и случай об
работки более чем двух последовательностей:
% python
>>> from inter2 import intersect, union
>>> s1, s2, s3 = "SPAM", "SCAM", "SLAM"
>>> intersect(s1, s2), union(s1, s2) # Два операнда
(['S', 'A', 'M'], ['S', 'P', 'A', 'M', 'C'])
>>> intersect([1,2,3], (1,4)) # Смешивание типов
[1]
>>> intersect(s1, s2, s3) # Три операнда
['S', 'A', 'M']
>>> union(s1, s2, s3)
['S', 'P', 'A', 'M', 'C', 'L']
Следует заметить, что в языке Python появился новый тип дан
ных – множества (описывается в главе 5), поэтому, строго говоря,
ни одна из этих функций больше не требуется, – они включены
в книгу только для демонстрации подходов к программированию
функций. (Так как Python постоянно улучшается, наблюдается
странная тенденция – мои книжные примеры делаются устарев
шими с течением времени!)
Специальные режимы сопоставления аргументов 435
Сопоставление аргументов: практические детали
Ниже приводится несколько правил в языке Python, которым вам не
обходимо следовать, если у вас появится потребность использовать
специальные режимы сопоставления аргументов:
• В вызове функции все аргументы, которые передаются не по ключу
(name), должны находиться в начале списка, далее должны следо
вать аргументы, которые передаются по ключу (name=value), вслед
за ними должна следовать форма *name и, наконец, **name.
• В заголовке функции аргументы должны стоять в том же самом по
рядке: обычные аргументы (name), вслед за ними аргументы со зна
чениями по умолчанию (name=value), далее форма *name, если необхо
димо, и, наконец, форма **name.
Если поставить аргументы в любом другом порядке, вы получите сооб
щение о синтаксической ошибке, потому что в этих случаях комбина
ция получается неоднозначной. Сам интерпретатор использует сле
дующий порядок сопоставления аргументов перед выполнением опе
раций присваивания:
1. Определяются позиционные аргументы, которые передаются не по
ключу.
2. Определяются аргументы, которые передаются по ключу, и произ
водится сопоставление имен.
3. Определяются и помещаются в кортеж *name дополнительные аргу
менты, которые передаются не по ключу.
4. Определяются и помещаются в словарь **name дополнительные ар
гументы, которые передаются по ключу.
5. Определяются аргументы, имеющие значения по умолчанию, кото
рые отсутствуют в вызове.
После этого интерпретатор убеждается, что в каждом аргументе пере
дается единственное значение, в противном возбуждает исключение.
Это действительно так же сложно, как выглядит, но изучение алгорит
ма сопоставления аргументов в языке Python поможет вам разобраться
с некоторыми сложными случаями, особенно когда одновременно ис
пользуются несколько режимов. Дополнительные примеры со специ
альными режимами сопоставления приводятся в упражнениях в конце
четвертой части.
Как видите, режимы сопоставления аргументов могут быть весьма
сложными. Но использовать их совершенно необязательно – вы може
те ограничиться исключительно позиционными аргументами и это,
пожалуй, будет наилучший выбор. Однако некоторые инструменты
языка Python используют эти режимы, поэтому их понимание играет
важную роль.
436 Глава 16. Области видимости и аргументы
В заключение
В этой главе мы изучили две ключевые концепции, имеющие отноше
ние к функциям: области видимости (как выполняется поиск перемен
ных при обращениях к ним) и аргументы (как объекты передаются
в функции). Здесь мы узнали, что переменные считаются локальными
для определений функций, где выполняется присваивание значений
этим переменным при условии, что они не объявлены как глобальные.
Кроме того, мы узнали, что аргументы передаются функции через опе
рацию присваивания, т. е. в виде ссылок на объекты, которые в дейст
вительности являются указателями.
Мы также познакомились с дополнительными особенностями облас
тей видимости и аргументов, например с областями видимости вло
женных функций и аргументами, которые передаются по ключу. На
конец мы познакомились с некоторыми рекомендациями по проекти
рованию приложений (стремиться минимизировать количество гло
бальных переменных и избегать изменений переменных в соседних
файлах) и увидели, что изменяемые объекты в аргументах проявляют
то же самое поведение, как и другие разделяемые ссылки на объекты, –
если функции явно не передается копия объекта, воздействие непо
Придется держать в уме:
аргументы, передаваемые по ключу
Аргументы, которые передаются по ключу, играют важную роль
в библиотеке Tkinter, которая фактически стала стандартным
средством для разработки графического интерфейса в языке Py
thon. Мы познакомимся с Tkinter далее в этой книге, но в каче
стве предварительного знакомства замечу, что при использова
нии этой библиотеки для установки значений параметров ком
понентов графического интерфейса используются аргументы,
передаваемые по ключу. Например, следующий вызов:
from Tkinter import *
widget = Button(text="Press me", command=someFunction)
создает новую кнопку и определяет текст на кнопке и функцию
обратного вызова, с помощью ключевых аргументов text и com
mand. Так как графические компоненты могут иметь большое чис
ло параметров, аргументы, передаваемые по ключу, позволяют
указывать только необходимые вам параметры. В противном
случае пришлось бы перечислять все возможные параметры в со
ответствии с их позициями или надеяться, что аргументы со зна
чениями по умолчанию будут правильно интерпретироваться во
всех возможных ситуациях.
Закрепление пройденного 437
средственно на изменяемый объект может отразиться на вызывающей
программе.
Следующая глава завершает тему функций исследованием более
сложных концепций, связанных с функциями: lambdaвыражений, ге
нераторов, итераторов, функциональных инструментов, таких как
map, и т. д. Многие из этих концепций исходят из того, что функции
в языке Python являются обычными объектами и потому поддержи
вают дополнительные, очень гибкие режимы работы. Однако, прежде
чем углубиться в эти темы, изучите контрольные вопросы к этой гла
ве, чтобы закрепить знания, полученные здесь.
Закрепление пройденного
Контрольные вопросы
1. Что выведет следующий фрагмент и почему?
>>> X = 'Spam'
>>> def func():
... print X
...
>>> func()
2. Что выведет следующий фрагмент и почему?
>>> X = 'Spam'
>>> def func():
... X = 'NI!'
...
>>> func()
>>> print X
3. Что выведет следующий фрагмент и почему?
>>> X = 'Spam'
>>> def func():
... X = 'NI'
... print X
...
>>> func()
>>> print X
4. Что выведет следующий фрагмент на этот раз и почему?
>>> X = 'Spam'
>>> def func():
... global X
... X = 'NI'
...
>>> func()
>>> print X
438 Глава 16. Области видимости и аргументы
5. Что можно сказать об этом фрагменте – что он выведет и почему?
>>> X = 'Spam'
>>> def func():
... X = 'NI'
... def nested():
... print X
... nested()
...
>>> func()
>>> X
6. И в последний раз: что выведет следующий фрагмент и почему?
>>> def func(a, b, c=3, d=4): print a, b, c, d
...
>>> func(1, *(5,6))
7. Назовите тричетыре способа в языке Python сохранять информа
цию о состоянии в функциях.
8. Назовите три способа, которые могут использоваться для передачи
результатов из функции в вызывающую программу.
Ответы
1. В данном случае будет выведена строка 'Spam', потому что функция
обращается к глобальной переменной в объемлющем модуле (если
внутри функции переменной не присваивается значение, она ин
терпретируется как глобальная).
2. В данном случае снова будет выведена строка 'Spam', потому что опе
рация присваивания внутри функции создает локальную перемен
ную и тем самым скрывает глобальную переменную с тем же име
нем. Инструкция print находит неизмененную переменную в гло
бальной области видимости.
3. Будет выведена последовательность символов 'Ni' в одной строке
и 'Spam' – в другой, потому что внутри функции инструкция print
найдет локальную переменную, а за ее пределами – глобальную.
4. На этот раз будет выведена строка 'Ni', потому что объявление glo
bal предписывает выполнять присваивание внутри функции пере
менной, находящейся в глобальной области видимости объемлю
щего модуля.
5. В этом случае снова будет выведена последовательность символов
'Ni' в одной строке и 'Spam' – в другой, потому что инструкция print
во вложенной функции отыщет имя в локальной области видимо
сти объемлющей функции, а инструкция print в конце фрагмента
отыщет имя в глобальной области видимости.
6. Здесь будет выведено "1 5 6 4": 1 соответствует аргументу в первой
позиции, 5 и 6 соответствуют аргументам b и c в соответствии с фор
Закрепление пройденного 439
мой *name (значение 6 переопределяет значение по умолчанию аргу
мента c) и d получит значение по умолчанию 4, потому что четвер
тый аргумент в вызове функции отсутствует.
7. Так как значения локальных переменных исчезают, когда функ
ция возвращает управление, то информацию о состоянии в языке
Python можно сохранять в глобальных переменных, для вложен
ных функций – в области видимости объемлющих функций, а так
же посредством аргументов со значениями по умолчанию. Альтер
нативный способ заключается в использовании классов и приемов
ООП, который обеспечивает лучшую поддержку возможности со
хранения информации о состоянии, чем любой из трех предыду
щих приемов, потому что этот способ делает сохранение явным, по
зволяя выполнять присваивание значений атрибутам.
8. Функции могут возвращать результаты с помощью инструкции re
turn, воздействуя на изменяемые объекты, передаваемые в аргу
ментах, а также изменением глобальных переменных. Вообще гло
бальные переменные использовать для этих целей не рекомендует
ся (за исключением редких случаев, таких как многопоточные про
граммы), потому что это осложняет понимание и использование
программного кода. Наилучшим способом является инструкция re
turn, хотя воздействие на изменяемые объекты – тоже неплохой ва
риант при условии, что он предусмотрен заранее. Кроме того, функ
ции могут выполнять обмен информацией через такие системные
устройства, как файлы и сокеты, но это уже выходит за рамки дан
ной главы.
17
Расширенные возможности функций
В этой главе будут представлены дополнительные расширенные воз
можности, имеющие отношение к функциям: lambdaвыражения, сред
ства функционального программирования, такие как функция map
и генераторы списков, функциигенераторы и выражениягенераторы
и многие другие. Отчасти искусство использования функций лежит
в области интерфейсов между ними, поэтому здесь мы также исследу
ем некоторые общие принципы проектирования функций. Так как это
последняя глава в четвертой части, ее завершает раздел с описанием
типичных ошибок и упражнения, которые помогут вам приступить
к использованию отраженных здесь идей.
Анонимные функции: lambda
Вы уже знаете, как писать свои собственные обычные функции на
языке Python. В следующих разделах будет описано несколько более
сложных концепций, имеющих отношение к функциям. Большинство
из них не являются обязательными, но при грамотном использовании
они могут упростить задачи программирования.
Помимо инструкции def в языке Python имеется возможность создавать
объекты функций в форме выражений. Изза сходства с аналогичной
возможностью в языке LISP она получила название lambda.1 Подобно
инструкции def это выражение создает функцию, которая будет вызы
ваться позднее, но в отличие от инструкции def, выражение возвращает
1 Название «lambda» отпугивает многих программистов, хотя в нем нет ни
чего страшного. Это название происходит из языка программирования
LISP, в котором это название было заимствовано из лямбдаисчисления –
разновидности символической логики. Однако в языке Python это просто
ключевое слово, которое вводит выражение синтаксически.
Анонимные функции: lambda 441
функцию, а не связывает ее с именем. Именно поэтому lambdaвыраже
ния иногда называют анонимными (т. е. безымянными) функциями.
На практике они часто используются как способ получить встроенную
функцию или отложить выполнение фрагмента программного кода.
lambdaвыражения
В общем виде lambda – это ключевое слово, за которым следуют один
или более аргументов (точно так же, как список аргументов в круглых
скобках в заголовке инструкции def), и далее, вслед за двоеточием, на
ходится выражение:
lambda argument1, argument2,... argumentN : выражение, использующее аргументы
В качестве результата lambdaвыражения возвращают точно такие же
объекты функций, которые создаются инструкцией def, но здесь есть
несколько различий, которые делают lambdaвыражения удобными в не
которых специализированных случаях:
• lambda – это выражение, а не инструкция. По этой причине ключе
вое слово lambda может появляться там, где синтаксис языка Python
не позволяет использовать инструкцию def, например внутри лите
ралов или в вызовах функций. Кроме того, lambdaвыражение воз
вращает значение (новую функцию), которое при желании можно
присвоить переменной, в противовес инструкции def, которая все
гда связывает функцию с именем в заголовке, а не возвращает ее
в виде результата.
• Тело lambda – это не блок инструкций, а выражение. Тело lambdaвы
ражения сродни тому, что вы помещаете в инструкцию return внут
ри определения def, – вы просто вводите результат в виде выраже
ния вместо его явного возврата. Вследствие этого ограничения lamb
daвыражения менее универсальны, чем инструкция def, – в теле
lambdaвыражения может быть реализована только логика, не ис
пользующая такие инструкции, как if. Такая реализация преду
смотрена заранее – она ограничивает возможность создания боль
шого числа уровней вложенности программ; lambdaвыражения
предназначены для создания простых функций, а инструкции def –
для решения более сложных задач.
Если отвлечься от этих различий, def и lambda выполняют одну и ту же
работу. Например, мы уже видели, как создаются функции с помощью
инструкции def:
>>> def func(x, y, z): return x + y + z
...
>>> func(2, 3, 4)
9
Но того же эффекта можно достигнуть с помощью lambdaвыражения,
явно присвоив результат имени, которое позднее будет использоваться
для вызова функции:
442 Глава 17. Расширенные возможности функций
>>> f = lambda x, y, z: x + y + z
>>> f(2, 3, 4)
9
Здесь имени f присваивается объект функции, созданный lambdaвыра
жением, – инструкция def работает точно так же, но присваивание вы
полняет автоматически.
В lambdaвыражениях точно так же можно использовать аргументы со
значениями по умолчанию:
>>> x = (lambda a="fee", b="fie", c="foe": a + b + c)
>>> x("wee")
'weefiefoe'
Для lambdaвыражений используются те же самые правила поиска пере
менных в областях видимости, что и для вложенных инструкций def.
lambdaвыражения создают локальную область видимости, как и вло
женные инструкции def, и автоматически получают доступ к именам
в объемлющих функциях, в модуле и во встроенной области видимо
сти (в соответствии с правилом LEGB):
>>> def knights():
... title = 'Sir'
... action = (lambda x: title + ' ' + x) # Заголовок в объемлющей def
... return action # Возвращает функцию
...
>>> act = knights()
>>> act('robin')
'Sir robin'
В этом примере до версии Python 2.2 значение для имени title переда
валось бы в виде значения по умолчанию – если вы забыли, почему,
вернитесь к главе 16, где рассматривались области видимости.
Зачем использовать lambdaвыражения?
Вообще говоря, lambdaвыражения очень удобны для создания очень
маленьких функций, к тому же они позволяют встраивать определе
ния функций в программный код, который их использует. Они не яв
ляются предметом первой необходимости (вы всегда сможете вместо
них использовать инструкции def), но они позволяют упростить сцена
рии, где требуется внедрять небольшие фрагменты программного кода.
Например, позднее мы увидим, что функции обратного вызова часто
реализуются в виде lambdaвыражений, встроенных непосредственно
в список аргументов, вместо инструкций def гдето в другом месте в мо
дуле и передаваемых по имени (примеры вы найдете во врезке «Придет
ся держать в уме: функции обратного вызова» ниже в этой главе).
lambdaвыражения также часто используются для создания таблиц пе+
реходов, которые представляют собой списки или словари действий,
выполняемых по требованию. Например:
Анонимные функции: lambda 443
L = [(lambda x: x**2), (lambda x: x**3), (lambda x: x**4)]
for f in L:
print f(2) # Выведет 4, 8, 16
print L[0](3) # Выведет 9
lambdaвыражения наиболее полезны в качестве сокращенного вариан
та инструкции def, когда необходимо вставить маленькие фрагменты
исполняемого программного кода туда, где использование инструк
ций недопустимо. Например, этот фрагмент программного кода созда
ет список из трех функций, встраивая lambdaвыражения в литерал
списка. Инструкция def не может быть вставлена в литерал, потому
что это – инструкция, а не выражение.
Подобные таблицы действий в языке Python можно создавать с помо
щью словаря и других структур данных:
>>> key = 'got'
>>> {'already': (lambda: 2 + 2),
... 'got': (lambda: 2 * 4),
... 'one': (lambda: 2 ** 6)
... }[key]()
8
В данном случае, когда интерпретатор Python создает словарь, каждое
из вложенных lambdaвыражений генерирует и оставляет после себя
функцию для последующего использования – обращение по ключу из
влекает одну из этих функций, а круглые скобки обеспечивают вызов
извлеченной функции. При таком подходе словарь превращается в бо
лее универсальное средство множественного выбора, чем то, что я смог
реализовать на основе инструкции if в главе 12.
Чтобы реализовать то же самое без использования lambdaвыражений,
пришлось бы написать три отдельные инструкции def за пределами
словаря, в котором эти функции используются:
def f1(): return 2 + 2
def f2(): return 2 * 4
def f3(): return 2 ** 6
...
key = 'one'
{'already': f1, 'got': f2, 'one': f3}[key]()
Этот прием тоже будет работать, но ведь инструкции def могут распо
лагаться в файле модуля достаточно далеко, несмотря на то, что они
очень короткие. Близость программного кода, которую обеспечивают
lambdaвыражения, особенно полезна, когда функции используются
в единственном месте – если три функции в этом фрагменте не исполь
зуются гдето еще, определенно имеет смысл встроить их в определе
ние словаря в виде lambdaвыражений. Кроме того, инструкции def тре
буют даже для маленьких функций указывать имена, а они могут
вступить в конфликт с другими именами в файле модуля.
444 Глава 17. Расширенные возможности функций
lambdaвыражения также очень удобно использовать в списках аргумен
тов функций – для определения временных функций, которые больше
нигде в программе не используются, – мы увидим примеры такого ис
пользования ниже, в этой главе, когда будем изучать функцию map.
Как (не) запутать программный код на языке Python
Тот факт, что lambda должно быть единственным выражением (а не се
рией инструкций), казалось бы, устанавливает серьезное ограничение
на объем логики, которую можно упаковать в lambdaвыражение. Од
нако если вы понимаете, что делаете, большую часть инструкций язы
ка Python можно представить в форме выражений.
Например, представим, что необходимо вывести некоторую информа
цию из тела lambdaвыражения, тогда достаточно просто записать
sys.stdout.write(str(x)+'\n’) вместо print x (в главе 11 объяснялось,
что это именно то действие, которое выполняет инструкция print).
Точно так же в lambdaвыражение можно заложить логику в виде трех
местного выражения if/else, представленного в главе 13, или исполь
зовать эквивалентную, хотя и более сложную комбинацию операторов
and/or, также описанную в главе 13. Как говорилось ранее, следую
щую инструкцию:
if a:
b
else:
c
можно имитировать одним из следующих примерно эквивалентных
выражений:
b if a else c
((a and b) or c)
Так как выражения, подобные этим, допустимо помещать внутрь lamb
daвыражения, они могут использоваться для реализации логики вы
бора внутри lambdaфункций:
>>> lower = (lambda x, y: x if x < y else y)
>>> lower('bb', 'aa')
'aa'
>>> lower('aa', 'bb')
'aa'
Кроме того, если внутри lambdaвыражения потребуется выполнять
циклы, их можно заменить вызовами функции map и генераторами
списков (с ними мы уже познакомились в главе 13 и вернемся к ним
еще раз ниже, в этой главе):
>>> import sys
>>> showall = (lambda x: map(sys.stdout.write, x))
Анонимные функции: lambda 445
>>> t = showall(['spam\n', 'toast\n', 'eggs\n'])
spam
toast
eggs
>>> showall = lambda x: [sys.stdout.write(line) for line in x]
>>> t = showall(('bright\n', 'side\n', 'of\n', 'life\n'))
bright
side
of
life
Теперь, когда я продемонстрировал вам некоторые уловки, я должен
просить вас использовать их только в случае крайней необходимости.
Без должной осторожности они могут сделать программный код нечи
табельным (запутанным). Вообще, простое лучше сложного, явное
лучше неявного, а понятные инструкции лучше таинственных выра
жений. С другой стороны, при умеренном использовании эти приемы
могут быть полезны.
Вложенные lambdaвыражения и области видимости
lambdaвыражения чаще других используют возможность поиска в об
ласти видимости вложенной функции (символ E в названии правила
LEGB, с которым мы познакомились в главе 16). Например, ниже
lambdaвыражение находится внутри инструкции def – типичный слу
чай – и потому получает значение имени x из области видимости объ
емлющей функции, имевшееся на момент ее вызова:
>>> def action(x):
... return (lambda y: x + y) # Создать и вернуть фцию, запомнить x
...
>>> act = action(99)
>>> act
<function <lambda> at 0x00A16A88>
>>> act(2)
101
В предыдущей главе, где обсуждались области видимости вложенных
функций, не говорилось о том, что lambdaвыражения обладают досту
пом к именам во всех объемлющих lambdaвыражениях. Это сложно се
бе вообразить, но представьте, что мы записали предыдущую инструк
цию def в виде lambdaвыражения:
>>> action = (lambda x: (lambda y: x + y))
>>> act = action(99)
>>> act(3)
102
>>> ((lambda x: (lambda y: x + y))(99))(4)
103
446 Глава 17. Расширенные возможности функций
Эта структура lambdaвыражений создает функцию, которая при вызо
ве создает другую функцию. В обоих случаях вложенное lambdaвыра
жение имеет доступ к переменной x в объемлющем lambdaвыражении.
Это фрагмент будет работать, но программный код выглядит весьма за
мысловато, поэтому в интересах соблюдения удобочитаемости лучше
избегать использования вложенных друг в друга lambdaвыражений.
Придется держать в уме:
функции обратного вызова
Другое распространенное применение lambdaвыражений состоит
в определении функций обратного вызова для Tkinter GUI API.
Например, следующий фрагмент создает кнопку, по нажатию
которой на консоль выводится сообщение:
import sys
x = Button(
text ='Press me',
command=(lambda:sys.stdout.write('Spam\n')))
Здесь в качестве обработчика события регистрируется функция,
сгенерированная lambdaвыражением в аргументе command. Преиму
щество lambdaвыражения перед инструкцией def в данном случае
состоит в том, что обработчик события нажатия на кнопку нахо
дится прямо здесь же, в вызове функции, создающей эту кнопку.
В действительности lambdaвыражение откладывает исполнение
обработчика до того момента, пока не произойдет событие: вызов
метода write произойдет, когда кнопка будет нажата, а не когда
она будет создана.
Поскольку правила областей видимости вложенных функций при
меняются и к lambdaвыражениям, их проще использовать в ка
честве функций обратного вызова. Начиная с версии Python 2.2,
они автоматически получают доступ к переменным объемлю
щих функций и в большинстве случаев не требуют передачи па
раметров со значениями по умолчанию. Это особенно удобно при
обращении к специальному аргументу экземпляра self, который
является локальной переменной в объемлющих методах классов
(подробнее о классах рассказывается в шестой части книги):
class MyGui:
def makewidgets(self):
Button(command=(lambda: self.display("spam")))
def display(self, message):
...использовать текст сообщения...
В предыдущих версиях даже self приходилось передавать в виде
аргумента со значением по умолчанию.
Применение функций к аргументам 447
Применение функций к аргументам
В некоторых программах бывает необходимо вызывать самые разные
функции одинаковым образом, заранее не зная ни имен функций, ни
их аргументов (примеры, где этот прием может быть полезен, будут
показаны позднее). Сделать это можно с помощью встроенной функ
ции apply и специального синтаксиса вызова в языке Python.
К моменту написания этих строк в версии Python 2.5 можно ис
пользовать и функцию apply, и специальный синтаксис вызова,
описываемые в этом разделе, но вполне вероятно, что в Python 3.0
функция apply исчезнет. Если для вас желательно, чтобы ваш
программный код сохранил свою работоспособность в будущем,
используйте специальный синтаксис вызова, а не функцию apply.
Встроенная функция apply
Для обеспечения динамичности сгенерированные функции можно вы
зывать, передавая их в качестве аргументов функции apply вместе с кор
тежем аргументов, которые должны быть переданы этой функции:
>>> def func(x, y, z): return x + y + z
...
>>> apply(func, (2, 3, 4))
9
>>> f = lambda x, y, z: x + y + z
>>> apply(f, (2, 3, 4))
9
Функция apply просто вызывает функцию, переданную ей в первом ар
гументе, и сопоставляет полученный кортеж аргументов с аргумента
ми, которые ожидает получить функция. Так как список аргументов
передается в виде кортежа (т. е. в виде структуры данных), программа
может создавать его во время выполнения.1
Истинная мощь функции apply заключается в том, что ей не требуется
знать, сколько аргументов принимает вызываемая ею функция. На
пример, можно с помощью условной инструкции if организовать вы
бор из множества функций и списков аргументов и затем передавать
их функции apply для вызова:
if <test>:
action, args = func1, (1,)
else:
action, args = func2, (1, 2, 3)
1 Будьте внимательны, не путайте функцию apply с функцией map, которая
описывается в следующем разделе. Функция apply вызывает функцию, по
лученную в аргументе, всего один раз, в то время как map вызывает функцию
несколько раз, по одному разу для каждого элемента последовательности.
448 Глава 17. Расширенные возможности функций
...
apply(action, args)
В общем случае функцию apply удобно использовать, когда заранее
нельзя определить список аргументов. Например, когда пользователь
выбирает произвольную функцию пользовательского интерфейса, мо
жет оказаться невозможным жестко определить вызов функции в сце
нарии. Чтобы решить эту проблему, можно просто создать список аргу
ментов в виде кортежа и вызвать функцию косвенно, с помощью apply:
>>> args = (2,3) + (4,)
>>> args
(2, 3, 4)
>>> apply(func, args)
9
Передача аргументов по ключу
Функция apply поддерживает третий необязательный аргумент, в ко
тором можно указать словарь, содержащий аргументы, передаваемые
функции по ключу:
>>> def echo(*args, **kwargs): print args, kwargs
...
>>> echo(1, 2, a=3, b=4)
(1, 2) {'a': 3, 'b': 4}
Эта возможность позволяет конструировать во время выполнения спи
ски позиционных аргументов и аргументов передаваемых по ключу:
>>> pargs = (1, 2)
>>> kargs = {'a':3, 'b':4}
>>> apply(echo, pargs, kargs)
(1, 2) {'a': 3, 'b': 4}
applyподобный синтаксис вызова
Тот же самый эффект, что дает функция apply, в языке Python можно
получить с использованием специального синтаксиса вызова. Этот
синтаксис отражает синтаксис передачи произвольного числа аргу
ментов в заголовке инструкции def, с которым мы познакомились
в главе 16. Например, предположим, что в этом примере используются
имена с присвоенными им значениями из примера выше:
>>> apply(func, args) # Традиционный способ: кортеж
9
>>> func(*args) # Новый, applyподобный синтаксис
9
>>> echo(*pargs, **kargs) # Словари с ключами также допустимы
(1, 2) {'a': 3, 'b': 4}
Этот специальный синтаксис вызова является более новым, чем функ
ция apply, и, в общем, более предпочтительным. Он не дает какихли
Отображение функций на последовательности: map 449
бо очевидных преимуществ перед явным вызовом apply, кроме соот
ветствия заголовку инструкции def и необходимости ввода меньшего
числа символов. Однако новый альтернативный синтаксис вызова по
зволяет передавать дополнительные аргументы и является более уни
версальным:
>>> echo(0, *pargs, **kargs) # Обычный, *tuple, **dictionary
(0, 1, 2) {'a': 3, 'b': 4}
Отображение функций
на последовательности: map
Одна из наиболее часто встречающихся задач, которые решаются в про
граммах, состоит в применении некоторой операции к каждому эле
менту в списке или в другой последовательности и сборе полученных
результатов. Например, обновление всех счетчиков в списке может
быть выполнено с помощью простого цикла for:
>>> counters = [1, 2, 3, 4]
>>>
>>> updated = []
>>> for x in counters:
... updated.append(x + 10) # Прибавить 10 к каждому элементу
...
>>> updated
[11, 12, 13, 14]
Но, так как такие операции встречаются достаточно часто, язык Py
thon предоставляет встроенную функцию, которая выполняет боль
шую часть этой работы. Функция map применяет указанную функцию
к каждому элементу последовательности и возвращает список, содер
жащий результаты всех вызовов функции. Например:
>>> def inc(x): return x + 10 # Функция, которая должна быть вызвана
...
>>> map(inc, counters) # Сбор результатов
[11, 12, 13, 14]
Функция map была представлена в главе 13, как средство одновремен
ного обхода сразу нескольких последовательностей в цикле. Как вы
наверняка помните, в той главе вместо функции мы передавали объ
ект None, чтобы выполнить попарное объединение элементов последо
вательностей. Ниже приводится более полезный пример, где исполь
зуется настоящая функция, применяемая ко всем элементам списка, –
функция map вызывает функцию inc для каждого элемента списка и со
бирает полученные результаты в новый список.
Функция map ожидает получить в первом аргументе функцию, поэтому
здесь часто можно встретить lambdaвыражения:
>>> map((lambda x: x + 3), counters) # Выражениефункция
[4, 5, 6, 7]
450 Глава 17. Расширенные возможности функций
В данном случае функция прибавляет число 3 к каждому элементу
списка counters, а так как эта функция нигде в другом месте больше не
используется, она оформлена в виде lambdaвыражения. Такой вариант
использования функции map представляет собой эквивалент цикла for,
поэтому такую утилиту в общем виде можно представить так:
>>> def mymap(func, seq):
... res = []
... for x in seq: res.append(func(x))
... return res
...
>>> map(inc, [1, 2, 3])
[11, 12, 13]
>>> mymap(inc, [1, 2, 3])
[11, 12, 13]
Однако функция map является встроенной функцией, поэтому она дос
тупна всегда, всегда работает одним и тем же способом и обладает неко
торыми преимуществами производительности (проще говоря – она вы
полняется быстрее, чем любой цикл for). Кроме того, функция map мо
жет использоваться в более сложных ситуациях, чем показано здесь.
Например, в данном случае имеется несколько аргументов с последо
вательностями, а функция map извлекает их параллельно и передает
как отдельные аргументы в функцию:
>>> pow(3, 4)
81
>>> map(pow, [1, 2, 3], [2, 3, 4]) # 1**2, 2**3, 3**4
[1, 8, 81]
Здесь функция pow при каждом вызове принимает от функции map два
аргумента – по одному из каждой последовательности. Мы могли реа
лизовать свою собственную функцию, имитирующую это действие, но
вполне очевидно, что в этом нет никакой необходимости, так как име
ется высокопроизводительная встроенная функция.
Этот вызов функции map напоминает генераторы списков, кото
рые рассматривались в главе 13 и с которыми мы встретимся еще
раз далее в этой главе. Основное отличие состоит в том, что map
применяет к каждому элементу последовательности не произ
вольное выражение, а функцию. Вследствие этого ограничения
она обладает меньшей гибкостью. Однако современная реализа
ция map в некоторых случаях обладает более высокой производи
тельностью, чем генераторы списков (например, когда отобража
ется встроенная функция), и использовать ее проще. Благодаря
этому функция map скорее всего останется доступной в версии Py
thon 3.0. Однако в недавнем описании Python 3.0 предлагалось
убрать из встроенного пространств имен (и, возможно, перенести
в модули) эту функцию, а также функции reduce и filter, которые
будут рассматриваться в следующем разделе.
Средства функционального программирования: filter и reduce 451
В то время как функция map может остаться в языке Python, функ
ции reduce и filter в версии 3.0 будут изъяты, отчасти потому, что
они избыточны и легко могут быть реализованы с помощью гене
раторов списков (функция filter легко замещается оператором if
в генераторах списков), а отчасти изза своей сложности (функция
reduce – одна из самых сложных функций в языке и одна из наиме
нее понятных). Впрочем, я не могу предсказывать будущее, поэто
му за дополнительной информацией об этих и других изменениях
обращайтесь к примечаниям к выпуску Python 3.0. Эти функции
попрежнему рассматриваются в данном издании книги потому,
что они входят в состав текущей версии Python, и почти наверняка
будут встречаться в программном коде еще какоето время.
Средства функционального
программирования: filter и reduce
Функция map – это простейший представитель класса встроенных
функций в языке Python, используемых в функциональном програм+
мировании, т. е. функций, которые применяют другие функции к по
следовательностям. Родственные ей функции отфильтровывают эле
менты с помощью функций, выполняющих проверку (filter), и при
меняют функции к парам элементов, накапливая результаты (reduce).
Например, следующий вызов функции filter отбирает элементы по
следовательности больше нуля:
>>> range(
5, 5)
[5, 4, 3, 2, 1, 0, 1, 2, 3, 4]
>>> filter((lambda x: x > 0), range(
5, 5))
[1, 2, 3, 4]
Элементы последовательности, для которых применяемая функция
возвращает истину, добавляются в список результатов. Как и функ
ция map, filter является примерным эквивалентом цикла for, только
она – встроенная функция и обладает высокой скоростью выполнения:
>>> res = [ ]
>>> for x in range(
5, 5):
... if x > 0:
... res.append(x)
...
>>> res
[1, 2, 3, 4]
reduce – более сложная функция. Ниже приводятся два вызова функции
reduce, которые вычисляют сумму и произведение элементов списка:
>>> reduce((lambda x, y: x + y), [1, 2, 3, 4])
10
>>> reduce((lambda x, y: x * y), [1, 2, 3, 4])
24
452 Глава 17. Расширенные возможности функций
На каждом шаге функция reduce передает текущую сумму или произве
дение вместе со следующим элементом списка lambdaфункции. По
умолчанию первый элемент последовательности принимается в качест
ве начального значения. Ниже приводится цикл for, эквивалентный
первому вызову, с жестко заданной операцией сложения внутри цикла:
>>> L = [1,2,3,4]
>>> res = L[0]
>>> for x in L[1:]:
... res = res + x
...
>>> res
10
Написать свою версию функции reduce (на тот случай, если она дейст
вительно будет убрана из Python 3.0) достаточно просто:
>>> def myreduce(function, sequence):
... tally = sequence[0]
... for next in sequence[1:]:
... tally = function(tally, next)
... return tally
...
>>> myreduce((lambda x, y: x + y), [1, 2, 3, 4, 5])
15
>>> myreduce((lambda x, y: x * y), [1, 2, 3, 4, 5])
120
Если этот пример разжег ваш интерес, загляните также во встроенный
модуль operator, который содержит функции, соответствующие встро
енным выражениям, которые могут пригодиться при использовании
некоторых функциональных инструментов:
>>> import operator
>>> reduce(operator.add, [2, 4, 6]) # Оператор сложения в виде функции
12
>>> reduce((lambda x, y: x + y), [2, 4, 6])
12
Как и функция map, filter и reduce поддерживают мощные приемы функ
ционального программирования. Некоторые программисты могут до
полнить комплект средств функционального программирования языка
Python также lambdaвыражениями в комплексе с функцией apply и ге
нераторами списков, которые рассматриваются в следующем разделе.
Еще раз о генераторах списков: отображения
Отображение операций на последовательности и сбор результатов яв
ляются настолько распространенной задачей в программировании на
языке Python, что в версии Python 2.0 появилась новая особенность –
генераторы списков, которые упрощают решение задач еще больше,
чем только что рассмотренные функции. Мы уже встречались с гене
Еще раз о генераторах списков: отображения 453
раторами списков в главе 13, но, так как они относятся к средствам
функционального программирования, таким как функции map и fil
ter, здесь мы вернемся к этой теме еще раз. С технической точки зре
ния эта особенность не привязана к функциям; как мы увидим, гене
раторы списков – более универсальные инструменты, чем map и filter,
но иногда их проще понять, проводя аналогии с функциональными
альтернативами.
Основы генераторов списков
Рассмотрим несколько примеров, демонстрирующих самые основы.
Как было показано в главе 7, встроенная функция ord в языке Python
возвращает целочисленный код ASCII единственного символа (обрат
ной к ней является встроенная функция chr – она возвращает символ,
соответствующий коду ASCII):
>>> ord('s')
115
Теперь предположим, что нам необходимо получить коды ASCII всех
символов в строке. Пожалуй, самый простой подход заключается в ис
пользовании цикла for, в котором полученные результаты добавляют
ся в список:
>>> res = []
>>> for x in 'spam':
... res.append(ord(x))
...
>>> res
[115, 112, 97, 109]
Однако теперь, когда мы уже познакомились с функцией map, тех же ре
зультатов мы можем достичь с помощью единственного вызова функ
ции без необходимости заботиться о создании и заполнении списка:
>>> res = map(ord, 'spam') # Применить функцию к последовательности
>>> res
[115, 112, 97, 109]
Но, начиная с версии Python 2.0, те же результаты можно получить
с помощью генератора списка:
>>> res = [ord(x) for x in 'spam'] # Применит выражение к последовательности
>>> res
[115, 112, 97, 109]
Генераторы списков собирают результаты применения произвольного
выражения к элементам последовательности и возвращают их в виде но
вого списка. Синтаксически генераторы списков заключаются в квад
ратные скобки (чтобы показать, что они конструируют списки). В про
стейшем виде генератор списков представляет собой выражение, опери
рующее переменной, за которым следует конструкция, напоминающая
454 Глава 17. Расширенные возможности функций
заголовок цикла for, в котором используется та же переменная. Во вре
мя выполнения интерпретатор Python собирает результаты выраже
ния для каждой итерации подразумеваемого списка.
Предыдущий пример дает тот же результат, что цикл for и вызов
функции map выше. Однако генераторы списков более удобны, особен
но, когда требуется применить к последовательности произвольное
выражение:
>>> [x ** 2 for x in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
Здесь создается список квадратов чисел от 0 до 9 (здесь мы позволили
интерактивной оболочке автоматически вывести список – если вам не
обходимо сохранить список, присвойте его переменной). Чтобы вы
полнить аналогичные действия с помощью функции map, потребова
лось бы написать отдельную функцию, реализующую операцию возве
дения в квадрат. Так как эта функция нам не потребуется в другом
месте программы, ее можно было бы (хотя это и не обязательно) реали
зовать не с помощью инструкции def, а в виде lambdaвыражения:
>>> map((lambda x: x ** 2), range(10))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
Этот вызов выполняет ту же работу, и он всего на несколько символов
длиннее эквивалентной реализации на базе генератора списка. Кроме
того, он ненамного сложнее (по крайней мере, для тех, кто разбирает
ся в lambdaвыражениях). Однако в случае более сложных выражений
генераторы списков часто выглядят проще. В следующем разделе бу
дет показано почему.
Добавление проверок и вложенных циклов
Генераторы списков обладают даже еще большей гибкостью, чем было
показано до сих пор. Например, после цикла for можно добавить опе
ратор if для реализации логики выбора. Генераторы списков с операто
ром if можно представить как аналог встроенной функции filter, пред
ставленной в предыдущем разделе, – они пропускают элементы, для ко
торых условное выражение в операторе if возвращает ложь. Ниже при
водятся две версии реализации выбора четных чисел в диапазоне от 0
до 4 – с помощью генератора списка и с помощью функции filter, кото
рая использует небольшое lambdaвыражение для выполнения проверки.
Для сравнения здесь также показана реализация на основе цикла for:
>>> [x for x in range(5) if x % 2 == 0]
[0, 2, 4]
>>> filter((lambda x: x % 2 == 0), range(5))
[0, 2, 4]
>>> res = [ ]
>>> for x in range(5):
Еще раз о генераторах списков: отображения 455
... if x % 2 == 0:
... res.append(x)
...
>>> res
[0, 2, 4]
Во всех этих версиях используется оператор деления по модулю (оста
ток от деления) %, с помощью которого определяются четные числа: ес
ли остаток от деления на два равен нулю, следовательно, число четное.
Вызов функции filter здесь также выглядит ненамного длиннее, чем
генератор списка. Однако, генераторы списков дают возможность объ
единять оператор if и произвольные выражения, позволяя добиться
эффекта действия функций filter и map в единственном выражении:
>>> [x ** 2 for x in range(10) if x % 2 == 0]
[0, 4, 16, 36, 64]
На этот раз создается список квадратов четных чисел в диапазоне от 0
до 9: цикл for пропускает числа, для которых условное выражение,
присоединенное справа, возвращает ложь, а выражение слева вычис
ляет квадраты. Эквивалентный вызов функции map потребовал бы от
нас больше работы – нам пришлось бы объединить выбор элементов
с помощью функции filter и обход списка с помощью map, что в ре
зультате дает более сложное выражение:
>>> map((lambda x: x**2), filter((lambda x: x % 2 == 0), range(10)))
[0, 4, 16, 36, 64]
В действительности, генераторы списков обладают еще большей гиб
костью. Они дают возможность запрограммировать любое число вло
женных циклов for, каждый из которых может сопровождаться собст
венным оператором if с условным выражением. В общем виде генера
торы списков выглядят следующим образом:
[ expression for target1 in sequence1 [if condition]
for target2 in sequence2 [if condition] ...
for targetN in sequenceN [if condition] ]
Вложенные операторы for в генераторах списков действуют точно так
же, как вложенные инструкции for. Например, следующий фрагмент:
>>> res = [x + y for x in [0, 1, 2] for y in [100, 200, 300]]
>>> res
[100, 200, 300, 101, 201, 301, 102, 202, 302]
дает тот же результат, что и более объемный эквивалент:
>>> res = []
>>> for x in [0, 1, 2]:
... for y in [100, 200, 300]:
... res.append(x + y)
...
>>> res
[100, 200, 300, 101, 201, 301, 102, 202, 302]
456 Глава 17. Расширенные возможности функций
Генераторы списков конструируют списки, однако итерации могут
выполняться по любым последовательностям и итерируемым объек
там. Следующий, немного похожий, фрагмент выполняет обход уже
не списков чисел, а строк, и возвращает результаты конкатенации:
>>> [x + y for x in 'spam' for y in 'SPAM']
['sS', 'sP', 'sA', 'sM', 'pS', 'pP', 'pA', 'pM',
'aS', 'aP', 'aA', 'aM', 'mS', 'mP', 'mA', 'mM']
В заключение приведу более сложный генератор списка, который ил
люстрирует действие оператора if, присоединенного к вложенному
оператору for:
>>> [(x, y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
Это выражение возвращает возможные комбинации четных и нечет
ных чисел в диапазоне от 0 до 4. Условные выражения отфильтровы
вают элементы в каждой из последовательностей. Ниже приводится
эквивалентная реализация на базе инструкций:
>>> res = []
>>> for x in range(5):
... if x % 2 == 0:
... for y in range(5):
... if y % 2 == 1:
... res.append((x, y))
...
>>> res
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
Не забывайте, что в случае, когда генератор списков становится слиш
ком сложным для понимания, вы всегда можете развернуть вложен
ные операторы for и if (добавляя отступы), чтобы получить эквива
лентные инструкции. Программный код при этом получится более
длинным, но более понятным.
Эквивалентные реализации на основе функций map и filter оказались
бы чрезвычайно сложными и имели бы глубокую вложенность вызо
вов, поэтому я даже не буду пытаться продемонстрировать их. Остав
лю эту задачу в качестве упражнения мастерам Дзен, бывшим про
граммистам на языке LISP и просто безумцам.
Генераторы списков и матрицы
Рассмотрим еще одно, более сложное применение генераторов спи
сков, чтобы поупражнять мозги. Основной способ реализации матриц
(они же – многомерные массивы) в языке Python заключается в ис
пользовании вложенных списков. В следующем примере определяют
ся матрицы 3x3 в виде вложенных списков:
>>> M = [[1, 2, 3],
... [4, 5, 6],
Еще раз о генераторах списков: отображения 457
... [7, 8, 9]]
>>> N = [[2, 2, 2],
... [3, 3, 3],
... [4, 4, 4]]
При такой организации всегда можно использовать обычную операцию
индексирования для обращения к строкам и элементам внутри строк:
>>> M[1]
[4, 5, 6]
>>> M[1][2]
6
Генераторы списков являются мощным средством обработки таких
структур данных, потому что они позволяют автоматически сканиро
вать строки и столбцы матриц. Например, несмотря на то, что при та
кой структуре матрицы хранятся в виде списка строк, мы легко мо
жем извлечь второй столбец, просто обходя строки матрицы и выби
рая элементы из требуемого столбца или выполняя обход требуемых
позиций в строках:
>>> [row[1] for row in M]
[2, 5, 8]
>>> [M[row][1] for row in (0, 1, 2)]
[2, 5, 8]
Пользуясь позициями, мы также легко можем извлечь элементы, ле
жащие на диагонали. В следующем примере используется функция
range – она создает список смещений, который затем используется для
индексирования строк и столбцов одним и тем же значением. В ре
зультате сначала выбирается M[0][0], затем M[1][1] и т. д. (здесь пред
полагается, что матрица имеет одинаковое число строк и столбцов):
>>> [M[i][i] for i in range(len(M))]
[1, 5, 9]
Наконец, проявив немного изобретательности, генераторы списков
можно использовать для объединения нескольких матриц. Первый
пример ниже создает простой список, содержащий результаты умно
жения соответствующих элементов двух матриц, а второй создает
структуру вложенных списков с теми же самыми значениями:
>>> [M[row][col] * N[row][col] for row in range(3) for col in range(3)]
[2, 4, 6, 12, 15, 18, 28, 32, 36]
>>> [[M[row][col] * N[row][col] for col in range(3)] for row in range(3)]
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]
В последнем выражении итерации по строкам выполняются во внеш
нем цикле: для каждой строки запускается итерация по столбцам, ко
торая создает одну строку в матрице с результатами. Это выражение
эквивалентно следующему фрагменту:
458 Глава 17. Расширенные возможности функций
>>> res = []
>>> for row in range(3):
... tmp = []
... for col in range(3):
... tmp.append(M[row][col] * N[row][col])
... res.append(tmp)
...
>>> res
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]
В отличие от этого фрагмента, версия на базе генератора списков уме
щается в единственную строку, вероятно, работает значительно быст
рее в случае больших матриц, но, правда, может и взорвать ваш мозг!
На этом перейдем к следующему разделу.
Понимание генераторов списков
При такой степени гибкости генераторы списков очень быстро могут
стать непостижимыми, особенно при наличии вложенных конструк
ций. Поэтому начинающим осваивать язык Python я рекомендую
в большинстве случаев использовать простые циклы for и функцию
map (если они не становятся слишком сложными). Здесь также дейст
вует правило «чем проще, тем лучше»: лаконичность программного
кода – намного менее важная цель, чем его удобочитаемость.
Однако в настоящее время усложнение программного кода обеспечи
вает более высокую его производительность: проведенные тесты свиде
тельствуют, что функция map работает практически в два раза быстрее,
чем эквивалентные циклы for, а генераторы списков обычно немного
быстрее, чем функция map.1 Это различие в скорости выполнения обу
словлено тем фактом, что функция map и генераторы списков реализо
ваны на языке C, что обеспечивает более высокую скорость, чем вы
полнение циклов for внутри виртуальной машины Python (PVM).
Применение циклов for делает логику программы более явной, поэто
му я рекомендую использовать их для обеспечения большей простоты.
Однако, функция map и генераторы списков стоят того, чтобы знать
и применять их для реализации простых итераций, а также в случаях,
1 Производительность этих тестов может зависеть от вида решаемой задачи,
а также от изменений и оптимизаций в самом интерпретаторе языка Py
thon. Например, в последних версиях Python была увеличена скорость вы
полнения инструкции цикла for. Тем не менее, генераторы списков обычно
показывают более высокую скорость работы, чем циклы for, и даже более
высокую, чем функция map (хотя функция map может выйти победителем
в состязании среди встроенных функций). Чтобы проверить скорость рабо
ты альтернативных реализаций, можно использовать функции time.clock
и time.time в модуле time. В версии Python 2.4 появился новый модуль
timeit, который рассматривается в разделе «Хронометраж итерационных
альтернатив» далее в этой главе.
Еще раз об итераторах: генераторы 459
когда скорость работы приложения имеет критически важное значе
ние. Кроме того, функция map и генераторы списков являются выраже
ниями и синтаксически могут находиться там, где недопустимо ис
пользовать инструкцию for, например в теле lambdaвыражений, в ли
тералах списков и словарей и во многих других случаях. То есть вы
должны стараться писать простые функции map и генераторы списков,
а в более сложных случаях использовать полные инструкции.
Еще раз об итераторах: генераторы
В этой части книги мы уже познакомились с обычными функциями, ко
торые получают входные параметры и возвращают результат. Однако
точно так же возможно написать функцию, которая может возвращать
значение, а позднее продолжить свою работу с того места, где она была
приостановлена. Такие функции известны как генераторы, потому что
они генерируют последовательность значений с течением времени.
Функциигенераторы во многом похожи на обычные функции, единст
венное отличие состоит в том, что они автоматически поддерживают
итерационный протокол и могут использоваться в контексте итераций.
Мы рассмотрели итераторы в главе 13, а здесь мы взглянем на них еще
раз, чтобы увидеть, какое отношение они имеют к генераторам.
Придется держать в уме:
генераторы списков и map
Ниже приводится более реалистичный пример использования
генераторов списков и функции map (мы решали эту задачу с по
мощью генераторов списков в главе 13, а здесь мы снова вернем
ся к ней, чтобы продемонстрировать альтернативную реализа
цию на базе функции map). Вспомните, что метод файлов read
lines возвращает строки с символом конца строки (\n) в конце:
>>> open('myfile').readlines()
['aaa\n', 'bbb\n', 'ccc\n']
Если требуется удалить символы конца строки, их можно отсечь
сразу во всех строках за одно действие с помощью генератора
списков или функции map:
>>> [line.rstrip() for line in open('myfile').readlines()]
['aaa', 'bbb', 'ccc']
>>> [line.rstrip() for line in open('myfile')]
['aaa', 'bbb', 'ccc']
>>> map((lambda line: line.rstrip()), open('myfile'))
['aaa', 'bbb', 'ccc']
460 Глава 17. Расширенные возможности функций
В отличие от обычных функций, которые возвращают значение и за
вершают работу, функциигенераторы автоматически приостанавли
вают и возобновляют свое выполнение, при этом сохраняя информа
цию, необходимую для генерации значений.
Вследствие этого часто они представляют собой удобную альтернативу
вычислению всей серии значений заранее и ручному сохранению и вос
становлению состояния в классах. Функциигенераторы при приоста
новке автоматически сохраняют информацию о своем состоянии, под
которым понимается вся локальная область видимости, со всеми ло
кальными переменными, которая становится доступной сразу же, как
только функция возобновляет работу.
Главное отличие функцийгенераторов от обычных функций состоит
в том, что генератор поставляет значение, а не возвращает его – ин
струкция yield приостанавливает работу функции и передает значение
вызывающей программе, при этом сохраняется информация о состоя
нии, необходимая, чтобы возобновить работу с того места, где она бы
В последних двух случаях используются файловые итераторы
(по сути это означает, что вам не требуется вызывать метод, кото
рый будет читать строки из файла). Вызов функции map выглядит
немного длиннее, чем генератор списков, но ни в одном из этих
двух случаев не требуется явно управлять списком результатов.
Кроме того, генераторы списков могут играть роль операции из
влечения столбца. Стандартный прикладной интерфейс доступа
к базам данных в языке Python возвращает результаты запроса
в виде списка кортежей, как показано ниже. Список – это табли
ца, кортежи – это строки, а элементы кортежей – это значения
столбцов:
listoftuple = [('bob', 35, 'mgr'), ('mel', 40, 'dev')]
Выбрать все значения из определенного столбца можно и вруч
ную, с помощью цикла for, но функция map и генераторы списков
сделают это быстрее и за один шаг:
>>> [age for (name, age, job) in listoftuple]
[35, 40]
>>> map((lambda (name, age, job): age), listoftuple)
[35, 40]
В обоих случаях используется операция присваивания кортежа,
чтобы извлечь значения в список.
За дополнительной информацией о прикладных интерфейсах
языка Python обращайтесь к другим книгам и источникам ин
формации.
Еще раз об итераторах: генераторы 461
ла приостановлена. Это позволяет функциям воспроизводить последо
вательности значений в течение долгого времени, вместо того чтобы
создавать всю последовательность сразу и возвращать ее в виде некото
рой конструкции, такой как список.
Функциигенераторы тесно связаны с понятием протокола итераций
в языке Python. Проще говоря, функции, содержащие инструкцию
yield, компилируются особым образом, как генераторы – при вызове
они возвращают объектгенератор, поддерживающий интерфейс итера
ций. Функциигенераторы могут также содержать инструкцию return,
которая завершает генерацию значений.
Объекты итераторов в свою очередь определяют метод next, который
либо возвращает следующий элемент в итерации, либо возбуждает ис
ключение (StopIteration) в конце итераций. Доступ к итератору можно
получить с помощью встроенной функции iter. Циклы for в языке Py
thon используют такой итерационный протокол, если он поддержива
ется, для обхода последовательностей (или генераторов последователь
ностей). Если протокол не поддерживается, инструкция for терпит не
удачу и возвращается к операции индексирования последовательности.
Пример функциигенератора
Генераторы и итераторы – это достаточно сложные особенности язы
ка, поэтому обязательно загляните в руководства по стандартной биб
лиотеке языка Python, где найдете исчерпывающую информацию.
Чтобы проиллюстрировать основные моменты, рассмотрим следую
щий фрагмент, где определяется функциягенератор, которая может
использоваться для генерации серии квадратов чисел:1
>>> def gensquares(N):
... for i in range(N):
... yield i ** 2 # Позднее продолжить работу с этого места
...
Эта функция поставляет значение и тем самым возвращает управление
вызывающей программе на каждой итерации цикла – когда она возоб
новляет работу, восстанавливается ее предыдущее состояние и управ
ление передается непосредственно в точку, находящуюся сразу же за
инструкцией yield. Например, при использовании в заголовке цикла
for управление возвращается функции на каждой итерации в точку,
находящуюся сразу же за инструкцией yield:
>>> for i in gensquares(5): # Возобновить работу функции
1 Генераторы появились в языке Python, начиная с версии 2.2. В версии 2.2
для их использования необходимо было применять специальную инструк
цию import: __future__ import generators (подробнее об этой форме инструк
ции рассказывается в главе 18). Генераторы стали доступны еще в версии 2.2
во многом благодаря тому, что лежащий в их основе протокол не требовал
нового ключевого слова yield, нарушающего обратную совместимость.
462 Глава 17. Расширенные возможности функций
... print i, ':', # Вывести последнее полученное значение
...
0 : 1 : 4 : 9 : 16 :
>>>
Для завершения генерации значений функция может либо воспользо
ваться инструкцией return без значения, либо просто позволить пото
ку управления достичь конца функции.
Если вам интересно узнать, что происходит внутри цикла for, вызови
те функциюгенератор напрямую:
>>> x = gensquares(4)
>>> x
<generator object at 0x0086C378>
Здесь обратно был получен объектгенератор, который поддерживает
протокол итераций (т. е. имеет метод next, который запускает функ
цию или возобновляет ее работу с места, откуда было поставлено по
следнее значение, а также возбуждает исключение StopIteration по
достижении конца последовательности значений):
>>> x.next()
0
>>> x.next()
1
>>> x.next()
4
>>> x.next()
9
>>> x.next()
Traceback (most recent call last):
File "<pyshell#453>", line 1, in <module>
x.next()
StopIteration
Циклы for работают с генераторами точно так же – вызывают метод
next в цикле, пока не будет перехвачено исключение. Если итерируе
мый объект не поддерживает этот протокол, вместо него цикл for ис
пользует протокол доступа к элементам по индексам.
Обратите внимание, что в этом примере мы могли бы просто сразу соз
дать список всех значений:
>>> def buildsquares(n):
... res = []
... for i in range(n): res.append(i**2)
... return res
...
>>> for x in buildsquares(5): print x, ':',
...
0 : 1 : 4 : 9 : 16 :
Еще раз об итераторах: генераторы 463
В такой ситуации мы могли бы использовать любой из приемов: цикл
for, функцию map или генератор списков:
>>> for x in [n**2 for n in range(5)]:
... print x, ':',
...
0 : 1 : 4 : 9 : 16 :
>>> for x in map((lambda x:x**2), range(5)):
... print x, ':',
...
0 : 1 : 4 : 9 : 16 :
Однако генераторы дают возможность избежать необходимости выпол
нять всю работу сразу, что особенно удобно, когда список результатов
имеет значительный объем или когда вычисление каждого значения
занимает продолжительное время. Генераторы распределяют время,
необходимое на создание всей последовательности значений, по отдель
ным итерациям цикла. Кроме того, в более сложных случаях использо
вания они обеспечивают простую альтернативу сохранению состояния
вручную между вызовами в объектах классов (подробнее о классах рас
сказывается в шестой части книги) – в случае с генераторами перемен
ные функций сохраняются и восстанавливаются автоматически.
Расширенный протокол функцийгенераторов:
send и next
В версии Python 2.5 в протокол функцийгенераторов был добавлен
метод send. Метод send не только перемещается к следующему элемен
ту в последовательности результатов, как это делает метод next, но еще
и обеспечивает для вызывающей программы способ взаимодейство
вать с генератором, влияя на его работу.
С технической точки зрения yield в настоящее время является не инст
рукцией, а выражением, которое возвращает элемент, передаваемый
методу send (несмотря на то, что его можно использовать любым из
двух способов, – как yield X или как A = yield(X)). Значения передают
ся генератору вызовом метода send(value). После этого программный
код генератора возобновляет работу, и выражение yield возвращает
значение, полученное от метода send. Когда вызывается обычный ме
тод next(), выражение yield возвращает None.
Метод send может использоваться, например, чтобы реализовать гене
ратор, который можно будет завершать из вызывающей программы.
Кроме того, генераторы в версии 2.5 поддерживают метод throw(type)
для возбуждения исключения внутри генератора в последнем выраже
нии yield и метод close(), который возбуждает исключение Generator
Exit внутри генератора, чтобы вынудить его завершить итерации. Мы
не будем углубляться здесь в эти расширенные возможности – за допол
нительной информацией обращайтесь к стандартным руководствам по
языку Python.
464 Глава 17. Расширенные возможности функций
Итераторы и встроенные типы
Как мы видели в главе 13, встроенные типы данных спроектированы
так, чтобы воспроизводить объекты итераторов в ответ на вызов встро
енной функции iter. Итераторы словарей, например, во время итера
ций воспроизводят список ключей:
>>> D = {'a':1, 'b':2, 'c':3}
>>> x = iter(D)
>>> x.next()
'a'
>>> x.next()
'c'
Кроме того, все разновидности итераций (включая циклы for, функ
цию map, генераторы списков и других, с которыми мы встречались
в главе 13) в свою очередь спроектированы так, чтобы для определе
ния – поддерживается ли протокол автоматически вызывать встроен
ную функцию iter. Именно поэтому существует возможность выпол
нить обход ключей словаря, не прибегая к вызову метода keys, строк
в файле – без вызова метода readlines или xreadlines и т. д.:
>>> for key in D:
... print key, D[key]
...
a 1
c 3
b 2
Мы также видели, что при использовании итераторов файлов интер
претатор Python просто загружает строки из файла по мере необходи
мости:
>>> for line in open('temp.txt'):
... print line,
...
Tis but
a flesh wound.
Кроме того, существует возможность реализовать произвольные объ
ектыгенераторы с помощью классов, которые соответствуют протоко
лу итераторов и поэтому могут использоваться в циклах for и в других
итерационных контекстах. Такие классы определяют специальный
метод __iter__, возвращающий объектитератор (что более предпочти
тельно, чем использование метода __getitem__, обеспечивающего дос
туп к элементам по индексу). Однако эта тема далеко выходит за рам
ки данной главы – обращайтесь к шестой части книги, где приводится
информация о классах, и к главе 24 в частности, где приводятся при
меры классов, реализующих протокол итераторов.
Еще раз об итераторах: генераторы 465
Выражениягенераторы: итераторы
и генераторы списков
В последних версиях Python понятия итератора и генератора списков
были объединены в новую языковую конструкцию – выражения+гене+
раторы. Синтаксически выражения напоминают обычные генераторы
списков, но они заключаются не в квадратные, а в круглые скобки:
>>> [x ** 2 for x in range(4)] # Генератор списков: создает список
[0, 1, 4, 9]
>>> (x ** 2 for x in range(4)) # Выражениегенератор: создает
# итерируемый объект
<generator object at 0x011DC648>
Однако с функциональной точки зрения выражениягенераторы кар
динально отличаются от генераторов списков – вместо того, чтобы соз
давать в памяти список с результатами, они возвращают объектгене
ратор, который в свою очередь поддерживает итерационный протокол,
поставляя по одному элементу списка за раз в любом итерационном
контексте:
>>> G = (x ** 2 for x in range(4))
>>> G.next()
0
>>> G.next()
1
>>> G.next()
4
>>> G.next()
9
>>> G.next()
Traceback (most recent call last):
File "<pyshell#410>", line 1, in <module>
G.next()
StopIteration
Как правило, нам не приходится наблюдать итерационную механику
действий выраженийгенераторов в виде вызовов метода next, как в дан
ном примере, потому что циклы for вызывают его автоматически:
>>> for num in (x ** 2 for x in range(4)):
... print '%s, %s' % (num, num / 2.0)
...
0, 0.0
1, 0.5
4, 2.0
9, 4.5
Фактически именно таким образом работает любой итерационный
контекст, включая встроенные функции sum, map и sorted, и другие ите
рационные инструменты, которые мы рассматривали в главе 13, такие
как встроенные функции all, any и list.
466 Глава 17. Расширенные возможности функций
Обратите внимание, что круглые скобки вокруг выражениягенерато
ра можно опустить, если оно является единственным элементом, за
ключенным в другие круглые скобки, например в вызове функции.
Однако круглые скобки необходимы во втором вызове функции sorted:
>>> sum(x ** 2 for x in range(4))
14
>>> sorted(x ** 2 for x in range(4))
[0, 1, 4, 9]
>>> sorted((x ** 2 for x in range(4)), reverse=True)
[9, 4, 1, 0]
>>> import math
>>> map(math.sqrt, (x ** 2 for x in range(4)))
[0.0, 1.0, 2.0, 3.0]
Выражениягенераторы в первую очередь оптимизируют использова
ние памяти – они не требуют создания в памяти полного списка с ре
зультатами, как это делают генераторы списков в квадратных скобках.
Кроме того, на практике они могут работать несколько медленнее, по
этому их лучше использовать, только когда объем результатов очень
велик, – и мы естественным образом переходим к следующему разделу.
Хронометраж итерационных альтернатив
В этой книге нам встретилось несколько итерационных альтернатив.
Чтобы подвести итог, коротко проанализируем ситуацию, соединив
все, что мы узнали об итерациях и функциях.
Я уже упоминал, что генераторы списков обладают более высокой ско
ростью выполнения, чем циклы for, а скорость работы функции map мо
жет быть выше или ниже в зависимости от конкретной решаемой зада
чи. Выражениягенераторы, рассматривавшиеся в предыдущем разде
ле, обычно немного медленнее, чем генераторы списков, но при этом
они минимизируют требования к объему используемой памяти.
Все это справедливо на сегодняшний день, но относительная произво
дительность может измениться со временем (интерпретатор Python по
стоянно оптимизируется). Если вам захочется проверить это самим,
попробуйте запустить следующий сценарий на своем компьютере, со
своей версией интерпретатора:
# файл timerseqs.py
import time, sys
reps = 1000
size = 10000
def tester(func, *args):
startTime = time.time()
for i in range(reps):
Хронометраж итерационных альтернатив 467
func(*args)
elapsed = time.time()  startTime
return elapsed
def forStatement():
res = []
for x in range(size):
res.append(abs(x))
def listComprehension():
res = [abs(x) for x in range(size)]
def mapFunction():
res = map(abs, range(size))
def generatorExpression():
res = list(abs(x) for x in range(size))
print sys.version
tests = (forStatement, listComprehension, mapFunction, generatorExpression)
for testfunc in tests:
print testfunc.__name__.ljust(20), '=>', tester(testfunc)
Этот сценарий тестирует все альтернативные способы создания спи
сков и, как видно из листинга, выполняет по 10 миллионов итераций
каждым из способов, т. е. каждый из тестов создает список из 10 000
элементов 1000 раз.
Обратите внимание, как выражениегенератор вызывается через вызов
встроенной функции list, чтобы вынудить его выдать все значения, –
если бы этого не было сделано, мы бы просто создали генератор, кото
рый не выполняет никакой работы. Кроме того, заметьте, как про
граммный код в самом конце сценария выполняет обход кортежа из
четырех функций и выводит значение атрибута __name__ для каждой из
них: это встроенный атрибут, который возвращает имя функции.
Когда я запустил этот сценарий в среде IDLE в Windows XP, где уста
новлен Python 2.5, я обнаружил следующее: генератор списков ока
зался почти в два раза быстрее эквивалентной инструкции цикла for,
функция map оказалась немного быстрее генератора списков при ото
бражении встроенной функции abs (возвращает абсолютное значение):
2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)]
forStatement => 6.10899996758
listComprehension => 3.51499986649
mapFunction => 2.73399996758
generatorExpression => 4.11600017548
Но вот как изменилось положение дел, когда сценарий был изменен
так, чтобы он выполнял настоящую операцию, такую как сложение:
...
...
def forStatement():
res = []
468 Глава 17. Расширенные возможности функций
for x in range(size):
res.append(x + 10)
def listComprehension():
res = [x + 10 for x in range(size)]
def mapFunction():
res = map((lambda x: x + 10), range(size))
def generatorExpression():
res = list(x + 10 for x in range(size))
...
...
Присутствие вызова функции сделало вызов map таким же медленным,
как и цикл for, несмотря на то, что инструкция цикла содержит боль
ше программного кода:
2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)]
forStatement => 5.25699996948
listComprehension => 2.68400001526
mapFunction => 5.96900010109
generatorExpression => 3.37400007248
Так как внутренние механизмы интерпретатора сильно оптимизирова
ны, анализ производительности, как в данном случае, становится очень
непростым делом. В действительности невозможно заранее утвер
ждать, какой метод лучше – лучшее, что можно сделать, это провести
хронометраж своего программного кода, на своем компьютере, со сво
ей версией Python. В этом случае все, что можно сказать наверняка, –
это то, что в данной версии Python использование пользовательской
функции в вызове map может привести к снижению производительно
сти по крайней мере в 2 раза и что в этом испытании генератор списков
оказался самым быстрым.
Однако, как уже говорилось ранее, производительность не должна быть
главной целью при создании программ на языке Python – основное вни
мание должно уделяться удобочитаемости и простоте программного ко
да, и только потом код можно будет оптимизировать, если это действи
тельно необходимо. Вполне возможно, что все четыре варианта облада
ют достаточной скоростью обработки имеющихся наборов данных –
в этом случае основной целью должна быть ясность программного кода.
Чтобы еще глубже вникнуть в ситуацию, попробуйте изменить коли
чество повторений в начале сценария или рассмотрите возможность
использования новейшего модуля timeit, который автоматизирует
хронометраж кода и позволяет избежать проблем, связанных с ис
пользуемой платформой (на некоторых платформах, к примеру, пред
почтительнее использовать функцию time.time, а не time.clock). Кроме
того, обратите внимание на модуль profile из стандартной библиоте
ки, где вы найдете полные исходные тексты инструментов профилиро
вания программного кода.
Концепции проектирования функций 469
Концепции проектирования функций
Когда начинают использоваться функции, возникает проблема выбо
ра, как лучше связать элементы между собой, например, как разло
жить задачу на функции (связность), как должны взаимодействовать
функции (взаимодействие) и т. д. Вы должны учитывать такие поня
тия, как слаженность, взаимодействие и размер функций, – часть ко
торых относится к категории структурного анализа и проектирова
ния. Некоторые понятия, имеющие отношение к взаимодействию
функций и модулей, были представлены в предыдущей главе, а здесь
мы коротко рассмотрим некоторые основные правила для тех, кто на
чинает осваивать язык Python:
• Взаимодействие: для передачи значений функции используйте ар!
гументы, для возврата результатов – инструкцию return. Всегда
следует стремиться сделать функцию максимально независимой от
того, что происходит за ее пределами. Аргументы и инструкция re
turn часто являются лучшими способами ограничить внешнее воз
действие небольшим числом известных мест в программном коде.
• Взаимодействие: используйте глобальные переменные, только ес!
ли это действительно необходимо. Глобальные переменные (т. е.
имена в объемлющем модуле) обычно далеко не самый лучший спо
соб организации взаимодействий с функциями. Они могут порож
дать зависимости и проблемы согласованности, которые существен
но осложняют отладку программ.
• Взаимодействие: не воздействуйте на изменяемые аргументы, если
вызывающая программа не предполагает этого. Функции могут
оказывать воздействие на части изменяемых объектов, получае
мых в виде аргументов, но, как и в случае с глобальными перемен
ными, это предполагает слишком тесную связь между вызывающей
программой и вызываемой функцией, что может сделать функцию
слишком специфичной и неустойчивой.
• Связность: каждая функция должна иметь единственное назначе!
ние. Хорошо спроектированная функция должна решать одну зада
чу, которую можно выразить в одном повествовательном предложе
нии. Если это предложение допускает слишком широкое толкова
ние (например: «эта функция реализует всю программу целиком»)
или содержит союзы (например: «эта функция дает возможность
клиентам составлять и отправлять заказ на доставку пиццы»), то
стоит подумать над тем, чтобы разбить ее на отдельные и более про
стые функции. В противном случае окажется невозможным по
вторно использовать программный код функции, в котором смеша
ны различные действия.
• Размер: каждая функция должна иметь относительно небольшой
размер. Это условие естественным образом следует из предыдущего,
однако если функция начинает занимать несколько экранов, – это
470 Глава 17. Расширенные возможности функций
явный признак, что пора подумать о том, чтобы разбить ее. Особен
но, если учесть краткость, присущую языку Python. Длинная функ
ция с большой глубиной вложенности часто свидетельствует о прома
хах в проектировании. Сохраняйте функции короткими и простыми.
• Взаимодействие: избегайте непосредственного изменения пере!
менных в другом модуле. Мы рассматривали эту концепцию в пре
дыдущей главе и еще вернемся к ней в следующей части книги, ко
гда сконцентрируем свое внимание на модулях. И тем не менее на
помню, что непосредственное изменение переменных в других мо
дулях устанавливает тесную зависимость между модулями, так же
как тесную зависимость устанавливает изменение глобальных пе
ременных из функций – модули становятся сложными в понима
нии и малопригодными для многократного использования. Всегда,
когда это возможно, для изменения переменных модуля вместо
прямых инструкций присваивания используйте функции доступа.
На рис. 17.1 приводится схема организации взаимодействий функций
с внешним миром – входные данные поступают в функции из элемен
тов слева, а результаты могут возвращаться в любой из форм справа.
Многие программисты предпочитают использовать для ввода только
аргументы, и для вывода – только инструкцию return.
Конечно, из приведенных выше правил проектирования есть свои ис
ключения, включая те, что связаны с поддержкой ООП в языке Python.
Как вы увидите в шестой части книги, классы в языке Python зависят
от изменения передаваемого изменяемого объекта – функции воздей
ствуют на атрибуты аргумента self, получаемого автоматически, из
Рис. 17.1. Окружение функции времени выполнения. Функция может полу+
чать входные данные и возвращать результаты различными способами,
однако функции проще в понимании и сопровождении, когда входные данные
передаются в виде аргументов, а возврат результатов производится с помо+
щью инструкции return или посредством воздействия на изменяемые аргу+
менты, при условии, что последнее предполагается вызывающей программой
Другие функции
Входные данные Выходные данные
Аргументы
Глобальные переменные
Файлы/потоки
Функция
Локальные
переменные
Инструкция return
Изменяемые аргументы
Глобальные переменные
Файлы/потоки
Концепции проектирования функций 471
меняя информацию о его состоянии (например, self.name = 'bob').
Кроме того, когда классы не используются, глобальные переменные
часто представляют для функций в модуле наилучший способ сохране
ния состояния между вызовами. Побочные эффекты в этом случае не
опасны, потому что они ожидаемы.
Функции – это объекты: косвенный вызов
Так как функции в языке Python во время выполнения являются объ
ектами, можно написать такую программу, которая будет обрабаты
вать их в общем виде. Объекты функций могут присваиваться, пере
даться другим функциям, сохраняться в структурах данных и т. д.,
как если бы они были простыми числами или строками. Мы встречали
уже такие способы использования в более ранних примерах. Кроме то
го, объекты функций поддерживают специальные операции: они мо
гут вызываться перечислением аргументов в круглых скобках, сле
дующих сразу же за выражением функции. И тем не менее, функции
принадлежат к той же категории, что и другие объекты.
Например, в имени, которое используется в инструкции def, нет ниче
го уникального: это всего лишь переменная, которая создается в теку
щей области видимости, как если бы она стояло слева от знака =. По
сле того как инструкция def будет выполнена, имя функции представ
ляет собой всего лишь ссылку на объект – ее можно присвоить другим
именам и вызывать функцию по любому из них (не только по первона
чальному имени):
>>> def echo(message): # Имени echo присваивается объект функции
... print message
...
>>> x = echo # Теперь на эту функцию ссылается еще и имя x
>>> x('Hello world!') # Вызов объекта добавлением ()
Hello world!
Поскольку аргументы передаются путем присваивания объектов,
функции легко можно передавать другим функциям в виде аргумен
тов. В результате вызываемая функция может вызвать переданную ей
функцию простым добавлением списка аргументов в круглых скобках:
>>> def indirect(func, arg):
... func(arg) # Вызов объекта добавлением ()
...
>>> indirect(echo, 'Hello jello!') # Передача функции в функцию
Hello jello!
Существует даже возможность наполнять структуры данных функ
циями, как если бы они были простыми числами или строками. В этом
нет ничего особенного, так как составные типы объектов могут содер
жать объекты любых типов:
>>> schedule = [ (echo, 'Spam!'), (echo, 'Ham!') ]
>>> for (func, arg) in schedule:
472 Глава 17. Расширенные возможности функций
... func(arg)
...
Spam!
Ham!
В этом фрагменте просто выполняется обход списка schedule и произ
водится вызов функции echo с одним аргументом (обратите внимание
на операцию присваивания кортежа в заголовке инструкции цикла
for, которая была представлена в главе 13). Отсутствие описаний ти
пов делает язык программирования Python невероятно гибким.
Типичные ошибки при работе с функциями
При работе с функциями вас поджидают подводные камни, о которых
вы можете не догадываться. Они не всегда видны, некоторые из них
исчезли в последних версиях, но большая часть оставшихся продол
жает ставить в тупик начинающих программистов.
Локальные имена определяются статически
Как известно, имена, которым выполняется присваивание внутри
функции, по умолчанию рассматриваются как локальные – они рас
полагаются в области видимости функции и существуют только во
время работы функции. Но я еще не говорил, что локальные перемен
ные определяются статически, во время компиляции программного
кода в инструкции def, а не в соответствии с операциями присваива
ния, производимыми во время выполнения. Эта особенность становит
ся причиной появления самых причудливых сообщений в группе но
востей, получаемых от начинающих программистов.
Обычно, если внутри функции имени не присваивается какоелибо
значение, поиск его будет производиться в области видимости объем
лющего модуля:
>>> X = 99
>>> def selector(): # Переменная X используется, но ей ничего
# не присваивается
... print X # Переменная X будет найдена в глобальной
# области видти
...
>>> selector()
99
В этом фрагменте переменная X внутри функции определяется как пе
ременная X модуля. Но посмотрите, что произойдет, если добавить ин
струкцию присваивания переменной X после ее использования:
>>> def selector():
... print X # Переменная еще не существует!
... X = 88 # X классифицируется как локальная переменная
... # То же самое происходит при "import X", "def X"...
Типичные ошибки при работе с функциями 473
>>> selector()
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "<stdin>", line 2, in selector
UnboundLocalError: local variable 'X' referenced before assignment
(UnboundLocalError: обращение к локальной переменной 'X' до присваивания)
Было получено сообщение о том, что переменная не определена, но
причина его появления неочевидна. Этот программный код компили
руется интерпретатором во время ввода в интерактивной оболочке или
во время импорта модуля. Во время компиляции Python обнаружива
ет операцию присваивания переменной X и делает вывод, что X – это
локальное имя везде в теле функции. Но во время выполнения функ
ции, изза того что к моменту вызова инструкции print операция при
сваивания еще не производилась, интерпретатор сообщает о том, что
имя не определено. Согласно этому правилу использования имен он го
ворит, что обращение к локальной переменной X произведено до того,
как ей было присвоено значение. Фактически, любая операция при
сваивания внутри функции создает локальное имя. Операция импор
тирования, =, вложенные инструкции def, вложенные определения
классов и т. д., – все трактуются именно таким образом.
Проблема возникает изза того, что операция присваивания делает
имена локальными для всей функции, а не только для той ее части, ко
торая следует за инструкцией присваивания. На самом деле предыду
щий пример далеко не однозначен: что имелось в виду – требовалось
вывести глобальную переменную X и затем создать локальную пере
менную или это просто ошибка программиста? Так как Python интер
претирует имя X как локальное во всей функции, то это ошибка – если
вы действительно хотите вывести значение глобальной переменной X,
объявите ее глобальной с помощью инструкции global:
>>> def selector():
... global X # Принудительное объявление X глобальным (везде)
... print X
... X = 88
...
>>> selector()
99
При этом следует помнить, что в этом случае операция присваивания
изменит глобальную переменную X, а не локальную. Внутри функции
можно использовать как локальную, так и глобальную версии одного
и того же имени. Если вы действительно предполагаете вывести значе
ние глобальной переменной, а затем присвоить значение локальной
версии того же самого имени, импортируйте вмещающий модуль и об
ращайтесь к глобальной переменной как к атрибуту модуля:
>>> X = 99
>>> def selector():
... import __main__ # Импортировать вмещающий модуль
474 Глава 17. Расширенные возможности функций
... print __main__.X # Квалифицированное обращение
# к глобальной версии имени
... X = 88 # Неквалифицированное локальное имя X
... print X # Вывести локальную версию имени
...
>>> selector()
99
88
Обращение по квалифицированному (полному) имени (с .X) приводит
к извлечению значения из пространства имен объекта. Пространством
имен интерактивной оболочки является модуль с именем __main__, по
этому при обращении по имени __main__.X извлекается глобальная вер
сия X. Если чтото вам показалось непонятным, прочитайте пятую
часть книги.1
Значения по умолчанию и изменяемые объекты
Значения по умолчанию для аргументов функции вычисляются и за
поминаются в момент выполнения инструкции def, а не при вызове
функции. Внутренняя реализация Python сохраняет по одному объек
ту для каждого аргумента со значением по умолчанию, присоединен
ного к функции.
Вычисление значений по умолчанию в момент определения функции
позволяет, в случае необходимости, сохранять значения из объемлю
щей области видимости. Но, так как значения по умолчанию сохраня
ются между вызовами функции, следует быть внимательным при воз
действии на изменяемые значения по умолчанию. Например, следую
щая функция использует пустой список в качестве значения по умол
чанию своего аргумента, а затем изменяет его при каждом вызове:
>>> def saver(x=[]): # Объект списка сохраняется
... x.append(1) # При каждом вызове изменяется один и тот же объект!
... print x
...
>>> saver([2]) # Значение по умолчанию не используется
[2, 1]
>>> saver() # Используется значение по умолчанию
[1]
>>> saver() # Список растет при каждом вызове!
[1, 1]
>>> saver()
[1, 1, 1]
1 Положение дел с локальными переменными в языке Python к настоящему
моменту несколько улучшилось, потому что в данном случае выводится бо
лее определенное сообщение об ошибке «обращение к локальной перемен
ной до присваивания», которое показано в листинге примера (теперь оно
используется вместо более расплывчатого сообщения об ошибке, связанной
с именем), впрочем, этот вид ошибки все еще встречается.
Типичные ошибки при работе с функциями 475
Некоторые воспринимают такое поведение как достоинство – изменяе
мые аргументы по умолчанию сохраняют свое состояние между вызова
ми функции, поэтому они могут играть роль, подобную роли статиче+
ских локальных переменных в языке C. В некотором смысле они ведут
себя как глобальные переменные за исключением того, что их имена яв
ляются локальными по отношению к функциям, вследствие чего исклю
чается конфликт имен с переменными, определенными в другом месте.
Для большинства же это выглядит как недостаток, особенно для тех,
кто впервые сталкивается с этой особенностью. В языке Python суще
ствует лучший способ сохранения состояния между вызовами функ
ций (например, за счет использования классов, которые будут рас
сматриваться в шестой части книги).
Кроме того, такое поведение аргументов по умолчанию сложно запом
нить (и вообще понять). Они могут изменяться с течением времени.
В предыдущем примере для значения по умолчанию существует един
ственный объект списка – тот, что был создан в момент выполнения
инструкции def. При каждом обращении к функции не будет созда
ваться новый список, поэтому он будет расти с каждым новым вызо
вом – он не опустошается при каждом вызове.
Если такое поведение является неприемлемым, можно просто созда
вать копию аргумента по умолчанию в начале тела функции или пере
местить выражение, возвращающее значение по умолчанию, в тело
функции. Поскольку в этом случае значение по умолчанию будет на
ходиться в программном коде, который выполняется при каждом вы
зове функции, вы всякий раз будете получать новый объект:
>>> def saver(x=None):
... if x is None: # Аргумент отсутствует?
... x = [] # Создать новый список
... x.append(1) # Изменить объект списка
... print x
...
>>> saver([2])
[2, 1]
>>> saver() # Список больше не растет
[1]
>>> saver()
[1]
Между прочим, инструкцию if в этом примере в большинстве случаев
можно было бы заменить выражением x = x or [], где используется тот
факт, что оператор or в языке Python возвращает один из двух объек
тов: если аргумент отсутствует, имя x получит значение по умолчанию
None, и тогда оператор or вернет новый пустой список справа от него.
Однако это не совсем одно и то же. Если функции будет передан пус
той список, оператор вернет вновь созданный список вместо получен
ного в аргументе, как это делает инструкция if. (Выражение примет
вид [] or [], которое возвращает новый пустой список справа, – вер
476 Глава 17. Расширенные возможности функций
нитесь к разделу «Проверка истинности» в главе 12, если вам не по
нятно, почему так происходит). В разных программах могут предъяв
ляться разные требования к такому поведению.
Функции, не возвращающие результат
В языке Python функции могут не иметь инструкцию return (или
yield). Когда функция не возвращает управление явно, выход из нее
происходит, когда поток управления достигает конца тела функции.
С технической точки зрения все функции возвращают некоторое зна
чение – в отсутствие инструкции return функция автоматически воз
вращает объект None:
>>> def proc(x):
... print x # Нет возвращаемого значения, возвращается None
...
>>> x = proc('testing 123...')
testing 123...
>>> print x
None
Такие функции, как эта, не имеющие инструкции return, представля
ют собой эквивалент того, что в других языках программирования на
зывается «процедурами». Как правило, они вызываются как инструк
ции, а возвращаемое значение None игнорируется, поскольку они вы
полняют свою работу, не вычисляя результат.
Об этом следует помнить, потому что интерпретатор ничего не сообщит
вам, если вы попытаетесь присвоить результат функции, которая ни
чего не возвращает. Например, присваивание результата метода спи
сков append не вызывает появления ошибки, но при этом вы получите
объект None, а не обновленный список:
>>> list = [1, 2, 3]
>>> list = list.append(4) # Метод append – это "процедура"
>>> print list # Метод append изменяет сам список
None
Как упоминалось в разделе «Типичные ошибки программирования»
в главе 14, действие таких функций проявляется как побочный эф
фект и они обычно вызываются как инструкции, а не как выражения.
Переменные цикла в объемлющей области видимости
Эта ошибка была описана в главе 16, когда мы рассматривали области
видимости объемлющих функций, однако напомню еще раз: будьте
внимательны при использовании переменных в области видимости
объемлющей функции, которые изменяются объемлющим циклом –
все ссылки на эту переменную будут запоминать значение, которое бу
дет иметь переменная в последней итерации цикла. Чтобы сохранить
значения переменной цикла в каждой итерации, используйте аргу
В заключение 477
менты со значениями по умолчанию (дополнительные сведения по
этой теме вы найдете в главе 16).
В заключение
В этой главе мы рассмотрели расширенные понятия, связанные с функ
циями – lambdaвыражения; функциигенераторы и инструкцию yield;
выражениягенераторы: applyподобный синтаксис вызова; инстру
менты функционального программирования, такие как map, filter
и reduce; и общие правила проектирования функций. Мы также по
вторно рассмотрели итераторы и генераторы списков, просто потому,
что они так же связаны с функциональным программированием, как
и инструкции циклов. В завершение изучения итерационных концеп
ций мы произвели измерения производительности различных методов
выполнения итераций. Наконец, мы коротко рассмотрели типичные
ошибки, допускаемые при работе с функциями, чтобы помочь вам
обойти потенциальные ловушки.
Эта глава завершает функциональную часть книги. В следующей час
ти мы рассмотрим модули – вершину в иерархии структур языка Py
thon; структуру, в которой всегда и располагаются наши функции. По
сле этого мы займемся исследованием классов – инструментов, кото
рые являются пакетами функций со специальным первым аргумен
том. Как вы увидите, все, что мы здесь узнали, пригодится везде, где
далее в книге будут появляться функции.
Но прежде чем двинуться дальше, проверьте, насколько вы овладели
основами функций, ответив на контрольные вопросы к главе и выпол
нив упражнения для этой части.
Закрепление пройденного
Контрольные вопросы
1. Чем отличаются генераторы списков в квадратных скобках и в круг
лых скобках?
2. Как связаны между собой генераторы и итераторы?
3. Как узнать, является ли функция функциейгенератором?
4. Для чего служит инструкция yield?
5. Пусть имеются функция и кортеж аргументов, как можно было бы
вызвать эту функцию?
6. Как связаны между собой функция map и генераторы списков? В чем
их сходства и различия?
7. Как связаны между собой lambdaвыражение и инструкция def? В чем
их сходства и различия?
478 Глава 17. Расширенные возможности функций
Ответы
1. Генераторы списков в квадратных скобках воспроизводят сразу весь
список целиком. Когда генераторы списков заключаются в круглые
скобки, они фактически превращаются в выражениягенераторы,
которые имеют похожее назначение, но не воспроизводят список
результатов целиком. Вместо этого выражениягенераторы возвра
щают объектгенератор, который поставляет по одному значению
при использовании в итерационном контексте.
2. Генераторы – это объекты, поддерживающие итерационный прото
кол – они обладают методом next, который выполняет переход к сле
дующему элементу в последовательности результатов и возбуждает
исключение по достижении конца последовательности. В языке Py
thon существует возможность создавать функциигенераторы с по
мощью инструкции def, выражениягенераторы в виде генераторов
списков, заключенных в круглые скобки, и объектыгенераторы
с помощью классов, которые определяют специальный метод
__iter__ (обсуждается далее в этой книге).
3. Функциигенераторы имеют в своем теле инструкцию yield. Во
всем остальном они ничем не отличаются от обычных функций.
4. При наличии этой инструкции интерпретатор Python компилирует
функцию как генератор – при вызове она возвращает объектгене
ратор, который поддерживает итерационный протокол. Когда за
пускается инструкция yield, она возвращает результат вызываю
щей программе и приостанавливает работу функции, после этого
в ответ на вызов метода next со стороны вызывающей программы
функция возобновляет свою работу с позиции после последней вы
полненной инструкции yield. Функциигенераторы также могут со
держать инструкцию return, которая завершает работу генератора.
5. Вызвать функцию можно с использованием applyподобного син
таксиса: function(*argstuple). Кроме того, можно использовать
встроенную функцию apply(function, args), но из будущих версий
Python эта функция, скорее всего, будет исключена и потому такой
способ нельзя считать универсальным.
6. Вызов функции map напоминает генератор списков тем, что обе кон
струкции создают новый список с результатами, применяя опера
цию к каждому элементу последовательности или другого итерируе
мого объекта, по одному за раз. Главное различие состоит в том, что
map применяет к каждому элементу функцию, а генератор списков –
произвольное выражение. Вследствие этого генераторы списков об
ладают большей гибкостью – они могут применять функцию, как и
map, а функция map требует, чтобы применяемое выражение было
оформлено в виде функции. Кроме того, генераторы списков поддер
живают расширенный синтаксис. Например, вложенные циклы for
и условные операторы if, что делает их похожими на встроенную
функцию filter.
Закрепление пройденного 479
7. И lambdaвыражения, и инструкция def создают объекты функций
для последующего вызова. Однако lambdaвыражения – это именно
выражения, и поэтому они могут использоваться для вложения
определений функций там, где инструкция def синтаксически не
допустима. Нет таких случаев, когда нельзя было бы обойтись без
lambdaвыражений, – всегда можно определить идентичную инст
рукцию def и ссылаться на функцию по имени. Однако lambdaвыра
жения удобно использовать для встраивания небольших фрагментов
кода, которые в программе больше нигде не используются. Синтак
сически lambda позволяет возвращать значение единственного выра
жения; так как эта конструкция не поддерживает блоки инструк
ций, она плохо подходит для создания больших функций.
Упражнения к четвертой части
В этих упражнениях вам будет предложено написать более сложные
программы. Обязательно проверьте решения в разделе «Часть IV.
Функции» в приложении B; оформляйте свои решения в виде файлов
модулей. Если будет допущена ошибка, будет очень сложно повторно
ввести эти упражнения с клавиатуры в интерактивной оболочке.
1. Основы. В интерактивной оболочке интерпретатора Python напи
шите функцию, которая выводит на экран единственный аргумент,
и попробуйте вызвать ее несколько раз, передавая объекты различ
ных типов: строки, целые числа, списки, словари. Затем попробуй
те вызвать ее без аргументов. Что произошло? Что произойдет, если
передать функции два аргумента?
2. Аргументы. Напишите функцию с именем adder в файле модуля.
Функция должна принимать два аргумента и возвращать их сумму
(или конкатенацию). Затем добавьте в конец файла модуля вызовы
функции adder с объектами различных типов (две строки, два спи
ска, два числа с плавающей точкой) и запустите этот файл как сцена
рий из командной строки операционной системы. Должны ли вы яв
но производить вывод результатов, чтобы они появились на экране?
3. Переменное число аргументов. Обобщите функцию adder из преды
дущего упражнения, чтобы она вычисляла сумму произвольного
числа аргументов, и измените вызовы функции так, чтобы ей пере
давалось больше или меньше двух аргументов. Какой тип имеет
возвращаемое значение суммы? (Подсказка: срез, такой как S[:0],
возвращает пустую последовательность того же типа, что и S, а с по
мощью встроенной функции type можно узнать тип объекта – смот
рите примеры с функцией min в главе 16, где используется подобный
прием.) Что произойдет, если функции передать аргументы разных
типов? Что произойдет, если ей передать словари?
4. Передача аргументов по ключу. Измените функцию adder из уп
ражнения 2 так, чтобы она принимала и вычисляла сумму/конка
тенацию трех аргументов: def adder(good, bad,ugly). После этого
480 Глава 17. Расширенные возможности функций
определите значения по умолчанию для каждого из аргументов
и поэкспериментируйте с функцией в интерактивной оболочке. По
пробуйте передавать ей один, два, три и четыре аргумента. Попро
буйте передавать аргументы по именам. Будет ли работать такой
вызов: adder(ugly=1, good=2)? Почему? Наконец, обобщите новую
версию функции adder так, чтобы принимала и вычисляла сумму/
конкатенацию произвольного числа аргументов, передаваемых по
ключу. Решение будет напоминать то, что было получено в упраж
нении 3, с той лишь разницей, что вам придется выполнить обход
словаря, а не кортежа. (Подсказка: метод dict.keys() возвращает
список, который можно обойти с помощью цикла for или while.)
5. Напишите функцию с именем copyDict(dict), которая копирует сло
варь, получаемый в виде аргумента. Она должна возвращать новый
словарь, содержащий все элементы аргумента. Используйте метод
keys для выполнения итераций (или в Python 2.2, выполните обход
ключей словаря без вызова метода keys). Копирование последова
тельностей выполняется достаточно просто (выражение X[:] выпол
няет поверхностное копирование); будет ли этот метод работать со
словарями?
6. Напишите функцию с именем addDict(dict1, dict2), которая вычис
ляет объединение двух словарей. Она должна возвращать новый
словарь, содержащий все элементы обоих аргументов (которые, как
предполагается, являются словарями). Если один и тот же ключ
присутствует в обоих аргументах, вы можете выбрать значение из
любого словаря. Проверьте свою функцию, добавив программный
код проверки в файл и запустив его как сценарий. Что произойдет,
если вместо словарей передать списки? Как можно было бы обоб
щить функцию, чтобы она обрабатывала и этот случай? (Подсказ
ка: смотрите встроенную функцию type, использовавшуюся ранее.)
Имеет ли значение порядок следования аргументов?
7. Дополнительные примеры на сопоставление аргументов. Сначала
определите следующие шесть функций (в интерактивной оболочке
или в файле модуля, который затем можно будет импортировать):
def f1(a, b): print a, b # Обычные аргументы
def f2(a, *b): print a, b # Переменное число позиционных аргументов
def f3(a, **b): print a, b # Переменное число аргументов по ключу
def f4(a, *b, **c): print a, b, c # Смешанный режим
def f5(a, b=2, c=3): print a, b, c # Аргументы со значениями по умолчанию
def f6(a, b=2, *c): print a, b, c # Переменное число позиционных
# аргументов и со значениями
# по умолчанию
Теперь протестируйте следующие вызовы в интерактивной оболочке
и попробуйте объяснить полученные результаты – в некоторых слу
Закрепление пройденного 481
чаях вам, возможно, придется вернуться к обсуждению алгоритмов
сопоставления в главе 16. Как вы думаете, смешивание режимов со
поставления вообще можно считать удачным выбором? Можете ли
вы придумать ситуации, когда это могло бы оказаться полезным?
>>> f1(1, 2)
>>> f1(b=2, a=1)
>>> f2(1, 2, 3)
>>> f3(1, x=2, y=3)
>>> f4(1, 2, 3, x=2, y=3)
>>> f5(1)
>>> f5(1, 4)
>>> f6(1)
>>> f6(1, 3, 4)
8. Снова простые числа. Вспомните следующий фрагмент из главы 13,
который определяет – является ли целое положительное число про
стым:
x = y / 2 # Для значений y > 1
while x > 1:
if y % x == 0: # Остаток
print y, 'has factor', x
break # Обойти блок else
x = x1
else: # Обычный выход
print y, 'is prime'
Оформите этот фрагмент в виде функции в файле модуля и добавьте
несколько вызовов функции в конец этого файла. При этом замени
те оператор / на // в первой строке, чтобы функция могла также об
рабатывать числа с плавающей точкой и была неуязвима для ис
тинной операции деления, которую, как планируется в Python 3.0,
будет выполнять оператор / (описывается в главе 5). Что вы можете
сказать об отрицательных значениях? Сумеете ли вы повысить ско
рость работы этой функции? Вывод из вашего модуля должен вы
глядеть примерно так, как показано ниже:
13 is prime
13.0 is prime
15 has factor 5
15.0 has factor 5.0
9. Генераторы списков. Напишите программный код, который будет
создавать новый список, содержащий квадратные корни всех чисел
из следующего списка: [2, 4, 9, 16, 25]. Начните с реализации на
основе цикла for, затем на основе функции map и, наконец, в виде ге
нератора списков. Для вычислений используйте функцию sqrt из
модуля math (т. е. выполните import math и вызов math.sqrt(x)). Ка
кой из трех вариантов на ваш взгляд является лучшим?


V
Модули

18
Модули: общая картина
Начиная с этой главы, мы приступаем к детальному изучению модуля
в языке Python – самой крупной организационной программной еди
ницы, которая вмещает в себя программный код и данные, готовые
для многократного использования. Если говорить более точно, модули
в языке Python обычно соответствуют файлам программ (или расшире
ниям, написанным на других языках программирования, таких как C,
Java или C#). Каждый файл – это отдельный модуль, и модули могут
импортировать другие модули для доступа к именам, которые в них
определены. Обработка модулей выполняется двумя инструкциями
и одной встроенной функцией:
import
Позволяет клиентам (импортерам) получать модуль целиком
from
Позволяет клиентам получать определенные имена из модуля
reload
Обеспечивает возможность повторной загрузки модуля без останов
ки интерпретатора Python
В главе 3 были представлены основные принципы, касающиеся моду
лей, и мы пользовались ими до сих пор. Часть V книги мы начнем
с подробного описания базовых концепций, а затем перейдем к иссле
дованию расширенных возможностей использования модулей. В этой
первой главе вашему вниманию предлагается общий взгляд на роль мо
дулей в структуре всей программы. В последующих главах мы начнем
рассматривать программный код, который основан на этой теории.
Попутно мы подробно рассмотрим сведения о модулях, которые до сих
пор были опущены: вы узнаете об операции перезагрузки модулей, об
атрибутах __name__ и __all__, об импорте пакетов и т. д. Поскольку мо
486 Глава 18. Модули: общая картина
дули и классы – это всего лишь пространства имен, здесь мы также
формализуем понятие пространства имен.
Зачем нужны модули?
В двух словах, модули обеспечивают простой способ организации ком
понентов в систему автономных пакетов переменных, известных как
пространства имен. Все имена, определяемые на верхнем уровне мо
дуля, становятся атрибутами объекта импортируемого модуля. Как
мы видели в предыдущей части, операция импорта предоставляет дос
туп к именам в глобальной области видимости модуля. Таким обра
зом, в процессе импортирования глобальная область видимости моду
ля образует пространство имен атрибутов объекта модуля. В конечном
счете модули позволяют связывать отдельные файлы в крупные про
граммные системы.
Если говорить более определенно, с точки зрения теории модули игра
ют как минимум три роли:
Повторное использование программного кода
Как говорилось в главе 3, модули позволяют сохранять программ
ный код в виде файлов. В отличие от программного кода, который
вводится в интерактивной оболочке интерпретатора Python и исчеза
ет безвозвратно после выхода из оболочки, программный код в фай
лах модулей хранится постоянно – его можно повторно загружать
и запускать столько раз, сколько потребуется. Можно добавить, что
модули – это место, где определяются имена, известные как атри+
буты, на которые может ссылаться множество внешних клиентов.
Разделение системы пространств имен
Модули в языке Python также являются самой высокоуровневой
единицей организации программ. По существу, они – всего лишь
пакеты имен. Модули позволяют изолировать имена в замкнутые
пакеты, которые позволяют избежать конфликтов имен, – вы нико
гда не увидите имя в другом файле, если не импортируете его. Фак
тически, все, что находится в модуле – выполняемый программный
код и создаваемые объекты, – всегда неявно включается в модули.
Вследствие этого модули являются естественными инструментами
группировки компонентов системы.
Реализация служб или данных для совместного пользования
С функциональной точки зрения модули могут также использовать
ся для реализации компонентов, используемых системой, вследст
вие чего требуется только одна копия такого компонента. Например,
если необходим глобальный объект, который используется более
чем одной функцией или модулем, можно написать его в виде моду
ля, который затем может импортироваться множеством клиентов.
Архитектура программы на языке Python 487
Однако, чтобы понять действительную роль модулей в системе Python,
нам необходимо отступить на шаг назад и исследовать общую структу
ру программы на языке Python.
Архитектура программы на языке Python
До сих пор в этой книге я избегал сложностей в описаниях программ
на языке Python. Обычно программы состоят более чем из одного фай
ла – любые программы, за исключением самых простых сценариев, со
стоят из нескольких файлов. Даже если вам удастся поместить всю ло
гику в один файл, вы почти наверняка будете использовать сторонние
модули, которые уже кемто были написаны.
В этом разделе дается введение в общую архитектуру программ на язы
ке Python – способ, которым программа делится на коллекцию файлов
с исходными текстами (то есть модулей) и увязывается в единое целое.
Кроме того, мы попутно рассмотрим основные концепции модулей
в языке Python, процедуру импортирования и атрибуты объектов.
Как организована программа
Как правило, программа на языке Python состоит из множества тек
стовых файлов, содержащих инструкции. Программа организована
как один главный файл, к которому могут подключаться дополнитель
ные файлы, известные как модули.
Главный файл определяет, как будет двигаться основной поток выпол
нения программы, – это тот файл, который необходимо запустить,
чтобы начать работу приложения. Файлы модулей – это библиотеки
инструментальных средств, где содержатся компоненты, используе
мые главным файлом (и, возможно, гдето еще). Главный файл ис
пользует инструменты, определенные в файлах модулей, а модули ис
пользуют инструменты, определенные в других модулях.
Обычно файлы модулей ничего не делают, если попытаться запустить
их отдельно, – в них определяются инструментальные средства, ис
пользуемые в других файлах. Чтобы получить доступ к определенным
в модуле инструментам, именующимся атрибутами модуля (имена
переменных, связанные с такими объектами, как функции), в языке
Python необходимо импортировать этот модуль. То есть мы импорти
руем модули и получаем доступ к их атрибутам, что дает нам возмож
ность использовать их функциональные возможности.
Импортирование и атрибуты
Давайте сделаем наше обсуждение более конкретным. На рис. 18.1
схематически изображена структура программы на языке Python, со
стоящей из трех файлов: a.py, b.py и c.py. Файл a.py является главным
файлом программы – это простой текстовый файл, состоящий из инст
488 Глава 18. Модули: общая картина
рукций, который при запуске выполняется от начала и до конца. Фай
лы b.py и c.py – это модули, они также являются простыми текстовыми
файлами, содержащими инструкции, но обычно они не запускаются
как самостоятельные программы. Вместо этого они, как уже говори
лось выше, обычно импортируются другими файлами, использующи
ми инструментальные средства, определяемые в этих файлах.
Например, предположим, что файл b.py на рис. 18.1 определяет функ
цию с именем spam. Как мы уже знаем из четвертой части книги, чтобы
определить функцию, которая затем сможет быть запущена за счет пе
редачи ей нуля или более аргументов в круглых скобках, файл b.py
должен содержать инструкцию def:
def spam(text):
print text, 'spam'
Теперь предположим, что модуль a.py использует функцию spam. Для
этого он мог бы содержать следующие инструкции:
import b
b.spam('gumby')
В первой строке здесь располагается инструкция import, дающая фай
лу a.py доступ ко всему, что определено на верхнем уровне в файле
b.py. Вкратце это означает следующее: «загрузить файл b.py (если он
еще не загружен) и предоставить доступ ко всем его атрибутам через
имя модуля b». Инструкции import (и, как вы узнаете далее, from) за
гружают и запускают другие файлы на этапе времени выполнения.
Верхний уровень:
главный файл программы
a.py
b.py
c.py
Модули
стандартной
библиотеки
Модули
Рис. 18.1. Архитектура программы на языке Python. Программа – это
система модулей. Она состоит из одного главного файла сценария (который
требуется запустить, чтобы начать работу программы) и нескольких
модулей (импортируемых библиотек инструментальных средств).
И сценарии, и модули – это текстовые файлы, содержащие инструкции на
языке Python, хотя инструкции в модулях обычно только создают объекты
для последующего использования. Стандартная библиотека языка Python
представляет собой коллекцию модулей, готовых к использованию
Архитектура программы на языке Python 489
В языке Python невозможно обращаться к именам в других модулях,
пока такие инструкции импорта не будут выполнены на этапе времени
выполнения. Основная задача этих инструкций состоит в том, чтобы
связать имена в модуле – простые переменные – с объектами загру
женных модулей. Фактически, имя модуля, используемое в инструк
ции import, вопервых, идентифицирует внешний файл и, вовторых,
становится именем переменной, которая будет представлять загру
женный модуль. Объекты, определяемые модулем, также создаются
во время выполнения, когда производится импорт модуля: инструк
ция import, в действительности, последовательно выполняет инструк
ции в указанном файле, чтобы воссоздать его содержимое.
Вторая инструкция в файле a.py вызывает функцию spam, определен
ную в модуле b, используя форму записи атрибутов объекта. Запись
b.spam означает следующее: «извлечь значение имени spam, располо
женного в объекте b». В нашем примере – это вызываемая функция,
поэтому далее ей передается строка в круглых скобках ('gumby'). Если
вы создадите эти файлы, сохраните их и запустите файл a.py, то будут
выведены слова «gumby spam».
Вы увидите, что повсюду в сценариях на языке Python используется
нотация object.attribute – большинство объектов обладают атрибута
ми, доступ к которым можно получить с помощью оператора «.». Не
которые атрибуты – имена вызываемых функций, а другие – простые
значения, которые представляют свойства объекта (например, имя
персоны).
Импорт – широко используемое понятие в языке Python. Любой файл
может импортировать функциональные возможности из любого дру
гого файла. Например, файл a.py может импортировать файл b.py, что
бы иметь возможность вызывать его функцию, при этом файл b.py мо
жет в свою очередь импортировать файл c.py, чтобы получить доступ
к другим функциональным возможностям, определенным в нем. Це
почка импортирования может уходить так глубоко, как это потребует
ся: в этом примере модуль a может импортировать модуль b, который
импортирует модуль c, который в свою очередь может еще раз импор
тировать модуль b, и т. д.
Помимо самой крупной единицы в организационной структуре про
граммы модули (и пакеты модулей, которые описываются в главе 20)
также играют роль самой крупной единицы программного кода, дос
тупного для повторного использования. Оформив программные ком
поненты в виде файлов модулей, вы сможете использовать их не толь
ко в оригинальной программе, но и в любых других программах, кото
рые вам придется писать. Например, если после написания програм
мы, структура которой изображена на рис. 18.1, вдруг обнаружится,
что функция b.spam является универсальным инструментом, мы смо
жем использовать ее в других программах. Все, что нам потребуется, –
это импортировать файл b.py из файлов другой программы.
490 Глава 18. Модули: общая картина
Модули стандартной библиотеки
Обратите внимание на правую часть рис. 18.1. Некоторые из модулей,
которые будут импортироваться вашими программами, входят непо
средственно в состав языка Python, и вам не придется писать их.
Интерпретатор Python поставляется с обширной коллекцией дополни
тельных модулей, которая известна как стандартная библиотека.
Эта коллекция насчитывает порядка 200 крупных модулей и содер
жит платформонезависимую поддержку распространенных задач про
граммирования: интерфейсы операционных систем, организацию хра
нилищ объектов, поиск по шаблону, сетевые взаимодействия, созда
ние графического интерфейса и многих других. Ни один из этих инст
рументов не является непосредственной частью языка Python, но вы
можете использовать их, импортируя соответствующие модули. Так
как это модули стандартной библиотеки, можно быть уверенным, что
они будут доступны и будут работать переносимым образом на боль
шинстве платформ, на которых работает интерпретатор Python.
В примерах этой книги вы увидите несколько модулей стандартной
библиотеки в действии, но за полной информацией вам следует обра
титься к справочным руководствам по стандартной библиотеке языка
Python, которые можно найти в инсталляции Python (в IDLE или в ме
ню кнопки Пуск (Start) в операционной системе Windows) или в Интер
нете, по адресу: http://www.python.org.
При таком большом количестве модулей это действительно единствен
ный способ получить представление о том, какие инструментальные
средства имеются в наличии. Кроме этого, описание библиотеки инст
рументов Python можно найти в некоторых книгах, посвященных
прикладному программированию, таких как «Programming Python»,
но, в отличие от книг, руководства распространяются бесплатно, их
можно просматривать в любом вебброузере (поскольку они распро
страняются в формате HTML) и к тому же они обновляются с выходом
каждой новой версии Python.
Как работает импорт
В предыдущем разделе говорилось об импортировании модулей, но ни
как не объяснялось, что происходит во время импорта. Так как в язы
ке Python инструкции импортирования составляют основу структуры
программы, здесь мы подробнее рассмотрим этот вопрос, чтобы сде
лать представление о процессе импорта менее абстрактным.
Некоторые программисты на языке C любят сравнивать инструкцию
import в языке Python с инструкцией #include, но они в корне неправы –
импортирование в языке Python – это не просто включение текста од
ного файла в другой. Это самые настоящие операции времени выпол
нения, которые выполняют следующие действия, когда программа
впервые импортирует заданный файл:
Как работает импорт 491
1. Отыскивают файл модуля.
2. Компилируют в байткод (если это необходимо).
3. Запускают программный код модуля, чтобы создать объекты, ко
торые он определяет.
Чтобы лучше понять, как протекает импорт модулей, мы исследуем
все эти действия по порядку. Примите во внимание, что все три дейст
вия выполняются, только когда модуль впервые импортируется во
время выполнения программы – все последующие операции импорта
того же модуля пропускают эти действия и просто выбирают уже нахо
дящийся в памяти объект модуля.
1. Поиск
Прежде всего, интерпретатор должен определить местонахождение
файла модуля, указанного в инструкции import. Обратите внимание,
что имена файлов в инструкции import в примерах из предыдущих раз
делов указаны без расширения .py и без пути к каталогу: вместо записи
в виде, например, import c:\dir1\b.py инструкция записывается просто –
import b. Фактически, допускается указывать лишь простые имена –
путь к каталогу и расширение файла должны быть опущены, потому
что для поиска файла, соответствующего имени, указанному в инст
рукции import, интерпретатор использует стандартный путь поиска
модулей.1 Поскольку это основная часть операции импорта, которую
необходимо знать программистам, мы рассмотрим ее более подробно.
Путь поиска модулей
В большинстве случаев можно положиться на автоматически организо
ванные пути поиска модулей и вообще не настраивать этот путь. Одна
ко, если вам потребуется импортировать модули из пользовательских
каталогов, вам необходимо будет знать, как работает путь поиска фай
лов, чтобы настроить его соответствующим образом. В общих чертах
пути поиска модулей в языке Python выбираются из объединенных
1 В действительности синтаксис стандартной инструкции import не позволяет
включать путь к файлу и его расширение. Для операции импортирования
пакетов, которая будет рассматриваться в главе 20, инструкция import до
пускает указывать путь к файлу в виде последовательности имен, разделен
ных точкой; но при этом операция импортирования пакетов попрежнему
использует обычный путь поиска модулей, чтобы отыскать самый первый
каталог в указанном пути к пакету (то есть пути к пакетам указываются от
носительно одного из каталогов, находящегося в пути поиска). Кроме того,
эта операция не позволяет использовать в инструкции import синтаксис пу
тей к каталогам, характерный для определенной платформы, – этот синтак
сис может использоваться только при определении самого пути поиска. Сле
дует также заметить, что проблемы поиска пути к файлам модулей отсутст
вуют при запуске фиксированных двоичных файлов (рассматривались в гла
ве 2); они обычно содержат в двоичном образе весь необходимый байткод.
492 Глава 18. Модули: общая картина
данных следующих основных источников. Некоторые из них предо
пределены, а некоторые можно настроить и тем самым сообщить ин
терпретатору, где выполнять поиск:
1. Домашний каталог программы.
2. Содержимое переменной окружения PYTHONPATH (если таковая опре
делена).
3. Каталоги стандартной библиотеки.
4. Содержимое любых файлов с расширением .pht (если таковые име
ются).
В конечном итоге объединение этих четырех компонентов составляет
sys.path – список строк с именами каталогов, о котором я расскажу
подробнее в следующем разделе. Первый и третий компоненты пути
поиска определяются автоматически, но, так как интерпретатор при
поиске использует данные всех этих компонентов, от первого до по
следнего, то второй и четвертый компоненты можно использовать для
расширения пути поиска, включая в него свои собственные каталоги
с исходными текстами. Далее описывается, как интерпретатор Python
использует эти компоненты пути:
Домашний каталог
В первую очередь интерпретатор ищет импортируемые файлы в до
машнем каталоге. В зависимости от того, как была запущена про
грамма, это будет либо каталог, где находится главный файл про
граммы, либо каталог, из которого вы работаете в интерактивной
оболочке. Поскольку поиск в первую очередь производится в этом
каталоге, если программа целиком располагается в одном каталоге,
все операции импорта будут выполнены автоматически, без необхо
димости настраивать путь поиска.
Каталоги в PYTHONPATH
После этого поиск производится во всех каталогах, перечисленных
в переменной окружения PYTHONPATH, слева направо (если эта пере
менная вообще установлена). В двух словах, переменная окруже
ния PYTHONPATH – это просто список имен каталогов, определяемых
пользователем и системой, в которых располагаются файлы с про
граммным кодом на языке Python. Вы можете добавить в эту пере
менную все каталоги, откуда предполагается импортировать моду
ли, и интерпретатор будет использовать ваши настройки при созда
нии пути поиска модулей.
Поскольку интерпретатор пытается отыскать файлы сначала в до
машнем каталоге, настройка этой переменной приобретает большое
значение, только когда необходимо импортировать модули, разме
щающиеся в разных каталогах, – то есть когда импортируемый
файл хранится в каталоге, отличном от каталога, где располагается
импортирующий файл. Вам наверняка потребуется настраивать пе
ременную окружения PYTHONPATH, как только вы начнете писать
Как работает импорт 493
большие программы, но на начальном этапе освоения языка храни
те файлы всех своих модулей в каталоге, в котором вы работаете (то
есть в домашнем каталоге), и тогда операции импорта будут рабо
тать без необходимости выполнять какиелибо настройки.
Каталоги стандартной библиотеки
Далее интерпретатор автоматически выполняет поиск в каталогах,
куда были установлены модули стандартной библиотеки. Так как
эти каталоги всегда участвуют в поиске, их можно не добавлять в пе
ременную окружения PYTHONPATH.
Каталоги в файле .pth
Наконец, относительно новая особенность языка Python дает поль
зователям возможность добавлять нужные каталоги в путь поиска
модулей, просто перечисляя их по одному в строке в текстовом фай
ле, имя которого оканчивается расширением .pth (от слова «path» –
«путь»). Эти файлы представляют собой расширенную возмож
ность, имеющую отношение к проблеме установки, и мы не будем
здесь подробно их обсуждать.
Текстовый файл со списком каталогов помещается в соответствую
щий каталог и может играть примерно ту же роль, что и перемен
ная окружения PYTHONPATH. Например, для расширения пути поиска
модулей файл с именем myconfig.pth можно поместить в главный
каталог, куда был установлен Python в Windows (например, C:\Py+
thon25 или C:\Python25\Lib\sitepackages). Интерпретатор добавит
в конец пути поиска модулей каталоги, перечисленные во всех
строках файла, от первой до последней. Поскольку это файлы, а не
параметры настройки командной оболочки, они могут применять
ся ко всем пользователям системы, а не только к одному пользова
телю или одной командной оболочке.
Эта особенность на практике более сложная, чем я описал. За до
полнительной информацией обращайтесь к руководству по библио
теке языка Python (в частности, к описанию модуля site, входяще
го в стандартную библиотеку). Начинающим я рекомендую исполь
зовать переменную окружения PYTHONPATH или единственный файл
.pth и только в том случае, если возникает необходимость импорти
ровать файлы из других каталогов. В приложении A вы найдете
примеры наиболее распространенных способов расширения пути
поиска файлов с помощью переменной окружения PYTHONPATH или
файлов .pth на различных платформах.
Это описание пути поиска модулей является верным, но достаточно об
щим, – точная конфигурация пути поиска зависит от типа платформы
и версии Python. В зависимости от используемой платформы в путь
поиска модулей могут добавляться дополнительные каталоги.
Например, в путь поиска вслед за каталогами из переменной окруже
ния PYTHONPATH и перед каталогами стандартной библиотеки, интерпре
татор может добавлять текущий рабочий каталог – каталог, откуда
494 Глава 18. Модули: общая картина
была запущена программа. Когда программа запускается из команд
ной строки, текущий рабочий каталог может не совпадать с домашним
каталогом, где находится главный файл программы (то есть с катало
гом, где находится программа).1 Так как от запуска к запуску програм
мы текущий рабочий каталог может изменяться, при обычных услови
ях рабочий каталог не должен иметь значения для операций импорта.2
Список sys.path
Если вам потребуется узнать, как выглядит путь поиска на вашей ма
шине, вы всегда сможете сделать это, просмотрев содержимое встроен
ного списка sys.path (то есть содержимое атрибута path модуля sys,
входящего в состав стандартной библиотеки). Этот список строк с име
нами каталогов представляет собой фактический путь поиска, исполь
зуемый интерпретатором, – при выполнении операций импорта Py
thon просматривает каждый каталог из списка, слева направо.
Действительно, sys.path – это путь поиска модулей. Интерпретатор
создает его во время запуска программы, автоматически объединяя
в список все каталоги, перечисленные в переменной окружения PYTHON
PATH и в файлах .pth, и добавляя в начало списка домашний каталог
главного файла программы (возможно как пустую строку).
Представление языком Python этого списка имеет два основных полез
ных результата. Вопервых, он обеспечивает возможность проверить
настройки пути поиска, которые вы выполнили, – если вы не видите
свои настройки в этом списке каталогов, вам следует проверить, на
сколько правильно вы все проделали. Вовторых, если вы понимаете,
как формируется список, вы можете обеспечить сценариям возмож
ность самостоятельно задавать свои пути поиска. Как будет показано
далее в этой части книги, изменяя список sys.path, вы можете изме
нить путь поиска для всех последующих операций импорта. Однако
эти изменения продолжают действовать, только пока выполняется
сценарий; переменная окружения PYTHONPATH и файлы .pth обеспечива
ют возможность более долговременного хранения измененного пути.3
1 Подробнее о запуске программ из командной строки говорится в главе 3.
2 В главе 21 дополнительно обсуждается относительно новый синтаксис
инструкции импортирования, добавленный в версии Python 2.5, – благода
ря ему можно изменять путь поиска в инструкции from с помощью симво
лов «.» (например, from . import string).
3 Некоторым программам действительно требуется изменять sys.path. Сце
нарии, которые выполняются на вебсервере, например, обычно выполня
ются с привилегиями пользователя «nobody» с целью ограничить доступ к
системе. Поскольку такие сценарии обычно не должны зависеть от значе
ния переменной окружения PYTHONPATH для пользователя «nobody», они час
то изменяют список sys.path вручную, чтобы включить в него необходимые
каталоги до того, как будет выполнена какаялибо инструкция import.
Обычно для этого бывает достаточно вызова sys.path.append(dirname).
Как работает импорт 495
Выбор файла модуля
Имейте в виду, что расширения имен файлов (например, .py) предна
меренно опущены в инструкции import. Интерпретатор выбирает пер
вый найденный в пути поиска файл, который соответствует указанно
му имени. Например, инструкция import b могла бы загрузить:
• Файл с исходным текстом, имеющий имя b.py.
• Файл с байткодом, имеющий имя b.pyc.
• Содержимое каталога b, при импортировании пакета (описывается
в главе 20).
• Скомпилированный модуль расширения, как правило, написанный
на языке C или C++ и динамически присоединенный при импорте
(например, b.so в Linux и b.dll или b.pyd в Cygwin и в Windows).
• Скомпилированный встроенный модуль, написанный на языке C
и статически скомпонованный с интерпретатором Python.
• Файл ZIPархива с компонентом, который автоматически извлека
ется при импорте.
• Образ памяти для фиксированных двоичных исполняемых файлов.
• Класс Java в версии Jython.
• Компонент .NET в версии IronPython.
Импортирование расширений, написанных на языке C, операция им
порта в Jython и импортирование пакетов – это расширенные возмож
ности импортирования компонентов, не являющихся простыми фай
лами модулей. Впрочем, для импортера различия в типах загружае
мых файлов совершенно незаметны как при импорте, так и при обра
щении к атрибутам модуля. Инструкция import b загружает некоторый
модуль b в соответствии с настройками пути поиска модулей, а b.attr
извлекает элемент модуля, будь то переменная или функция, написан
ная на языке C. Некоторые стандартные модули, которые мы будем
использовать в этой книге, в действительности написаны на языке C,
но благодаря прозрачности импортирования это не имеет никакого
значения для клиентов.
Если у вас в различных каталогах имеются файлы b.py и b.so, интер
претатор всегда будет загружать тот, что будет найден в каталоге, ко
торый располагается раньше (левее) в пути поиска модулей, так как
поиск в списке sys.path выполняется слева направо. Но что произой
дет, если оба файла, b.py и b.so, находятся в одном и том же каталоге?
В этом случае интерпретатор будет следовать стандартному порядку
выбора файлов, впрочем, нет никаких гарантий, что такой порядок бу
дет оставаться неизменным с течением времени. Вообще вы должны
избегать зависимости от порядка выбора файлов интерпретатором Py
thon в одном и том же каталоге – давайте своим модулям различные
имена или настраивайте путь поиска модулей, чтобы обеспечить более
очевидный порядок выбора файлов.
496 Глава 18. Модули: общая картина
Дополнительные возможности выбора модуля
Обычно операция импорта работает именно так, как описывается в дан
ном разделе, – она отыскивает и загружает файлы, находящиеся на ва
шей машине. Однако вполне возможно переопределить большую часть
того, что делает операция импорта, используя то, что называется про+
граммными ловушками импорта. Эти ловушки могут использовать
ся, чтобы придать операции импорта дополнительные полезные воз
можности, такие как загрузка файлов из архивов, расшифровывание
и т. д. Фактически сам интерпретатор Python использует эти ловуш
ки, чтобы обеспечить возможность извлечения импортируемых ком
понентов из ZIPархивов – заархивированные файлы автоматически
извлекаются во время импорта, когда в пути поиска выбирается файл
с расширением .zip. За дополнительной информацией обращайтесь
к описанию встроенной функции __import__ в руководстве по стан
дартной библиотеке Python – настраиваемому инструменту, которым
в действительности пользуется инструкция import.
Кроме того, Python поддерживает понятие файлов с оптимизированным
байткодом (.pyo), которые создаются и запускаются интерпретатором из
командной строки с флагом –O, однако они выполняются лишь немно
гим быстрее, чем обычные файлы .pyc (обычно на 5 процентов быстрее),
поэтому они используются достаточно редко. Система Psyco (глава 2)
обеспечивает куда более существенный прирост в скорости выполнения.
2. Компиляция (если необходимо)
После того как в пути поиска модулей будет найден файл, соответствую
щий имени в инструкции import, интерпретатор компилирует его в байт
код, если это необходимо. (Мы рассматривали байткод в главе 2.)
Интерпретатор проверяет время создания файла и пропускает этап
компиляции исходного программного кода, если файл с байткодом
.pyc не старше, чем соответствующий ему файл .py с исходным тек
стом. Кроме того, если Python обнаружит в пути поиска только файл
с байткодом и не найдет файл с исходным текстом, он просто загрузит
байткод. Другими словами, этап компиляции пропускается, если
можно ускорить запуск программы. Если вы измените исходный про
граммный код, Python автоматически скомпилирует байткод при сле
дующем запуске программы. Кроме того, вы можете распространять
свою программу исключительно в виде файлов с байткодом, чтобы не
передавать файлы с исходными текстами.
Обратите внимание, что компиляция выполняется в момент импорти
рования файла. По этой причине файл .pyc с байткодом для главного
файла программы обычно не создается, если только он не был импор
тирован еще куданибудь, – файлы .pyc создаются только при импор
тировании файлов. Байткод главного файла программы создается
в памяти компьютера, а байткод импортированных файлов сохраня
ется в файлах для ускорения будущих операций импорта.
Как работает импорт 497
Главные файлы программ часто планируется исполнять непосредст
венно и никуда их не импортировать. Позднее мы увидим, что сущест
вует возможность создать файл, который будет играть роль как глав
ного файла программы, так и модуля, доступного для импорта. Такие
файлы могут и исполняться, и импортироваться, поэтому для них соз
даются соответствующие файлы .pyc. Чтобы разобраться с тем, как это
получается, читайте обсуждение специальных атрибутов __name__
и __main__ в главе 21.
3. Запуск
На последнем шаге операции импортирования производится запуск
байткода модуля. Все инструкции в файле модуля выполняются по
порядку, сверху вниз, и любые операции присваивания, которые
встретятся на этом шаге, будут создавать атрибуты конечного объекта
модуля. Таким образом, этот этап выполнения создает все инструмен
ты, которые определяются модулем. Например, во время импортиро
вания выполняются инструкции def в файле, которые создают функ
ции и присваивают их атрибутам модуля. После этого функции могут
вызываться из программы, выполнившей импорт.
На этом последнем шаге операции импортирования фактически запус
кается программный код модуля, поэтому, если программный код
верхнего уровня в файле модуля выполняет какиенибудь действия,
результаты этих действий можно будет наблюдать во время импорта.
Например, при импорте файла можно будет наблюдать результат рабо
ты инструкций print на верхнем уровне модуля. Инструкции def про
сто определяют объекты для последующего использования.
Как видите, во время импорта выполняется достаточно много работы –
производится поиск файла, в случае необходимости запускается ком
пилятор и производится запуск программного кода. Вследствие этого
любой заданный модуль по умолчанию импортируется только один
раз за все время работы программы. При повторных попытках импор
тировать модуль все три шага просто пропускаются, и повторно ис
пользуется модуль, уже загруженный в память.1 Если вам потребуется
еще раз импортировать файл, который уже был загружен (например,
чтобы обеспечить поддержку настроек, выполняемых пользователем),
воспользуйтесь функцией reload, с которой мы встретимся в следую
щей главе.
1 В реальности интерпретатор хранит загруженные модули во встроенном
словаре sys.modules, который проверяется в начале операции импортирова
ния, чтобы определить, не был ли уже загружен указанный модуль. Если
вам потребуется увидеть, какие модули были загружены, импортируйте
модуль sys и выведите результат работы метода sys.modules.keys(). Подроб
нее об этой внутренней таблице рассказывается в главе 21.
498 Глава 18. Модули: общая картина
В заключение
В этой главе были даны основные понятия, имеющие отношение к мо
дулям, атрибутам и импорту, а также был исследован принцип дейст
вия инструкции import. Мы узнали, что во время операции импортиро
вания производится поиск файла модуля в пути поиска модулей, ком
пиляция в байткод и выполнение всех инструкций, создающих его со
держимое. Мы также узнали, как настроить путь поиска, в первую
очередь с помощью переменной окружения PYTHONPATH, чтобы иметь
возможность импортировать модули из других каталогов, отличных
от домашнего каталога и от каталогов стандартной библиотеки.
Как показала эта глава, операция импортирования и модули являют
ся основой архитектуры программ на языке Python. Крупные про
граммы делятся на множество файлов, которые связываются между
собой во время выполнения посредством импортирования. Местонахо
ждение файлов модулей во время импортирования определяется с по
Стороннее программное обеспечение: distutils
Настройка пути поиска модулей, описание которой приводится
в этой главе, в первую очередь касается программного кода, ко
торый вы пишете самостоятельно. Сторонние расширения для
Python обычно используют для автоматической установки са
мих себя такой инструмент, как distutils, входящий в состав
стандартной библиотеки, поэтому для использования такого
программного кода не требуется выполнять настройку пути по
иска модулей.
Системы, использующие distutils, обычно поставляются со сце
нарием setup.py, который запускается для установки таких сис
тем – этот сценарий импортирует и использует модуль distutils,
чтобы поместить систему в каталог, который уже является ча
стью пути поиска модулей (обычно в подкаталог Lib\sitepackages
в каталоге, куда был установлен Python).
За дополнительной информацией о распространении и установ
ке с помощью distutils обращайтесь к стандартному набору ру
ководств по языку Python, потому что эта тема далеко выходит
за рамки данной книги (например, этот инструмент дополни
тельно обеспечивает возможность компиляции расширений на
языке C на машине, где производится установка). Кроме того,
обратите внимание на развивающуюся систему eggs, распростра
няемую с открытыми исходными текстами, которая добавляет
возможность проверки зависимостей для установленного про
граммного кода на языке Python.
Закрепление пройденного 499
мощью пути поиска модулей, а модули определяют атрибуты, исполь
зующиеся за пределами этих модулей.
Конечно, основное назначение операции импорта и модулей состоит
в том, чтобы образовать структуру программы, логика которой под
разделяется на самостоятельные программные компоненты. Про
граммный код в одном модуле изолирован от программного кода в дру
гом – фактически ни один модуль не может получить доступ к именам,
определенным в другом модуле, если явно не выполнит инструкцию
import. Благодаря этому модули дают возможность минимизировать
конфликты имен между различными частями программы.
В следующей главе вы увидите, что все это означает в терминах факти
ческого программного кода. Но прежде чем двинуться дальше, поста
райтесь ответить на контрольные вопросы к главе.
Закрепление пройденного
Контрольные вопросы
1. Каким образом файл с исходным программным кодом модуля пре
вращается в объект модуля?
2. Зачем может потребоваться настраивать значение переменной ок
ружения PYTHONPATH?
3. Назовите четыре основных компонента, составляющих путь поиска
модулей.
4. Назовите четыре типа файлов, которые могут загружаться опера
цией импортирования.
5. Что такое пространство имен, и что содержит пространство имен
модуля?
Ответы
1. Файл с исходными текстами модуля автоматически превращается
в объект модуля в результате выполнения операции импортирова
ния. С технической точки зрения исходный программный код моду
ля выполняется во время импортирования, инструкция за инструк
цией, и все имена, которым по мере выполнения операций будут
присвоены значения, превращаются в атрибуты объекта модуля.
2. Настройка переменной PYTHONPATH может потребоваться только в слу
чае необходимости импортировать модули, размещенные в катало
гах, отличных от того, в котором вы работаете (то есть отличных от
текущего каталога при работе в интерактивной оболочке или от ка
талога, где находится главный файл программы).
3. Четырьмя основными компонентами, составляющими путь поиска
модулей, являются: домашний каталог главного файла программы
(каталог, в котором он находится), все каталоги, перечисленные
500 Глава 18. Модули: общая картина
в переменной окружения PYTHONPATH, каталоги стандартной библио
теки и все каталоги в файлах с расширением .pth, размещенных
в стандартных местах. Из них доступны для настройки переменная
окружения PYTHONPATH и файлы с расширением .pth.
4. Интерпретатор Python может загружать файлы с исходными тек
стами (.py), файлы с байткодом (.pyc), файлы расширений, написан
ных на языке C (например, файлы с расширением .so в Linux или
с расширением .dll в Windows), или каталог с указанным именем,
в случае импортирования пакета. Операция импортирования может
также загружать менее обычные файлы, такие как компоненты из
архивов в формате ZIP, классы Java в Jython – версии Python, ком
поненты .NET в IronPython и статически скомпонованные расшире
ния, написанные на языке C, которые вообще не представлены в ви
де файлов. С помощью программных ловушек, которые имеет реа
лизация операции импорта, можно загрузить все, что угодно.
5. Пространство имен – это независимый пакет переменных, извест
ных как атрибуты пространства имен объекта. Пространство имен
модуля содержит все имена, присваивание значений которым про
изводится программным кодом на верхнем уровне модуля (то есть не
вложенным в инструкции def или class). С технической точки зре
ния глобальная область видимости трансформируется в пространст
во имен атрибутов объекта модуля. Пространство имен модуля мо
жет изменяться с помощью операций присваивания из других фай
лов, которые импортируют данный модуль, хотя это и не приветст
вуется (подробнее об этом рассказывается в главе 16).
19
Основы программирования модулей
Теперь, когда мы рассмотрели общие идеи, лежащие в основе модулей,
обратимся к простому примеру модулей в действии. Модули в языке
Python создаются очень просто – это всего лишь файлы с программ
ным кодом на языке Python, которые создаются с помощью текстового
редактора. Вам не требуется употреблять специальные инструкции,
чтобы сообщить интерпретатору Python, что вы создаете модуль, –
практически любой текстовый файл может играть эту роль. Интерпре
татор сам заботится о поиске и загрузке модулей, поэтому их очень
просто использовать – клиент просто импортирует модуль или опре
деленные имена из модуля и использует объекты, на которые эти име
на ссылаются.
Создание модуля
Чтобы определить модуль, достаточно воспользоваться текстовым ре
дактором, с его помощью ввести некоторый программный код на язы
ке Python в текстовый файл и сохранить его с расширением «.py» –
любой такой файл автоматически будет считаться модулем Python.
Все имена, которым будет выполнено присваивание на верхнем уровне
модуля, станут его атрибутами (именами, ассоциированными с объек
том модуля) и будут доступны для использования клиентами.
Например, если ввести следующую инструкцию def в файл с именем
module1.py и импортировать его, тем самым будет создан объект моду
ля с единственным атрибутом – именем printer, которое ссылается на
объект функции:
def printer(x): # Атрибут модуля
print x
Прежде чем мы двинемся дальше, следует сказать несколько слов об
именах файлов модулей. Вы можете называть ваши модули, как вам
502 Глава 19. Основы программирования модулей
будет угодно, при условии, что эти имена будут оканчиваться расши
рением .py, если вы собираетесь импортировать их. Для главных фай
лов программ, которые будут запускаться, но не будут импортировать
ся, имена не обязательно должны иметь расширение .py, однако было
бы желательно использовать это расширение в любом случае, потому
что оно делает назначение файлов более очевидным и позволит в буду
щем импортировать любой из ваших файлов.
Поскольку имена модулей внутри программы превращаются в имена пе
ременных (без расширения .py), они также должны следовать правилам
именования обычных переменных, которые приводились в главе 11.
Например, можно создать файл модуля с именем if.py, но его невозмож
но будет импортировать, потому что if – это зарезервированное слово,
и когда вы попытаетесь выполнить инструкцию import if, интерпрета
тор выдаст сообщение о синтаксической ошибке. Фактически и имена
модулей, и имена каталогов, используемых при импортировании паке
тов (рассматривается в следующей главе), должны соответствовать тре
бованиям, предъявляемым к именам переменных и представленным
в главе 11, – они могут, например, содержать только алфавитные сим
волы, цифры и символы подчеркивания. Имена каталогов с пакетами
также не могут содержать посторонних символов, таких как пробелы,
даже если они являются допустимыми для используемой платформы.
Когда производится импорт модуля, интерпретатор Python преобразу
ет имя модуля в имя внешнего файла, добавляя в начало путь к ката
логу из пути поиска модулей и добавляя .py или другое расширение
в конец. Например, в конечном итоге имя модуля M преобразуется в имя
некоторого внешнего файла <каталог>\M.<расширение>, который содер
жит программный код модуля.
Как упоминалось в предыдущей главе, существует возможность соз
дать модуль для Python на другом языке программирования, таком
как C или C++ (или Java в реализации Jython). Такие модули называ
ются модулями расширений и обычно используются для создания биб
лиотек, используемых сценариями на языке Python. Когда модули
расширений импортируются программным кодом на языке Python,
они выглядят и ведут себя точно так же, как обычные модули, напи
санные на языке Python, – они импортируются инструкцией import
и предоставляют функции и объекты в виде атрибутов объекта моду
ля. Обсуждение модулей расширений выходит далеко за рамки этой
книги, поэтому за дополнительной информацией обращайтесь к стан
дартным руководствам по языку Python или к специализированным
книгам, таким как «Programming Python».
Использование модулей
Клиенты могут использовать простой файл модуля, только что напи
санный нами, выполнив инструкцию import или from. Обе инструкции
отыскивают, компилируют и запускают программный код модуля, ес
Использование модулей 503
ли он еще не был загружен. Главное различие этих инструкций заклю
чается в том, что инструкция import загружает модуль целиком, поэто
му при обращении к именам в модуле их необходимо дополнять име
нем модуля. Инструкция from, напротив, загружает (или копирует) из
модуля отдельные имена.
Посмотрим, что это означает на примере программного кода. Все сле
дующие примеры вызывают функцию printer, определенную во внеш
нем модуле module1.py, но делают это различными способами.
Инструкция import
В первом примере имя module1 служит двум различным целям – оно
идентифицирует внешний файл, который должен быть загружен, и пре
вращается в имя переменной, которая ссылается на объект модуля по
сле загрузки файла:
>>> import module1 # Загрузить модуль целиком
>>> module1.printer('Hello world!') # Имя дополняется именем модуля
Hello world!
Так как в результате выполнения инструкции import в сценарии появ
ляется имя, ссылающееся на полный объект модуля, нам необходимо
использовать имя модуля при обращении к его атрибутам (например,
module1.printer).
Инструкция from
Напротив, инструкция from копирует имена из области видимости од
ного файла в область видимости другого, что позволяет непосредствен
но использовать скопированные имена, не предваряя их именем моду
ля (например, printer):
>>> from module1 import printer # Копировать одну переменную
>>> printer('Hello world!') # Имя не требует дополнения
Hello world!
Этот пример дает тот же результат, что и предыдущий, но так как им
портируемое имя копируется в область видимости, в которой находит
ся сама инструкция from, можно напрямую обращаться к переменной
в сценарии, не предваряя его именем вмещающего модуля.
Как будет показано далее, инструкция from является всего лишь не
большим расширением инструкции import – она импортирует файл мо
дуля как обычно, но выполняет дополнительный шаг, на котором ко
пирует одно или более имен из импортируемого файла.
Инструкция from *
Наконец, в следующем примере используется специальная форма ин
струкции from: когда используется символ *, копируются все имена, ко
торым присваиваются значения на верхнем уровне указанного модуля.
504 Глава 19. Основы программирования модулей
В этом случае точно так же можно использовать скопированное имя
printer, не предваряя его именем модуля:
>>> from module1 import * # Скопировать все переменные
>>> printer('Hello world!')
Hello world!
С технической точки зрения обе инструкции, from и import, вызывают
одну и ту же операцию импорта, просто форма from * дополнительно
выполняет копирование всех имен в импортируемом модуле в область
видимости, откуда производится импорт. По сути происходит совме
щение пространств имен модулей, что позволяет нам меньше вводить
с клавиатуры.
Как видите, модули действительно легко использовать. Чтобы еще
лучше понять, что присходит в действительности, когда вы определяе
те и используете модули, рассмотрим некоторые их свойства более
подробно.
Импорт выполняется только один раз
Один из самых типичных вопросов, которые задают начинающие про
граммисты, начав использовать модули: «Почему операция импорта
перестает работать?». Они часто сообщают, что при первой попытке
импортировать модуль все работает, но последующие попытки импор
та в интерактивной оболочке (или во время работы программы) не да
ют должного эффекта. В действительности такой эффект и не предпо
лагается, и вот почему.
Модули загружаются и запускаются первой и только первой инструк
цией import или from. Реализовано такое поведение преднамеренно, по
тому что импортирование – это дорогостоящая операция и интерпре
татор выполняет ее всего один раз за все время работы. Последующие
операции импорта просто получают объект уже загруженного модуля.
Из этого следует: так как программный код на верхнем уровне модуля
выполняется всего один раз, это обстоятельство можно использовать
для инициализации переменных. Рассмотрим пример модуля simple.py:
print 'hello'
spam = 1 # Инициализировать переменную
В этом примере инструкции print и = выполняются при первой опера
ции импортирования модуля, и переменная spam инициализируется во
время импортирования:
% python
>>> import simple # Первая инструкция import: загружает
# и запускает код модуля
hello
>>> simple.spam # Операция присваивания создает атрибут
1
Использование модулей 505
Вторая и все последующие операции импортирования не приводят
к перезапуску программного кода модуля – они просто получают объ
ект модуля из внутренней таблицы модулей интерпретатора. В резуль
тате повторная инициализация переменной spam не происходит:
>>> simple.spam = 2 # Изменить атрибут модуля
>>> import simple # Просто получает уже загруженный модуль
>>> simple.spam # Код не перезапускается: атрибут не изменился
2
Конечно, иногда действительно бывает необходимо перезапустить
программный код модуля при повторных операциях импортирования.
Позднее в этой главе мы увидим, как это можно сделать с помощью
функции reload.
Инструкции import и from – операции присваивания
Так же, как и инструкция def, инструкции import и from являются вы
полняемыми инструкциями, а не объявлениями времени компиля
ции. Они могут вкладываться в условные инструкции if, присутство
вать в объявлениях функций def и т. д., и они не имеют никакого эф
фекта, пока интерпретатор не достигнет их в ходе выполнения про
граммы. Другими словами, импортируемые модули и имена в них не
будут доступны, пока не будут выполнены соответствующие инструк
ции import или from. Кроме того, подобно инструкции def, import и from –
это явные операции присваивания:
• Инструкция import присваивает ссылку на объект модуля един
ственной переменной.
• Инструкция from присваивает одно или более имен объектам с теми
же именами в другом модуле.
Все, что уже обсуждалось ранее, в равной степени применимо и к мо
дулям. Например, имена, копируемые инструкцией from, становятся
ссылками на разделяемые объекты – как и в случае с аргументами
функций, переприсваивание полученному имени не оказывает воздей
ствия на модуль, откуда это имя было скопировано, но изменение из+
меняемого объекта может оказывать воздействие на объект в модуле,
откуда он был импортирован. Для иллюстрации рассмотрим следую
щий файл small.py:
x = 1
y = [1, 2]
% python
>>> from small import x, y # Скопировать два имени
>>> x = 42 # Изменяется только локальная переменная x
>>> y[0] = 42 # Изменяется непосредственно изменяемый объект
Здесь x не является разделяемым изменяемым объектом, а вот y – яв
ляется. Имена y в импортирующем и импортируемом модулях ссыла
ются на один и тот же объект списка, поэтому изменения, произведен
ные в одном модуле, будут видны в другом модуле:
506 Глава 19. Основы программирования модулей
>>> import small # Получить имя модуля (инструкция from его не дает)
>>> small.x # x в small – это не моя переменная x
1
>>> small.y # Но изменяемый объект используется совместно
[42, 2]
Чтобы увидеть графическое изображение того, что делает со ссылками
инструкция from, вернитесь к рис. 16.2 (передача аргументов функци
ям) и мысленно замените слова «вызывающая программа» и «функ
ция» на «импортируемый модуль» и «импортирующий модуль». Эф
фект тот же самый, за исключением того, что здесь мы имеем дело
с именами в модулях, а не с функциями. Операция присваивания вез
де в языке Python работает одинаково.
Изменение значений имен в других файлах
Вспомним, что в предыдущем примере присваивание переменной x
в интерактивной оболочке изменяло ее значение только в этой области
видимости и не оказывало влияния на переменную x в файле – между
именем, скопированным инструкцией from, и именем в файле, откуда
это имя было скопировано, нет никакой связи. Чтобы действительно
изменить глобальное имя в другом файле, необходимо использовать
инструкцию import:
% python
>>> from small import x, y # Скопировать два имени
>>> x = 42 # Изменить только локальное имя x
>>> import small # Получить имя модуля
>>> small.x = 42 # Изменить x в другом модуле
Это явление было описано в главе 16. Поскольку изменение перемен
ных в других модулях, как в данном случае, часто является источни
ком проблем (и следствием неудачного проектирования), мы еще вер
немся к этому приему позднее в этой части книги. Обратите внимание,
что изменение элемента y[0] в предыдущем примере – это нечто иное;
изменяется объект, а не имя.
Эквивалентность инструкций import и from
Обратите внимание: в предыдущем примере после инструкции from
нам потребовалось выполнить инструкцию import, чтобы получить
доступ к имени модуля small, – инструкция from копирует только име
на из одного модуля в другой и ничего не присваивает самому имени
модуля. Инструкция from, приведенная ниже:
from module import name1, name2 # Копировать только эти два имени
эквивалентна следующей последовательности, по крайней мере, кон
цептуально:
import module # Получить объект модуля
Использование модулей 507
name1 = module.name1 # Скопировать имена с помощью присваивания
name2 = module.name2
del module # Удалить имя модуля
Как и все операции присваивания, инструкция from создает новые пе
ременные в импортирующем модуле, которые ссылаются на объекты
с теми же именами в импортируемом файле. При этом копируются
только имена, а не сам модуль. При использовании формы from * этой
инструкции (from module import *) эквивалентная последовательность
действий та же самая, только при этом копируются все имена, опреде
ленные на верхнем уровне импортируемого модуля.
Обратите внимание, что на первом шаге инструкция from выполняет
обычную операцию import. Вследствие этого инструкция from всегда
импортирует весь модуль целиком, если он еще не был импортирован,
независимо от того, сколько имен копируется из файла. Нет никакой
возможности загрузить только часть модуля (например, только одну
функцию), но так как модули – это байткод, а не машинный код,
влияние на производительность оказывается незначительным.
Потенциальные проблемы инструкции from
Инструкция from делает местоположение переменных менее явным и оче
видным (имя name несет меньше информации, чем module.name), поэтому
некоторые пользователи Python рекомендуют использовать инструк
цию import вместо from. Однако я не уверен, что это такой уж однознач
ный совет: инструкция from используется достаточно часто и без каких
либо страшных последствий. На практике часто бывает удобно изба
виться от необходимости набирать имя модуля всякий раз, когда требу
ется использовать один из его инструментов. Это особенно справедливо
для крупных модулей, которые предоставляют большое число атрибу
тов, таких как модуль Tkinter из стандартной библиотеки, например.
Суть проблемы состоит в том, что инструкция from способна повреждать
пространства имен, по крайней мере, в принципе – если использовать
ее для импортирования переменных, когда существуют одноименные
переменные в имеющейся области видимости, то эти переменные про
сто будут перезаписаны. Эта проблема отсутствует при использовании
инструкции import, потому что доступ к содержимому импортируемого
модуля возможен только через его имя (имя module.attr не конфликтует
с именем attr в текущей области видимости). Пока вы понимаете и кон
тролируете все, что может происходить при использовании инструкции
from, во всем этом нет большой проблемы, особенно если импортируе
мые имена указываются явно (например, from module import x, y, z).
С другой стороны, инструкция from скрывает в себе более серьезные
проблемы, когда используется в комбинации с функцией reload, т. к.
импортированные имена могут ссылаться на предыдущие версии объ
ектов. Кроме того, инструкция в форме from module import * действи
тельно может повреждать пространства имен и затрудняет понимание
508 Глава 19. Основы программирования модулей
имен, особенно когда она применяется более чем к одному файлу.
В этом случае нет никакого способа определить, какому модулю при
надлежит то или иное имя, разве только выполнить поиск по файлам
с исходными текстами. В действительности форма from * вставляет од
но пространство имен в другое, что сводит на нет преимущества, кото
рые несет возможность разделения пространств имен. Мы будем рас
сматривать эти проблемы более подробно в разделе «Типичные ошиб
ки при работе с модулями» в конце этой части книги (глава 21).
Пожалуй, лучший совет, который можно дать, – в общем отдавать
предпочтение инструкции import для простых модулей, явно перечис
лять необходимые переменные в инструкциях from и не использовать
форму from * для импорта более чем одного файла в модуле. При таком
подходе можно предполагать, что все неопределенные имена распола
гаются в модуле, к которому обращались через инструкцию from *.
При работе с инструкцией from, конечно, следует проявлять осторож
ность, но, вооруженные знаниями, большинство программистов нахо
дят ее удобной для организации доступа к модулям.
Когда необходимо использовать инструкцию import
Единственное, когда необходимо вместо инструкции from использо
вать инструкцию import, – когда требуется использовать одно и то же
имя, присутствующее в двух разных модулях. Например, когда два
файла поразному определяют одно и то же имя:
# M.py
def func():
...выполнить чтото одно...
# N.py
def func():
...выполнить чтото другое...
и необходимо использовать обе версии имени в программе. В этом слу
чае инструкцию from использовать нельзя, потому что в результате вы
получите единственное имя в вашей области видимости:
# O.py
from M import func
from N import func # Перезапишет имя, импортированное из модуля M
func() # Будет вызвана N.func
Зато можно использовать инструкцию import, потому что включение
имени вмещающего модуля сделает имена уникальными:
# O.py
import M, N # Получить модуль целиком, а не отдельные имена
M.func() # Теперь можно вызывать обе функции
N.func() # Наличие имени модуля делает их уникальными
Этот случай достаточно необычен, поэтому вы вряд ли часто будете
сталкиваться с ним на практике.
Пространства имен модулей 509
Пространства имен модулей
Модули будут, вероятно, более понятны, если представлять их, как
простые пакеты имен – то есть место, где определяются переменные,
которые должны быть доступны остальной системе. С технической
точки зрения каждому модулю соответствует отдельный файл, и ин
терпретатор создает объект модуля, содержащий все имена, которым
присвоены какиелибо значения в файле модуля. Проще говоря, моду
ли – это всего лишь пространства имен (места, где создаются имена),
и имена, находящиеся в модуле, называются его атрибутами. В этом
разделе мы исследуем, как работает этот механизм.
Файлы создают пространства имен
Итак, как же файлы трансформируются в пространства имен? Суть
в том, что каждое имя, которому присваивается некоторое значение на
верхнем уровне файла модуля (то есть не вложенное в функции или
в классы), превращается в атрибут этого модуля.
Например, операция присваивания, такая как X = 1, на верхнем уров
не модуля M.py, превращает имя X в атрибут модуля M, обратиться
к которому изза пределов модуля можно как M.X. Кроме того, имя X ста
новится глобальной переменной для программного кода внутри M.py,
но нам необходимо более формально объяснить понятия загрузки мо
дуля и областей видимости, чтобы понять почему:
• Инструкции модуля выполняются во время первой попытки им!
порта. Когда модуль импортируется в первый раз, интерпретатор
Python создает пустой объект модуля и выполняет инструкции в мо
дуле одну за другой, от начала файла до конца.
• Операции присваивания, выполняемые на верхнем уровне, созда!
ют атрибуты модуля. Во время импортирования инструкции при
сваивания выполняемые на верхнем уровне файла и не вложенные в
инструкции def или class (например, =, def) создают атрибуты объек
та модуля – при присваивании имена сохраняются в пространстве
имен модуля.
• Доступ к пространствам имен модулей можно получить через атри!
буты __dict__ или dir(M). Пространства имен модулей, создаваемые
операцией импортирования, представляют собой словари – доступ
к ним можно получить через встроенный атрибут __dict__, ассоции
рованный с модулем, и с помощью функции dir. Функция dir – это
примерный эквивалент отсортированного списка ключей атрибута
__dict__, но она включает унаследованные имена классов, может воз
вращать не полный список и часто изменяется от версии к версии.
• Модуль – это единая область видимости (локальная является гло!
бальной). Как мы видели в главе 16, имена на верхнем уровне моду
ля подчиняются тем же правилам обращения/присваивания, что
имена в функциях, только в этом случае локальная область видимо
510 Глава 19. Основы программирования модулей
сти совпадает с глобальной (точнее, они следуют тому же правилу
LEGB поиска в областях видимости, с которым мы познакомились
в главе 16, только без уровней поиска L и E). Но в модулях область
видимости модуля после загрузки модуля превращается в атрибут
словарь объекта модуля. В отличие от функций (где локальное про
странство имен существует только во время выполнения функции),
область видимости файла модуля превращается в область видимо
сти атрибутов объекта модуля и никуда не исчезает после выполне
ния операции импортирования.
Ниже эти понятия демонстрируются в программном коде. Предполо
жим, что мы создаем в текстовом редакторе следующий файл модуля
с именем module2.py:
print 'starting to load...'
import sys
name = 42
def func(): pass
class klass: pass
print 'done loading.'
Когда модуль будет импортироваться в первый раз (или будет запущен
как программа), интерпретатор выполнит инструкции модуля от нача
ла до конца. В ходе операции импортирования одни инструкции созда
ют имена в пространстве имен модуля, а другие выполняют определен
ную работу. Например, две инструкции print в этом файле выполня
ются во время импортирования:
>>> import module2
starting to load...
done loading.
Но как только модуль будет загружен, его область видимости превра
тится в пространство имен атрибутов объекта модуля, который возвра
щает инструкция import. После этого можно обращаться к атрибутам
в этом пространстве имен, дополняя их именем вмещающего модуля:
>>> module2.sys
<module 'sys' (builtin)>
>>> module2.name
42
>>> module2.func
<function func at 0x012B1830>
>>> module2.klass
<class module2.klass at 0x011C0BA0>
Здесь именам sys, name, func и klass были присвоены значения во время
выполнения инструкций модуля, поэтому они стали атрибутами после
завершения операции импортирования. О классах мы будем говорить
Пространства имен модулей 511
в шестой части книги, но обратите внимание на атрибут sys – инструк
ции import действительно присваивают объекты модулей именам, а лю
бая операция присваивания на верхнем уровне файла создает атрибут
модуля.
Внутри интерпретатора пространства имен хранятся в виде объектов
словарей. Это самые обычные объекты словарей с обычными метода
ми. Обратиться к словарю пространства имен модуля можно через ат
рибут __dict__ модуля:
>>> module2._ _dict_ _.keys()
['__file__', 'name', '__name__', 'sys', '__doc__', '__builtins__',
'klass', 'func']
Имена, которые были определены в файле модуля, становятся ключа
ми внутреннего словаря, таким образом, большинство имен здесь от
ражают операции присваивания на верхнем уровне в файле. Однако
интерпретатор Python добавляет в пространство имен модуля еще не
сколько имен, например __file__ содержит имя файла, из которого
был загружен модуль, а __name__ – это имя, под которым модуль извес
тен импортерам (без расширения .py и без пути к каталогу).
Дополнение имен атрибутов
После ознакомления с модулями мы должны поближе рассмотреть по
нятие дополнения имен. В языке Python для доступа к атрибутам любо
го объекта используется синтаксис дополнения имени object.attribute.
Дополнение имени – это в действительности выражение, возвращаю
щее значение, присвоенное имени атрибута, ассоциированного с объ
ектом. Например, выражение module2.sys в предыдущем примере воз
вращает значение атрибута sys в объекте module2. Точно так же, если
имеется встроенный объект списка L, выражение L.append вернет метод
append, ассоциированный с этим списком.
Итак, какую роль играет дополнение имен атрибутов с точки зрения
правил, рассмотренных нами в главе 16? В действительности – ника
кую: это совершенно независимые понятия. Когда вы обращаетесь
к именам, используя дополнение, вы явно указываете интерпретатору
объект, атрибут которого требуется получить. Правило LEGB приме
няется только к кратким, неполным именам. Ниже приводятся при
нятые правила:
Простые переменные
Использование краткой формы имени, например X, означает, что
будет произведен поиск этого имени в текущих областях видимости
(следуя правилу LEGB).
Полные имена
Имя X.Y означает, что будет произведен поиск имени X в текущих об
ластях видимости, а затем будет выполнен поиск атрибута Y в объек
те X (не в областях видимости).
512 Глава 19. Основы программирования модулей
Полные пути
Имя X.Y.Z означает, что будет произведен поиск имени Y в объекте X,
а затем поиск имени Z в объекте X.Y.
Общий случай
Дополнение имен применимо ко всем объектам, имеющим атрибу
ты: модулям, классам, расширениям типов на языке C и т. д.
В шестой части книги мы увидим, что дополнение имен для классов
имеет немного большее значение (здесь также имеет место то, что на
зывается наследованием), но в общем случае правила, описанные
здесь, применяются ко всем именам в языке Python.
Импортирование и области видимости
Как мы уже знаем, невозможно получить доступ к именам, определен
ным в другом модуле, не импортировав его предварительно. То есть вы
никогда автоматически не получите доступ к именам в другом файле,
независимо от вида импортируемого модуля и вызовов функций в ва
шей программе. Смысл переменной всегда определяется местоположе
нием операции присваивания в программном коде, а для обращения
к атрибутам всегда необходимо явно указывать объект.
Например, рассмотрим два следующих простых модуля. Первый, mo+
da.py, определяет переменную X, которая является глобальной только
для программного кода в этом файле, и функцию, изменяющую гло
бальную переменную X в этом файле:
X = 88 # Переменная X: глобальная только для этого файла
def f():
global X # Изменяет переменную X в этом файле
X = 99 # Имена в других модулях недоступны
Второй модуль, modb.py, определяет свою собственную глобальную пе
ременную X, а также импортирует и вызывает функцию из первого мо
дуля:
X = 11 # Переменная X: глобальная только для этого файла
import moda # Получает доступ к именам в модуле moda
moda.f() # Изменяет переменную moda.X, но не X в этом файле
print X, moda.X
При запуске этого модуля функция moda.f изменит переменную X в мо
дуле moda, а не в modb. Глобальной областью видимости для функции mo
da.f всегда является файл, вмещающий ее, независимо от того, из ка
кого модуля она была вызвана:
% python modb.py
11 99
Другими словами, операция импортирования никогда не изменяет об
ласть видимости для программного кода в импортируемом файле – из
Пространства имен модулей 513
импортируемого файла нельзя получить доступ к именам в импорти
рующем файле. Если быть более точным:
• Функциям никогда не будут доступны имена, определенные в дру
гих функциях, если только они физически не вложены друг в друга.
• Программному коду модуля никогда не будут доступны имена, оп
ределенные в других модулях, если только они явно не были им
портированы.
Это поведение является частью понятия лексической области видимо+
сти – в языке Python области видимости, доступные части программ
ного кода, полностью определяются физическим расположением этого
программного кода в файле. Области видимости не подвержены влия
ниям вызовов функций или операции импортирования.1
Вложенные пространства имен
Операция импорта не дает возможности доступа к внешним областям
видимости, но она дает возможность обращаться к вложенным облас
тям видимости. Используя полные пути к именам атрибутов, вполне
возможно погрузиться в сколь угодно глубоко вложенные модули и по
лучить доступ к их атрибутам. Например, рассмотрим следующие три
файла. Файл mod3.py определяет единственное глобальное имя и атри
бут операцией присваивания:
X = 3
Файл mod2.py определяет свою переменную X, затем импортирует мо
дуль mod3 и использует дополнение имени, чтобы получить доступ к ат
рибуту импортированного модуля:
X = 2
import mod3
print X, # Моя глобальная переменная X
print mod3.X # Глобальная переменная X из модуля mod3
Файл mod3.py также определяет свою собственную переменную X, за
тем импортирует модуль mod2 и получает значения атрибутов обоих мо
дулей:
X = 1
import mod2
print X, # Моя глобальная переменная X
print mod2.X, # Переменная X из модуля mod2
print mod2.mod3.X # Переменная X из модуля mod3
1 Некоторые языки программирования подразумевают иной порядок дейст
вий и реализуют динамические области видимости, когда области види
мости в действительности могут зависеть от вызовов функций во время вы
полнения программы. Это усложняет программный код, потому что смысл
переменной может изменяться с течением времени.
514 Глава 19. Основы программирования модулей
В действительности, когда mod1 импортирует mod2, он создает двухуров
невое вложение пространств имен. Используя полный путь к имени
mod2.mod3.X, он может погрузиться в модуль mod3, который вложен в им
портированный модуль mod2. Суть в том, что модуль mod1 может обра
щаться к переменным X во всех трех файлах и, следовательно, имеет
доступ ко всем трем глобальным областям видимости:
% python mod1.py
2 3
1 2 3
Однако обратное неверно: модуль mod3 не имеет доступа к именам в mod2,
а модуль mod2 не имеет доступа к именам в mod1. Возможно, этот пример
будет проще понять, если отвлечься от пространств имен и областей ви
димости и сосредоточиться на объектах, задействованных в примере.
mod2 внутри модуля mod1 – это всего лишь имя, которое ссылается на
объект с атрибутами, некоторые из которых могут ссылаться на другие
объекты с атрибутами (инструкция import выполняет операцию при
сваивания). Для таких путей, как mod2.mod3.X, интерпретатор Python
выполняет вычисления слева направо, извлекая атрибуты из объектов.
Обратите внимание: в mod1 можно вставить инструкцию import mod2 и за
тем использовать обращение mod2.mod3.X, но нельзя записать import
mod2.mod3 – такой синтаксис используется для операции импортирова
ния пакетов (каталогов), которая будет описана в следующей главе.
При импортировании пакетов также создаются вложенные простран
ства имен, но в этом случае инструкция import воспринимает свой ар
гумент как дерево каталогов, а не как цепочку модулей.
Повторная загрузка модулей
Как мы уже видели, программный код модуля по умолчанию запуска
ется всего один раз за все время работы программы. Чтобы принуди
тельно повторно загрузить модуль и запустить программный код в нем,
необходимо явно вызвать встроенную функцию reload. В этом разделе
мы исследуем, как использовать возможность повторной загрузки мо
дулей, чтобы сделать систему более динамичной. В двух словах:
• При вызове операции импортирования (с помощью как инструкции
import, так и from) программный код модуля загружается и выпол
няется, только когда модуль импортируется в первый раз за время
работы программы.
• При последующих попытках импортировать модуль будет использо
ваться объект уже загруженного модуля. Повторная загрузка и за
пуск программного кода в этом случае не происходят.
• Функция reload принудительно выполняет повторную загрузку
уже загруженного модуля и запускает его программный код. Инст
рукции присваивания, выполняемые при повторном запуске, будут
изменять существующий объект модуля.
Повторная загрузка модулей 515
Для чего вся эта суета вокруг повторной загрузки модулей? Функция
reload позволяет изменять части программы, не останавливая всю про
грамму. Благодаря функции reload эффект от изменений в программ
ном коде можно наблюдать сразу же после внесения этих изменений.
Повторная загрузка модулей поможет не во всех ситуациях, но она по
зволит существенно сократить цикл разработки. Например, пред
ставьте себе программу, предназначенную для работы с базами дан
ных, которая должна при запуске соединиться с сервером – так как из
менения или настройки могут проверяться немедленно после повтор
ной загрузки, вам достаточно соединиться с базой данных всего один
раз за весь сеанс отладки.
Язык Python относится к языкам интерпретирующего типа (более или
менее), поэтому в нем отсутствуют этапы компиляции/компоновки,
необходимые, чтобы запустить программу, например, на языке C: мо
дули загружаются динамически уже запущенной программой. Воз
можность повторной загрузки обеспечивает повышение производи
тельности труда, позволяя вам изменять части работающей програм
мы без ее остановки. Обратите внимание, что в настоящее время функ
ция reload может обслуживать только модули, написанные на языке
Python, – скомпилированные модули расширений, написанные на та
ких языках, как C, тоже могут динамически загружаться во время ра
боты программы, но их нельзя загрузить повторно.
Основы использования функции reload
В отличие от инструкций import и from:
• reload – это не инструкция, а встроенная функция.
• Функции reload передается существующий объект модуля, а не имя.
Функция reload ожидает получить объект, поэтому к моменту ее вызо
ва модуль уже должен быть успешно импортирован (если операция им
порта оказалась неудачной изза синтаксических или какихлибо дру
гих ошибок, вам может потребоваться повторить ее, прежде чем можно
будет повторно загрузить модуль). Кроме того, синтаксис инструкции
import и функции reload отличается: аргумент должен передаваться
функции reload в круглых скобках, а инструкции import – без них. По
вторная загрузка модуля выполняется примерно следующим образом:
import module # Первоначальное импортирование
...используются атрибуты модуля...
... # Теперь выполняются изменения в файле модуля
...
reload(module) # Загрузить обновленный модуль
...используются атрибуты модуля...
Это типичный случай, когда вы импортируете модуль, затем изменяе
те исходный программный код в текстовом редакторе, а потом повтор
но загружаете его. Когда вы вызываете функцию reload, интерпрета
тор повторно читает файл с исходными текстами и выполняет инст
516 Глава 19. Основы программирования модулей
рукции, находящиеся на верхнем уровне. Пожалуй, самое важное, что
следует знать о функции reload, – это то, что она изменяет непосредст+
венно сам объект модуля – она не удаляет и не создает его повторно.
Вследствие этого все ссылки на объект модуля, имеющиеся в програм
ме, автоматически будут учитывать изменения, произошедшие в ре
зультате повторной загрузки. А теперь подробнее о том, как происхо
дит повторная загрузка:
• Функция reload запускает новый программный код в файле моду!
ля в текущем пространстве имен модуля. При повторном выполне
нии программный код перезаписывает существующее пространство
имен вместо того, чтобы удалять его и создавать вновь.
• Инструкции присваивания на верхнем уровне файла замещают
имена новыми значениями. Например, повторный запуск инструк
ции def приводит к замещению предыдущей версии функции в про
странстве имен модуля, выполняя повторную операцию присваива
ния имени функции.
• Повторная загрузка оказывает воздействие на всех клиентов, ис!
пользовавших инструкцию import для получения доступа к моду!
лю. Клиенты, использовавшие инструкцию import, получают дос
туп к атрибутам модуля, указывая полные их имена, поэтому после
повторной загрузки они будут получать новые значения атрибутов.
• Повторная загрузка будет воздействовать только на тех клиентов,
которые будут использовать инструкцию from в будущем. Клиенты,
которые использовали инструкцию from для получения доступа к ат
рибутам в прошлом, не заметят изменений, произошедших в ре
зультате повторной загрузки, – они попрежнему будут ссылаться
на старые объекты, полученные до выполнения перезагрузки.
Пример использования reload
Ниже приводится более конкретный пример использования функции
reload. В следующем примере мы изменяем и повторно загружаем
файл модуля без остановки интерактивного сеанса работы с интерпре
татором Python. Повторная загрузка может использоваться в различ
ных других случаях (смотрите врезку «Придется держать в уме: по
вторная загрузка модулей»), но мы рассмотрим лишь самый простой
пример. Во первых, в текстовом редакторе создайте файл модуля с име
нем changer.py и добавьте в него следующее содержимое:
message = "First version"
def printer():
print message
Этот модуль создает и экспортирует два имени – одно связано со стро
кой, а другое является функцией. Теперь запустите интерпретатор Py
thon, импортируйте модуль и вызовите функцию, которую он экспор
тирует. Функция выведет значение глобальной переменной message:
Повторная загрузка модулей 517
% python
>>> import changer
>>> changer.printer()
First version
Придется держать в уме:
повторная загрузка модулей
Помимо возможности перезагружать (и, соответственно, переза
пускать) модули в интерактивной оболочке операция повторной
загрузки может также использоваться в крупных системах, осо
бенно когда стоимость перезапуска всего приложения слишком
высока. Например, первыми кандидатами на использование воз
можности динамической перезагрузки модулей являются систе
мы, которые на запуске соединяются с серверами сети.
Эта возможность также может использоваться в приложениях
с графическим интерфейсом (чтобы изменять действие обработ
чиков событий в графических элементах управления, не закры
вая окна графического интерфейса) и при использовании Python
в качестве встроенного языка в программах, написанных на C
или C++ (вмещающая программа может вызывать повторную за
грузку программного кода на языке Python без остановки всего
приложения). За более подробным описанием повторной загруз
ки обработчиков событий в графическом интерфейсе и встроен
ном программном коде на языке Python обращайтесь к книге
«Programming Python».
Как правило, повторная загрузка позволяет программам реали
зовать высокодинамичные интерфейсы. Например, Python часто
используется как язык для настройки больших систем – поль
зователи могут настраивать программные продукты, изменяя
программный код на языке Python без необходимости переком
пилировать весь продукт (и даже не имея исходных текстов это
го продукта). В таких условиях программный код на языке Py
thon уже сам по себе добавляет динамичности.
Тем не менее, чтобы обеспечить еще более высокую динамич
ность, такие системы могут автоматически выполнять повтор
ную загрузку настроечного кода на языке Python с заданной пе
риодичностью. В этом случае изменения, внесенные пользовате
лями, автоматически вступают в силу прямо во время работы
системы – нет никакой необходимости останавливать и переза
пускать ее всякий раз, когда изменяется программный код на
языке Python. Не все системы реализуют такой подход, но для
тех из них, которые обеспечивают такую возможность, повтор
ная перезагрузка модулей является простым и удобным средст
вом выполнения настроек.
518 Глава 19. Основы программирования модулей
Не закрывая интерактивную оболочку интерпретатора, отредактируй
те файл модуля в другом окне:
...измените файл changer.py, не останавливая интерактивный сеанс...
% vi changer.py
Измените глобальную переменную message, а также тело функции
printer:
message = "After editing"
def printer():
print 'reloaded:', message
Затем вернитесь в окно интерактивной оболочки и перезагрузите мо
дуль, чтобы выполнить обновленный программный код. Обратите вни
мание: в следующем листинге видно, что операция импортирования
модуля не дает желаемого результата – на экран выводится первона
чальный текст сообщения, несмотря на то что файл был изменен. Что
бы задействовать новую версию, необходимо вызвать функцию reload:
...вернитесь обратно в интерактивную оболочку...
>>> import changer
>>> changer.printer() # Никакого эффекта: используется прежняя версия модуля
First version
>>> reload(changer) # Принудительная загрузка/выполнение нового кода
<module 'changer'>
>>> changer.printer() # Теперь будет запущена новая версия
reloaded: After editing
Обратите внимание, что функция reload в действительности возвраща
ет объект – обычно ее результат игнорируется, но поскольку интерак
тивная оболочка автоматически выводит результат выражения, ин
терпретатор вывел результат в виде строки <module 'name'>.
В заключение
В этой главе были рассмотрены основные инструменты, используемые
при программировании модулей, – инструкции import и from, и функ
ция reload. Мы узнали, что инструкция from просто выполняет один
дополнительный шаг, на котором она копирует имена из файла после
того, как он будет импортирован, и что функция reload принудительно
выполняет операцию импортирования файла без остановки и переза
пуска интерпретатора Python. Мы также рассмотрели понятия про
странства имен, увидели, что происходит при вложенных операциях
импортирования, узнали, как файлы становятся пространствами
имен модулей, и познакомились с некоторыми потенциальными ло
вушками инструкции from.
Мы уже достаточно знаем, чтобы начать работать с файлами модулей
в наших программах, и тем не менее в следующей главе приводятся
расширенные сведения о модели импортирования – об импортирова
Закрепление пройденного 519
нии пакетов – о способе, с помощью которого инструкции import мож
но указать относительный путь к каталогу, где находится требуемый
модуль. Как мы увидим, возможность импортирования пакетов обес
печивает механизм, удобный для крупных систем и позволяющий из
бежать конфликтов между одинаковыми именами модулей. Но преж
де чем двинуться дальше, постарайтесь ответить на контрольные во
просы по представленным здесь идеям.
Закрепление пройденного
Контрольные вопросы
1. Как создать модуль?
2. Как взаимосвязаны инструкции from и import?
3. Какое отношение к операции импортирования имеет функция re
load?
4. Когда вместо инструкции from следует использовать инструкцию
import?
5. Назовите три потенциальных ловушки инструкции from.
6. Какова скорость полета ласточки без груза?
Ответы
1. Чтобы создать модуль, достаточно просто создать текстовый файл
с инструкциями на языке Python; любой файл с исходным про
граммным кодом автоматически становится модулем – нет ника
ких синтаксических конструкций для его объявления. Можно так
же создать модуль, написав программный код на другом языке про
граммирования, таком как C или Java, но такие модули находятся
вне рассмотрения этой книги.
2. Инструкция from импортирует модуль целиком, как и инструкция
import, но кроме этого она еще копирует одно или более имен из им
портируемого модуля в ту область видимости, где находится инст
рукция from. Это позволяет использовать импортированные имена
напрямую (name), без дополнения их именем модуля (module.name).
3. По умолчанию модуль импортируется один раз за все время выпол
нения программы. Функция reload принудительно выполняет по
вторное импортирование. Она часто используется, чтобы загрузить
новую версию исходного программного кода модуля в процессе раз
работки и в случаях динамической настройки.
4. Инструкция import обязательно должна использоваться вместо ин
струкции from, только когда необходимо обеспечить доступ к одно
му и тому же имени в двух разных модулях – поскольку вы будете
вынуждены указывать имена вмещающих модулей, эти два имени
будут уникальны.
520 Глава 19. Основы программирования модулей
5. Инструкция from может делать непонятным смысл переменной (в ка
ком модуле она определена), вызывать проблемы при использова
нии функции reload (имена могут ссылаться на прежние версии
объектов) и может повреждать пространства имен (может приво
дить к перезаписи значений имен, используемых в вашей области
видимости). Самой худшей, во многих отношениях, является фор
ма from * – она может приводить к серьезным повреждениям про
странств имен и скрывать смысл переменных – эту форму инструк
ции следует использовать с большой осторожностью.
6. А какая ласточка имеется в виду? Африканская или европейская?
20
Пакеты модулей
До сих пор, импортируя модули, мы загружали файлы. Это типичный
способ использования модулей, и скорее всего, этот прием будет вами
использоваться наиболее часто в начале вашей карьеры программиста
на языке Python. Однако возможности импортирования модулей не
много богаче, чем я предлагал вам считать до настоящего момента.
Помимо возможности импортировать имя модуля существует возмож
ность импортировать имена каталогов. Каталог, как говорят на языке
Python, является пакетом, поэтому такая операция импортирования
называется импортированием пакетов. В действительности, опера
ция импортирования пакета превращает имя каталога в еще одну раз
новидность пространства имен, в котором атрибутам соответствуют
подкаталоги и файлы модулей, находящиеся в этих каталогах.
Это немного усложненная особенность, но иерархическая структура,
которую она создает, оказывается удобной для организации файлов
в крупных системах и в большинстве случаев упрощает настройку пу
ти поиска модулей. Как мы увидим дальше, операция импортирова
ния пакетов иногда оказывается просто необходимой, чтобы избежать
неоднозначности при наличии нескольких файлов программ с одина
ковыми именами, установленных на одном компьютере.
Основы операции импортирования пакетов
Так как же работает импортирование пакетов? В инструкциях import,
там, где вы указывали имя простого файла, можно указать список
имен в пути к каталогу, разделяя их символами точки:
import dir1.dir2.mod
То же самое относится и к инструкции from:
from dir1.dir2.mod import x
522 Глава 20. Пакеты модулей
Предполагается, что такой «точечный» путь в этих инструкциях соот
ветствует пути через иерархию каталогов на вашей машине, ведущему
к файлу mod.py (или к файлу с похожим именем – расширение в имени
файла может быть другим). Таким образом, предыдущие инструкции
указывают, что на вашей машине имеется каталог dir1, в котором су
ществует подкаталог dir2, в котором находится файл модуля mod.py
(или с похожим именем).
Кроме того, эти инструкции предполагают, что каталог dir1 находится
внутри некоторого контейнерного каталога dir0, который находится
в пути поиска модулей. Другими словами, обе инструкции импорта
предполагают наличие структуры каталогов, которая выглядит при
мерно так, как показано ниже (здесь в качестве разделителей имен ка
талогов используется символ обратного слеша, принятый в операци
онной системе DOS):
dir0\dir1\dir2\mod.py # Или mod.pyc, mod.so и т. д.
Контейнерный каталог dir0 должен быть добавлен в путь поиска моду
лей (если это не домашний каталог главного файла программы), как
если бы имя dir1 было именем модуля. Инструкция import в вашем
сценарии определяет пути, ведущие непосредственно к модулям, на
чиная от этого каталога.
Пакеты и настройка пути поиска
Если вы используете эту возможность, имейте в виду, что пути к ката
логам в инструкции import могут содержать только имена переменных,
разделенные точками. Здесь нельзя использовать синтаксис путей к ка
талогам, специфичный для текущей платформы, как, например,
C:\dir1, My Documents.dir2 или ../dir1 – это недопустимый синтаксис.
Вместо этого платформозависимый синтаксис используйте в настрой
ках путей поиска модулей, именуя необходимые каталогиконтейнеры.
Так, в предыдущем примере dir0 – это имя каталога, которое требует
ся добавить в путь поиска модулей и которое может иметь произволь
ную длину и путь, с учетом специфики используемой платформы, ве
дущий к каталогу dir1. Вместо того чтобы использовать ошибочный
синтаксис, как показано ниже:
import C:\mycode\dir1\dir2\mod # Ошибка: недопустимый синтаксис
добавьте путь C:\mycode в переменную окружения PYTHONPATH или в файл
.pth (предполагается, что это не домашний каталог программы, по
скольку в этом случае этот шаг не является необходимым) и исполь
зуйте такую инструкцию:
import dir1.dir2.mod
В сущности, записи в списке путей поиска модулей содержат платфор
мозависимые пути к каталогам, которые ведут к самым левым именам
Основы операции импортирования пакетов 523
в цепочках, представленных в инструкциях import, а сами инструкции
import предоставляют окончание пути к каталогам платформонезави
симым способом.1
Файлы пакетов _ _init_ _.py
Если вы решили использовать импортирование пакетов, существует
еще одно условие, которое необходимо будет соблюдать: каждый ката
лог в пути, указанном в инструкции импортирования пакета, должен
содержать файл с именем __init__.py, в противном случае операция
импорта пакета будет терпеть неудачу. То есть в примере выше катало
ги dir1 и dir2 должны содержать файл с именем __init__.py; каталог
контейнер dir0 может не содержать такой файл, потому что сам он не
указан в инструкции импортирования пакета. Точнее говоря, для та
кой структуры каталогов:
dir0\dir1\dir2\mod.py
и инструкции импортирования, имеющей следующий вид:
import dir1.dir2.mod
применяются следующие правила:
• dir1 и dir2 должны содержать файл __init__.py.
• dir0, каталогконтейнер, может не содержать файл __init__.py –
этот файл будет проигнорирован, если он присутствует.
• dir0, но не dir0\dir1, должен присутствовать в пути поиска модулей
(то есть он должен быть домашним каталогом или присутствовать
в переменной окружения PYTHONPATH и т. д.).
Таким образом, структура каталогов в этом примере должна иметь
следующий вид (здесь отступы указывают на вложенность каталогов):
dir0\ # Каталогконтейнер в пути поиска модулей
dir1\
__init__.py
dir2\
__init__.py
mod.py
1 Символ точки как разделитель имен каталогов был выбран не только для
обеспечения независимости от используемой платформы, но и потому, что
пути в инструкциях import в действительности становятся вложенными
объектами пути. Этот синтаксис также подразумевает, что вы будете полу
чать невразумительные сообщения об ошибках, если забудете опустить
расширение .py. Например, инструкция import mod.py подразумевает, что
выполняется импорт пути к каталогу, – она загрузит mod.py, затем попыта
ется загрузить mod\py.py, что в конечном счете приведет к появлению сби
вающего с толку сообщения об ошибке.
524 Глава 20. Пакеты модулей
Файлы __init__.py могут содержать программный код на языке Py
thon, как любые другие файлы модулей. Отчасти они являются объяв
лениями для интерпретатора и могут вообще ничего не содержать. Эти
файлы, будучи объявлениями, предотвращают неумышленное сокры
тие в каталогах с совпадающими именами истинно требуемых моду
лей, если они отображаются позже в списке путей поиска модулей. Без
этого защитного механизма интерпретатор мог бы выбирать каталоги,
которые не имеют никакого отношения к вашему программному коду,
только лишь потому, что в пути поиска они появляются ранее.
В общем случае файл __init__.py предназначен для выполнения дей
ствий по инициализации пакета, создания пространства имен для ка
талога и реализации поведения инструкций from * (то есть from ... im
port *), когда они используются для импортирования каталогов:
Инициализация пакета
Когда интерпретатор Python импортирует каталог в первый раз, он
автоматически запускает программный код файла __init__.py это
го каталога. По этой причине обычно в эти файлы помещается про
граммный код, выполняющий действия по инициализации, необ
ходимые для файлов в пакете. Например, этот файл инициализа
ции в пакете может использоваться для создания файлов с данны
ми, открытия соединения с базой данных и т. д. Обычно файлы
__init__.py не предназначены для непосредственного выполнения –
они запускаются автоматически, когда выполняется первое обра
щение к пакету.
Инициализация пространства имен модуля
При импортировании пакетов пути к каталогам в вашем сценарии
после завершения операции импортирования превращаются в на
стоящие иерархии вложенных объектов. Например, в предыдущем
примере после завершения операции импортирования можно будет
использовать выражение dir1.dir2, которое возвращает объект мо
дуля, чье пространство имен содержит все имена, определяемые
файлом __init__.py из каталога dir2. Такие файлы создают про
странства имен для объектов модулей, соответствующих катало
гам, в которых отсутствуют настоящие файлы модулей.
Поведение инструкции from *
В качестве дополнительной особенности, в файлах __init__.py мож
но использовать списки __all__, чтобы определить, что будет им
портироваться из каталога инструкцией from *. (Мы познакомимся
со списком __all__ в главе 21.) Список __all__ в файлах __init__.py
представляет собой список имен субмодулей, которые должны им
портироваться, когда в инструкции from * указывается имя пакета
(каталога). Если список __all__ отсутствует, инструкция from * не
будет автоматически загружать субмодули, вложенные в каталог, –
она загрузит только имена, определяемые инструкциями присваи
вания в файле __init__.py, включая любые субмодули, явно импор
Пример импортирования пакета 525
тируемые программным кодом в этом файле. Например, инструк
ция from submodule import X в файле __init__.py создаст имя X в про
странстве имен каталога.
Эти файлы можно оставить пустыми, если вам не требуется выполнять
специальных действий. Однако для успешного выполнения операции
импортирования каталогов они должны существовать обязательно.
Пример импортирования пакета
Рассмотрим практический пример программного кода, который де
монстрирует, как используются файлы инициализации и пути к ката
логам. Следующие три файла располагаются в каталоге dir1 и в подка
талоге dir2:
# Файл: dir1\__init__.py
print 'dir1 init'
x = 1
# Файл: dir1\dir2\__init__.py
print 'dir2 init'
y = 2
# Файл: dir1\dir2\mod.py
print 'in mod.py'
z = 3
В данном случае каталог dir1 может быть подкаталогом нашего рабо
чего каталога (то есть домашнего каталога программы) или подкатало
гом одного из каталогов, перечисленных в пути поиска модулей (с точ
ки зрения реализации: каталога, входящего в список sys.path). В лю
бом из этих случаев для каталога, вмещающего подкаталог dir1, не
требуется наличие файла __init__.py.
Инструкции import выполняют файл инициализации в каждом ката
логе, который присутствует в пути к модулю, – инструкции print, при
сутствующие в этих файлах, позволят отследить их выполнение. Кро
ме того, как и файлы модулей, уже импортированные каталоги могут
передаваться функции reload для принудительного повторного испол
нения этого единственного элемента. Как показано ниже, для повтор
ной загрузки каталогов и файлов функция reload также может прини
мать цепочку имен, разделенных точками:
% python
>>> import dir1.dir2.mod # Сначала запускаются файлы инициализации
dir1 init
dir2 init
in mod.py
>>>
>>> import dir1.dir2.mod # Повторное импортирование не выполняется
>>>
>>> reload(dir1)
526 Глава 20. Пакеты модулей
dir1 init
<module 'dir1' from 'dir1\__init__.pyc'>
>>>
>>> reload(dir1.dir2)
dir2 init
<module 'dir1.dir2' from 'dir1\dir2\__init__.pyc'>
После операции импортирования путь, указанный в инструкции im
port, становится цепочкой вложенных объектов. Здесь mod – это объ
ект, вложенный в объект dir2, который в свою очередь вложен в объ
ект dir1:
>>> dir1
<module 'dir1' from 'dir1\__init__.pyc'>
>>> dir1.dir2
<module 'dir1.dir2' from 'dir1\dir2\__init__.pyc'>
>>> dir1.dir2.mod
<module 'dir1.dir2.mod' from 'dir1\dir2\mod.pyc'>
Каждый каталог в пути фактически становится переменной, которой
присваивается объект модуля, пространство имен которого инициали
зируется всеми инструкциями присваивания в файле __init__.py, на
ходящемся в этом каталоге. Имя dir1.x ссылается на переменную x,
которой присваивается значение в файле dir1\__init_ _.py, точно так
же, как имя mod.z ссылается на переменную z, которой присваивается
значение в файле mod.py:
>>> dir1.x
1
>>> dir1.dir2.y
2
>>> dir1.dir2.mod.z
3
Инструкции from и import для пакетов
Использование инструкции import может оказаться несколько неудоб
ным для импортирования пакетов, потому что в этом случае далее в про
грамме вам придется часто вводить полные пути для обращения к име
нам. В примере из предыдущего раздела, например, приходилось каж
дый раз вводить полный путь от dir1, когда необходимо было обратить
ся к переменной z. Если попытаться непосредственно обратиться к dir2
или mod, будет получено сообщение об ошибке:
>>> dir2.mod
NameError: name 'dir2' is not defined
>>> mod.z
NameError: name 'mod' is not defined
Поэтому для импортирования пакетов часто более удобно использо
вать инструкцию from, чтобы избежать необходимости ввода полного
имени при каждом обращении к нему. Пожалуй, еще более важно, что
Зачем используется операция импортирования пакетов? 527
если вы когданибудь выполните реструктуризацию дерева каталогов,
то в случае использования инструкции from достаточно будет обновить
только саму инструкцию, тогда как в случае использования инструк
ции import придется обновлять все обращения к именам в изменив
шемся пакете. Расширение import as, обсуждаемое в следующей главе,
поможет вам определить сокращенные синонимы для полных путей:
% python
>>> from dir1.dir2 import mod # Описание пути находится только в этом месте
dir1 init
dir2 init
in mod.py
>>> mod.z # Указывать полный путь не требуется
3
>>> from dir1.dir2.mod import z
>>> z
3
>>> import dir1.dir2.mod as mod # Использование короткого синонима
>>> mod.z
3
Зачем используется операция
импортирования пакетов?
Если вы только начинаете осваивать язык Python, то прежде чем пере
ходить к использованию пакетов, вам сначала необходимо освоить ра
боту с простыми модулями. Пакеты действительно являются полез
ным инструментом, особенно в крупных программах: они делают опе
рацию импортирования более информативной, выступают в роли орга
низационного инструмента, упрощают поиск файлов модулей и
способны разрешать возникающие неоднозначности.
Так как операция импортирования пакетов содержит некоторые сведе
ния о структуре каталогов, где находятся файлы программы, они,
в первую очередь, упрощают поиск файлов и служат организационным
инструментом. Не имея информации о путях к пакетам, вам часто при
шлось бы обращаться к содержимому пути поиска модулей, чтобы оты
скать требуемые файлы. Кроме того, если вы организовали размещение
своих файлов в дереве каталогов по функциональным признакам, то
операция импортирования пакетов делает более очевидной роль, кото
рую играют пакеты, что обеспечивает более высокую удобочитаемость
программного кода. Например, обычная операция импорта файла в ка
талоге, находящемся гдето в пути поиска модулей, выглядит так:
import utilities
предлагая намного меньше информации, чем операция импорта,
включающая путь к модулю:
import database.client.utilities
528 Глава 20. Пакеты модулей
Операция импортирования пакетов может также упростить задание
переменной окружения PYTHONPATH и файлов .pth, хранящих настройки
пути поиска модулей. Фактически, если вы используете импортирова
ние пакетов для всех имеющихся каталогов, где хранится ваш про
граммный код, и импорт производится относительно общего корнево
го каталога, вам достаточно будет добавить единственную запись
в путь поиска модулей: общий корневой каталог. Наконец, операция
импортирования пакетов способна разрешать неоднозначности за счет
явного и точного указания импортируемых файлов. В следующем раз
деле эта роль исследуется более подробно.
История о трех программах
Единственный случай, когда операция импортирования действитель
но необходима, – это разрешение неоднозначностей, которые могут
возникать, когда на одной машине установлено множество программ,
содержащих файлы с одинаковыми именами. В определенной степени
это проблема установки программ, но она может стать источником бес
покойств в обычной практике. Давайте рассмотрим гипотетическую
ситуацию, чтобы проиллюстрировать эту проблему.
Предположим, что программист разработал программу на языке Py
thon, которая содержит файл именем utilities.py, хранящий вспомога
тельный программный код, и файл main.py, используемый для запус
ка программы. Все файлы программы вызывают инструкцию import
utilities для загрузки и использования общего программного кода.
Программа распространяется в виде единого архива в формате .tar или
.zip, содержащего все файлы программы, и при установке все файлы
распаковываются в единственный каталог с именем system1:
system1\
utilities.py # Общие вспомогательные функции, классы
main.py # Этот файл запускает программу
other.py # Импортирует и использует модуль utilities
Теперь предположим, что другой программист разработал другую про
грамму, в которой также имеются файлы utilities.py и main.py, и так
же используется инструкция import utilities во всех файлах програм
мы для загрузки общего программного кода. Во время установки этой
второй программы на том же самом компьютере, где уже была уста
новлена первая программа, ее файлы были распакованы в новый ката
лог с именем system2, чтобы не перезаписать одноименные файлы пер
вой программы:
System2\
utilities.py # Общие вспомогательные функции
main.py # Этот файл запускает программу
other.py # Импортирует модуль utilities
Пока что никаких явных проблем не наблюдается: обе программы пре
красно сосуществуют и работают на одной и той же машине. Фактиче
Зачем используется операция импортирования пакетов? 529
ски для этих программ вам даже не нужно настраивать путь поиска мо
дулей, потому что интерпретатор всегда начинает поиск модулей с до
машнего каталога программы (то есть с каталога, в котором находится
главный файл программы), операции импортирования в любой из этих
программ автоматически будут находить все необходимые файлы в до
машнем каталоге программы. Например, если запускается файл sys+
tem1\main.py, все операции импортирования сначала будут просматри
вать каталог system1. Точно так же при запуске файла system2\main.py
в первую очередь будет просматриваться каталог system2. Не забывай
те, что настраивать путь поиска модулей необходимо только при необ
ходимости импортировать модули из разных каталогов.
А теперь предположим, что после установки этих двух программ вы ре
шили использовать вспомогательные функции из обоих файлов utili+
ties.py в своей собственной программе. В конце концов, это обычный
вспомогательный программный код, а для программного кода на языке
Python вполне естественно, когда он используется многократно. В та
кой ситуации вам необходима возможность из своего программного ко
да, хранящегося в третьем каталоге, загрузить один из двух файлов:
import utilities
utilities.func('spam')
Теперь проблема начинает вырисовываться. Чтобы вообще выполнить
эту работу, вам придется включить в путь поиска модулей каталоги,
содержащие файлы utilities.py. Но какой каталог поместить первым –
system1 или system2?
Проблема заключается в линейной природе пути поиска. Он всегда
просматривается слева направо. Независимо от того, как долго вы бу
дете ломать голову над этой проблемой, вы всегда будете получать
файл utilities.py из каталога, который находится в пути поиска раньше
(левее). Как следствие, вы никогда не сможете импортировать одно
именный файл из другого каталога. Вы можете попытаться изменять
sys.path в своей программе перед каждой операцией импортирования,
но это сложная работа и при ее выполнении легко ошибиться. По
умолчанию проблема оказывается для вас неразрешимой.
Эту проблему можно решить с помощью пакетов. Вместо того чтобы
устанавливать программы как плоские списки файлов в независимые
каталоги, можно установить их в подкаталоги с общим корнем. На
пример, можно было бы организовать установку всего программного
кода из этого примера в виде следующей иерархии:
root\
system1\
__init__.py
utilities.py
main.py
other.py
system2\
530 Глава 20. Пакеты модулей
__init__.py
utilities.py
main.py
other.py
system3\ # Здесь или в другом месте
__init__.py # располагается ваш новый программный код
myfile.py
Теперь достаточно просто добавить общий корневой каталог в путь по
иска модулей. Если теперь выполнять импортирование относительно
этого общего корня, можно будет с помощью операции импортирова
ния пакетов импортировать любой файл из любой программы – ис
пользование имени вмещающего каталога делает путь (а значит,
и ссылку на модуль) уникальным. Фактически можно даже импорти
ровать обе утилиты сразу в одном и том же модуле, при условии, что
вы будете использовать инструкцию import и при каждом обращении
к именам будете указывать полный путь к вспомогательным модулям:
import system1.utilities
import system2.utilities
system1.utilities.function('spam')
system2.utilities.function('eggs')
В данном случае имя вмещающего каталога обеспечивает уникаль
ность ссылок на модули.
Обратите внимание, что вместо инструкции from необходимо использо
вать инструкцию import, только если вам необходимо получить доступ
к двум или более одноименным атрибутам. Если бы имена вызывае
мых здесь функций различались, можно было бы использовать инст
рукцию from, чтобы избежать необходимости всякий раз вводить пол
ные пути к пакетам, как уже описывалось выше.
Кроме того, следует заметить, что в приведенной выше иерархии уста
новки файлы __init__.py были добавлены в каталоги установки про
грамм system1 и system2, но не в корневой каталог root. Этот файл тре
буется помещать только в каталоги, перечисленные в инструкциях im
port, – как вы наверняка помните, они автоматически выполняются
интерпретатором при первой попытке программы импортировать ка
талог пакета.
С точки зрения реализации, каталог system3 не обязательно должен
находиться в каталоге root – здесь должны находиться только катало
ги, откуда производится импорт пакетов. Однако, поскольку ваши
собственные модули могут когданибудь быть использованы в других
программах, было бы желательно поместить их в общий корневой ка
талог, чтобы избежать подобных проблем в будущем.
Наконец, обратите внимание, что операции импорта в обеих оригиналь
ных программах продолжают действовать без изменений. Поскольку
в этих программах поиск модулей производится в первую очередь в их
домашних каталогах, добавление общего корневого каталога в путь по
В заключение 531
иска модулей никак не отражается на программном коде в system1
и system2 – они попрежнему могут использовать инструкции import
utilities и ожидать получить в ответ свои собственные файлы. Кроме
того, если вы предусмотрительно будете устанавливать все программы
на языке Python в общий корневой каталог, как в данном примере, на
стройка пути поиска станет элементарной: вам достаточно будет один
раз добавить в него общий корневой каталог.
В заключение
В этой главе была представлена модель импортирования пакетов – не
обязательный, но удобный способ явно указать путь к каталогам с мо
дулями. В инструкциях импорта указывается путь относительно ката
лога, находящегося в пути поиска модулей, но вместо того, чтобы по
лагаться на результаты поиска, выполняемого интерпретатором, ва
ши сценарии могут явно указывать остаток пути к модулю.
Как мы видели, пакеты не только делают операцию импортирования бо
лее осмысленной в крупных программах, но еще и упрощают настройку
пути поиска (если все каталоги, откуда производится импорт, вложены
Придется держать в уме: пакеты модулей
Теперь, когда пакеты стали стандартной частью Python, часто
можно встретить крупные расширения сторонних разработчи
ков, распространяемые не как плоский список модулей, а как на
бор каталогов с пакетами. Например, пакет расширений win32all
для Python в операционной системе Windows был одним из пер
вых, кто перешел на сторону победителя. Многие вспомогатель
ные модули этого пакета располагаются в пакетах, импортируе
мых посредством указания пути. Например, чтобы загрузить на
бор инструментальных средств для работы с технологией COM на
стороне клиента, можно использовать такую инструкцию:
from win32com.client import constants, Dispatch
Эта инструкция извлекает имена из модуля client в пакете
win32com (подкаталог, куда был установлен пакет).
Импортирование пакетов повсеместно используется в программ
ном коде, работающем под управлением Jython, – реализации
языка Python на Java, потому что библиотеки самого языка Java
тоже организованы в виде иерархии каталогов. В последних вер
сиях Python инструменты для работы с электронной почтой
и XML в стандартной библиотеке также были организованы
в подкаталоги пакетов. Если вы создаете каталоги пакетов, в ко
нечном итоге у вас будет возможность импортировать их.
532 Глава 20. Пакеты модулей
в один общий корневой каталог), а также позволяют разрешать возни
кающие неоднозначности в тех случаях, когда существует более одного
модуля с одним и тем же именем (наличие имен каталогов в операциях
импортирования позволяет обеспечить уникальность имен модулей).
В следующей главе мы исследуем несколько более сложных тем,
имеющих отношение к модулям, таких как синтаксис относительного
импорта и переменная режима использования __name__. Как обычно,
мы заканчиваем эту главу серией контрольных вопросов, чтобы прове
рить, насколько хорошо вы запомнили сведения, полученные здесь.
Закрепление пройденного
Контрольные вопросы
1. Для чего служит файл __init__.py в каталогах пакетов модулей?
2. Как избежать необходимости снова и снова вводить полное имя па
кета при каждом обращении к содержимому пакетов?
3. В каких каталогах необходимо создавать файл __init__.py?
4. В каких случаях вместо инструкции from приходится использовать
инструкцию import?
Ответы
1. Файлы __init__.py служат для объявления и инициализации па
кета, – интерпретатор автоматически запускает программный код
в этих файлах, когда каталог импортируется программой впервые.
Переменные, которым выполняется присваивание в этих файлах,
становятся атрибутами объекта модуля для соответствующего ката
лога. Присутствие этих файлов в каталогах пакетов обязательно –
вы не сможете импортировать пакеты при отсутствии этих файлов
в каталогах.
2. Используйте инструкцию from, чтобы скопировать имена из пакета
или воспользуйтесь расширением as инструкции import, чтобы пе
реименовать полный путь в короткий синоним. В обоих случаях
полный путь будет присутствовать только в одном месте – в инст
рукции from или import.
3. Каждый каталог, перечисленный в инструкции import или from,
должен содержать файл __init__.py. Другие каталоги, включая ка
талог, содержащий самый первый компонент пути к пакету, не тре
буют наличия этого файла.
4. Инструкция import должна использоваться вместо инструкции from,
только если вам необходимо обеспечить доступ к одному и тому же
имени более чем в одном каталоге. Благодаря инструкции import
употребление полного пути обеспечивает уникальность ссылок, то
гда как инструкция from допускает наличие только одной версии
любого имени.
21
Дополнительные возможности модулей
Эта глава завершает пятую часть книги, представляя коллекцию бо
лее сложных тем, имеющих отношение к модулям, – синтаксис отно
сительного импорта, сокрытие данных, модуль __future__, переменная
__name__, изменение списка sys.path и т. д. и, кроме того, содержит пе
речень наиболее типичных ошибок и упражнения, завершающие эту
часть книги. Как и функции, модули наиболее эффективны, когда
должным образом определены их интерфейсы, поэтому в данной главе
представлен краткий обзор концепций проектирования модулей, не
которые из которых мы исследовали в предыдущих главах.
Несмотря на слово «дополнительные» в заглавии этой главы, некото
рые из обсуждаемых здесь возможностей (такие, как приемы работы
с переменной __name__) используются достаточно широко, поэтому обя
зательно ознакомьтесь с ними, прежде чем переходить к классам в сле
дующей части книги.
Сокрытие данных в модулях
Как мы уже видели, модули в языке Python экспортируют все имена,
которым были присвоены значения на верхнем уровне файлов. В язы
ке нет никаких объявлений, которые позволили бы сделать одни име
на видимыми, а другие – невидимыми за пределами модуля. Фактиче
ски нет никакого способа предотвратить возможность изменения имен
в модуле извне, если в этом появится необходимость.
Сокрытие данных модуля в языке Python регулируется соглашения
ми, а не синтаксическими конструкциями. Если задаться целью по
вредить модуль, изменяя имена в нем, вам ничто не сможет помешать,
но, к счастью, я еще не встречал программистов, кто стремился бы это
сделать. Некоторые пуристы возражают против такого либерального
отношения к сокрытию данных, утверждая в связи с этим, что в языке
534 Глава 21. Дополнительные возможности модулей
Python отсутствует возможность инкапсуляции. Инкапсуляция в язы
ке Python скорее относится к организации пакетов, чем к возможно
сти накладывать ограничения.
Минимизация повреждений, причиняемых
инструкцией from *: _X и __all__
Как особый случай, существует возможность начинать имена перемен
ных с одного символа подчеркивания (например, _X), чтобы предотвра
тить их перезаписывание, когда клиент выполняет импортирование
модуля инструкцией from *. Этот прием на самом деле предназначен
только для минимизации загрязнения пространства имен – так как
инструкция from * копирует все имена, импортирующий модуль мо
жет получить больше, чем предполагал (включая имена, которые пе
резапишут имена импортирующего модуля). Символы подчеркивания
не являются объявлением «частных» данных: вы попрежнему може
те видеть эти имена и изменять их с помощью других форм импорти
рования, таких как инструкция import.
Альтернативный способ достижения эффекта сокрытия данных, напо
минающий соглашение об именовании _X, заключается в присвоении
на верхнем уровне модуля переменной __all__ списка строк с именами
переменных. Например:
__all__ = ["Error", "encode", "decode"] # Экспортируются только эти имена
При использовании этого приема инструкция from * будет копировать
только имена, перечисленные в списке __all__. В действительности это
соглашение, обратное соглашению _X: переменная __all__ идентифи
цирует имена, доступные для копирования, тогда как соглашение _X
идентифицирует имена, недоступные для копирования. Интерпрета
тор Python сначала отыскивает список __all__ в модуле, и если он от
сутствует, инструкция from * копирует все имена, которые не начина
ются с единственного символа подчеркивания.
Подобно соглашению _X, список __all__ имеет смысл только для инст
рукции from * и не является объявлением частных данных. Програм
мисты могут использовать при реализации модулей любой из этих
приемов, которые хорошо работают с инструкцией from *. (Смотрите
также обсуждение списков __all__ в файлах пакетов __init__.py в гла
ве 20 – там эти списки объявляют субмодули, которые могут быть за
гружены инструкцией from *.)
Включение будущих возможностей языка
В языке периодически появляются изменения, которые могут повли
ять на работоспособность существующего программного кода. Сначала
они появляются в виде расширений, которые по умолчанию отключе
ны. Чтобы включить такие расширения, используется инструкция
импорта специального вида:
Смешанные режимы использования: _ _name_ _ и _ _main__ 535
from __future__ import имя_функциональной_особенности
Эта инструкция вообще должна появляться в самом начале файла мо
дуля (возможно, сразу же вслед за строкой документирования), потому
что она включает специальный режим компиляции программного кода
для каждого отдельно взятого модуля. Возможно также выполнить эту
инструкцию в интерактивной оболочке, что позволит поэксперименти
ровать с грядущими изменениями в языке; включенная особенность
будет после этого доступна в течение всего интерактивного сеанса.
Например, в предыдущем издании этой книги мы использовали эту
форму инструкции для демонстрации функцийгенераторов, в которых
используется ключевое слово, еще недоступное по умолчанию в то вре
мя (в качестве имя_функциональной_особенности указывалось имя genera
tors). Мы уже использовали эту инструкцию для включения операции
истинного деления чисел в главе 5 и будем использовать ее и в этой гла
ве для включения возможности абсолютного импорта, а также в седь
мой части книги – для демонстрации менеджеров контекста.
Все эти изменения могут отрицательно сказаться на работоспособности
существующего программного кода, и поэтому они так постепенно вво
дятся в язык – сначала в виде дополнительных возможностей, вклю
чаемых с помощью этой специальной формы инструкции импорта.
Смешанные режимы использования:
__name__ и __main__
Ниже демонстрируется специальный прием, позволяющий импорти
ровать файлы как модули и запускать их как самостоятельные про
граммы. Каждый модуль обладает встроенным атрибутом __name__, ко
торый устанавливается интерпретатором следующим образом:
• Если файл запускается как главный файл программы, атрибуту
__name__ на запуске присваивается значение "__main__".
• Если файл импортируется, атрибуту __name__ присваивается имя
модуля, под которым он будет известен клиенту.
Благодаря этому модуль может проверить собственный атрибут
__name__ и определить, был он запущен как самостоятельная програм
ма или импортирован другим модулем. Например, предположим, что
мы создаем файл модуля с именем runme.py, который экспортирует
единственную функцию с именем tester:
def tester():
print "It's Christmas in Heaven..."
if __name__ == '__main__': # Только когда запускается,
tester() # а не импортируется
Этот модуль определяет функцию для клиентов и может импортиро
ваться как обычный модуль:
536 Глава 21. Дополнительные возможности модулей
% python
>>> import runme
>>> runme.tester()
It's Christmas in Heaven...
Но в самом конце модуля имеется программный код, который вызыва
ет функцию, когда этот файл запускается как самостоятельная про
грамма:
% python runme.py
It's Christmas in Heaven...
Пожалуй, чаще всего проверка атрибута __name__ выполняется в про
граммном коде для самопроверки модуля. Проще говоря, вы можете
добавить в конец модуля программный код, который будет выполнять
проверку экспортируемых элементов внутри самого модуля, заключив
этот код в условную инструкцию, проверяющую атрибут __name__. При
таком подходе вы можете использовать файл в других модулях, импор
тируя его, и тестировать логику работы, запуская его из командной
строки или какимлибо другим способом. На практике программный
код самопроверки в конце файла, заключенный в условную инструк
цию, проверяющую атрибут __name__, является, пожалуй, самым рас
пространенным и удобным способом модульного тестирования в языке
Python. (В главе 29 обсуждаются другие часто используемые способы
тестирования программного кода на языке Python – как будет показа
но, в стандартной библиотеке существуют модули unittest и doctest,
которые реализуют более совершенные средства тестирования.)
Прием, основанный на проверке атрибута __name__, также часто ис
пользуется при создании файлов, которые могут использоваться и как
утилиты командной строки, и как библиотеки инструментов. Напри
мер, предположим, что вы пишете на языке Python сценарий поиска
файлов. Код принесет больше пользы, если реализовать его в виде
функций и добавить проверку атрибута __name__ для организации вы
зова этих функции, когда файл запускается как самостоятельная про
грамма. При таком подходе сценарий может повторно использоваться
в составе других программ.
Тестирование модулей с помощью __name__
Мы уже видели в этой книге один хороший пример, применительно
к которому проверка атрибута __name__ могла бы быть полезной. В раз
деле, рассказывающем об аргументах, в главе 16, мы написали сцена
рий, который находит минимальное значение среди множества пред
ложенных аргументов:
def minmax(test, *args):
res = args[0]
for arg in args[1:]:
if test(arg, res):
res = arg
Смешанные режимы использования: _ _name_ _ и _ _main__ 537
return res
def lessthan(x, y): return x < y
def grtrthan(x, y): return x > y
print minmax(lessthan, 4, 2, 1, 5, 6, 3) # Код самопроверки
print minmax(grtrthan, 4, 2, 1, 5, 6, 3)
В самом конце этого сценария присутствует программный код само
проверки, благодаря которому мы можем проверить правильность ра
боты модуля без необходимости вводить его в интерактивной оболочке
всякий раз, когда нам потребуется проверить модуль. Однако при та
кой реализации имеется одна проблема – результаты самопроверки
будут выводиться на экран всякий раз, когда этот файл будет импор
тироваться для использования другим файлом, но тогда это становит
ся невежливым по отношению к пользователю! Чтобы исправить поло
жение, можно обернуть проверочные вызовы функции в условную ин
струкцию, проверяющую атрибут __name__ так, чтобы они выполня
лись, только когда файл запускается как самостоятельная программа,
а не во время импорта:
print 'I am:', __name__
def minmax(test, *args):
res = args[0]
for arg in args[1:]:
if test(arg, res):
res = arg
return res
def lessthan(x, y): return x < y
def grtrthan(x, y): return x > y
if __name__ == '__main__':
print minmax(lessthan, 4, 2, 1, 5, 6, 3) # Код самопроверки
print minmax(grtrthan, 4, 2, 1, 5, 6, 3)
Здесь в самом начале добавлена инструкция вывода значения атрибу
та __name__, чтобы проверить его визуально. Интерпретатор Python соз
дает эту переменную и присваивает ей значение во время загрузки
файла. Когда файл запускается как самостоятельная программа, это
му имени присваивается значение '__main__', поэтому в данном случае
происходит автоматическое выполнение кода самопроверки:
% python min.py
I am: __main__
1
6
Однако, когда файл импортируется, значение атрибута __name__ уже не
равно '__main__', поэтому необходимо явно вызвать функцию, чтобы
запустить ее:
>>> import min
538 Глава 21. Дополнительные возможности модулей
I am: min
>>> min.minmax(min.lessthan, 's', 'p', 'a', 'm')
'a'
Неважно, будет ли использоваться этот прием для нужд тестирования,
главный результат – что наш программный код может использоваться
и как библиотека инструментов, и как самостоятельная программа.
Изменение пути поиска модулей
В главе 18 мы узнали, что путь поиска модулей – это список катало
гов, и что этот список можно дополнить с помощью переменной окру
жения PYTHONPATH и файлов .pth. Но я пока еще не показывал, как сами
программы на языке Python могут изменять путь поиска, изменяя
встроенный список с именем sys.path (атрибут path встроенного моду
ля sys). Список sys.path инициализируется во время запуска програм
мы, однако после этого допускается удалять, добавлять и изменять
компоненты списка по своему усмотрению:
>>> import sys
>>> sys.path
['', 'D:\\PP3ECDPartial\\Examples', 'C:\\Python25', ...далее опущено...]
>>> sys.path.append('C:\\sourcedir') # Дополнение пути поиска модулей
>>> import string # Новый каталог будет участвовать
# в поиске
Как только будут внесены изменения, они будут воздействовать на все
последующие инструкции импорта, выполняемые в программе, так
как все инструкции во всех файлах программы используют один и тот
же общий список sys.path. Этот список может изменяться произволь
ным образом:
>>> sys.path = [r'd:\temp'] # Изменяет путь поиска модулей
>>> sys.path.append('c:\\lp3e\\examples') # Только для этой программы
>>> sys.path
['d:\\temp', 'c:\\lp3e\\examples']
>>> import string
Traceback (most recent call last):
File "<stdin>", line 1, in ?
ImportError: No module named string
Таким образом, этот прием может использоваться для динамической
настройки пути поиска внутри программ на языке Python. Однако
будьте внимательны: если убрать из пути критически важный ката
лог, можно потерять доступ к критически важным утилитам. В пре
дыдущем примере, например, был потерян доступ к модулю string, по
тому что из пути был удален исходный каталог библиотеки.
Кроме того, не забывайте, что такие изменения списка sys.path действу
ют только в рамках интерактивного сеанса или внутри программы (тех
Расширение import as 539
нически – в рамках процесса), где были выполнены эти изменения, –
они не сохраняются после завершения работы интерпретатора. Настрой
ки в переменной окружения PYTHONPATH и в файлах .pth располагаются
в самой операционной системе, а не в работающей программе, и пото
му они имеют более глобальный характер: они воспринимаются всеми
программами, которые запускаются на вашей машине, и продолжают
существовать по завершении программы.
Расширение import as
Обе инструкции, import и from, были расширены так, чтобы позволить
дать модулю в вашем сценарии другое имя. Следующая инструкция
import:
import longmodulename as name
эквивалентна инструкциям:
import longmodulename
name = longmodulename
del longmodulename # Не сохранять оригинальное имя
После выполнения такой инструкции import для ссылки на модуль
можно (и фактически необходимо) использовать имя, указанное после
ключевого слова as. Точно такое же расширение имеется и у инструк
ции from, где оно позволяет изменять имена, импортируемые из файла:
from module import longname as name
Это расширение обычно используется с целью создать короткие сино
нимы для длинных имен и избежать конфликтов с именами, уже ис
пользуемыми в сценарии, которые в противном случае были бы просто
перезаписаны инструкцией импортирования. Кроме того, это расши
рение может пригодиться с целью создания коротких и простых имен
для длинных путей, состоящих из цепочки каталогов, при импортиро
вании пакетов, которое описывалось в главе 20.
Синтаксис относительного импорта
В версии Python 2.5 была изменена семантика пути поиска в некото
рых инструкциях from, когда они применяются к пакетам модулей, ко
торые мы рассматривали в предыдущей главе. Некоторые аспекты это
го изменения не будут очевидны до выхода более поздних версий Py
thon (в настоящее время их включение запланировано для версий 2.7
и 3.0), однако некоторые из них доступны уже сегодня.
Говоря в двух словах, инструкции from теперь могут использовать точ
ки («.»), чтобы указать, что поиск модулей в первую очередь должен
производиться в том же самом пакете (эта особенность известна также
как относительный импорт внутри пакета), и только потом может
540 Глава 21. Дополнительные возможности модулей
выполняться гдето в другом месте, в пути поиска импортируемых мо
дулей (эта особенность называется абсолютным импортом). То есть:
• На сегодняшний день можно использовать точки, чтобы указать,
что импорт должен производиться относительно вмещающего па
кета – при таком способе импортирования предпочтение будет отда
ваться модулям, расположенным внутри пакета, а не одноименным
модулям, находящимся гдето в пути поиска, в sys.path.
• Обычная операция импортирования в программном коде пакета
(без точек) в настоящее время по умолчанию выполняется в поряд
ке «сначала поиск относительно пакета, потом – абсолютный по
иск». Однако в будущем интерпретатор будет по умолчанию ис
пользовать абсолютный импорт – при отсутствии точек операции
импортирования будут пропускать вмещающий пакет и искать им
портируемые модули в пути поиска sys.path.
Например, в настоящее время инструкция:
from .spam import name
означает: «из модуля с именем spam, расположенного в том же пакете,
что и сама инструкция, импортировать переменную name». Похожая
инструкция без начальной точки по умолчанию также будет использо
вать порядок поиска «сначала относительно пакета, а затем – абсолют
ный поиск», если только в импортирующий файл не будет включена
следующая инструкция:
from __future__ import absolute_import # До выхода версии 2.7?
Если эта инструкция присутствует, она включает использование абсо
лютного пути поиска, которое станет поведением по умолчанию в бу
дущем. В результате этого все операции импортирования без дополни
тельных точек будут пропускать компоненты в том же пакете и произ
водить поиск по абсолютному пути, хранящемуся в списке sys.path.
Например, когда абсолютный импорт включен таким способом, сле
дующая инструкция всегда будет находить не модуль string в текущем
пакете, а одноименный модуль в стандартной библиотеке:
import string # Всегда будет находить версию модуля в стандартной библиотеке
Без инструкции from __future__ всегда будет импортироваться модуль
string, если он присутствует в пакете. Чтобы получить то же самое по
ведение в будущем, когда по умолчанию будет выполняться абсолют
ный импорт, для выполнения относительного импорта можно будет
использовать следующую форму инструкции (которая работает и в на
стоящее время):
from . import string # Сначала поиск производится внутри пакета
Обратите внимание: ведущий символ точки может использоваться
только в инструкции from, в инструкции import он недопустим. Инст
рукция import modname в настоящее время попрежнему выполняет от
Синтаксис относительного импорта 541
носительный импорт, но в Python 2.7 она будет выполнять абсолют
ный импорт.
Возможны также и другие варианты точечной нотации для ссылки на
модули в пакете. Допустим, что имеется пакет mypkg, тогда следующие
альтернативные варианты импортирования внутри этого пакета будут
работать так, как описывается:
from .string import name1, name2 # Импорт имен из mypkg.string
from . import string # Импорт mypkg.string
from .. import string # Импорт string из родительского каталога
Чтобы лучше понять эти последние формы инструкций, необходимо
разобраться с обоснованием этого грядущего изменения.
Зачем необходим относительный импорт
Эта возможность предназначена, чтобы дать сценариям возможность
ликвидировать возникающие неоднозначности, которые могут возни
кать, когда в разных местах в пути поиска присутствует несколько од
ноименных модулей. Рассмотрим следующий каталог пакета:
mypkg\
__init__.py
main.py
string.py
Это каталог пакета с именем mypkg, содержащий модули mypkg.main
и mypkg.string. Теперь предположим, что модуль main пытается импор
тировать модуль с именем string. В Python 2.4 и в более ранних верси
ях интерпретатор будет сначала искать модуль в каталоге mypkg, вы
полняя относительный импорт. Он найдет и импортирует файл
string.py, находящийся в этом каталоге, и присвоит его имени string
в пространстве имен модуля mypkg.main.
Однако может так получиться, что этой инструкцией предполагалось
импортировать модуль string из стандартной библиотеки языка Py
thon. К сожалению, в этих версиях Python нет достаточно простого
способа проигнорировать модуль mypkg.string и импортировать модуль
string из стандартной библиотеки, расположенной в пути поиска мо
дулей правее. Мы не можем зависеть от структуры каталогов пакета,
описанных выше стандартной библиотеки, присутствующей на любом
компьютере.
Другими словами, инструкции импортирования в пакетах могут быть
неоднозначными – внутри пакета может быть непонятно, какой мо
дуль пытается импортировать инструкция import spam, – внутри паке
та или за его пределами. Если говорить более точно, локальный мо
дуль или пакет могут сделать невозможным импорт другого модуля,
присутствующего в пути поиска sys.path, преднамеренно или нет.
На практике пользователи Python могут избегать использовать имена
модулей стандартной библиотеки для своих модулей (если вам требует
542 Глава 21. Дополнительные возможности модулей
ся стандартный модуль string, не называйте свой модуль этим именем).
Но это не поможет, если пакет делает недоступным стандартный модуль
случайно. Кроме того, с течением времени в стандартную библиотеку
Python могут добавляться новые модули – с теми же именами, которые
присвоены вашим уже существующим модулям. Программный код, ис
пользующий особенности относительного импорта, сложнее понять, по
тому что бывает трудно выяснить, какой модуль импортируется. Гораз
до лучше, если решение явно описывается в программном коде.
В Python 2.5 мы можем управлять поведением операций импорта, вы
нуждая их использовать абсолютный режим импортирования инст
рукцией from __future__, которая была описана ранее. Учтите, что ре
жим абсолютного импортирования будет использоваться по умолча
нию в будущих версиях (планируется ввести его в Python 2.7). Когда
режим абсолютного импортирования будет включен, следующая инст
рукция в нашем примере файла mypkg\main.py всегда будет находить
версию модуля string из стандартной библиотеки благодаря абсолют
ному поиску:
import string # Импорт модуля string из стандартной библиотеки
Вы должны уже сейчас привыкать к использованию абсолютного ре
жима импорта, чтобы быть готовыми, когда изменения вступят в си
лу. Таким образом, если вы действительно хотите импортировать мо
дуль из своего пакета, то, чтобы сделать это явным и абсолютным, вы
должны начать писать инструкции, подобные этой (mypkg будет най
ден в режиме абсолютного поиска по sys.path):
from mypkg import string # Импортирует mypkg.string (по абсолютному пути)
Режим относительного импорта попрежнему остается доступным –
при использовании точки в инструкции from:
from . import string # Импортирует mypkg.string (по относительному пути)
Данная форма инструкции импортирует модуль string относительно
текущего пакета и является примерным эквивалентом абсолютной
формы из предыдущего примера (поиск в каталоге пакета автоматиче
ски выполняется в первую очередь).
С помощью относительного синтаксиса можно также копировать за
данные имена из модуля:
from .string import name1, name2 # Импортирует имена из mypkg.string
Эта инструкция также ссылается на модуль string относительно теку
щего пакета. Если поместить эту инструкцию в модуль mypkg.main, на
пример, она будет импортировать имена name1 и name2 из модуля myp
kg.string. Дополнительная начальная точка предписывает выполнить
относительный импорт, начиная с родительского каталога текущего
пакета. Например, инструкция:
from .. import spam # Импортирует модуль одного уровня с пакетом mypkg
Концепции проектирования модулей 543
загрузит модуль, находящийся на том же уровне в иерархии катало
гов, что и пакет mypkg, – то есть модуль spam, находящийся в каталоге,
родительском по отношению к пакету mypkg. В общем случае действия
программного кода в модуле A.B.C будут следующими:
from . import D # Импортирует A.B.D
from .. import E # Импортирует A.E
from ..F import G # Импортирует A.F.G
Синтаксис относительного импорта и предложенные изменения по
использованию «абсолютного импорта по умолчанию» – это достаточ
но сложные концепции, которые лишь частично реализованы в Py
thon 2.4. Поэтому мы больше не будем углубляться в эту тему, и за бо
лее подробной информацией обращайтесь к набору стандартных руко
водств по языку Python.
Концепции проектирования модулей
Как и в случае с функциями, при проектировании модулей использу
ются свои правила: вам необходимо подумать о том, какие функции
и в какие модули будут входить, предусмотреть механизмы взаимо
действия между модулями и т. д. Все это станет более понятным, когда
вы начнете создавать крупные программы на языке Python, а пока оз
накомьтесь с несколькими основными положениями:
• В языке Python вы всегда находитесь в модуле. Нет никакого спосо
ба написать программный код, который не находился бы в каком
нибудь модуле. Фактически даже программный код, который вво
дится в интерактивной оболочке, на самом деле относится к встроен
ному модулю с именем __main__ – единственная уникальная особен
ность интерактивной оболочки состоит в том, что программный код
после выполнения сразу же удаляется, а результаты выражений
выводятся автоматически.
• Минимизируйте взаимозависимость модулей: глобальные пере!
менные. Как и функции, модули работают лучше, когда они напи
саны как самостоятельные закрытые компоненты. Следуйте прави
лу: модули должны быть максимально независимы от глобальных
имен в других модулях.
• Максимизируйте согласованность внутри модуля: общая цель.
Уменьшить взаимозависимость модулей можно за счет увеличения
согласованности отдельного модуля – если все компоненты модуля
используются для достижения общей цели, маловероятно, что та
кой модуль будет зависеть от внешних имен.
• Модули должны редко изменять переменные в других модулях. Мы
демонстрировали справедливость этого правила на примере про
граммного кода в главе 16. Но будет совсем нелишним повторить его:
использование глобальных переменных из других модулей (в кон
це концов, это один из способов, каким клиенты импортируют
544 Глава 21. Дополнительные возможности модулей
службы) – совершенно нормальное явление, тогда как внесение из
менений в глобальные переменные в других модулях служит при
знаком проблем с проектированием. Конечно, из этого правила есть
исключения, но вы должны стремиться обмениваться данными че
рез такие механизмы, как аргументы и возвращаемые значения
функций, не прибегая к прямому изменению переменных в других
модулях. В противном случае глобальные значения могут попасть
в зависимость от порядка выполнения инструкций присваивания
в других файлах, и такие модули будет сложнее понять и приспосо
бить к повторному использованию в других программах.
Для иллюстрации на рис. 21.1 приводится окружение, в котором дейст
вуют модули. Модули содержат переменные, функции, классы и другие
модули (если импортируют их). В функциях имеются свои собственные
локальные переменные. С классами – еще одной разновидностью объ
ектов, которые находятся в модулях, – вы познакомитесь в главе 22.
Модули – это объекты: метапрограммы
Поскольку модули экспортируют большую часть своих свойств в виде
встроенных атрибутов, это позволяет легко создавать программы, ко
торые управляют другими программами. Такие менеджеры программ
импортирование
импортирование
Переменные
Функции
Классы/Типы
Переменные
Функции
Классы/Типы
Другие модули
(на языке Python или C)
Другие модули
(на языке Python или C)
Модули
Переменные
Функции
Классы
Члены классов
Методы
Переменные
Рис. 21.1. Среда выполнения модуля. Модули импортируются и сами
могут импортировать и использовать другие модули, которые могут быть
написаны на языке Python или на других языках программирования, таких
как C. Модули содержат переменные, функции и классы, с помощью которых
решают возложенные на них задачи. Их функции и классы также могут
содержать свои собственные переменные и другие программные элементы.
Но надо помнить, что на самом верхнем уровне программы – это всего
лишь наборы модулей
Концепции проектирования модулей 545
мы обычно называем метапрограммами, потому что они работают по
верх других программ. Этот прием также называется интроспекцией,
потому что программы могут просматривать внутреннее устройство
объектов и действовать, исходя из этого. Интроспекция – это дополни
тельная особенность, которая может быть полезна при создании инст
рументальных средств программирования.
Например, чтобы получить значение атрибута с именем name в модуле
с именем M, мы можем использовать полное имя атрибута или обра
титься к нему с помощью словаря атрибутов модуля (экспортируется
в виде встроенного атрибута __dict__). Кроме того, интерпретатор экс
портирует список всех загруженных модулей в виде словаря sys.mod
ules (то есть в виде атрибута modules модуля sys) и предоставляет встро
енную функцию getattr, которая позволяет получать доступ к атрибу
там по строкам с их именами (напоминает выражение object.attr,
только attr – это строка времени выполнения). Благодаря этому все
следующие выражения представляют один и тот же атрибут и объект:
M.name # Полное имя объекта
M.__dict__['name'] # Доступ с использованием словаря пространства имен
sys.modules['M'].name # Доступ через таблицу загруженных модулей
getattr(M, 'name') # Доступ с помощью встроенной функции
Обеспечивая доступ к внутреннему устройству модулей, интерпретатор
помогает создавать программы, управляющие другими программами.1
Например, ниже приводится модуль с именем mydir.py, в котором ис
пользованы эти идеи для реализации измененной версии встроенной
функции dir. Этот модуль определяет и экспортирует функцию с име
нем listing, которая принимает объект модуля в качестве аргумента
и выводит отформатированный листинг пространства имен модуля:
# Модуль, который выводит содержимое пространства имен других модулей
verbose = 1
def listing(module):
if verbose:
print ""*30
print "name:", module.__name__, "file:", module.__file__
print ""*30
count = 0
1 Как мы видели в главе 16, функция может получить доступ к вмещающему
модулю с помощью таблицы sys.modules, что позволяет имитировать дейст
вие инструкции global. Например, эффект действия инструкций global X;
X=0 внутри функции можно реализовать (хотя для этого придется ввести
с клавиатуры значительно больше символов!) так: import sys; glob=sys.mod
ules[__name__]; glob.X=0. Не забывайте, что каждый модуль имеет атрибут
__name__; внутри функции, принадлежащей модулю, он выглядит как гло
бальное имя. Этот прием обеспечивает еще один способ изменения одно
именных локальных и глобальных переменных внутри функции.
546 Глава 21. Дополнительные возможности модулей
for attr in module.__dict__.keys(): # Сканировать пространство имен
print "%02d) %s" % (count, attr),
if attr[0:2] == "__":
print "<builtin name>" # Пропустить __file__ и др.
else:
print getattr(module, attr) # То же, что и .__dict__[attr]
count = count+1
if verbose:
print ""*30
print module.__name__, "has %d names" % count
print ""*30
if __name__ == "__main__":
import mydir
listing(mydir) # Код самопроверки: вывести свое
# пространство имен
В модуле, в самом конце, реализована логика самопроверки, которая за
ставляет модуль импортировать самого себя и вывести содержимое сво
его пространства имен. Ниже показан результат работы этого модуля:
C:\python> python mydir.py

name: mydir file: mydir.py

00) __file__ <builtin name>
01) __name__ <builtin name>
02) listing <function listing at 885450>
03) __doc__ <builtin name>
04) __builtins__ <builtin name>
05) verbose 1

mydir has 6 names

С функцией getattr и родственными ей мы встретимся еще раз позд
нее. Самое важное здесь, что mydir – это программа, которая позволяет
исследовать другие программы. Так как интерпретатор не скрывает
внутреннее устройство модулей, вы можете реализовать обработку лю
бых объектов единообразно.1
1 Инструменты, такие как mydir.listing, могут быть предварительно загру
жены в пространство имен интерактивной оболочки импортированием их
в файле, указанном в переменной окружения PYTHONSTARTUP. Так как про
граммный код этого файла выполняется в интерактивном пространстве
имен (модуль __main__), такой способ импортирования часто используемых
инструментов позволит вам сэкономить время на вводе инструкций вруч
ную. Дополнительная информация приводится в приложении A.
Типичные проблемы при работе с модулями 547
Типичные проблемы при работе с модулями
В этом разделе мы рассмотрим обычный набор пограничных ситуа
ций, которые делают жизнь интересной для тех, кто только начинает
осваивать язык Python. Некоторые из них настолько неочевидны, что
трудно привести к ним примеры, но в большинстве своем они иллюст
рируют важные сведения о языке.
Порядок следования инструкций
на верхнем уровне имеет значение
Когда модуль впервые импортируется (или загружается повторно),
интерпретатор выполняет инструкции в нем одну за другой, сверху
вниз. Из этого следует несколько замечаний, которые касаются опере
жающих ссылок на переменные, которые следует подчеркнуть особо:
• Инструкции программного кода на верхнем уровне в файле модуля
(не вложенные в функцию) выполняются, как только интерпретатор
достигает их в процессе импортирования. По этой причине он не мо
жет ссылаться на имена, присваивание которым производится ниже.
• Программный код внутри функций не выполняется, пока функция
не будет вызвана, – разрешение имен внутри функций не произво
дится до момента их вызова, поэтому они обычно могут ссылаться
на имена, расположенные в любой части файла.
Вообще опережающие ссылки доставляют беспокойство только в про
граммном коде верхнего уровня, который выполняется немедленно;
функции могут ссылаться на любые имена. Ниже приводится пример,
демонстрирующий опережающие ссылки:
func1() # Ошибка: имя "func1" еще не существует
def func1():
print func2() # OK: поиск имени "func2" будет выполнен позднее
func1() # Ошибка: имя "func2" еще не существует
def func2():
return "Hello"
func1() # OK: "func1" и "func2" определены
Когда этот файл будет импортироваться (или запускаться как само
стоятельная программа), интерпретатор Python будет выполнять его
инструкции сверху вниз. Первый вызов func1 потерпит неудачу, пото
му что инструкция def для имени func1 еще не была выполнена. Вызов
func2 внутри func1 будет работать без ошибок при условии, что к мо
менту вызова func1 инструкция def func2 уже будет выполнена (этого
еще не произошло к моменту второго вызова func1 на верхнем уровне).
Последний вызов func1 в конце файла будет выполнен успешно, пото
му что оба имени, func1 и func2, уже определены.
548 Глава 21. Дополнительные возможности модулей
Смешивание инструкций def с программным кодом верхнего уровня не
только осложняет его чтение, но еще и ставит его работоспособность
в зависимость от порядка следования инструкций. Если вам необходи
мо объединять в модуле программный код, выполняемый непосредст
венно, с инструкциями def, возьмите за правило помещать инструкции
def в начало файла, а программный код верхнего уровня – в конец фай
ла. При таком подходе ваши функции гарантированно будут определе
ны к моменту выполнения программного кода, который их использует.
Импортирование модулей по имени в виде строки
Имя модуля в инструкции import или from является именем перемен
ной. Тем не менее иногда ваша программа будет получать имя модуля,
который следует импортировать, в виде строки во время выполнения
(например, в случае, когда пользователь выбирает имя модуля внутри
графического интерфейса). К сожалению, невозможно напрямую ис
пользовать инструкции импорта для загрузки модуля, имя которого
задано в виде строки, – в этих инструкциях интерпретатор ожидает
получить имя переменной, а не строку. Например:
>>> import "string"
File "<stdin>", line 1
import "string"
^
SyntaxError: invalid syntax
Точно так же невозможно импортировать модуль, если просто присво
ить строку переменной:
x = "string"
import x
Чтобы решить эту проблему, необходим специальный инструмент, вы
полняющий динамически загрузку модулей, имена которых создают
ся в виде строк во время выполнения. Обычно для этого конструирует
ся строка программного кода, содержащая инструкцию import, кото
рая затем передается инструкции exec для исполнения:
>>> modname = "string"
>>> exec "import " + modname # Выполняется как строка программного кода
>>> string # Модуль был импортирован в пространство имен
<module 'string'>
Инструкция exec (и родственная ей функция eval, используемая для
вычисления значений выражений) скомпилирует строку в код и пере
даст его интерпретатору для исполнения. В языке Python компилятор
байткода доступен непосредственно во время выполнения, поэтому
можно писать программы, которые конструируют и выполняют другие
программы, как в этом случае. По умолчанию инструкция exec выпол
няет программный код в текущей области видимости, но существует
возможность передавать ей необязательные словари пространств имен.
Типичные проблемы при работе с модулями 549
Единственный настоящий недостаток инструкции exec состоит в том,
что она должна компилировать инструкцию import всякий раз, когда
она запускается, – если импортировать приходится достаточно часто,
программный код может работать немного быстрее при использовании
встроенной функции __import__, которая выполняет загрузку модуля,
получая его имя в виде строки. Результат получается тот же самый, но
функция __import__ возвращает объект модуля, поэтому его надо при
своить переменной, чтобы сохранить:
>>> modname = "string"
>>> string = __import__(modname)
>>> string
<module 'string'>
Инструкция from создает копии, а не ссылки
Несмотря на то что инструкция from широко применяется, она часто
становится источником самых разных проблем. При выполнении при
сваивания именам в области видимости импортирующего модуля она
не создает синонимы, а копирует имена. Результат будет тем же самым,
что и для любых других инструкций присваивания в языке Python, но
есть одно тонкое отличие, особенно когда программный код, исполь
зующий объекты совместно, находится в разных файлах. Например,
предположим, что у нас имеется следующий модуль (nested1.py):
X = 99
def printer(): print X
Если импортировать эти два имени с помощью инструкции from в дру
гом модуле (nested2.py), будут получены копии этих имен, а не ссылки
на них. Изменение имени в импортирующем модуле приведет к изме
нениям только локальной версии этого имени, а имя в модуле
nested1.py будет иметь прежнее значение:
from nested1 import X, printer # Копировать имена
X = 88 # Изменит только локальную версию "X"!
printer() # X в nested1 попрежнему будет равно 99
% python nested2.py
99
Однако, если выполнить импорт всего модуля с помощью инструкции
import и затем изменить значение с использованием полного имени,
это приведет к изменению имени в файле nested1.py. Полное имя на
правляет интерпретатор к имени в указанном объекте модуля, а не
к имени в импортирующем модуле (nested3.py):
import nested1 # Импортировать модуль целиком
nested1.X = 88 # OK: изменяется имя X в nested1
nested1.printer()
% python nested3.py
88
550 Глава 21. Дополнительные возможности модулей
Инструкция from * может затушевывать
смысл переменных
Я упоминал об этом в главе 19, но оставил подробности до этого момен
та. Поскольку в инструкции from module import * не указываются необ
ходимые имена переменных, она может непреднамеренно перезаписать
имена, уже используемые в области видимости импортирующего моду
ля. Хуже того, это может осложнить поиск модуля, откуда исходит пе
ременная, вызвавшая проблемы. Это особенно верно, когда форма инст
рукции from * используется более чем в одном импортированном файле.
Например, если инструкция from * применяется к трем модулям, то
у вас не будет иного способа узнать, какая в действительности вызыва
ется функция, кроме как выполнить поиск в трех разных файлах мо
дулей (каждый из которых может находиться в отдельном каталоге):
>>> from module1 import * # Плохо: может незаметно перезаписать мои имена
>>> from module2 import * # Еще хуже: нет никакого способа понять,
>>> from module3 import * # что мы получили!
>>> . . .
>>> func() # Ну???
Решение опять же заключается в том, чтобы так не делать: старайтесь
явно перечислять требуемые атрибуты в инструкции from и ограничи
вайте применение формы from * одним модулем на файл. В этом случае
любые неопределенные имена, согласно дедуктивному методу, долж
ны находиться в модуле, который импортируется единственной инст
рукцией from *. Этой проблемы вообще можно избежать, если всегда
использовать инструкцию import вместо from, но это слишком сложно –
как и многое другое в программировании, инструкция from – очень
удобный инструмент при разумном использовании.
Функция reload может не оказывать влияния,
если импорт осуществлялся инструкцией from
Это еще одна ловушка, связанная с инструкцией from: как уже говори
лось ранее, инструкция from копирует (присваивает) имена при выпол
нении, поэтому нет никакой обратной связи с модулем, откуда были
скопированы имена. Имена, скопированные инструкцией from, просто
становятся ссылками на объекты, на которые ссылались по тем же име
нам в импортируемом модуле, когда была выполнена инструкция from.
Вследствие этого повторная загрузка импортируемого модуля может
не оказывать воздействия на клиентов, которые импортировали его
имена с помощью инструкции from. То есть имена в модуляхклиентах
будут попрежнему ссылаться на оригинальные объекты, полученные
инструкцией from, даже если имена в оригинальном модуле будут пе
реопределены:
from module import X # X может не измениться в результате перезагрузки!
. . .
Типичные проблемы при работе с модулями 551
reload(module) # Изменится модуль, но не мои имена
X # Попрежнему ссылается на старый объект
Чтобы сделать повторную загрузку более эффективной, используйте
инструкцию import и полные имена переменных вместо инструкции
from. Поскольку полные имена всегда ведут обратно в импортирован
ный модуль, после повторной загрузки они автоматически будут свя
заны с новыми именами в модуле.
import module # Получить объект модуля, а не имена
. . .
reload(module) # Изменит непосредственно сам объект модуля
module.X # Текущее значение X: отражает результат перезагрузки
reload, from и тестирование в интерактивной оболочке
В главе 3 уже говорилось, что изза возникающих сложностей лучше не
использовать операции импорта и повторной загрузки для запуска про
грамм. Дело еще больше осложняется, когда в игру вступает инструк
ция from. Начинающие осваивать язык Python часто сталкиваются
с проблемой, описываемой здесь. Представим, что после открытия мо
дуля в окне редактирования текста вы запускаете интерактивный сеанс,
чтобы загрузить и протестировать модуль с помощью инструкции from:
from module import function
function(1, 2, 3)
Отыскав ошибку, вы возвращаетесь в окно редактирования, исправ
ляете ее и пытаетесь повторно загрузить модуль следующим способом:
reload(module)
Но вы не получите ожидаемого эффекта – инструкция from создала имя
function, но не создала имя module. Чтобы сослаться на модуль в функ
ции reload, его сначала необходимо импортировать инструкцией import:
import module
reload(module)
function(1, 2, 3)
Однако и в этом случае вы не получите ожидаемого эффекта – функ
ция reload обновит объект модуля, но, как говорилось в предыдущем
разделе, имена, такие как function, скопированные из модуля ранее,
попрежнему продолжают ссылаться на старые объекты (в данном слу
чае – на первоначальную версию функции). Чтобы действительно по
лучить доступ к новой версии функции, после перезагрузки модуля ее
необходимо вызывать как module.function или повторно запустить ин
струкцию from:
import module
reload(module)
from module import function
function(1, 2, 3)
552 Глава 21. Дополнительные возможности модулей
Теперь наконецто нам удалось запустить новую версию функции.
Как видите, прием, основанный на использовании функции reload в па
ре с инструкцией from, имеет врожденные проблемы: вы не только
должны не забывать перезагружать модуль после импорта, но и не за
бывать повторно запускать инструкции from после перезагрузки моду
ля. Это достаточно сложно, чтобы время от времени сбивать с толку да
же опытного программиста.
Вы не должны ожидать, что функция reload и инструкция from будут
безукоризненно работать в паре. Лучше всего вообще не объединять их –
используйте функцию reload в паре с инструкцией import или запус
кайте свои программы другими способами, как предлагалось в главе 3
(например, выбирая пункт Run→Run Module (Запустить→Запустить модуль)
в меню среды разработки IDLE щелчком мыши на ярлыке файла или
из командной строки системы).
Функция reload не обладает транзитивностью
Когда выполняется повторная загрузка модуля, интерпретатор переза
гружает только данный конкретный файл модуля – он не выполняет
повторную загрузку модулей, которые были импортированы перезагру
жаемым модулем. Например, если выполняется перезагрузка некото
рого модуля A, и A импортирует модули B и C, перезагружен будет только
модуль A, но не B и C. Инструкции внутри модуля A, которые импортиру
ют модули B и C, будут перезапущены в процессе перезагрузки, но они
просто вернут объекты уже загруженных модулей B и C (предполагает
ся, что к этому моменту они уже были импортированы). Чтобы было бо
лее понятно, ниже приводится пример содержимого файла A.py:
import B # Эти модули не будут перезагружены вместе с A
import C # Просто будут импортированы уже загруженные модули
% python
>>> . . .
>>> reload(A)
Не следует полагаться на транзитивную перезагрузку модулей – лучше
несколько раз вызывайте функцию reload для непосредственного об
новления субкомпонентов. При желании можно предусмотреть в про
грамме автоматическую перезагрузку ее компонентов, добавив вызо
вы reload в родительские модули, каким здесь является A.
Еще лучше было бы написать универсальный инструмент для автома
тического выполнения рекурсивной перезагрузки модулей, сканируя
содержимое атрибутов __dict__ модулей (смотрите раздел «Модули –
это объекты: метапрограммы», выше в этой главе) и проверяя атрибут
type в каждом элементе (глава 9), чтобы отыскать вложенные модули.
Такие вспомогательные функции могут рекурсивно вызывать сами се
бя и обходить произвольные цепочки импортирования.
Типичные проблемы при работе с модулями 553
Например, модуль reloadall.py, в листинге ниже, содержит функцию
reload_all, автоматически выполняющую перезагрузку модуля, каж
дого импортируемого им модуля, и т. д., до самого конца каждой це
почки импортирования. Она использует словарь, с помощью которого
отыскивает уже загруженные модули, рекурсию – для обхода цепочек
импорта и модуль types из стандартной библиотеки (был представлен
в конце главы 9), в котором просто предопределены значения атрибута
type для всех встроенных типов.
Чтобы воспользоваться этой утилитой, импортируйте функцию relo
ad_all и передайте ей имя уже загруженного модуля (как если бы это
была встроенная функция reload). Когда файл запускается как само
стоятельная программа, его код самопроверки выполнит проверку са
мого модуля – он должен импортировать самого себя, потому что его
собственное имя не будет определено в файле без инструкции импорти
рования. Я рекомендую поэкспериментировать с этим примером само
стоятельно:
import types
def status(module):
print 'reloading', module.__name__
def transitive_reload(module, visited):
if not visited.has_key(module): # Пропустить повторные посещения
status(module) # Перезагрузить модуль
reload(module) # И посетить дочерние модули
visited[module] = None
for attrobj in module.__dict__.values(): # Для всех атрибутов
if type(attrobj) == types.ModuleType: # Рекурсия, если модуль
transitive_reload(attrobj, visited)
def reload_all(*args):
visited = { }
for arg in args:
if type(arg) == types.ModuleType:
transitive_reload(arg, visited)
if __name__ == '__main__':
import reloadall # Тест: перезагрузить самого себя
reload_all(reloadall) # Должна перезагрузить этот модуль
# и модуль types
Рекурсивный импорт с инструкцией from
может не работать
Напоследок я оставил самую странную (и, к счастью, малоизвестную)
проблему. В ходе импортирования инструкции в файле выполняются
от начала и до конца, поэтому необходимо быть внимательнее, когда ис
пользуются модули, импортирующие друг друга (эта ситуация называ
ется рекурсивным импортом). Поскольку не все инструкции в модуле
могут быть выполнены к моменту запуска процедуры импортирования
554 Глава 21. Дополнительные возможности модулей
другого модуля, некоторые из его имен могут оказаться еще не опреде
ленными.
Если вы используете инструкцию import, чтобы получить модуль цели
ком, это может иметь, а может не иметь большого значения – имена мо
дуля не будут доступны, пока позже не будут использованы полные
имена для получения их значений. Но если для получения определен
ных имен используется инструкция from, имейте в виду, у вас будет дос
туп только к тем именам, которые уже были определены в этом модуле.
Например, рассмотрим следующие модули, recur1 и recur2. Модуль
recur1 создает имя X и затем импортирует recur2 до того, как присвоит
значение имени Y. В этом месте модуль recur2 может импортировать мо
дуль recur1 целиком с помощью инструкции import (он уже существует
во внутренней таблице модулей интерпретатора), но если используется
инструкция from, ей будет доступно только имя X, а имя Y, которому бу
дет присвоено значение только после инструкции import в recur1, еще не
существует, поэтому возникнет ошибка:
# Файл: recur1.py
X = 1
import recur2 # Запустить recur2, если он еще не был импортирован
Y = 2
# Файл: recur2.py
from recur1 import X # OK: "X" уже имеет значение
from recur1 import Y # Ошибка: "Y" еще не существует
>>> import recur1
Traceback (innermost last):
File "<stdin>", line 1, in ?
File "recur1.py", line 2, in ?
import recur2
File "recur2.py", line 2, in ?
from recur1 import Y # Ошибка: "Y" еще не существует
ImportError: cannot import name Y
При рекурсивном импорте модуля recur1 и модуля recur2 интерпрета
тор не будет повторно выполнять инструкции модуля recur1 (в против
ном случае это могло бы привести к бесконечному циклу), но про
странство имен модуля recur1 еще не заполнено до конца к моменту,
когда он импортируется модулем recur2.
Решение? Не используйте инструкцию from в операции рекурсивного
импорта (в самом деле!). Интерпретатор не зациклится, если вы всета
ки сделаете это, но ваша программа попадет в зависимость от порядка
следования инструкций в модулях.
Существует два способа решения этой проблемы:
• Обычно можно ликвидировать рекурсивный импорт, подобный
приведенному, правильно проектируя модули: увеличить согласо
ванность внутри модуля и уменьшить взаимозависимость между
модулями – это самое первое, что стоит попробовать сделать.
В заключение 555
• Если от циклов не удается избавиться полностью, попробуйте от
срочить обращение к именам модуля, используя инструкции import
и полные имена (вместо инструкции from), или поместите инструк
ции from либо внутрь функций (чтобы они не вызывались в про
граммном коде верхнего уровня), либо ближе к концу файла, чтобы
отложить их выполнение.
В заключение
В этой главе был рассмотрен ряд дополнительных концепций, связан
ных с модулями. Мы изучили приемы сокрытия данных, включение но
вых особенностей языка из модуля __future__, возможности использова
ния переменной __name__, синтаксис относительного импортирования
в пакетах и многое другое. Мы также исследовали проблемы проектиро
вания модулей и познакомились с типичными ошибками при работе
с модулями, что позволит вам избежать их в своем программном коде.
Со следующей главы мы приступим к изучению объектноориентиро
ванного инструмента языка Python – класса. Большая часть сведений,
рассмотренных в последних нескольких главах, применима и здесь –
классы располагаются в модулях и также являются пространствами
имен, но они добавляют еще один элемент в поиск атрибутов, который
называется «поиск в цепочке наследования». Поскольку это послед
няя глава в этой части книги, прежде чем углубиться в объектноори
ентированное программирование, обязательно выполните упражне
ния к этой части книги. Но перед этим попробуйте ответить на кон
трольные вопросы главы, чтобы освежить в памяти темы, рассматри
вавшиеся здесь.
Закрепление пройденного
Контрольные вопросы
1. Что важно знать о переменных в программном коде верхнего уров
ня модуля, имена которых начинаются с одного символа подчерки
вания?
2. Что означает, когда переменная __name__ модуля имеет значение "
__main__"?
3. В чем разница между инструкциями from mypkg import spam и from .
import spam?
4. Если пользователь вводит имя модуля в ответ на запрос програм
мы, как импортировать этот модуль?
5. Чем отличается изменение списка sys.path от изменения значения
переменной окружения PYTHONPATH?
6. Импорт будущих изменений в языке возможен с помощью модуля
__future__, а возможен ли импорт из прошлого?
556 Глава 21. Дополнительные возможности модулей
Ответы
1. Переменные в программном коде верхнего уровня модуля, чьи име
на начинаются с одного символа подчеркивания, не копируются
при импортировании с помощью инструкции from *. Однако они
доступны при использовании инструкции import и обычной формы
инструкции from.
2. Если переменная __name__ модуля содержит строку "__main__", это
означает, что файл выполняется как самостоятельный сценарий,
а не был импортирован в качестве модуля другим файлом в програм
ме. То есть файл используется как программа, а не как библиотека.
3. Инструкция from mypkg import spam выполняет импортирование в аб
солютном режиме, используя путь поиска в sys.path. Инструкция
from . import spam, напротив, выполняет импорт в относительном
режиме – поиск модуля spam осуществляется сначала в пакете, где
находится инструкция, и только потом в sys.path.
4. Как правило, ввод пользователя поступает в сценарий в виде стро
ки – чтобы импортировать модуль по имени, заданному в виде стро
ки, можно собрать и выполнить инструкцию import с помощью ин
струкции exec или передать строку с именем функции __import__.
5. Изменения в sys.path воздействуют только на работающую про
грамму и носят временный характер – изменения будут утеряны
сразу же после завершения программы. Содержимое переменной
окружения PYTHONPATH хранится в операционной системе – оно ока
зывает воздействие на все программы, выполняемые на этом ком
пьютере, а изменения сохраняются после завершения программ.
6. Нет, мы не можем импортировать из прошлого. Мы можем устано
вить (или упорно использовать) более старую версию языка, но, как
правило, самая лучшая версия – это последняя версия Python.1
Упражнения к пятой части
Решения приводятся в разделе «Часть V, Модули» приложения A.
1. Основы импортирования. Напишите программу, которая подсчи
тывает количество строк и символов в файле (в духе утилиты wc
в операционной системы UNIX). В своем текстовом редакторе соз
дайте модуль с именем mymod.py, который экспортирует три имени:
• Функцию countLines(name), которая читает входной файл и под
считывает число строк в нем (подсказка: большую часть работы
можно выполнить с помощью метода file.readlines, а оставшую
ся часть – с помощью функции len).
1 Последняя стабильная версия. – Примеч. науч. ред.
Закрепление пройденного 557
• Функцию countChars(name), которая читает входной файл и под
считывает число символов в нем (подсказка: метод file.read воз
вращает единую строку).
• Функцию test(name), которая вызывает две предыдущие функ
ции с заданным именем файла. Вообще говоря, имя файла мож
но жестко определить в программном коде, принимать ввод име
ни от пользователя или принимать его как параметр командной
строки через список sys.argv,– но пока исходите из предположе
ния, что оно передается как аргумент функции.
Все три функции в модуле mymod должны принимать имя файла в ви
де строки. Если размер любой из функций превысит дветри стро
ки, это значит, что вы делаете лишнюю работу, – используйте под
сказки, которые я вам дал!
Затем проверьте свой модуль в интерактивной оболочке, используя
инструкцию import и полные имена экспортируемых функций. Сле
дует ли добавить в переменную PYTHONPATH каталог, где находится
ваш файл mymod.py? Попробуйте проверить модуль на самом себе:
например, test("mymod.py"). Обратите внимание, что функция test
открывает файл дважды – если вы достаточно честолюбивы, попро
буйте оптимизировать программный код, передавая двум функци
ям счета объект открытого файла (подсказка: метод file.seek(0) вы
полняет переустановку указателя в начало файла).
2. from/from *. Проверьте модуль mymod из упражнения 1 в интерактив
ной оболочке, используя для загрузки экспортируемых имен инст
рукцию from – сначала по имени, а потом с помощью формы from *.
3. __main__. Добавьте в модуль mymod строку, в которой автоматиче
ски производился бы вызов функции test, только когда модуль вы
полняется как самостоятельный сценарий, а не во время импорти
рования. Добавляемая вами строка, вероятно, должна содержать
проверку значения атрибута __name__ на равенство строке "__main__",
как было показано в этой главе. Попробуйте запустить модуль из
системной командной строки, затем импортируйте модуль и про
верьте работу функций в интерактивном режиме. Будут ли рабо
тать функции в обоих режимах?
4. Вложенное импортирование. Напишите второй модуль myclient.py,
который импортирует модуль mymod и проверяет работу его функций,
затем запустите myclient из системной командной строки. Будут ли
доступны функции из mymod на верхнем уровне myclient, если импор
тировать их с помощью инструкции from? А если они будут импорти
рованы с помощью инструкции import? Попробуйте реализовать оба
варианта в myclient и проверить в интерактивном режиме, импорти
руя модуль myclient и проверяя содержимое его атрибута __dict__.
5. Импорт пакетов. Импортируйте ваш файл из пакета. Создайте ка
талог с именем mypkg, вложенный в каталог, находящийся в пути
поиска модулей. Переместите в него файл mymod.py, созданный
558 Глава 21. Дополнительные возможности модулей
в упражнении 1 или 3, и попробуйте импортировать его как пакет,
инструкцией import mypkg.mymod.
Вам потребуется добавить файл __init__.py в каталог, куда был по
мещен ваш модуль. Это упражнение должно работать на всех основ
ных платформах Python (это одна из причин, почему в языке Py
thon в качестве разделителя компонентов пути используется сим
вол «.»). Каталог пакета может быть простым подкаталогом в ва
шем рабочем каталоге – в этом случае он будет обнаружен
интерпретатором при поиске в домашнем каталоге и вам не потре
буется настраивать путь поиска. Добавьте какойнибудь программ
ный код в __init__.py и посмотрите, будет ли он выполняться при
каждой операции импортирования.
6. Повторная загрузка. Поэкспериментируйте с возможностью по
вторной загрузки модуля: выполните тесты, которые приводятся
в примере changer.py в главе 19, многократно изменяя текст сообще
ния и/или поведение модуля, без остановки интерактивного сеанса
работы с интерпретатором Python. В зависимости от операционной
системы файл модуля можно было бы редактировать в другом окне
или, приостановив интерпретатор, редактировать модуль в том же
окне (в UNIX комбинация клавиш CtrlZ обычно приводит к приос
тановке текущего процесса, а команда fg – возобновляет его работу).
7. Циклический импорт.1 В разделе, где описываются проблемы, свя
занные с рекурсивным импортом, импортирование модуля recur1
вызывает появление ошибки. Но если перезапустить интерактив
ный сеанс работы с интерпретатором и предварительно импортиро
вать модуль recur2, ошибка не возникает – проверьте этот факт са
ми. Как вы думаете, почему импортирование recur2 проходит без
ошибок, а импортирование recur1 с ошибками? (Подсказка: интер
претатор Python сохраняет новые модули во встроенной таблице
(словаре) sys.modules перед их запуском, независимо от того, «завер
шен» модуль или нет.) Теперь попробуйте запустить recur1 как са
мостоятельный сценарий: python recur1.py. Получите ли вы ту же
самую ошибку, которая возникает при импортировании recur1 в ин
терактивной оболочке? Почему? (Подсказка: когда модули запус
каются как самостоятельные программы, они не импортируются,
поэтому здесь возникает тот же эффект, как и при импортировании
recur2 в интерактивной оболочке, – recur2 является первым импор
тируемым модулем.) Что произойдет, если запустить recur2 как са
мостоятельный сценарий? Почему?
1 Обратите внимание, что циклическое импортирование чрезвычайно редко
встречается на практике. Автор этой книги за десять лет работы с языком
Python на практике сам не использовал и не сталкивался с циклическим
импортом. Однако если вы в состоянии понять, в чем заключается пробле
ма при использовании циклического импорта, это будет означать, что вы
достаточно много знаете о семантике языка Python.
VI
Классы и ООП

22
ООП: общая картина
До сих пор в этой книге мы использовали термин «объект» в общем
смысле. В действительности весь программный код, написанный нами
до сих пор, был основан на объектах (object+based) – везде в своих сце
нариях мы передавали объекты, использовали их в выражениях, вы
зывали их методы и т. д. Однако, чтобы наш программный код стал
понастоящему объектноориентированным (object+oriented, ОО), на
ши объекты должны участвовать в иерархии наследования.
Начиная с этой главы, мы приступаем к исследованию классов в язы
ке Python – программных компонентов, используемых для реализа
ции новых типов объектов, поддерживающих наследование. Классы –
это основные инструменты объектноориентированного программиро
вания (ООП) в языке Python, поэтому в этой части книги мы попутно
рассмотрим основы ООП. ООП предлагает другой, часто более эффек
тивный подход к программированию, при котором мы разлагаем про
граммный код на составляющие, чтобы снизить его избыточность,
и пишем новые программы, адаптируя имеющийся программный код,
а не изменяя существующий или создавая новый код.
Классы в языке Python создаются с помощью новой для нас инструк
ции: инструкции class. Как вы увидите, объекты, определяемые с по
мощью классов, очень напоминают встроенные типы, которые мы изу
чали ранее в этой книге. В действительности классы лишь применяют
и дополняют понятия, которые мы уже рассмотрели. Грубо говоря –
они представляют собой пакеты функций, которые в основном исполь
зуют и обрабатывают объекты встроенных типов. Основное назначе
ние классов состоит в том, чтобы создавать и манипулировать новыми
объектами, а кроме того, они поддерживают механизм наследования –
совсем иной способ адаптации программного кода и повторного его ис
пользования, чем мы рассматривали ранее.
562 Глава 22. ООП: общая картина
Одно предварительное замечание: ООП в языке Python является не
обязательным к применению, и на первых порах вам не обязательно
использовать классы. Многие задачи можно реализовать с помощью
более простых конструкций, таких как функции, или даже просто
программируя на верхнем уровне в сценарии. Поскольку использова
ние классов требует некоторого предварительного планирования, они
представляют больший интерес для тех, кто работает в стратегиче+
ском режиме (участвует в долгосрочной разработке программных про
дуктов), чем для тех, кто работает в тактическом режиме (где на раз
работку дается очень короткое время).
Однако, как вы увидите в этой части книги, классы являются одним
из самых мощных инструментов в языке Python. При грамотном ис
пользовании классы способны радикально сократить время, затрачи
ваемое на разработку. Они также присутствуют в таких популярных
инструментах, как Tkinter GUI API, поэтому для большинства про
граммистов, использующих язык Python, знание основ работы с клас
сами будет как минимум полезно.
Зачем нужны классы?
Помните, как я говорил вам, что «программы выполняют некоторые
действия над чемто»? Проще говоря, классы – это всего лишь способ
определить новое «чтото», они являются отражением реальных объ
ектов в мире программ. Например, предположим, что мы решили реа
лизовать гипотетическую машину по изготовлению пиццы, которую
мы использовали в качестве примера в главе 15. Если реализовать ее
на основе классов, мы могли бы смоделировать более близкое к реаль
ности строение машины и взаимосвязь между ее механизмами. Полез
ными здесь оказываются два аспекта ООП:
Наследование
Машина по изготовлению пиццы – это разновидность машин, по
этому она обладает обычными свойствами, характерными для ма
шин. В терминах ООП это называется «наследованием» свойств бо
лее общей категории машин. Эти общие свойства необходимо реа
лизовать всего один раз, после чего мы сможем использовать их для
моделирования любых типов машин, которые нам потребуется соз
дать в будущем.
Композиция
Машины по изготовлению пиццы состоят из множества компонен
тов, которые все вместе работают как единое целое. Например, на
шей машине необходимы манипуляторы, чтобы раскатывать тесто,
двигатели, чтобы перемещаться к духовке, и т. д. На языке ООП на
ша машина – это пример композиции; она содержит другие объек
ты, которые активизируются для выполнения определенных дейст
Зачем нужны классы? 563
вий. Каждый компонент может быть оформлен как класс, который
определяет свое поведение и принципы взаимодействия.
Общие идеи ООП, такие как наследование и композиция, применимы
к любым приложениям, которые могут быть разложены на ряд объек
тов. Например, в типичных программах с графическим интерфейсом
сам интерфейс создается как набор визуальных элементов управления –
кнопок, меток и т. д., которые рисуются на экране в тот момент, когда
выполняется рисование их контейнеров (композиция). Кроме того, мы
можем создать свои собственные визуальные элементы – кнопки
с уникальными шрифтами, метки с новыми цветовыми схемами, ко
торые будут представлять собой специализированные версии более об
щих интерфейсных элементов (наследование).
Если говорить более точно, с точки зрения программирования классы –
это программные компоненты на языке Python, точно такие же, как
функции и модули: они представляют собой еще один способ упаковки
выполняемого кода и данных. Кроме того, классы определяют свои
пространства имен, так же как и модули. Но в отличие от других про
граммных компонентов, которые мы уже видели, классы имеют три
важных отличия, которые делают их более полезными, когда дело до
ходит до создания новых объектов:
Множество экземпляров
Классы по своей сути являются фабриками по созданию объектов.
Каждый раз, когда вызывается класс, создается новый объект со
своим собственным пространством имен. Каждый объект, создан
ный из класса, имеет доступ к атрибутам класса и получает в свое
распоряжение собственное пространство имен для своих собствен
ных данных, отличных от данных других объектов.
Адаптация через наследование
Классы также поддерживают такое понятие ООП, как наследова
ние, – мы можем расширять возможности класса, переопределяя
его атрибуты за пределами самого класса. В более общем смысле
классы могут создавать иерархии пространств имен, которые опре
деляют имена для использования объектами, созданными из клас
сов в иерархии.
Перегрузка операторов
Обеспечивая специальный протокол оформления методов, классы
могут определять объекты, над которыми можно производить ка
кието из операций, которые мы знаем по работе со встроенными
типами. Например, объекты, созданные из классов, могут подвер
гаться операции извлечения среза, конкатенации, извлечения эле
ментов по их индексам и т. д. Язык Python предоставляет специ
альные обработчики, которые могут использоваться классами для
перехвата и реализации любой встроенной операции.
564 Глава 22. ООП: общая картина
ООП с высоты 30 000 футов
Прежде чем мы увидим, что все это означает в терминах программного
кода, я хотел бы сказать несколько слов об общих идеях, лежащих в ос
нове ООП. Если раньше вам не приходилось делать чтонибудь в объект
ноориентированном стиле, некоторые термины в этой главе при первом
знакомстве могут вам показаться немного сложными. Кроме того,
смысл этих терминов может ускользать от вас, пока вы не получите воз
можность познакомиться с тем, как программисты применяют их
в крупных программах. ООП – это не только технология, но еще и опыт.
Поиск унаследованных атрибутов
Самое интересное, что ООП в языке Python проще в изучении и ис
пользовании, чем в других языках программирования, таких как C++
и Java. Будучи языком сценариев с динамической типизацией, Python
ликвидирует синтаксическую перегруженность и сложность, свойст
венные ООП в других языках. Фактически ООП в языке Python сво
дится к выражению:
object.attribute
Мы использовали это выражение на протяжении всей книги для орга
низации доступа к атрибутам модуля, вызова методов объектов и т. д.
Однако, когда подобное выражение применяется к объекту, получен
ному с помощью инструкции class, интерпретатор начинает поиск –
поиск в дереве связанных объектов, который заканчивается, как толь
ко будет встречено первое появление атрибута attribute. Когда в дело
вступают классы, это выражение на языке Python можно перевести
в следующее выражение на естественном языке:
Найти первое вхождение атрибута attribute, просмотрев объект,
а потом все классы выше него, снизу вверх и слева направо.
Другими словами, выборка атрибутов производится в результате про
стого поиска по дереву. Мы называем эту процедуру поиском в дереве
наследования, потому что объекты, расположенные в дереве ниже, на
следуют атрибуты, имеющиеся у объектов, расположенных в дереве
выше. Так как поиск происходит в направлении снизу вверх, объекты
в некотором смысле оказываются связаны в древовидную структуру,
представляющую собой объединение всех атрибутов, определяемых
всеми их родителями в дереве.
В языке Python все это понимается буквально: с помощью программно
го кода мы действительно создаем деревья связанных объектов, и ин
терпретатор действительно поднимается вверх по дереву, пытаясь во
время выполнения отыскать атрибуты всякий раз, когда мы использу
ем выражение object.attribute. Чтобы было более понятно, на рис. 22.1
приводится пример одного из таких деревьев.
ООП с высоты 30 000 футов 565
На этом рисунке изображено дерево из пяти объектов, помеченных
именами переменных. Каждый из этих объектов обладает набором ат
рибутов. Если говорить более точно, это дерево связывает вместе три
объекта классов (в овалах, C1, C2 и C3) и два объекта экземпляра (в пря
моугольниках, I1 и I2) в иерархию наследования. Обратите внимание,
что в модели объектов в языке Python классы и экземпляры порожда
ются от двух разных типов объектов:
Классы
Играют роль фабрик экземпляров. Их атрибуты – данные и функ
ции – обеспечивают поведение, то есть наследуются всеми экземп
лярами, созданными от них (например, функция, вычисляющая
зарплату служащего, исходя из часового тарифа).
Экземпляры
Представляют конкретные элементы программы. Их атрибуты хра
нят данные, которые могут отличаться в конкретных объектах (на
пример, номер социального страхования служащего).
В терминах деревьев поиска экземпляры наследуют атрибуты своих
классов, а классы наследуют атрибуты всех других классов, находя
щихся в дереве выше.
На рис. 22.1 можно продолжить категоризацию классов по относитель
ным положениям овалов в дереве. Классы, расположенные в дереве вы
ше (такие как C2 и C3), мы обычно называем суперклассами, а классы,
расположенные ниже (такие как C1), называются подклассами.1 Эти
1 В других книгах можно также встретить такие термины, как базовые клас+
сы и дочерние классы, которые используются для обозначения суперклас
сов и подклассов соответственно.
C1
C2 C3
I1 I2
.x
.z
.w
.z
.x
.y
.name .name
Рис. 22.1. Дерево классов с двумя экземплярами внизу (I1 и I2), классом выше
их (C1) и двумя суперклассами в самом верху (C2 и C3). Все эти объекты
являются пространствами имен (пакетами переменных), а наследование
означает просто поиск в дереве снизу вверх, цель которого – найти самое
нижнее вхождение атрибута с требуемым именем. Программный код
задает структуру таких деревьев
566 Глава 22. ООП: общая картина
термины обозначают относительное положение в дереве и исполняе
мые роли. Суперклассы реализуют поведение, общее для всех их под
классов, но изза того, что поиск производится снизу верх, подклассы
могут переопределять поведение, определяемое их суперклассами, пе
реопределяя имена суперклассов ниже в дереве.
Так как эти последние несколько слов отражают основную суть адапта
ции программного обеспечения в ООП, давайте подробнее рассмотрим
эту концепцию. Предположим, что мы создали дерево, приведенное на
рис. 22.1, и затем пишем:
I2.w
Этот программный код демонстрирует использование механизма на
следования. Так как это выражение вида object.attribute, оно приво
дит к запуску поиска в дереве с рис. 22.1 – интерпретатор приступает
к поиску атрибута w, начиная с I2, и движется вверх по дереву. В част
ности, он будет просматривать объекты в следующем порядке:
I2, C1, C2, C3
и остановится, как только будет найден первый атрибут с таким име
нем (или возбудит исключение, если атрибут w вообще не будет найден).
В этом случае поиск будет продолжаться, пока не будет достигнут объ
ект C3, поскольку атрибут w имеется только в этом объекте. Другими
словами, имя I2.w в терминах автоматического поиска ищется как C3.w.
В терминологии ООП это называется: I2 «наследует» атрибут w от C3.
В конечном итоге два экземпляра наследуют от своих классов четыре
атрибута: w, x, y и z. Другие атрибуты будут найдены в различных пу
тях в дереве. Например:
• Для I1.x и I2.x атрибут x будет найден в C1, где поиск остановится,
потому что C1 находится в дереве ниже, чем C2.
• Для I1.y и I2.y атрибут y будет найден в C1, где поиск остановится,
потому что это единственное место, где он появляется.
• Для I1.z и I2.z атрибут z будет найден в C2, потому что C2 находится
в дереве левее, чем C3.
• Для I2.name атрибут name будет найден в I2, в этом случае поиск по
дереву вообще осуществляться не будет.
Проследите эти пути поиска в дереве на рис. 22.1, чтобы понять, как
выполняется поиск по дереву наследования в языке Python.
Первый элемент в предыдущем списке является, пожалуй, самым
важным, потому что C1 переопределяет атрибут x ниже в дереве, тем
самым замещая версию атрибута, расположенную выше, в C2. Как вы
увидите через мгновение, такие переопределения составляют основу
адаптации программного обеспечения в ООП – переопределяя и заме
щая атрибут, C1 эффективно изменяет свое поведение, унаследованное
от своего суперкласса.
ООП с высоты 30 000 футов 567
Классы и экземпляры
Являясь отдельными типами объектов в модели языка Python, классы
и экземпляры, которые мы объединили в иерархические деревья, вы
полняют практически одну и ту же роль: каждый из этих типов слу
жит некоторым представлением пространства имен – пакета пере
менных и места, где определяются атрибуты. Если вследствие этого
классы и экземпляры покажутся вам похожими на модули, то можно
считать и так, но при этом объекты в деревьях классов содержат авто
матически определяемые ссылки на другие объекты пространств имен,
и классы соответствуют инструкциям, а не файлам.
Основное различие между классами и экземплярами состоит в том, что
классы представляют собой своего рода фабрики по производству экзем
пляров. Например, в реалистичном приложении у нас мог бы быть класс
Employee, которые определяет характеристики служащего, – из этого
класса мы можем создавать фактические экземпляры класса Employee.
Это еще одно различие между классами и модулями: у нас всегда име
ется всего один экземпляр заданного модуля в памяти (именно по этой
причине приходится перезагружать модуль, чтобы загрузить в память
новый программный код), но в случае с классами можно создать столь
ко экземпляров, сколько потребуется.
В оперативном отношении у классов обычно имеются функции, присое
диненные к ним (например, computeSalary), а у экземпляров – элементы
данных, используемые функциями класса (например, hoursWorked).
Фактически объектноориентированная модель не так сильно отлича
ется от классической модели обработки данных, основанной на про+
граммах и записях, – в ООП экземпляры подобны записям с «данны
ми», а классы – «программам», обрабатывающими эти записи. Однако
в ООП имеется также понятие иерархии наследования, которая обес
печивает более широкие возможности адаптации программного обес
печения, чем более ранние модели.
Вызовы методов классов
В предыдущем разделе мы видели, как атрибут I2.w в нашем примере
дерева классов транслируется в C2.w при выполнении поиска в дереве на
следования. Не менее важно понять, что точно так же наследуются и ме
тоды (то есть функции, присоединенные к классам в виде атрибутов).
Если ссылка I2.w – это вызов функции, тогда в действительности это
выражение означает: «вызвать функцию С3.w для обработки I2». То
есть интерпретатор Python автоматически отобразит вызов I2.w() на
вызов C3.w(), передав унаследованной функции экземпляр в виде пер
вого аргумента.
Фактически всякий раз, когда вызывается функция, присоединенная
к классу, подразумевается не класс целиком, а экземпляр класса. Этот
подразумеваемый экземпляр, или контекст, является одной из причин,
568 Глава 22. ООП: общая картина
почему данная модель называется объектноориентированной – всегда
существует объект, над которым выполняются действия. В более реа
листичном примере мы могли бы вызывать метод с именем giveRaise,
присоединенный как атрибут к классу Employee, – вызов этого метода
был бы бессмысленным без указания служащего, которому дается
надбавка к зарплате.
Как мы увидим позднее, Python передает методам подразумеваемый
экземпляр в виде специального первого аргумента, в соответствии с со
глашением именуемого self. Мы также узнаем, что методы могут вы
зываться как через экземпляры (например, bob.giveRaise()), так и че
рез классы (например, Employee.giveRaise(bob)), причем обе формы иг
рают одну и ту же роль в наших сценариях. Чтобы увидеть, как мето
ды принимают свои подразумеваемые экземпляры, нам необходимо
рассмотреть примеры программного кода.
Создание деревьев классов
Несмотря на всю отвлеченность наших разговоров, тем не менее за ку
лисами всех этих идей стоит реальный программный код. Мы создаем
деревья и объекты в них с помощью инструкций class и вызовов клас
сов, которые позднее мы рассмотрим более подробно. В двух словах:
• Каждая инструкция class создает новый объект класса.
• Каждый раз, когда вызывается класс, он создает новый объект эк
земпляра.
• Экземпляры автоматически связываются с классами, из которых
они были созданы.
• Классы связаны со своими суперклассами, перечисленными в круг
лых скобках в заголовке инструкции class, – порядок следования
в списке определяет порядок расположения в дереве.
Чтобы создать дерево, изображенное на рис. 22.1, например, мы могли
бы использовать следующий программный код (здесь я опустил реали
зацию классов):
class C2: ... # Создать объекты классов (овалы)
class C3: ...
class C1(C2, C3): ... # Связанные с суперклассами
I1 = C1() # Создать объекты экземпляров (прямоугольники),
I2 = C1() # связанные со своими классами
Здесь мы построили дерево объектов классов, выполнив три инструк
ции class, и два объекта экземпляров, вызвав класс C1 дважды, как ес
ли бы это была обычная функция. Экземпляры помнят класс, из кото
рого они были созданы, а класс C1 помнит о своих суперклассах.
С технической точки зрения в этом примере используется то, что на
зывается множественным наследованием, которое означает, что не
кий класс имеет более одного суперкласса над собой в дереве классов.
ООП с высоты 30 000 футов 569
В языке Python, если в инструкции class в круглых скобках перечис
лено более одного суперкласса (как в случае с классом C1 в данном при
мере), их порядок следования слева направо определяет порядок поис
ка атрибутов в суперклассах.
Изза особенностей поиска в дереве наследования имеет большое значе
ние, к какому из объектов присоединяется тот или иной атрибут, – тем
самым определяется его область видимости. Атрибуты, присоединяе
мые к экземплярам, принадлежат только этим конкретным экземпля
рам, но атрибуты, присоединяемые к классам, совместно используют
ся всеми подклассами и экземплярами. Позднее мы подробно изучим
программный код, выполняющий присоединение атрибутов к этим
объектам. Мы увидим, что:
• атрибуты обычно присоединяются к классам с помощью инструк
ций присваивания внутри инструкции class, а не во вложенных ин
струкциях def, определяющих функции.
• атрибуты обычно присоединяются к экземплярам с помощью при
сваивания значений специальному аргументу с именем self, пере
даваемому функциям внутри классов.
Например, классы определяют поведение своих экземпляров с помо
щью функций, создаваемых инструкциями def внутри инструкции
class. Поскольку такие вложенные инструкции def выполняют при
сваивание именам внутри класса, они присоединяются к объектам
классов в виде атрибутов и будут унаследованы всеми экземплярами
и подклассами:
class C1(C2, C3): # Создать и связать класс C1
def setname(self, who): # Присвоить: C1.setname
self.name = who # Self – либо I1, либо I2
I1 = C1() # Создать два экземпляра
I2 = C1()
I1.setname('bob') # Записать 'bob' в I1.name
I2.setname('mel') # Записать 'mel' в I2.name
print I1.name # Выведет 'bob'
Синтаксис инструкции def в этом контексте – совершенно обычный.
С функциональной точки зрения, когда инструкция def появляется
внутри инструкции class, как в этом примере, она обычно называется ме+
тодом и автоматически принимает специальный первый аргумент с име
нем self, который содержит ссылку на обрабатываемый экземпляр.1
Так как классы являются фабриками, способными производить мно
жество экземпляров, их методы обычно используют этот, получаемый
1 Если когданибудь вам приходилось использовать язык C++ или Java, вы
без труда поймете, что в языке Python имя self – это то же, что указатель
this, но в языке Python аргумент self всегда используется явно, чтобы сде
лать обращения к атрибутам более очевидными.
570 Глава 22. ООП: общая картина
автоматически, аргумент self для получения или изменения значений
атрибутов конкретного экземпляра, который обрабатывается мето
дом. В предыдущем фрагменте программного кода имя self использу
ется для сохранения имени служащего в конкретном экземпляре.
Подобно простым переменным, атрибуты классов и экземпляров не
объявляются заранее, а появляются, когда им впервые выполняется
присваивание значений. Когда метод присваивает значение атрибуту
с помощью имени self, он тем самым создает атрибут экземпляра, на
ходящегося в нижнем уровне дерева классов (то есть в одном из прямо
угольников), потому что имя self автоматически ссылается на обраба
тываемый экземпляр.
Фактически благодаря тому, что все объекты в дереве классов – это
всего лишь объекты пространств имен, мы можем получать или уста
навливать любой из их атрибутов, используя соответствующие имена.
Например, выражение C1.setname является таким же допустимым, как
и I1.setname, при условии, что имена C1 и I1 находятся в области види
мости программного кода.
В настоящий момент класс C1 не присоединяет атрибут name к экземп
лярам, пока не будет вызван метод setname. Фактически попытка обра
титься к имени I1.name до вызова I1.setname приведет к появлению
ошибки, сообщающей о неопределенном имени. Если в классе потре
буется гарантировать, что атрибут, такой как name, всегда будет при
сутствовать в экземплярах, то такой атрибут должен создаваться на
этапе создания класса, как показано ниже:
class C1(C2, C3):
def __init__(self, who): # Создать имя при создании класса
self.name = who # Self – либо I1, либо I2
I1 = C1('bob') # Записать 'bob' в I1.name
I2 = C1('mel') # Записать 'mel' в I2.name
print I1.name # Выведет 'bob'
В этом случае интерпретатор Python автоматически будет вызывать
метод с именем __init__ каждый раз при создании экземпляра класса.
Новый экземпляр будет передаваться методу __init__ в виде первого
аргумента self, а любые значения, перечисленные в круглых скобках
при вызове класса, будут передаваться во втором и последующих за
ним аргументах. В результате инициализация экземпляров будет вы
полняться в момент их создания, без необходимости вызывать допол
нительные методы.
Метод __init__ известен как конструктор, так как он запускается на
этапе конструирования экземпляра. Этот метод является типичным
представителем большого класса методов, которые называются метода+
ми перегрузки операторов. Более подробно эти методы будут рассмат
риваться в последующих главах. Такие методы наследуются в дереве
классов как обычно, а их имена начинаются и заканчиваются двумя
ООП с высоты 30 000 футов 571
символами подчеркивания, чтобы подчеркнуть их особенное назначе
ние. Интерпретатор Python вызывает их автоматически, когда экземп
ляры, поддерживающие их, участвуют в соответствующих операциях,
и они главным образом являются альтернативой вызовам простых ме
тодов. Кроме того, они являются необязательными: при их отсутствии
соответствующие операции экземплярами не поддерживаются.
Например, чтобы реализовать пересечение множеств, класс может пре
дусмотреть реализацию метода intersect или перегрузить оператор &,
описав логику его работы в методе с именем __and__. Поскольку исполь
зование операторов делает экземпляры более похожими на встроенные
типы, это позволяет определенным классам обеспечивать непротиворе
чивый и естественный интерфейс и быть совместимыми с программ
ным кодом, который предполагает выполнение операций над объекта
ми встроенных типов.
ООП – это многократное использование
программного кода
Вот, в основном, и все описание ООП в языке Python (за исключением
некоторых синтаксических особенностей). Конечно, в ООП присутст
вует не только наследование. Например, перегрузка операторов может
применяться гораздо шире, чем описывалось до сих пор, – классы мо
гут предоставлять собственные реализации таких операций, как дос
туп к элементам по их индексам, получение значений атрибутов, вы
вод и многие другие. Но вообще говоря, ООП реализует поиск атрибу
тов в деревьях.
Тогда зачем нам погружаться в тонкости создания деревьев объектов
и выполнения поиска в них? Нужно накопить некоторый опыт, чтобы
увидеть, как при грамотном использовании классы поддерживают
возможность многократного использования программного кода спосо
бами, которые недоступны в других программных компонентах. Ис
пользуя классы, мы программируем, настраивая написанное про
граммное обеспечение, вместо того чтобы изменять существующий
программный код или писать новый код в каждом новом проекте.
С фундаментальной точки зрения, классы – это действительно всего
лишь пакеты функций и других имен, которые во многом напоминают
модули. Однако автоматический поиск атрибутов в дереве наследова
ния, который мы получаем при использовании классов, обеспечивает
возможности по адаптации программного обеспечения более широкие,
чем это возможно с помощью модулей и функций. Кроме того, классы
представляют собой удобную структуру, обеспечивающую компактное
размещение выполняемого кода и переменных, что помогает в отладке.
Например, методы – это обычные функции со специальным первым
аргументом, поэтому мы можем подражать некоторым чертам их по
ведения, вручную передавая объекты для обработки обычным функ
572 Глава 22. ООП: общая картина
циям. Однако участие методов в наследовании классов позволяет нам
естественным образом адаптировать существующее программное обес
печение, создавая новые подклассы, определяющие новые методы,
вместо того чтобы изменять существующий программный код. Подоб
ное невозможно в случае с модулями и функциями.
В качестве примера предположим, что вас привлекли к реализации
приложения базы данных, где хранится информация о служащих.
Как программист, использующий объектноориентированные особен
ности языка Python, вы могли бы начать работу с реализации общего
суперкласса, который определяет поведение, общее для всех катего
рий служащих в вашей организации:
class Employee: # Общий суперкласс
def computeSalary(self): ... # Общее поведение
def giveRaise(self): ...
def promote(self): ...
def retire(self): ...
Реализовав это общее поведение, можно специализировать его для ка
ждой категории служащих, чтобы отразить отличия разных катего
рий от стандарта. То есть можно создать подклассы, которые изменяют
лишь ту часть поведения, которая отличает их от типового представле
ния служащего, – остальное поведение будет унаследовано от общего
класса. Например, если зарплата инженеров начисляется в соответст
вии с какимито особыми правилами (то есть не по почасовому тари
фу), в подклассе можно переопределить всего один метод:
class Engineer(Employee): # Специализированный подкласс
def computeSalary(self): ... # Особенная реализация
Поскольку эта версия computeSalary находится в дереве классов ниже,
она будет замещать (переопределять) общую версию метода в классе
Employee. Затем можно создать экземпляры разновидностей классов
служащих в соответствии с принадлежностью имеющихся служащих
классам, чтобы обеспечить корректное поведение:
bob = Employee() # Поведение по умолчанию
mel = Engineer() # Особые правила начисления зарплаты
Обратите внимание, что существует возможность создавать экземпля
ры любых классов в дереве, а не только тех, что находятся внизу, –
класс, экземпляр которого создается, определяет уровень, откуда бу
дет начинаться поиск атрибутов. В перспективе эти два объекта экзем
пляров могли бы быть встроены в больший контейнерный объект (на
пример, в список или в экземпляр другого класса), который представ
ляет отдел или компанию, реализуя идею композиции, упомянутую
в начале главы.
Когда позднее вам потребуется узнать размер зарплаты этих служа
щих, их можно будет вычислить в соответствии с правилами классов,
ООП с высоты 30 000 футов 573
из которых были созданы объекты, благодаря поиску в дереве наследо
вания:1
company = [bob, mel] # Составной объект
for emp in company:
print emp.computeSalary() # Вызвать версию метода для данного объекта
Это еще одна разновидность полиморфизма – идеи, которая была пред
ставлена в главе 4 и повторно рассматривалась в главе 15. Вспомните,
полиморфизм означает, что смысл операции зависит от объекта, над
которым она выполняется. Здесь метод computeSalary определяется в хо
де поиска в каждом объекте в дереве наследования, прежде чем он бу
дет вызван. В других приложениях полиморфизм может также ис
пользоваться для сокрытия (то есть для инкапсуляции) различий ин
терфейсов. Например, программа, которая обрабатывает потоки дан
ных, может работать с объектами, имеющими методы ввода и вывода,
не заботясь о том, что эти методы делают в действительности:
def processor(reader, converter, writer):
while 1:
data = reader.read()
if not data: break
data = converter(data)
writer.write(data)
Передавая экземпляры классов с необходимыми интерфейсными ме
тодами read и write, специализированными под различные источники
данных, мы можем использовать одну и ту же функцию processor для
работы с любыми источниками данных, как уже существующими, так
и с теми, что появятся в будущем:
class Reader:
def read(self): ... # Поведение и инструменты по умолчанию
def other(self): ...
class FileReader(Reader):
def read(self): ... # Чтение из локального файла
class SocketReader(Reader):
def read(self): ... # Чтение из сокета
...
processor(FileReader(...), Converter, FileWriter(...))
processor(SocketReader(...), Converter, TapeWriter(...))
processor(FtpReader(...), Converter, XmlWriter(...))
1 Обратите внимание, что список company из этого примера мог бы сохранять
ся в файле, чтобы обеспечить постоянное хранение базы данных с информа
цией о служащих (с помощью модуля pickle, представленного в главе 9
в разделе «Использование файлов»). Кроме того, в состав Python входит мо
дуль shelve, который мог бы позволить сохранять экземпляры классов
в файлах с доступом по ключу, – сторонняя разработка, система ZODB, по
зволяет реализовать то же самое, но имеет более качественную поддержку
объектноориентированных баз данных для промышленного использования.
574 Глава 22. ООП: общая картина
Кроме того, благодаря тому, что внутренняя реализация этих методов
read и write была разделена по типам источников данных, их можно из
менять, не трогая программный код, подобный приведенному, который
использует их. Фактически функция processor сама может быть клас
сом, реализующим логику работы функции преобразования converter,
которую могут унаследовать подклассы, и позволяющим встраивать
экземпляры, выполняющие чтение и запись, в соответствии с принци
пом композиции (далее в этой части книги будет показано, как это реа
лизуется).
Когда вы привыкнете программировать в этом стиле (адаптации про
граммного обеспечения), то обнаружите, начиная писать новую про
грамму, что большая часть вашей задачи уже реализована, и ваша за
дача в основном сводится к тому, чтобы подобрать уже имеющиеся су
перклассы, которые реализуют поведение, требуемое вашей програм
ме. Например, возможно, ктото другой, для совершенно другой
программы, уже написал классы Employee, Reader и Writer из данного
примера. В этом случае вы сможете воспользоваться уже готовым про
граммным кодом «за так».
На практике во многих прикладных областях вы можете получить или
купить коллекции суперклассов, известных как платформы, в кото
рых реализованы наиболее часто встречающиеся задачи программиро
вания на основе классов, готовые к использованию в ваших приложе
ниях. Такие платформы могут предоставлять интерфейсы к базам дан
ных, протоколы тестирования, средства создания графического интер
фейса и т. д. В среде такой платформы вам часто будет достаточно
создать свой подкласс, добавив в него одиндва своих метода, а основ
ная работа будет выполняться классами платформы, расположенны
ми выше в дереве наследования. Программирование в мире ООП – это
лишь вопрос сборки уже отлаженного программного кода и настройки
его путем написания своих собственных подклассов.
Безусловно, на то чтобы понять, как использовать классы для дости
жения такого объектноориентированного идеала, потребуется время.
На практике ООП влечет за собой большой объем предварительного
проектирования, на этапе которого осмысливаются преимущества, по
лучаемые от использования классов; с этой целью программисты нача
ли составлять список наиболее часто встречающихся решений в ООП,
известных как шаблоны проектирования – помогающих решать про
блемы проектирования. При этом объектноориентированный про
граммный код на языке настолько прост, что он сам по себе не будет
препятствием в освоении ООП. Чтобы убедиться в этом, вам следует
перейти к главе 23.
В заключение 575
В заключение
В этой главе мы в общих чертах рассмотрели ООП и классы, получив
представление о них, прежде чем углубиться в детали синтаксиса. Как
мы узнали, основу ООП составляет поиск атрибутов в дереве связан
ных объектов; мы называем его поиском в дереве наследования. Объек
ты в нижней части дерева наследуют атрибуты объектов, расположен
ных в дереве выше, – эта особенность позволяет создавать программы
за счет адаптации программного кода, а не за счет его изменения или
создания нового кода. При грамотном использовании эта модель про
граммирования может привести к существенному сокращению време
ни, необходимого на разработку.
В следующей главе мы приступим к рассмотрению подробностей,
стоящих за общей картиной, рассмотренной здесь. Мы начнем углуб
ляться в изучение классов, однако не стоит забывать, что объектно
ориентированная модель в языке Python очень проста – как я уже за
метил, она, по сути, сводится к поиску атрибутов в деревьях объектов.
Прежде чем двинуться дальше, ответьте на контрольные вопросы, что
бы освежить в памяти все то, о чем рассказывалось здесь.
Закрепление пройденного
Контрольные вопросы
1. Каково основное назначение ООП в языке Python?
2. Где выполняется поиск унаследованных атрибутов?
3. В чем разница между объектом класса и объектом экземпляра?
4. В чем состоит особенность первого аргумента в методах классов?
5. Для чего служит метод __init__?
6. Как создать экземпляр класса?
7. Как создать класс?
8. Как определяются суперклассы для класса?
Ответы
1. Основное назначение ООП состоит в том, чтобы обеспечить много
кратное использование программного кода, – программный код
разлагается на составляющие, чтобы снизить его избыточность,
и при создании новых программ выполняется адаптация имеюще
гося программного кода, а не изменение существующего или созда
ние нового кода.
2. Поиск унаследованных атрибутов выполняется сначала в объекте
экземпляра, затем в классе, из которого был создан экземпляр, за
тем во всех суперклассах, в направлении снизу вверх и слева напра
576 Глава 22. ООП: общая картина
во в дереве объектов (по умолчанию). Как только будет найдено пер
вое вхождение атрибута, поиск прекращается. Поскольку резуль
татом поиска является самая нижняя версия имени из имеющихся
в дереве, иерархия классов естественным образом поддерживает
возможность адаптации за счет создания подклассов.
3. И классы, и экземпляры – это пространства имен (пакеты перемен
ных, которые играют роль атрибутов). Главное различие между ни
ми состоит в том, что классы представляют собой своего рода фабри
ки, позволяющие производить множество экземпляров. Кроме того,
классы поддерживают методы перегрузки операторов, которые на
следуются экземплярами, а функции, вложенные в классы, интер
претируются как специальные методы обработки экземпляров.
4. Первый аргумент в методах классов играет особую роль, так как че
рез него всегда передается ссылка на объект экземпляра, который
подразумевается при вызове метода. Согласно общепринятым со
глашениям он обычно называется self. Так как по умолчанию ме
тоды всегда принимают этот подразумеваемый объект, мы говорим,
что они «объектноориентированные», то есть предназначенные
для обработки или изменения объектов.
5. Если метод __init__ присутствует в классе или наследуется им, ин
терпретатор автоматически будет вызывать его при создании каж
дого экземпляра этого класса. Этот метод также называют конст
руктором – он неявно получает новый экземпляр, а также все аргу
менты, которые были указаны при вызове имени класса. Кроме то
го, он является типичным представителем методов перегрузки
операторов. В отсутствии метода __init__ экземпляры начинают
свое существование как пустые пространства имен.
6. Экземпляр класса создается вызовом имени класса, как если бы это
была функция – любые аргументы в вызове будут переданы конст
руктору __init__, как второй и следующие аргументы. Новый эк
земпляр запоминает, из какого класса он был создан, благодаря че
му обеспечивается наследование.
7. Класс создается с помощью инструкции class, так же как определе
ния функций. Эти инструкции обычно выполняются во время им
портирования файла вмещающего модуля (подробнее об этом рас
сказывается в следующей главе).
8. Суперклассы для заданного класса определяются в виде списка
в круглых скобках в инструкции class после имени нового класса.
Порядок следования суперклассов в списке определяет порядок по
иска в дереве наследования.
23
Основы программирования классов
Теперь, когда мы поговорили об ООП в общем, настало время посмот
реть, как это выглядит в фактическом программном коде. В этой и сле
дующей главах подробно будет рассказываться о синтаксисе, который
составляет основу модели классов в языке Python.
Если ранее вам не приходилось сталкиваться с ООП, будет сложно сра
зу усвоить все сведения о классах. Чтобы облегчить освоение програм
мирования классов, мы начнем наше детальное исследование ООП
с того, что рассмотрим в этой главе несколько простых классов в дей
ствии. Классы в языке Python в самой простой их форме легко понять,
а детали будут рассмотрены подробнее в следующих главах.
Классы обладают тремя основными отличительными особенностями.
На самом простом уровне они представляют собой всего лишь про
странства имен, во многом похожие на модули, которые мы изучали
в пятой части книги. Но, в отличие от модулей, классы также поддер
живают создание множества объектов, реализуют наследуемое про
странство имен и перегрузку операторов. Начнем наше путешествие
с инструкции class и исследуем каждую из этих трех особенностей.
Классы генерируют множество
экземпляров объектов
Чтобы понять, каким образом обеспечивается возможность создания
множества объектов, для начала нужно понять, что в объектноориен
тированной модели языка Python существует две разновидности объек
тов: объекты классов и объекты экземпляров. Объекты классов реали
зуют поведение по умолчанию и играют роль фабрик по производству
объектов экземпляров. Объекты экземпляров – это настоящие объек
ты, обрабатываемые программой, – каждый представляет собой само
стоятельное пространство имен, но наследует имена (то есть автомати
578 Глава 23. Основы программирования классов
чески имеет доступ к ним) класса, из которого он был создан. Объекты
классов создаются инструкциями, а объекты экземпляров – вызова
ми. Каждый раз, когда вы вызываете класс, вы получаете новый эк
земпляр этого класса.
Эта объектная концепция существенно отличается от любых других
программных конструкций, которые мы видели до сих пор в этой кни
ге. В действительности, классы – это фабрики, способные производить
множество экземпляров. В противоположность этому каждый модуль
в программе может присутствовать в единственном экземпляре (фак
тически это одна из причин, почему необходимо использовать функ
цию reload для обновления объекта модуля, чтобы отразить внесенные
в модуль изменения).
Ниже приводится краткий обзор основных особенностей ООП в языке
Python. Как вы увидите, классы в языке Python сочетают в себе черты,
напоминающие функции и модули, но они совершенно не похожи на
классы в других языках программирования.
Объекты классов реализуют поведение по умолчанию
Когда выполняется инструкция class, она создает объект класса. Ни
же приводятся несколько основных отличительных характеристик
классов в языке Python.
• Инструкция class создает объект класса и присваивает ему имя.
Так же как и инструкция def, инструкция class является выполняе+
мой инструкцией. Когда она выполняется, она создает новый объ
ект класса и присваивает его имени, указанному в заголовке инст
рукции class. Кроме того, как и инструкции def, инструкции class
обычно выполняются при первом импортировании содержащих их
файлов.
• Операции присваивания внутри инструкции class создают атрибу!
ты класса. Так же как и в модулях, инструкции присваивания на
верхнем уровне внутри инструкции class (не вложенные в инструк
ции def) создают атрибуты объекта класса. С технической точки зре
ния инструкция class преобразует свою область видимости в про
странство имен атрибутов объекта класса, так же, как глобальная
область видимости модуля преобразуется в его пространство имен.
После выполнения инструкции class атрибуты класса становятся
доступны по их составным (полным) именам: object.name.
• Атрибуты класса описывают состояние объекта и его поведение.
Атрибуты объекта класса хранят информацию о состоянии и опи
сывают поведение, которым обладают все экземпляры класса, – ин
струкции def, вложенные в инструкцию class, создают методы, ко
торые обрабатывают экземпляры.
Классы генерируют множество экземпляров объектов 579
Объекты экземпляров – это конкретные элементы
Когда вызывается объект класса, возвращается объект экземпляра.
Ниже приводятся несколько отличительных характеристик экземп
ляров классов:
• Вызов объекта класса как функции создает новый объект экземп!
ляра. Всякий раз, когда вызывается класс, создается и возвращает
ся новый объект экземпляра. Экземпляры представляют собой кон
кретные элементы данных в вашей программе.
• Каждый объект экземпляра наследует атрибуты класса и приобре!
тает свое собственное пространство имен. Объекты экземпляров
создаются из классов и представляют собой новые пространства
имен; они первоначально пустые, но наследуют атрибуты классов,
из которых были созданы.
• Операции присваивания значений атрибутам через ссылку self
в методах создают атрибуты в каждом отдельном экземпляре. Ме
тоды класса получают в первом аргументе (с именем self в соответ
ствии с соглашениями) ссылки на обрабатываемый объект экземп
ляра – присваивание атрибутам через ссылку self создает или изме
няет данные экземпляра, а не класса.
Первый пример
Обратимся к первому примеру, демонстрирующему работу этих идей на
практике. Для начала определим класс с именем FirstClass, выполнив
инструкцию class в интерактивной оболочке интерпретатора Python:
>>> class FirstClass: # Определить объект класса
... def setdata(self, value): # Определить методы класса
... self.data = value # self – это экземпляр
... def display(self):
... print self.data # self.data: данные экземпляров
...
Здесь мы работаем в интерактивной оболочке, но обычно такие инст
рукции выполняются во время импортирования вмещающего файла
модуля. Подобно функциям, создаваемым с помощью инструкции def,
классы не существуют, пока интерпретатор Python не достигнет этих
инструкций и не выполнит их.
Как и все составные инструкции, инструкция class начинается со
строки заголовка, содержащей имя класса, за которой следует тело
класса из одной или более вложенных инструкций (обычно) с отступа
ми. Здесь вложенными инструкциями являются инструкции def – они
определяют функции, реализующие поведение класса. Как мы уже
знаем, инструкции def в действительности являются операциями при
сваивания – в данном случае они присваивают объекты функций име
нам setdata и display в области видимости инструкции class и тем са
мым создают атрибуты, присоединяемые к классу: FirstClass.setdata
580 Глава 23. Основы программирования классов
и FirstClass.display. Фактически любое имя, которому присваивается
значение на верхнем уровне во вложенном блоке класса, становится
атрибутом этого класса.
Функции внутри классов обычно называются методами. Это обычные
инструкции def, и для них верно все то, что мы уже знаем о функциях
(они могут иметь аргументы со значениями по умолчанию, возвращать
значения и т. д.). Но в первом аргументе методы автоматически получа
ют подразумеваемый объект экземпляра – контекст вызова метода. Нам
необходимо создать пару экземпляров, чтобы понять, как это делается:
>>> x = FirstClass() # Создаются два экземпляра
>>> y = FirstClass() # Каждый является отдельным пространством имен
Вызывая класс таким способом (обратите внимание на круглые скоб
ки), мы создаем объекты экземпляров, которые являются всего лишь
пространствами имен и обладают доступом к атрибутам класса. Собст
венно говоря, к настоящему моменту у нас имеется три объекта – два
экземпляра и один класс. В действительности у нас имеется три свя
занных пространства имен, как показано на рис. 23.1. В терминах
ООП мы говорим, что x «наследует» классу FirstClass, как и y.
Изначально оба экземпляра пустые, но они связаны с классом, из ко
торого были созданы. Если через имя экземпляра обратиться к атрибу
ту объекта класса, то в результате поиска по дереву наследования ин
терпретатор вернет значение атрибута класса (при условии, что в эк
земпляре отсутствует одноименный атрибут):
>>> x.setdata("King Arthur") # Вызов метода: self – это x
>>> y.setdata(3.14159) # Эквивалентно: FirstClass.setdata(y, 3.14159)
Ни x, ни y не имеют собственного атрибута setdata, поэтому, чтобы оты
скать его, интерпретатор следует по ссылке от экземпляра к классу.
В этом заключается суть наследования в языке Python: механизм на
следования привлекается в момент разрешения имени атрибута, и вся
наследует
FirstClass
наследует
– setdata
– display
Y
– data
X
– data
Рис. 23.1. Экземпляры и классы – это связанные между собой объекты
пространств имен в дереве наследования классов, внутри которого
выполняется поиск. Здесь атрибут «data» обнаруживается в экземплярах,
а «setdata» и «display» – в классе, расположенном выше их
Классы генерируют множество экземпляров объектов 581
его работа заключается лишь в поиске имен в связанных объектах (на
пример, следуя по ссылкам «наследует», как показано на рис. 23.1).
В функции setdata внутри класса FirstClass значение аргумента запи
сывается в self.data. Имя self внутри метода – имя самого первого ар
гумента, в соответствии с общепринятыми соглашениями, – автомати
чески ссылается на обрабатываемый экземпляр (x или y), поэтому опе
рация присваивания сохраняет значения в пространстве имен экземп
ляра, а не класса (так создаются имена data, показанные на рис. 23.1).
Поскольку классы способны генерировать множество экземпляров, ме
тоды должны использовать аргумент self, чтобы получить доступ к об
рабатываемому экземпляру. Когда мы вызываем метод класса display,
чтобы вывести значения атрибутов self.data, мы видим, что для каждо
го экземпляра они разные; с другой стороны, имя display само по себе
одинаковое в x и y, так как оно пришло (унаследовано) из класса:
>>> x.display() # В каждом экземпляре свое значение self.data
King Arthur
>>> y.display()
3.14159
Обратите внимание, что в атрибутах data экземпляров мы сохранили
объекты различных типов (строку и число с плавающей точкой). Как
и повсюду в языке Python, атрибуты экземпляров (иногда называются
членами) никак не объявляются – они появляются, как только будет
выполнена первая операция присваивания, точно так же, как и в слу
чае с переменными. Фактически, если вызвать метод display до вызова
метода setdata, будет получено сообщение об ошибке обращения к не
определенному имени – атрибут с именем data не существует в памяти,
пока ему не будет присвоено какоелибо значение в методе setdata.
Еще один способ, дающий возможность оценить, насколько динамич
на эта модель, позволяет изменять атрибуты экземпляров в самом
классе, выполняя присваивание как с помощью аргумента self внутри
методов, так и за пределами класса, когда экземпляр явно участвует
в операции присваивания:
>>> x.data = "New value" # Можно получать/записывать значения атрибутов
>>> x.display() # И за пределами класса тоже
New value
Хотя это и нечасто применяется, тем не менее существует возмож
ность создания новых атрибутов в пространстве имен экземпляра,
присваивая значения именам за пределами методов класса:
>>> x.anothername = "spam" # Здесь также можно создавать новые атрибуты
Эта операция присоединит новый атрибут с именем anothername, кото
рый затем сможет использоваться любыми методами класса в объекте
экземпляра x. Обычно классы создают все атрибуты экземпляров за
счет присваивания значений аргументу self, но это не обязательно –
582 Глава 23. Основы программирования классов
программы могут получать, изменять или создавать атрибуты в лю
бых объектах, к которым они имеют доступ.
Классы адаптируются посредством наследования
Помимо роли фабрик по созданию объектов экземпляров, классы так
же позволяют нам вносить изменения за счет введения новых компо
нентов (которые называются подклассами), а не за счет изменения су
ществующего программного кода. Объекты экземпляров, созданные
из класса, наследуют атрибуты класса. В языке Python классы также
могут наследовать другие классы, что открывает дверь к созданию ие+
рархий классов, поведение которых специализируется за счет переоп
ределения существующих атрибутов ниже в иерархии. Здесь также
нет никакого сходства с модулями: их атрибуты находятся в едином
плоском пространстве имен.
В языке Python экземпляры наследуют классам, а классы наследуют
суперклассам. Ниже приводятся основные идеи, лежащие в основе ме
ханизма наследования атрибутов:
• Суперклассы перечисляются в круглых скобках в заголовке инст!
рукции class. Чтобы унаследовать атрибуты другого класса, доста
точно указать этот класс в круглых скобках в заголовке инструкции
class. Класс, который наследует, называется подклассом, а класс,
которому наследуют, называется его суперклассом.
• Классы наследуют атрибуты своих суперклассов. Как экземпляры
наследуют имена атрибутов, определяемых их классами, так же
и классы наследуют все имена атрибутов, определяемые в их супер
классах, – интерпретатор автоматически отыскивает их, когда
к ним выполняется обращение, если эти атрибуты отсутствуют
в подклассах.
• Экземпляры наследуют атрибуты всех доступных классов. Каж
дый экземпляр наследует имена из своего класса, а также из всех
его суперклассов. Во время поиска имен интерпретатор проверяет
сначала экземпляр, потом его класс, а потом все суперклассы.
• Каждое обращение object.attribute вызывает новый независимый
поиск. Интерпретатор выполняет отдельную процедуру поиска в де
реве классов для каждого атрибута, который ему встречается в вы
ражении запроса. Сюда входят ссылки на экземпляры и классы из
инструкции class (например, X.attr), а также ссылки на атрибуты
аргумента экземпляра self в методах класса. Каждое выражение
self.attr в методе вызывает поиск attr в self и выше.
• Изменения в подклассах не затрагивают суперклассы. Замещение
имен суперкласса в подклассах ниже в иерархии (в дереве) изменя
ет подклассы и тем самым изменяет унаследованное поведение.
Результат и главная цель такой процедуры поиска состоит в том, что
классы обеспечивают разложение на отдельные операции и адаптацию
Классы адаптируются посредством наследования 583
программного кода лучше, чем это могут сделать другие компоненты
языка, которые мы рассматривали ранее. С одной стороны, классы по
зволяют минимизировать избыточность программного кода (и тем са
мым снизить стоимость обслуживания) за счет создания единой и об
щей реализации операций, а с другой стороны, они обеспечивают воз
можность адаптировать уже существующий программный код вместо
того, чтобы изменять его или писать заново.
Второй пример
Этот второй пример основан на предыдущем. Для начала мы опреде
лим новый класс, SecondClass, который наследует все имена из класса
FirstClass и добавляет свои собственные:
>>> class SecondClass(FirstClass): # Наследует setdata
... def display(self): # Изменяет display
... print 'Current value = "%s"' % self.data
...
Класс SecondClass определяет метод display, осуществляющий вывод
в другом формате. Определяя атрибут с тем же именем, что и атрибут
в классе FirstClass, класс SecondClass замещает атрибут display своего
суперкласса.
Вспомните, что поиск в дереве наследования выполняется снизу вверх –
от экземпляров к классам и далее к суперклассам и останавливается,
как только будет найдено первое вхождение искомого имени атрибута.
В данном случае имя display в классе SecondClass будет найдено рань
ше, чем это же имя в классе FirstClass. В этом случае мы говорим, что
класс SecondClass переопределяет метод display класса FirstClass. Ино
гда такая замена атрибутов за счет их переопределения ниже в дереве
классов называется перегрузкой.
Главный результат здесь состоит в том, что класс SecondClass специа
лизирует класс FirstClass, изменяя поведение метода display. С другой
стороны, класс SecondClass (и все экземпляры, созданные из него) по
прежнему наследует из класса FirstClass метод setdata. Создадим эк
земпляр, чтобы продемонстрировать это:
>>> z = SecondClass()
>>> z.setdata(42) # Найдет setdata в FirstClass
>>> z.display() # Найдет переопределенный метод в SecondClass
Current value = "42"
Как и прежде, мы создали объект экземпляра, вызвав класс SecondClass.
При обращении к setdata все так же вызывается версия метода из First
Class, но при обращении к атрибуту display, вызывается версия метода
из SecondClass, которая выводит измененный текст сообщения. Схема
пространств имен, вовлеченных в действие, изображена на рис. 23.2.
Здесь очень важно заметить следующее: специализация, выполненная
в классе SecondClass, находится полностью за пределами класса First
584 Глава 23. Основы программирования классов
Class. Как следствие она не оказывает влияния на уже созданные или
создаваемые впоследствии объекты класса FirstClass, такие как x в пре
дыдущем примере:
>>> x.display() # x попрежнему экземпляр FirstClass (старое сообщение)
New value
Вместо того чтобы изменять класс FirstClass, мы адаптировали его.
Безусловно, это достаточно искусственный пример, но он демонстри
рует, как наследование позволяет вносить изменения с помощью
внешних компонентов (то есть с помощью подклассов). Часто классы
поддерживают возможность расширения и повторного использования
гораздо лучше, чем функции или модули.
Классы – это атрибуты в модулях
Прежде чем двинуться дальше, вспомним, что в именах классов нет ни
чего необычного. Это всего лишь переменные, которым присваиваются
объекты во время выполнения инструкций class, а ссылки на объекты
можно получить с помощью обычных выражений. Например, если бы
определение класса FirstClass находилось в файле модуля, а не было
введено в интерактивной оболочке, мы могли бы импортировать этот
модуль и использовать имя в строке заголовка инструкции class:
from modulename import FirstClass # Скопировать имя в мою область видимости
class SecondClass(FirstClass): # Использовать имя класса непосредственно
def display(self): ...
Или эквивалентный вариант:
import modulename # Доступ ко всему модулю целиком
class SecondClass(modulename.FirstClass): # Указать полное имя
def display(self): ...
Имена классов, как и все остальное, всегда находятся в модулях, и по
тому при их употреблении необходимо следовать правилам, которые
наследует
Z (экземпляр)
наследует
SecondClass
FirstClass
– data
– display
– setdata
– display
Z.data Z.display Z.setdata
Рис. 23.2. Специализация путем переопределения унаследованных имен
посредством повторного их определения ниже в дереве классов. Здесь класс
SecondClass переопределяет и тем самым адаптирует метод «display»
для экземпляров этого класса
Классы адаптируются посредством наследования 585
мы рассматривали в пятой части книги. Например, в одном файле мо
дуля могут находиться определения сразу нескольких классов – по
добно другим инструкциям в модуле, инструкции class выполняются
в ходе операции импортирования и определяют имена, которые в свою
очередь становятся атрибутами модуля. Вообще любой модуль может
содержать самые произвольные сочетания из любого числа перемен
ных, функций и классов, и все эти имена будут вести себя в модуле
одинаково. Это демонстрирует файл food.py:
# food.py
var = 1 # food.var
def func(): # food.func
...
class spam: # food.spam
...
class ham: # food.ham
...
class eggs: # food.eggs
...
Это правило остается справедливым, даже если модуль и класс имеют
одинаковые имена. Например, пусть имеется следующий файл per+
son.py:
class person:
...
Чтобы получить доступ к классу, нам необходимо обратиться к моду
лю, как обычно:
import person # Импортировать модуль
x = person.person() # Класс внутри модуля
Хотя этот способ может показаться избыточным, он совершенно необ
ходим: имя person.person ссылается на класс person внутри модуля per
son. Если использовать просто имя person, мы обратимся к модулю,
а не к классу; кроме случая, когда используется инструкция from:
from person import person # Получить класс из модуля
x = person() # Использовать имя класса
Как и любые другие переменные, мы не увидим класс в файле модуля,
пока не импортируем его или както иначе не извлечем класс из вме
щающего файла. Если вам это кажется сложным, то не используйте
одинаковые имена для модулей и классов в них.
Кроме того, имейте в виду: несмотря на то, что классы и модули явля
ются пространствами имен для подключения атрибутов, они представ
ляют собой совершенно разные структуры: модуль является отражени
ем целого файла, а класс – это лишь инструкция внутри файла. Под
робнее об этих различиях мы поговорим позднее в этой части книги.
586 Глава 23. Основы программирования классов
Классы могут переопределять
операторы языка Python
Теперь давайте рассмотрим третье основное отличие классов и моду
лей: перегрузку операторов. Говоря простым языком, перегрузка опе
раторов позволяет объектам, созданным из классов, перехватывать
и участвовать в операциях, которые применяются к встроенным типам:
сложение, получение среза, вывод, дополнение имен и т. д. По большей
части это автоматический механизм: при выполнении выражений
и других встроенных операций интерпретатор передает управление
реализации классов. В модулях нет ничего подобного: модули могут
реализовать функции, но не операторы выражений.
Мы можем полностью реализовать поведение класса в виде методов,
однако перегрузка операторов позволяет объектам теснее интегриро
ваться в объектную модель языка Python. Кроме того, перегрузка опе
раторов помогает нашим объектам действовать так же, как действуют
встроенные объекты, потому что она позволяет создавать менее проти
воречивые и более простые в изучении интерфейсы объектов и обеспе
чивает возможность обрабатывать объекты, созданные из классов,
программным кодом, который предполагает взаимодействие со встро
енными типами.
• Имена методов, начинающиеся и заканчивающиеся двумя симво!
лами подчеркивания (__X__), имеют специальное назначение. Пе
регрузка операторов в языке Python реализуется за счет создания
методов со специальными именами для перехватывания операций.
Язык Python определяет фиксированные и неизменяемые имена
методов для каждой из операций.
• Такие методы вызываются автоматически, когда экземпляр участ!
вует во встроенных операциях. Например, если объект экземпляра
наследует метод __add__, этот метод будет вызываться всякий раз,
когда объект будет появляться в операции сложения (+). Возвра
щаемое значение метода становится результатом соответствующей
операции.
• Классы могут переопределять большинство встроенных операто!
ров. Существует множество специальных имен методов для реали
зации перегрузки почти всех операторов, доступных для встроен
ных типов. Сюда входят операторы выражений, а также такие базо
вые операции, как вывод и создание объекта.
• В методах перегрузки операторов не существует аргументов со зна!
чениями по умолчанию, и ни один из таких методов не является
обязательным для реализации. Если класс не определяет и не на
следует методы перегрузки операторов, это означает лишь то, что
экземпляры класса не поддерживают эти операции. Например, ес
ли отсутствует метод __add__, попытка выполнить операцию сложе
ния + будет приводить к возбуждению исключения.
Классы могут переопределять операторы языка Python 587
• Операторы позволяют интегрировать классы в объектную модель
языка Python. Благодаря перегрузке операторов объекты, реализо
ванные на базе классов, действуют подобно встроенным типам и тем
самым обеспечивают непротиворечивые и совместимые интерфейсы.
Перегрузка операторов является необязательной функциональной
особенностью – она используется в основном специалистами, создаю
щими инструментальные средства для других программистов, а не
разработчиками прикладных программ. И честно говоря, вам не стоит
использовать ее только потому, что это «круто». Если не требуется,
чтобы класс имитировал поведение встроенных типов, лучше ограни
читься использованием простых методов. Например, зачем приложе
нию, работающему с базой данных служащих, поддержка таких опе
раторов, как * и +? Методы с обычными именами, такими как giveRaise
и promote, обычно более уместны.
Вследствие этого мы не будем в этой книге углубляться в подробности
реализации методов перегрузки каждого оператора, доступного в язы
ке Python. Однако имеется один метод перегрузки оператора, который
можно встретить практически в любом классе: метод __init__, кото
рый известен как конструктор и используется для инициализации
состояния объектов. Методу __init__ следует уделить особое внима
ние, потому что он, наряду с аргументом self, является одним из клю
чей к пониманию ООП в языке Python.
Третий пример
На этот раз мы определим подкласс от SecondClass, реализующий три
специальных метода, которые будут вызываться интерпретатором ав
томатически: метод __init__ вызывается, когда создается новый объ
ект экземпляра (аргумент self представляет новый объект ThirdClass),
и методы __add__ и __mul__ вызываются, когда экземпляр ThirdClass
участвует в операциях + или *, соответственно. Ниже приводится опре
деление нашего класса:
>>> class ThirdClass(SecondClass): # Наследует SecondClass
... def __init__(self, value): # Вызов "ThirdClass(value)"
... self.data = value
... def __add__(self, other): # Для выражения "self + other"
... return ThirdClass(self.data + other)
... def __mul__(self, other):
... self.data = self.data * other # Для выражения "self * other"
...
>>> a = ThirdClass("abc") # Вызывается новый метод __init__
>>> a.display() # Унаследованный метод
Current value = "abc"
>>> b = a + 'xyz' # Новый __add__: создается новый экземпляр
>>> b.display()
Current value = "abcxyz"
588 Глава 23. Основы программирования классов
>>> a * 3 # Новый __mul__: заменяется сам экземпляр
>>> a.display()
Current value = "abcabcabc"
Класс ThirdClass «наследует» классу SecondClass, поэтому его экземп
ляры наследуют метод display от SecondClass. Но теперь при создании
экземпляра класса ThirdClass ему передается дополнительный аргу
мент (например, «abc») – в виде аргумента value в конструкторе
__init__, значение которого присваивается атрибуту self.data. Далее,
объекты ThirdClass могут участвовать в операциях + и * – объект экзем
пляра слева от оператора передается в виде аргумента self, а значение
справа в виде аргумента other, как показано на рис. 23.3.
Методы со специальными именами, такими как __init__ и __add__, на
следуются подклассами и экземплярами, как любые другие имена, ко
торым выполняется присваивание в инструкции class. Если методы от
сутствуют в классе, интерпретатор, как обычно, продолжит их поиск
в суперклассах. Кроме того, имена методов перегрузки операторов не
являются встроенными именами или зарезервированными словами –
это обычные атрибуты, которые отыскиваются интерпретатором в слу
чае появления объектов в различных контекстах. Как правило, интер
претатор вызывает их автоматически, но они могут вызываться и ва
шим программным кодом (подробнее об этом мы поговорим позднее –
метод __init__, например, часто вызывается вручную, с целью запус
тить конструктор суперкласса).
Обратите внимание, что метод __add__ создает и возвращает новый объ
ект экземпляра этого класса (вызывая ThirdClass, которому передается
значение результата), а метод __mul__ изменяет текущий объект эк
земпляра (выполняя присваивание атрибуту аргумента self). Такое
поведение отличается от поведения встроенных типов, таких как чис
ла и строки, которые всегда создают новые объекты при выполнении
оператора *. Поскольку перегрузка операторов – это в действительно
сти всего лишь механизм отображения выражений на методы, вы мо
a * 3
_mul_(self, other)
Рис. 23.3. Механизм перегрузки отображает операторы выражений
и другие встроенные операции, выполняемые над экземплярами классов,
на специальные имена методов в классе. Эти специальные методы являются
необязательными и могут наследоваться, как обычные методы. Здесь
использование оператора «*» приводит к вызову метода «__mul__»
Самый простой в мире класс на языке Python 589
жете интерпретировать операторы в своих объектах классов, как вам
будет угодно.1
C другой стороны, вы могли бы использовать перегрузку операторов,
чтобы иметь возможность передавать объекты, определяемые пользо
вателем, в функцию, которая выполняет операции, поддерживаемые
встроенными типами, такими как списки или словари. Наличие реа
лизации того же самого набора операторов в вашем классе обеспечит
поддержку вашими объектами тех же самых интерфейсов и, как след
ствие, совместимость с используемой функцией.
Один из методов перегрузки присутствует практически во всех реали
стичных классах: методконструктор __init__. Он позволяет классам не
медленно заполнять атрибуты вновь созданных экземпляров, поэтому
конструктор полезно использовать практически во всех разновидностях
ваших классов. Фактически даже при том, что в языке Python атрибуты
не объявляются, вы без труда сможете определить, какие атрибуты при
надлежат экземплярам, просмотрев программный код метода __init__.
В этой книге мы не будем углубляться в изучение этой расширенной осо
бенности, но мы еще будем рассматривать некоторые приемы использо
вания механизма наследования и перегрузки операторов в главе 24.
Самый простой в мире класс на языке Python
В этой главе мы приступили к детальному изучению синтаксиса инст
рукции class, но я еще раз хотел бы напомнить вам, что сама модель
наследования, на которой основаны классы, очень проста – суть ее за
ключается всего лишь в организации поиска атрибутов в деревьях
взаимосвязанных объектов. Фактически мы можем создавать вообще
пустые классы. Следующая инструкция создает класс без присоеди
ненных к нему атрибутов (объект пустого пространства имен):
>>> class rec: pass # Объект пустого пространства имен
Инструкция пустой операции pass (обсуждавшаяся в главе 13) необхо
дима потому, что здесь у нас нет никаких методов с программным ко
дом. После создания класса, выполнив инструкцию в интерактивной
оболочке, мы можем приступать к присоединению атрибутов, выпол
няя операции присваивания изза пределов класса:
>>> rec.name = 'Bob' # Так же для объектов с атрибутами
>>> rec.age = 40
1 Но лучше этого не делать. Обычная практика показывает, что перегружен
ные операторы должны работать так же, как и встроенные реализации.
В данном случае это означает, что метод __mul__ должен был бы возвращать
новый объект в виде результата, а не изменять существующий экземпляр
(self); для непосредственного изменения объекта лучше предусмотреть метод
mul, чем выполнять перегрузку оператора * (например, mul(3), вместо a*3).
590 Глава 23. Основы программирования классов
После того как атрибуты будут созданы, мы можем обращаться к ним
с помощью обычного синтаксиса. Когда класс используется таким спо
собом, он напоминает структуры в языке C или записи в языке Pascal –
объект с присоединенными к нему полями (то же самое можно проде
лывать с ключами словарей, но для этого потребуется вводить допол
нительные символы):
>>> print rec.name # Как структура в языке C или запись
Bob
Обратите внимание: такой подход будет работать даже в случае, когда
еще не было создано ни одного экземпляра класса. Классы – это полно
ценные объекты, даже если нет ни одного экземпляра. Фактически
они всего лишь самостоятельные пространства имен, поэтому, пока
у нас имеется ссылка на класс, мы можем в любое время добавлять
или изменять его атрибуты по своему усмотрению. Однако посмотрим,
что произойдет, когда будут созданы два экземпляра класса:
>>> x = rec() # Экземпляры наследуют имена из класса
>>> y = rec()
Эти экземпляры начинают свое существование как объекты абсолют
но пустых пространств имен. Однако изза того, что они помнят класс,
из которого были созданы, они по наследству получат атрибуты, кото
рые мы присоединили к классу:
>>> x.name, y.name # Сейчас имена хранятся только в классе
('Bob', 'Bob')
В действительности у этих экземпляров нет своих собственных атри
бутов – они просто получают атрибут name из класса. Тем не менее если
выполнить присваивание атрибуту экземпляра, будет создан (или из
менен) атрибут этого объекта, а не другого – атрибуты обнаруживают
ся в результате поиска по дереву наследования, но операция присваи
вания значения атрибуту воздействует только на тот объект, к которо
му эта операция применяется. Ниже экземпляр x получает свой собст
венный атрибут name, а экземпляр y попрежнему наследует атрибут
name, присоединенный к классу выше его:
>>> x.name = 'Sue' # Но присваивание изменит только объект x
>>> rec.name, x.name, y.name
('Bob', 'Sue', 'Bob')
Фактически, как будет более подробно рассказано в следующей главе,
атрибуты объекта пространства имен обычно реализованы в виде сло
варей, и деревья наследования классов (вообще говоря) тоже всего
лишь словари со ссылками на другие словари. Если знать, куда смот
реть, в этом можно убедиться явно. В большинстве объектов, создан
ных на базе классов, имеется атрибут __dict__, который является сло
варем пространства имен:
>>> rec.__dict__.keys()
['age', '__module__', '__doc__', 'name']
Самый простой в мире класс на языке Python 591
>>> x.__dict__.keys()
['name']
>>> y.__dict__.keys()
[]
Здесь в словаре класса присутствуют атрибуты name и age, которые мы
создали ранее, объект x имеет свой собственный атрибут name, а объект y
попрежнему пуст. Каждый экземпляр имеет ссылку на свой наследуе
мый класс, она называется __class__, если вам захочется проверить ее:
>>> x.__class__
<class __main__.rec at 0x00BAFF60>
Классы также имеют атрибут __base__, который представляет собой
кортеж его суперклассов – эти два атрибута описывают, как деревья
классов размещаются в памяти.
Главное, что следует из этого взгляда на внутреннее устройство, это то,
что модель классов в языке Python чрезвычайно динамична. Классы
и экземпляры – это всего лишь объекты пространств имен с атрибута
ми, создаваемыми на лету с помощью операции присваивания. Обыч
но эти операции присваивания выполняются внутри инструкции
class, но они могут находиться в любом другом месте, где имеется
ссылка на один из объектов в дереве.
Даже методы, которые обычно создаются инструкциями def, вложен
ными в инструкцию class, могут создаваться совершенно независимо
от объекта класса. Например, ниже определяется простая функция
вне какоголибо класса, которая принимает единственный аргумент:
>>> def upperName(self):
... return self.name.upper() # Аргумент self попрежнему необходим
Здесь еще ничего не говорится о классе – это простая функция, и она
может вызываться как обычная функция при условии, что объект, по
лучаемый ею, имеет атрибут name (в данном случае имя аргумента self
не имеет никакого особого смысла). Однако если эту простую функцию
присвоить атрибуту нашего класса, она станет методом, вызываемым
из любого экземпляра (а также через имя самого класса при условии,
что функции вручную будет передан экземпляр):1
1 Фактически это одна из причин, почему в языке Python аргумент self все
гда должен явно объявляться в методах, – потому что методы могут созда
ваться как простые функции, независимо от классов, и им необходим яв
ный аргумент со ссылкой на подразумеваемый экземпляр. В противном
случае интерпретатор не смог бы обеспечить превращение простой функции
в метод класса. Однако основная причина, по которой аргумент self объяв
ляется явно, заключается в том, чтобы сделать назначение имен более оче
видным. Имена, к которым обращаются не через аргумент self, являются
простыми переменными, тогда как имена, обращение к которым происхо
дит через аргумент self, очевидно являются атрибутами экземпляра.
592 Глава 23. Основы программирования классов
>>> rec.method = upperName
>>> x.method() # Вызвать метод для обработки x
'SUE'
>>> y.method() # То же самое, но в self передается y
'BOB'
>>> rec.method(x) # Можно вызвать через имя экземпляра или класса
'SUE'
Обычно заполнение классов производится внутри инструкции class,
а атрибуты экземпляров создаются в результате присваивания значе
ний атрибутам аргумента self в методах. Однако отметим снова, что
все это не является обязательным, поскольку ООП в языке Python –
это в основном поиск атрибутов во взаимосвязанных объектах про
странств имен.
В заключение
В этой главе были представлены основы программирования классов
в языке Python. Мы изучили синтаксис инструкции class и увидели,
как ее можно использовать для построения дерева классов. Мы также
узнали, что интерпретатор Python автоматически заполняет первый
аргумент методов, что атрибуты присоединяются к объектам в дереве
классов простым присваиванием и что существуют специальные име
на методов перегрузки операторов, позволяющие реализовать выпол
нение встроенных операций в наших объектах (например, операции
выражений и вывод).
В следующей главе мы продолжим изучение программирования клас
сов и повторно рассмотрим модель, чтобы восполнить недостающие
подробности, которые были опущены здесь для простоты. Мы также
приступим к исследованию нескольких больших классов, обладаю
щих большей практической ценностью. Однако для начала ответьте на
контрольные вопросы, чтобы освежить в памяти основы, которые бы
ли рассмотрены здесь.
Закрепление пройденного
Контрольные вопросы
1. Как классы связаны с модулями?
2. Как создаются классы и экземпляры классов?
3. Где и как создаются атрибуты классов?
4. Где и как создаются атрибуты экземпляров классов?
5. Что в языке Python означает слово self для классов?
Закрепление пройденного 593
6. Как производится перегрузка операторов в классах на языке Py
thon?
7. Когда может потребоваться перегрузка операторов в ваших клас
сах?
8. Какой метод перегрузки оператора используется наиболее часто?
9. Какие две концепции ООП являются наиболее важными в языке
Python?
Ответы
1. Классы всегда находятся внутри модулей – они являются атрибута
ми объекта модуля. Классы и модули являются пространствами
имен, но классы соответствуют инструкциям (а не целым файлам)
и поддерживают такие понятия ООП, как экземпляры класса, на
следование и перегрузка операторов. В некотором смысле модули
напоминают классы с единственным экземпляром, без наследова
ния, которые соответствуют целым файлам.
2. Классы создаются с помощью инструкций class, а экземпляры соз
даются вызовом класса, как если бы это была функция.
3. Атрибуты класса создаются присваиванием атрибутам объекта
класса. Обычно они создаются инструкциями верхнего уровня в ин
струкции class – каждое имя, которому будет присвоено значение
внутри инструкции class, становится атрибутом объекта класса
(с технической точки зрения область видимости инструкции class
преобразуется в пространство имен атрибутов объекта класса). Ат
рибуты класса могут также создаваться через присваивание атри
бутам класса в любом месте, где доступна ссылка на объект класса,
то есть даже за пределами инструкции class.
4. Атрибуты экземпляра создаются присваиванием атрибутам объек
та экземпляра. Обычно они создаются внутри методов класса, в ин
струкции class – присваиванием значений атрибутам аргумента
self (который всегда является подразумеваемым экземпляром). По
вторюсь: возможно создавать атрибуты с помощью операции при
сваивания в любом месте программы, где доступна ссылка на экзем
пляр, даже за пределами инструкции class. Обычно все атрибуты эк
земпляров инициализируются в конструкторе __init__ – благодаря
этому при последующих вызовах методов можно быть уверенным
в существовании необходимых атрибутов.
5. self – это имя, которое обычно дается первому (самому левому) ар
гументу в методах классов. Интерпретатор Python автоматически
записывает в него объект экземпляра, который подразумевается
при вызове метода. Этот аргумент не обязательно должен носить
имя self, главное – это положение аргумента. (Бывшие программи
сты на C++ или Java могут предпочесть использовать имя this, по
тому что в этих языках программирования это имя является отра
594 Глава 23. Основы программирования классов
жением той же идеи, только в языке Python этот аргумент всегда
должен присутствовать явно.)
6. Перегрузка операторов в языке Python выполняется с помощью ме
тодов со специальными именами – они начинаются и заканчивают
ся двумя символами подчеркивания. Эти имена не являются встро
енными или зарезервированными именами – интерпретатор Python
просто автоматически вызывает методы с этими именами, когда эк
земпляр появляется в составе соответствующей операции. Язык
Python определяет порядок отображения операций на специальные
имена методов.
7. Перегрузка операторов может использоваться для реализации объ
ектов, которые имитируют поведение встроенных типов (напри
мер, последовательностей или числовых объектов, таких как мат
рицы), и для реализации интерфейсов встроенных типов, которые
ожидают получить те или иные части программного кода. Кроме
того, имитация интерфейсов встроенных типов позволяет переда
вать в экземплярах классов информацию о состоянии – то есть ат
рибуты, в которых сохраняются данные между вызовами опера
ций. Однако не следует использовать перегрузку операторов, когда
достаточно использовать простые методы.
8. Наиболее часто используется метод конструктора __init__ – этот
метод присутствует практически во всех классах и используется
для установки начальных значений атрибутов экземпляров и вы
полнения других начальных операций.
9. Наиболее важными концепциями ООП в языке Python являются
аргумент self в методах и конструктор __init__.
24
Подробнее
о программировании классов
Если чтото в главе 23 осталось для вас непонятным, не волнуйтесь – те
перь, совершив краткий тур, мы начнем копать немного глубже и под
робно изучим понятия, представленные ранее. В этой главе мы с другой
стороны посмотрим на классы и методы, наследование и перегрузку
операторов, формализуем и дополним некоторые идеи программирова
ния классов, представленные в главе 23. Поскольку классы являются
нашим последним инструментом пространств имен, то здесь мы также
сведем вместе концепции пространств имен в языке Python. Кроме то
го, в этой главе будут представлены примеры более крупных и более
реалистичных классов, чем те, что мы видели до сих пор, в том числе
завершающий пример, который связывает воедино многое из того, что
мы узнали об ООП.
Инструкция class
Несмотря на то что на первый взгляд инструкция class в языке Python
напоминает похожие инструменты в других языках программирова
ния, при более близком рассмотрении видно, что она существенно от
личается от того, к чему привыкли некоторые программисты. Напри
мер, как и инструкция class в языке C++, инструкция class в языке
Python является основным инструментом ООП, но в отличие от инст
рукции в C++, в языке Python она не является объявлением. Подобно
инструкции def, инструкция class создает объект и является неявной
инструкцией присваивания – когда она выполняется, создается объ
ект класса, ссылка на который сохраняется в имени, использованном
в заголовке инструкции. Кроме того, как и инструкция def, инструк
ция class является настоящим выполняемым программным кодом –
класс не существует, пока поток выполнения не достигнет инструкции
596 Глава 24. Подробнее о программировании классов
class, которая определяет его (обычно при импортировании модуля,
в котором она находится, но не ранее).
Общая форма
Инструкция class – это составная инструкция, с блоком операторов,
обычно под строкой заголовка. В заголовке после имени в круглых
скобках через запятую перечисляются суперклассы. Наличие более
одного суперкласса в списке означает множественное наследование
(которое будет обсуждаться в следующей главе). Ниже показана об
щая форма инструкции:
class <name>(superclass,...): # Присваивание имени
data = value # Совместно используемые данные класса
def method(self,...): # Методы
self.member = value # Данные экземпляров
Внутри инструкции class любая операция присваивания создает атри
бут класса, а методы со специальными именами перегружают операто
ры. Например, функция с именем __init__, если она определена, вызы
вается во время создания объекта экземпляра.
Пример
Как мы уже видели, классы – это всего лишь пространства имен, то
есть инструменты, определяющие имена (атрибуты), с помощью кото
рых клиентам экспортируются данные и логика. Так как же инструк
ция class порождает пространство имен?
А вот как. Так же как и в модулях, инструкции, вложенные в тело ин
струкции class, создают атрибуты класса. Когда интерпретатор дости
гает инструкции class (а не тогда, когда происходит вызов класса), он
выполняет все инструкции в ее теле от начала и до конца. Все присваи
вания, которые производятся в течение этого процесса, создают имена
в локальной области видимости класса, которые становятся атрибу
тами объекта класса. Благодаря этому классы напоминают модули
и функции:
• Подобно функциям, инструкции class являются локальными об
ластями видимости, где располагаются имена, созданные вложен
ными операциями присваивания.
• Подобно именам в модуле, имена, созданные внутри инструкции
class, становятся атрибутами объекта класса.
Основное отличие классов состоит в том, что их пространства имен
также составляют основу механизма наследования в языке Python –
ссылки на атрибут, отсутствующие в классе или в объекте экземпляра,
будут получены из других классов.
Поскольку инструкция class – это составная инструкция, в ее тело мо
гут быть вложены любые инструкции – print, =, if, def и т. д. Все инст
Инструкция class 597
рукции внутри инструкции class выполняются, когда выполняется са
ма инструкция class (а не когда позднее класс вызывается для созда
ния экземпляра). Операции присваивания именам внутри инструкции
class создают атрибуты класса, а вложенные инструкции def создают
методы класса; кроме этого, атрибуты класса создаются и другими ин
струкциями, выполняющими присваивание.
Например, присваивание объекта, не являющегося функцией, атрибу
там создает атрибуты данных, совместно используемых всеми экзем
плярами:
>>> class SharedData:
... spam = 42 # Создает атрибут данных класса
...
>>> x = SharedData() # Создать два экземпляра
>>> y = SharedData()
>>> x.spam, y.spam # Они наследуют и совместно используют
# атрибут spam
(42, 42)
В данном случае изза того, что имя spam создается на верхнем уровне
в инструкции class, оно присоединяется к классу и поэтому совместно
используется всеми экземплярами. Мы можем изменять значение ат
рибута, выполняя присваивание через имя класса и обращаться к не
му через имена экземпляров или класса.1
>>> SharedData.spam = 99
>>> x.spam, y.spam, SharedData.spam
(99, 99, 99)
Такие атрибуты класса могут использоваться для хранения информа
ции, доступной всем экземплярам, например для хранения счетчика
количества созданных экземпляров (эту идею мы рассмотрим в главе
26). Теперь посмотрим, что произойдет, если присвоить значение ат
рибуту spam не через имя класса, а через имя экземпляра:
>>> x.spam = 88
>>> x.spam, y.spam, SharedData.spam
(88, 99, 99)
Операция присваивания, применяемая к атрибуту экземпляра, созда
ет или изменяет имя в экземпляре, а не в классе. Вообще говоря, поиск
в дереве наследования производится только при попытке чтения ат
рибута, но не при присваивании: операция присваивания атрибуту
1 Если у вас есть опыт работы с языком C++, вы можете заметить в этом не
которое сходство со «статическими» членами данных в языке С++ – члена
ми, которые хранятся в классе независимо от экземпляров. В языке Python
в этом нет ничего особенного: все атрибуты класса – это всего лишь имена,
созданные в инструкции class, независимо от того, ссылаются они на мето
ды («методы» в C++) или на чтото другое («члены» в C++).
598 Глава 24. Подробнее о программировании классов
объекта всегда изменяет сам объект, а не чтото другое.1 Например, ат
рибут y.spam будет найден в наследуемом классе, а операция присваи
вания атрибуту x.spam присоединит имя непосредственно к объекту x.
Ниже приводится более понятный пример этого поведения, где одно
и то же имя создается в двух местах. Предположим, что мы использу
ем следующий класс:
class MixedNames: # Определение класса
data = 'spam' # Присваивание атрибуту класса
def __init__(self, value): # Присваивание имени метода
self.data = value # Присваивание атрибуту экземпляра
def display(self):
print self.data, MixedNames.data # Атрибут экземпляра,
# атрибут класса
Этот класс содержит две инструкции def, которые связывают атрибу
ты класса с методами. Здесь также присутствует инструкция присваи
вания =. Так как эта инструкция выполняет присваивание имени data
внутри инструкции class, оно создается в локальной области видимо
сти класса и становится атрибутом объекта класса. Как и все атрибуты
класса, атрибут data наследуется и используется всеми экземплярами
класса, которые не имеют собственного атрибута data.
Когда создаются экземпляры этого класса, имя data присоединяется
к этим экземплярам через присваивание атрибуту self.data в конст
рукторе:
>>> x = MixedNames(1) # Создаются два объекта экземпляров
>>> y = MixedNames(2) # каждый из которых имеет свой атрибут data
>>> x.display(); y.display() # self.data  это другие атрибуты,
1 spam # а Subclass.data  тот же самый
2 spam
Суть этого примера состоит в том, что атрибут data находится в двух
разных местах: в объектах экземпляров (создаются присваиванием ат
рибуту self.data в методе __init__) и в классе, от которого они наследу
ют имена (создается присваиванием имени data в инструкции class).
Метод класса display выводит обе версии – сначала атрибут экземпля
ра self, а затем атрибут класса.
Используя этот прием сохранения атрибутов в различных объектах,
мы определяем их области видимости. Атрибуты классов совместно
используются всеми экземплярами, а атрибуты экземпляров уникаль
ны для каждого экземпляра – ни данные, ни поведение экземпляра не
доступны для совместного использования. Несмотря на то что опера
ция поиска в дереве наследования позволяет отыскивать имена, мы
1 При условии, что класс не переопределил операцию присваивания с помо
щью метода перегрузки оператора __setattr__ с целью выполнять какието
особые действия.
Методы 599
всегда можем получить доступ к ним в любой точке дерева, обратив
шись непосредственно к нужному объекту.
В предыдущем примере, например, выражения x.data и self.data воз
вращают атрибут экземпляра, которые переопределяют то же самое
имя в классе. Однако выражение MixedNames.data явно обращается к ат
рибуту класса. Позднее мы еще встретим подобные шаблоны програм
мирования, например следующий раздел описывает один из наиболее
часто используемых.
Методы
Вы уже знакомы с функциями и знаете о методах в классах. Методы –
это обычные объекты функций, которые создаются инструкциями def
в теле инструкции class. Говоря вкратце, методы реализуют поведе
ние, наследуемое объектами экземпляров. С точки зрения программи
рования методы работают точно так же, как и обычные функции, с од
ним важным исключением: в первом аргументе методам всегда пере
дается подразумеваемый объект экземпляра.
Другими словами, интерпретатор автоматически отображает вызов
метода экземпляра на метод класса следующим образом. Вызов метода
экземпляра:
instance.method(args...)
автоматически преобразуется в вызов метода класса:
class.method(instance, args...)
где класс определяется в результате поиска имени метода по дереву
наследования. Фактически в языке Python обе формы вызова метода
являются допустимыми.
Помимо обычного наследования имен методов, первый специальный
аргумент – это единственная необычная особенность методов. Первый
аргумент в методах классов обычно называется self, в соответствии
с общепринятыми соглашениями (с технической точки зрения само имя
не играет никакой роли, значение имеет позиция аргумента). Этот ар
гумент обеспечивает доступ к экземпляру, то есть к субъекту вызова –
поскольку из классов может создаваться множество объектов экземп
ляров, этот аргумент необходим для доступа к данным конкретного
экземпляра.
Программисты, знакомые с языком C++, сочтут, что аргумент self
в языке Python напоминает указатель this в языке C++. Однако в язы
ке Python имя self всегда явно используется в программном коде: ме
тоды всегда должны использовать имя self для получения или измене
ния атрибутов экземпляра, обрабатываемого текущим вызовом мето
да. Такая явная природа аргумента self предусмотрена намеренно –
присутствие этого имени делает очевидным использование имен атри
бутов экземпляра.
600 Глава 24. Подробнее о программировании классов
Пример
Чтобы пояснить эти концепции, обратимся к примеру. Предположим,
что имеется следующее определение класса:
class NextClass: # Определение класса
def printer(self, text): # Определение метода
self.message = text # Изменение экземпляра
print self.message # Обращение к экземпляру
Имя printer ссылается на объект функции, а так как оно создается в об
ласти видимости инструкции class, оно становится атрибутом объекта
класса и будет унаследовано всеми экземплярами, которые будут созда
ны из класса. Обычно методы, такие как printer, предназначены для
обработки экземпляров, поэтому мы вызываем их через экземпляры:
>>> x = NextClass() # Создать экземпляр
>>> x.printer('instance call') # Вызвать его метод
instance call
>>> x.message # Экземпляр изменился
'instance call'
Когда метод вызывается с использованием составного имени экземп
ляра, как в данном случае, то сначала определяется местонахождение
метода printer, а затем его аргументу self автоматически присваивает
ся объект экземпляра (x). В аргумент text записывается строка, пере
данная в вызов метода ('instance call'). Обратите внимание, что Py
thon автоматически передает в первом аргументе self ссылку на сам
экземпляр, поэтому нам достаточно передать методу только один аргу
мент. Внутри метода printer имя self используется для доступа к дан
ным конкретного экземпляра, потому что оно ссылается на текущий
обрабатываемый экземпляр.
Методы могут вызываться любым из двух способов – через экземпляр
или через сам класс. Например, метод printer может быть вызван с ис
пользованием имени класса, явно передавая при этом экземпляр в ар
гументе self:
>>> NextClass.printer(x, 'class call') # Прямой вызов метода класса
class call
>>> x.message # Экземпляр снова изменился
'class call'
Вызов метода, который производится через экземпляр и через имя
класса, оказывает одинаковое воздействие при условии, что при вызо
ве через имя класса передается тот же самый экземпляр. По умолча
нию, если попытаться вызвать метод без указания экземпляра, будет
выведено сообщение об ошибке:
>>> NextClass.printer('bad call')
TypeError: unbound method printer() must be called with NextClass instance...
Методы 601
(TypeError: несвязанный метод printer() должен вызываться с экземпляром
NextClass...)
Вызов конструкторов суперклассов
Обычно методы вызываются через экземпляры. Тем не менее вызовы
методов через имя класса могут играть особую роль. Одна из таких ро
лей связана с вызовом конструктора. Метод __init__ наследуется точно
так же, как и любые другие атрибуты. Это означает, что во время соз
дания экземпляра интерпретатор отыскивает только один метод
__init__. Если в конструкторе подкласса необходимо гарантировать
выполнение действий, предусматриваемых конструктором суперклас
са, необходимо явно вызвать метод __init__ через имя класса:
class Super:
def __init__(self, x):
...программный код по умолчанию...
class Sub(Super):
def __init__(self, x, y):
Super.__init__(self, x) # Вызов метода __init__ суперкласса
...адаптированный код... # Выполнить дополнительные действия
I = Sub(1, 2)
Это один из немногих случаев, когда вашему программному коду по
требуется явно вызывать метод перегрузки оператора. Естественно,
вызывать конструктор суперкласса таким способом следует, только
если это действительно необходимо – без этого вызова подкласс полно
стью переопределяет данный метод. Более реалистичный случай при
менения этого приема приводится в заключительном примере этой
главы.1
Другие возможности методов
Такой способ вызова методов через имя класса представляет собой ос
нову для расширения (без полной замены) поведения унаследованных
методов. В главе 26 мы познакомимся с еще одной возможностью, до
бавленной в Python 2.2, статическими методами, которые не пред
полагают наличие объекта экземпляра в первом аргументе. Такие ме
тоды могут действовать как обычные функции, имена которых явля
ются локальными по отношению к классам, где они были определены.
Однако это дополнительное расширение не является обязательным –
обычно нам всегда бывает необходимо передавать экземпляр методам,
вызываемым либо через сам экземпляр, либо через имя класса.
1 Небольшое замечание: внутри одного и того же класса можно определить
несколько методов с именем __init__, но использоваться будет только по
следнее определение. Дополнительные подробности приводятся в главе 25.
602 Глава 24. Подробнее о программировании классов
Наследование
Основное назначение такого инструмента пространств имен, как инст
рукция class, заключается в обеспечении поддержки наследования
имен. В этом разделе мы подробно остановимся на вопросах, связан
ных с механизмами наследования атрибутов в языке Python.
В языке Python наследование включается в игру после того, как объект
квалифицирован, и заключается в операции поиска в дереве определе
ний атрибутов (в одном или более пространствах имен). Каждый раз,
когда используется выражение вида object.attr (где object – это объект
экземпляра или класса), интерпретатор приступает к поиску первого
вхождения атрибута attr в дереве пространств имен снизу вверх, начи
ная с объекта object. Сюда относятся и ссылки на атрибуты аргумента
self внутри методов. Поскольку самые нижние определения в дереве
наследования переопределяют те, что находятся выше, механизм на
следования составляет основу специализации программного кода.
Создание дерева атрибутов
На рис. 24.1 приводятся способы, которыми создаются и заполняются
именами деревья пространств имен. Вообще:
• Атрибуты экземпляров создаются посредством присваивания атри
бутам аргумента self в методах.
Экземпляр
Объекты Программа
Суперкласс Суперкласс
Класс
class X(S1, S2):
def attr(self,...):
self.attr = V
class S1:
class S2:
object = X()
object.attr?
Рис. 24.1. Программный код создает дерево наследования объектов
в памяти, в котором будет выполняться поиск атрибутов. Вызов класса
создает новый экземпляр, который помнит, к какому классу он принадлежит.
Инструкция class, в заголовке которой в круглых скобках перечислены
суперклассы, создает новый класс. Каждое обращение к атрибуту вызывает
новую процедуру поиска в дереве наследования снизу вверх – даже обращения
к атрибутам аргумента self в методах класса
Наследование 603
• Атрибуты классов создаются инструкциями (присваивания), рас
положенными внутри инструкции class.
• Ссылки на суперклассы создаются путем перечисления классов
в круглых скобках в заголовке инструкции class.
Результатом является дерево пространств имен с атрибутами, которое
ведет в направлении от экземпляров к классам, из которых они были
созданы, и ко всем суперклассам, перечисленным в заголовке инст
рукции class. Интерпретатор выполняет поиск в дереве в направлении
снизу вверх, от экземпляров к суперклассам, всякий раз, когда ис
пользуемое имя подразумевает атрибут объекта экземпляра.1
Специализация унаследованных методов
Только что описанная модель поиска в дереве наследования представ
ляет собой прекрасный способ специализации программ. Поскольку
механизм наследования сначала пытается отыскать имена в подклас
сах и только потом в их суперклассах, подклассы могут изменять пове
дение по умолчанию, предусматриваемое атрибутами их суперклассов.
Фактически можно создавать целые системы как иерархии классов,
возможности которых расширяются за счет добавления новых под
классов, а не за счет изменения существующего программного кода.
Идея переопределения унаследованных имен приводит к множеству
приемов специализации. Например, подклассы могут полностью заме+
щать унаследованные атрибуты, предоставлять атрибуты, которые
ожидается отыскать в суперклассах, и расширять методы суперклас
са за счет их вызова из методов подкласса. Мы уже видели прием с за
мещением в действии. Ниже приводится пример, демонстрирующий,
как выполняется расширение:
>>> class Super:
... def method(self):
... print 'in Super.method'
...
>>> class Sub(Super):
... def method(self): # Переопределить метод
... print 'starting Sub.method' # Дополнительное действие
... Super.method(self) # Выполнить действие по умолчанию
... print 'ending Sub.method'
...
Главное здесь – это прямые вызовы методов суперкласса. Класс Sub за
мещает метод method класса Super своей собственной, специализирован
1 Это описание далеко не полное, потому что точно так же возможно созда
вать атрибуты экземпляров и классов с помощью инструкций присваива
ния за пределами инструкций class – но этот прием используется сущест
венно реже и зачастую более подвержен ошибкам (изменения не изолирова
ны от инструкций class) . В языке Python все атрибуты всегда доступны по
умолчанию – более подробно о сокрытии данных мы поговорим в главе 26.
604 Глава 24. Подробнее о программировании классов
ной версией. Но внутри замещающего метода в классе Sub производит
ся вызов версии, экспортируемой классом Super, чтобы выполнить дей
ствия по умолчанию. Другими словами, метод Sub.method не замещает
полностью метод Super.method, а просто расширяет его:
>>> x = Super() # Создать экземпляр класса Super
>>> x.method() # Вызвать Super.method
in Super.method
>>> x = Sub() # Создать экземпляр класса Sub
>>> x.method() # Вызвать Sub.method, который вызовет Super.method
starting Sub.method
in Super.method
ending Sub.method
Этот прием расширения также часто используется в конструкторах, за
примерами обращайтесь к предыдущему разделу «Методы».
Приемы организации взаимодействия классов
Расширение – это лишь один из способов организации взаимодействий
с суперклассом. В файле ниже, specialize.py, определяется несколько
классов, которые иллюстрируют различные приемы использования
классов:
Super
Определяет метод method и метод delegate, который предполагает на
личие метода action в подклассе.
Inheritor
Не предоставляет никаких новых имен, поэтому он получает все,
что определено только в классе Super.
Replacer
Переопределяет метод method класса Super своей собственной версией.
Extender
Адаптирует метод method класса Super, переопределяя и вызывая
его, чтобы выполнить действия, предусмотренные по умолчанию.
Provider
Реализует метод action, который ожидается методом delegate клас
са Super.
Рассмотрим каждый из этих классов, чтобы получить представление
о способах, которыми они адаптируют свой общий суперкласс. Содер
жимое самого файла приводится ниже:
class Super:
def method(self):
print 'in Super.method' # Поведение по умолчанию
def delegate(self):
self.action() # Ожидаемый метод
Наследование 605
class Inheritor(Super): # Наследует методы, как они есть
pass
class Replacer(Super): # Полностью замещает method
def method(self):
print 'in Replacer.method'
class Extender(Super): # Расширяет поведение метода method
def method(self):
print 'starting Extender.method'
Super.method(self)
print 'ending Extender.method'
class Provider(Super): # Определяет необходимый метод
def action(self):
print 'in Provider.action'
if __name__ == '__main__':
for klass in (Inheritor, Replacer, Extender):
print '\n' + klass.__name__ + '...'
klass().method()
print '\nProvider...'
x = Provider()
x.delegate()
Здесь следует отметить несколько моментов. Программный код тести
рования модуля в конце примера создает экземпляры трех разных
классов в цикле for. Поскольку классы – это объекты, можно помес
тить их в кортеж и создавать экземпляры единообразным способом
(подробнее об этой идее рассказывается ниже). Кроме всего прочего,
классы, как и модули, имеют атрибут __name__ – он содержит строку
с именем класса, указанным в заголовке инструкции class. Ниже по
казано, что произойдет, если запустить файл:
% python specialize.py
Inheritor...
in Super.method
Replacer...
in Replacer.method
Extender...
starting Extender.method
in Super.method
ending Extender.method
Provider...
in Provider.action
Абстрактные суперклассы
Обратите внимание, как работает класс Provider в предыдущем приме
ре. Когда через экземпляр класса Provider вызывается метод delegate,
инициируются две независимые процедуры поиска:
606 Глава 24. Подробнее о программировании классов
1. При вызове x.delegate интерпретатор отыскивает метод delegate
в классе Super, начиная поиск от экземпляра класса Provider и дви
гаясь вверх по дереву наследования. Экземпляр x передается мето
ду в виде аргумента self, как обычно.
2. Внутри метода Super.delegate выражение self.action приводит к за
пуску нового, независимого поиска в дереве наследования, начиная
от экземпляра self и дальше вверх по дереву. Поскольку аргумент
self ссылается на экземпляр класса Provider, метод action будет
найден в подклассе Provider.
Такой способ «восполнения пробелов» в реализации – обычное дело
для платформ ООП. По крайней мере, в терминах метода delegate такие
суперклассы, как в этом примере, иногда называют абстрактными су+
перклассами – классы, которые предполагают, что часть их функцио
нальности будет реализована их подклассами. Если ожидаемый метод
не определен в подклассе, интерпретатор возбудит исключение с сооб
щением о неопределенном имени, когда поиск в дереве наследования
завершится неудачей. Разработчики классов иногда делают такие тре
бования к подклассам более очевидными с помощью инструкций assert
или возбуждая встроенное исключение NotImplementedError:
class Super:
def method(self):
print 'in Super.method'
def delegate(self):
self.action()
def action(self):
assert 0, 'action must be defined!'
Мы познакомимся с инструкцией assert в главе 27, а пока лишь заме
чу, что если выражение возвращает ложь, она возбуждает исключение
с сообщением об ошибке. В данном случае выражение всегда возвра
щает ложь (0), чтобы вызвать появление об ошибке, если метод не бу
дет переопределен и поиск по дереву наследования остановится на
этой версии. В некоторых классах, напротив, в таких методахзаглуш
ках исключение NotImplementedError возбуждается напрямую. Инст
рукцию возбуждения исключений raise мы рассмотрим в главе 27.
Более реалистичный пример использования концепций, представлен
ных в этом разделе, вы найдете в упражнении 8 в конце главы 26 и в ре
шении этого упражнения в разделе «Часть VI, Классы и ООП» (прило
жение B). Такое частичное наследование является традиционным спо
собом введения в ООП, но оно постепенно исчезает из арсенала многих
разработчиков.
Перегрузка операторов
Перегрузку операторов мы коротко рассмотрели в предыдущей главе,
а здесь мы обсудим все более детально и рассмотрим несколько наиболее
Перегрузка операторов 607
часто используемых методов перегрузки. Ниже приводится краткий
обзор ключевых идей, лежащих в основе механизма перегрузки:
• Перегрузка операторов в языке Python позволяет классам участво
вать в обычных операциях.
• Классы в языке Python могут перегружать все операторы выраже
ний.
• Классы могут также перегружать такие операции, как вывод, вы
зов функций, обращение к атрибутам и т. д.
• Перегрузка делает экземпляры классов более похожими на встро
енные типы.
• Перегрузка заключается в реализации в классах методов со специ
альными именами.
Рассмотрим простой пример перегрузки в действии. Если в классе при
сутствуют определенные методы со специальными именами, интерпре
татор автоматически будет вызывать их при появлении экземпляров
класса в выражениях, выполняющих перегруженные операции. На
пример, класс Number в следующем файле number.py реализует метод пе
регрузки операции создания экземпляра (__init__), а также метод реа
лизации операции вычитания (__sub__). Специальные методы, такие
как эти, позволяют перехватывать и выполнять встроенные операции:
class Number:
def __init__(self, start): # Вызов Number(start)
self.data = start
def __sub__(self, other): # Выражение: экземпляр – другой
return Number(self.data  other) # Результат – новый экземпляр
>>> from number import Number # Извлечь класс из модуля
>>> X = Number(5) # Number.__init__(X, 5)
>>> Y = X 
 2 # Number.__sub__(X, 2)
>>> Y.data # Y – новый экземпляр класса Number
3
Как уже обсуждалось ранее, конструктор __init__, присутствующий
в этом примере, – это наиболее часто используемый метод перегрузки
оператора в языке Python, потому что он присутствует в большинстве
классов. В этом разделе мы изучим некоторые другие инструменты,
связанные с перегрузкой, и рассмотрим наиболее типичные примеры
их использования.
Общие методы перегрузки операторов
Почти все, что можно делать с объектами встроенных типов, такими
как целые числа и списки, можно реализовать и в классах – с помощью
специальных методов перегрузки операторов. В табл. 24.1 перечисле
ны наиболее часто используемые, но на самом деле их намного больше.
На деле многие методы перегрузки существуют в нескольких версиях
(например, __add__, __radd__ и __iadd__ для сложения). Исчерпывающий
608 Глава 24. Подробнее о программировании классов
список имен специальных методов вы найдете в других книгах, посвя
щенных языку Python, и в справочных руководствах.
Таблица 24.1. Общие методы перегрузки операторов
Все методы перегрузки имеют имена, начинающиеся и заканчиваю
щиеся двумя символами подчеркивания, что отличает их от других
имен, которые вы обычно определяете в своих классах. Отображение
операторов выражений или операций на методы со специальными
именами предопределяется языком Python (и описывается в стандарт
ном руководстве по языку). Например, по определению языка опера
тор + всегда отображается на имя __add__ независимо от того, что в дей
ствительности делает метод __add__.
Все методы перегрузки операторов являются необязательными – если
какойто метод не реализован, это лишь означает, что соответствующая
ему операция не поддерживается классом (а при попытке применить
такую операцию возбуждается исключение). Большинство методов пе
регрузки операторов используются только при решении специальных
Метод Перегружает Вызывается
__init__ Конструктор При создании объекта: X = Class()
__del__ Деструктор При уничтожении объекта
__add__ Оператор + X + Y, X += Y
__or__ Оператор | (побитовое ИЛИ) X | Y, X |= Y
__repr__,
__str__
Вывод, преобразование print X, repr(X), str(X)
__call__ Вызовы функций X()
__getattr__ Обращение к атрибуту X.undefined
__setattr__ Присваивание атрибутам X.any = value
__getitem__ Доступ к элементу по ин
дексу
X[key], циклы for и другие конст
рукции итерации, при отсутствии
метода __iter__
__setitem__ Присваивание элементу по
индексу
X[key] = value
__len__ Длина len(X), проверка истинности
__cmp__ Сравнение X == Y, X < Y
__lt__ Специальное сравнение X < Y (в ином случае __cmp__)
__eq__ Специальное сравнение X == Y (в ином случае __cmp__)
__radd__ Правосторонний оператор + Не_экземпляр + X
__iadd__ Добавление (увеличение) X += Y (в ином случае __add__)
__iter__ Итерационный контекст Циклы for, оператор in, генерато
ры списков, map и другие
Перегрузка операторов 609
задач, когда необходимо, чтобы объекты имитировали поведение встро
енных типов, однако конструктор __init__ присутствует в большинст
ве классов. Мы уже познакомились с конструктором __init__, который
вызывается на этапе инициализации, и с несколькими другими, пере
численными в табл. 24.1. Теперь мы исследуем примеры использова
ния некоторых других методов из таблицы.
_ _getitem_ _ реализует доступ к элементам по индексу
Метод __getitem__ реализует операции доступа к элементам по индек
су. Когда экземпляр X появляется в выражении извлечения элемента
по индексу, таком как X[i], интерпретатор Python вызывает метод
__getitem__, наследуемый этим экземпляром (если он имеется), переда
вая методу объект X в первом аргументе и индекс в квадратных скоб
ках во втором аргументе. Например, следующий класс возвращает
квадрат значения индекса:
>>> class indexer:
... def __getitem__(self, index):
... return index ** 2
...
>>> X = indexer()
>>> X[2] # Выражение X[i] вызывает __getitem__(X, i).4
>>> for i in range(5):
... print X[i],
...
0 1 4 9 16
_ _getitem_ _ и _ _iter_ _ реализуют итерации
Здесь описывается прием, который не всегда очевиден для начинаю
щих программистов, но на практике может оказаться необычайно по
лезным. Инструкция for многократно применяет операцию индекси
рования к последовательности, используя индексы от нуля и выше,
пока не будет получено исключение выхода за границы. Благодаря
этому метод __getitem__ представляет собой один из способов перегруз
ки итераций в языке Python – если этот метод реализован, инструкции
циклов for будут вызывать его на каждом шаге цикла, с постоянно
увеличивающимся значением смещения. Это один из случаев, когда
«купив один предмет, другой получаешь в подарок», – любой встроен
ный или определяемый пользователем объект, к которому применима
операция индексирования, также может участвовать в итерациях:
>>> class stepper:
... def __getitem__(self, i):
... return self.data[i]
...
>>> X = stepper() # X – это экземпляр класса stepper
>>> X.data = "Spam"
>>>
610 Глава 24. Подробнее о программировании классов
>>> X[1] # Индексирование, вызывается __getitem__
'p'
>>> for item in X: # циклы for вызывают __getitem__
... print item, # for индексирует элементы 0..N
...
S p a m
Фактически это случай, когда «купив один предмет, в подарок полу
чаешь целую связку». Любой класс, поддерживающий циклы for, ав
томатически поддерживает все итерационные контексты, имеющиеся
в языке Python, многие из которых мы видели в более ранних главах
(другие итерационные контексты описываются в главе 13). Напри
мер, оператор проверки на принадлежность in, генераторы списков,
встроенная функция map, присваивание списков и кортежей и конст
рукторы типов также автоматически вызывают метод __getitem__, ес
ли он определен:
>>> 'p' in X # Во всех этих случаях вызывается __getitem__
1
>>> [c for c in X] # Генератор списков
['S', 'p', 'a', 'm']
>>> map(None, X) # Функция map
['S', 'p', 'a', 'm']
>>> (a, b, c, d) = X # Присваивание последовательностей
>>> a, c, d
('S', 'a', 'm')
>>> list(X), tuple(X), ''.join(X)
(['S', 'p', 'a', 'm'], ('S', 'p', 'a', 'm'), 'Spam')
>>> X
<__main__.stepper instance at 0x00A8D5D0>
На практике этот прием может использоваться для создания объектов,
которые реализуют интерфейс последовательностей, и для добавления
логики к операциям над встроенными типами – мы рассмотрим эту
идею, когда будем расширять встроенные типы в главе 26.
Итераторы, определяемые пользователями
В настоящее время все итерационные контексты в языке Python пыта
ются сначала использовать метод __iter__ и только потом – метод
__getitem__. То есть при выполнении обхода элементов объекта пред
почтение отдается итерационному протоколу, с которым мы познако
мились в главе 13, – если итерационный протокол не поддерживается
объектом, вместо него используется операция индексирования.
С технической точки зрения итерационные контексты вызывают
встроенную функцию iter, чтобы определить наличие метода __iter__,
который должен возвращать объект итератора. Если он предоставля
Перегрузка операторов 611
ется, то интерпретатор Python будет вызывать метод next объекта ите
ратора для получения элементов до тех пор, пока не будет возбуждено
исключение StopIteration. Если метод __iter__ отсутствует, интерпре
татор переходит на использование схемы с использованием метода
__getitem__ и начинает извлекать элементы по индексам, пока не будет
возбуждено исключение IndexError.
В новой схеме классы реализуют итераторы простой реализацией ите
рационного протокола, представленного в главах 13 и 17 (за дополни
тельной информацией об итераторах возвращайтесь к этим главам).
Например, в следующем файле iters.py определяется класс итератора,
который возвращает квадраты чисел:
class Squares:
def __init__(self, start, stop): # Сохранить состояние при создании
self.value = start  1
self.stop = stop
def __iter__(self): # Возвращает итератор в iter()
return self
def next(self): # Возвращает квадрат в каждой итерации
if self.value == self.stop:
raise StopIteration
self.value += 1
return self.value ** 2
% python
>>> from iters import Squares
>>> for i in Squares(1, 5): # for вызывает iter(),
который вызывает __iter__()
... print i, # на каждой итерации вызывается next()
...
1 4 9 16 25
Здесь объект итератора – это просто экземпляр self, поэтому метод
next является частью этого класса. В более сложных ситуациях объект
итератора может быть определен как отдельный класс и объект со сво
ей собственной информацией о состоянии, с целью поддержки не
скольких активных итераций на одних и тех же данных (совсем скоро
мы рассмотрим это на примере). Об окончании итераций интерпрета
тору сообщается с помощью инструкции raise (подробнее о возбужде
нии исключений рассказывается в следующей части книги).
Эквивалентная реализация с использованием __getitem__ может ока
заться менее естественной, потому что цикл for явно выполняет пере
бор всех смещений от нуля и выше; смещения, передаваемые методу,
могут оказаться связаны с диапазоном воспроизводимых значений
лишь косвенно (диапазон 0..N может потребоваться отображать на
диапазон start..stop). Поскольку объекты, возвращаемые методом
__iter__, явно манипулируют информацией о своем состоянии и сохра
няют ее между вызовами метода next, такая реализация может быть
более универсальной, чем использование метода __getitem__.
612 Глава 24. Подробнее о программировании классов
C другой стороны, итераторы, реализованные на основе метода
__iter__, иногда могут оказаться более сложными и менее удобными,
чем метод __getitem__. Но они действительно предназначены для ите
раций, а не для случайной индексации – фактически, они вообще не
перегружают операцию индексирования:
>>> X = Squares(1, 5)
>>> X[1]
AttributeError: Squares instance has no attribute '__getitem__'
(AttributeError: экземпляр Squares не имеет атрибута '__getitem__')
Схема на основе метода __iter__ реализована также во всех остальных
итерационных контекстах, к которыс применим метод __getitem__
(проверка на вхождение, конструкторы, присваивание последователь
ностей и т. д.). Однако, в отличие от __getitem__, схема на основе мето
да __iter__ предназначена для выполнения обхода элементов один раз,
а не несколько. Например, элементы класса Squares можно обойти все
го один раз – для каждой последующей итерации необходимо будет
создавать новый объект итератора:
>>> X = Squares(1, 5)
>>> [n for n in X] # Получить все элементы
[1, 4, 9, 16, 25]
>>> [n for n in X] # Теперь объект пуст
[]
>>> [n for n in Squares(1, 5)] # Создать новый объект итератора
[1, 4, 9, 16, 25]
>>> list(Squares(1, 3))
[1, 4, 9]
Примечательно, что этот пример можно было бы реализовать проще,
применив функциигенераторы (которые имеют отношение к итерато
рам и были представлены в главе 17):
>>> from __future__ import generators # Требуется только в Python 2.2
>>>
>>> def gsquares(start, stop):
... for i in range(start, stop+1):
... yield i ** 2
...
>>> for i in gsquares(1, 5):
... print i,
...
1 4 9 16 25
В отличие от класса, функция автоматически сохраняет информацию
о своем состоянии между итерациями. Конечно, для реализации тако
го искусственного примера можно было бы вообще не использовать ни
один из этих приемов, а просто использовать цикл for, функцию map
или генератор списков, чтобы создать сразу весь список. Нередко са
мый лучший и самый быстрый способ в языке Python оказывается еще
и самым простым:
Перегрузка операторов 613
>>> [x ** 2 for x in range(1, 6)]
[1, 4, 9, 16, 25]
Однако реализация на базе классов может оказаться лучше при моде
лировании более сложных итераций, особенно когда возможность со
хранения информации о состоянии и наследование могут принести су
щественную выгоду. Один из таких случаев исследуется в следующем
разделе.
Несколько итераторов в одном объекте
Ранее я упоминал, что объект итератора может быть определен как от
дельный класс, со своей собственной информацией о состоянии, что
обеспечивает поддержку протекания нескольких итерационных про
цессов с одним и тем же набором данных. Посмотрим, что происходит
при выполнении обхода элементов встроенных типов, таких как строка:
>>> S = 'ace'
>>> for x in S:
... for y in S:
... print x + y,
...
aa ac ae ca cc ce ea ec ee
Здесь внешний цикл получает итератор строки вызовом функции iter,
и каждый вложенный цикл делает то же самое, чтобы получить незави
симый итератор. Так как каждый итератор хранит свою собственную
информацию о состоянии, каждый цикл управляет своим собственным
положением в строке, независимо от любых других активных циклов.
Чтобы добиться того же эффекта в итераторах, определяемых пользо
вателем, метод __iter__ должен не просто возвращать аргумент self,
а создавать новый объект итератора со своей информацией о состоянии.
Например, в следующем примере определяется класс итератора, кото
рый пропускает каждый второй элемент. Поскольку объект итератора
создается заново для каждой итерации, он обеспечивает поддержку
нескольких активных циклов одновременно:
class SkipIterator:
def __init__(self, wrapped):
self.wrapped = wrapped # Информация о состоянии
self.offset = 0
def next(self):
if self.offset >= len(self.wrapped): # Завершить итерации
raise StopIteration
else:
item = self.wrapped[self.offset] # иначе перешагнуть и вернуть
self.offset += 2
return item
class SkipObject:
def __init__(self, wrapped): # Сохранить элемент,
self.wrapped = wrapped # который будет использоваться
614 Глава 24. Подробнее о программировании классов
def __iter__(self):
return SkipIterator(self.wrapped) # Каждый раз новый итератор
if __name__ == '__main__':
alpha = 'abcdef'
skipper = SkipObject(alpha) # Создать объектконтейнер
I = iter(skipper) # Создать итератор для него
print I.next(), I.next(), I.next() # Обойти элементы 0, 2, 4
for x in skipper: # for вызывает __iter__ автоматически
for y in skipper: # Вложенные циклы for также вызывают __iter__
print x + y, # Каждый итератор помнит свое состояние, смещение
Этот пример работает подобно вложенным циклам со строками – каж
дый активный цикл запоминает свое положение в строке, потому что
каждый из них получает независимый объект итератора, который
хранит свою собственную информацию о состоянии:
% python skipper.py
a c e
aa ac ae ca cc ce ea ec ee
Наш более ранний пример класса Squares, напротив, поддерживал все
го одну активную итерацию, нужно было во вложенных циклах вызы
вать Squares снова, чтобы получить новый объект. Здесь у нас имеется
единственный объект SkipObject, который создает множество объектов
итераторов.
Как и прежде, подобных результатов можно было бы достичь с исполь
зованием встроенных инструментов, например с помощью операции
получения среза с третьим граничным значением, чтобы организовать
пропуск элементов:
>>> S = 'abcdef'
>>> for x in S[::2]:
... for y in S[::2]: # Новые объекты в каждой итерации
... print x + y,
...
aa ac ae ca cc ce ea ec ee
Однако это далеко не то же самое по двум причинам. Вопервых, каж
дое выражение извлечения среза физически сохраняет весь список
с результатами в памяти, тогда как итераторы воспроизводят по одному
значению за раз, что позволяет существенно экономить память в случае
большого объема результатов. Вовторых, операции извлечения среза
создают новые объекты, поэтому в действительности итерации не про
текают одновременно в одном и том же объекте. Чтобы оказаться бли
же к реализации на основе классов, нам необходимо было бы создать
единственный объект для обхода, заранее выполнив операцию извле
чения среза:
>>> S = 'abcdef'
>>> S = S[::2]
Перегрузка операторов 615
>>> S
'ace'
>>> for x in S:
... for y in S: # Тот же самый объект, новые итераторы
... print x + y,
...
aa ac ae ca cc ce ea ec ee
Эта реализация больше похожа на наше решение, выполненное с помо
щью классов, но здесь попрежнему список с результатами целиком
хранится в памяти (на сегодняшний день не существует генераторов,
способных формировать срезы), и эта реализация эквивалентна только
для данного конкретного случая пропуска каждого второго элемента.
Итераторы могут выполнять любые действия, которые можно реали
зовать в классах, поэтому они обладают более широкими возможно
стями, чем предполагается в данном примере. Независимо от того,
требуется ли такая широта возможностей в наших приложениях, ите
раторы, определяемые пользователем, представляют собой мощный
инструмент – они позволяют создавать произвольные объекты, кото
рые выглядят и ведут себя подобно другим последовательностям и ите
рируемым объектам, с которыми мы встречались в этой книге. Мы
могли бы использовать этот механизм, например, для создания объек
та базы данных, чтобы одновременно выполнять несколько итераций
в одном и том же наборе данных, извлеченном в результате запроса
к базе данных.
_ _getattr_ _ и _ _setattr_ _ перехватывают
обращения к атрибутам
Метод __getattr__ выполняет операцию получения ссылки на атрибут.
Если говорить более определенно, он вызывается с именем атрибута
в виде строки всякий раз, когда обнаруживается попытка получить
ссылку на неопределенный (несуществующий) атрибут. Этот метод не
вызывается, если интерпретатор может обнаружить атрибут посредст
вом выполнения процедуры поиска в дереве наследования. Вследствие
этого метод __getattr__ удобно использовать для универсальной обра
ботки запросов к атрибутам. Например:
>>> class empty:
... def __getattr__(self, attrname):
... if attrname == "age":
... return 40
... else:
... raise AttributeError, attrname
...
>>> X = empty()
>>> X.age
40
>>> X.name
616 Глава 24. Подробнее о программировании классов
...текст сообщения об ошибке опущен...
AttributeError: name
В этом примере класс и его экземпляр X не имеют своих собственных
атрибутов, поэтому при обращении к атрибуту X.age вызывается метод
__getattr__ – в аргументе self передается экземпляр (X), а в аргументе
attrname – строка с именем неопределенного атрибута ("age"). Класс вы
глядит так, как если бы он действительно имел атрибут age, возвращая
результат обращения к имени X.age (40).В результате получается атри
бут, вычисляемый динамически.
Для атрибутов, обработка которых классом не предусматривается,
возбуждается встроенное исключение AttributeError, чтобы сообщить
интерпретатору, что это действительно неопределенные имена, – по
пытка обращения к имени X.name приводит к появлению ошибки. Вы
еще раз встретитесь с методом __getattr__, когда мы будем рассматри
вать делегирование и свойства в действии в следующих двух главах,
а об исключениях я подробно буду рассказывать в седьмой части книги.
Родственный ему метод перегрузки __setattr__ перехватывает все по
пытки присваивания значений атрибутам. Если этот метод определен,
выражение self.attr = value будет преобразовано в вызов метода
self.__setattr_('attr', value). Работать с этим методом немного слож
нее, потому что любая попытка выполнить присваивание любому атри
буту аргумента self приводит к повторному вызову метода __setattr__,
вызывая бесконечный цикл рекурсивных вызовов (и, в конечном ито
ге, исключение переполнения стека!). Если вам потребуется использо
вать этот метод, все присваивания в нем придется выполнять посредст
вом словаря атрибутов, как описывается в следующем разделе. Ис
пользуйте self.__dict__['name'] = x, а не self.name = x:
>>> class accesscontrol:
... def __setattr__(self, attr, value):
... if attr == 'age':
... self.__dict__[attr] = value
... else:
... raise AttributeError, attr + ' not allowed'
...
>>> X = accesscontrol()
>>> X.age = 40 # Вызовет метод __setattr__
>>> X.age
40
>>> X.name = 'mel'
...текст сообщения об ошибке опущен...
AttributeError: name not allowed
Эти два метода перегрузки операций доступа к атрибутам позволяют
контролировать или специализировать доступ к атрибутам в ваших
объектах. Они могут играть весьма специфические роли, часть из ко
торых мы рассмотрим далее в этой книге.
Перегрузка операторов 617
Имитация частных атрибутов экземпляра
Следующий фрагмент является обобщением предыдущего примера
и позволяет каждому подклассу иметь свой перечень частных имен ат
рибутов, которым нельзя присваивать значения:
class PrivateExc(Exception): pass # Подробнее об исключениях позднее
class Privacy:
def __setattr__(self, attrname, value): # Вызывает self.attrname = value
if attrname in self.privates:
raise PrivateExc(attrname, self)
else:
self.__dict__[attrname] = value # Self.attrname = value
# вызовет зацикливание!
class Test1(Privacy):
privates = ['age']
class Test2(Privacy):
privates = ['name', 'pay']
def __init__(self):
self.__dict__['name'] = 'Tom'
x = Test1()
y = Test2()
x.name = 'Bob'
y.name = 'Sue' # <== ошибка
y.age = 30
x.age = 40 # <== ошибка
Фактически это лишь первая прикидочная реализация частных атри
бутов в языке Python (то есть запрет на изменение атрибутов вне клас
са). Несмотря на то что язык Python не поддерживает возможность
объявления частных атрибутов, такие приемы, как этот, могут их ими
тировать. Однако это лишь половинчатое решение – чтобы сделать его
более эффективным, его необходимо дополнить возможностью изме
нять значения частных атрибутов из подклассов и использовать метод
__getattr__ и классобертку (иногда называется проксиклассом), что
бы контролировать получение значений частных атрибутов.
Полную реализацию я оставлю как упражнение для самостоятельного
решения, потому что хотя таким способом можно имитировать сокры
тие атрибутов, это практически никогда не используется. Программи
сты, использующие язык Python, способны писать крупные объектно
ориентированные платформы без частных объявлений, но существую
щие интересные решения по управлению доступом далеко выходят за
рамки нашего обсуждения.
Перехват операций обращения к атрибутам и присваивания им значе
ний – вообще очень полезный прием. Он обеспечивает возможность де+
легирования – способ, позволяющий обертывать встроенные объекты
объектамиконтроллерами, добавлять новое поведение и делегировать
618 Глава 24. Подробнее о программировании классов
выполнение операций обернутым объектам (подробнее о делегирова
нии и классахобертках рассказывается в следующей главе).
_ _repr_ _ и _ _str_ _ возвращают строковое представление
В следующем примере реализованы конструктор __init__ и метод пере
грузки __add__, которые мы уже видели, но также в нем реализован ме
тод __repr__, который возвращает строковое представление экземпля
ров. Здесь этот метод используется для преобразования объекта self.da
ta в строку. Если метод __repr__ (или родственный ему метод __str__) оп
ределен, он автоматически будет вызываться при попытках вывести
экземпляр класса или преобразовать его в строку. Эти методы позволя
ют определить более удобочитаемый формат вывода ваших объектов:
>>> class adder:
... def __init__(self, value=0):
... self.data = value # Инициализировать атрибут data
... def __add__(self, other):
... self.data += other # Прибавить другое значение
...
>>> class addrepr(adder): # Наследует __init__, __add__
... def __repr__(self): # Добавляет строковое представление
... return 'addrepr(%s)' % self.data # Преобразует в строку
... # программного кода
>>> x = addrepr(2) # Вызывает __init__
>>> x + 1 # Вызывает __add__
>>> x # Вызывает __repr__
addrepr(3)
>>> print x # Вызывает __repr__
addrepr(3)
>>> str(x), repr(x) # Вызывает __repr__
('addrepr(3)', 'addrepr(3)')
Почему имеется два метода вывода? Дело в том, что сначала выполня
ется попытка использовать метод __str__, чтобы вывести объект в удоб
ном для пользователя виде, как это делают инструкция print и встроен
ная функция str. Метод __repr__ должен возвращать строку, которая
могла бы использоваться как программный код для воссоздания объек
та, – он используется при автоматическом выводе результатов выраже
ний в интерактивной оболочке и в функции repr. Если метод __str__ от
сутствует, интерпретатор использует метод __repr__ (но не наоборот):
>>> class addstr(adder):
... def __str__(self): # есть __str__, но нет метода __repr__
... return '[Value: %s]' % self.data # Преобразовать в красивую строку
...
>>> x = addstr(3)
>>> x + 1
>>> x # По умолчанию вызывается repr
<__main__.addstr instance at 0x00B35EF0>
>>> print x # Вызывает __str__
Перегрузка операторов 619
[Value: 4]
>>> str(x), repr(x)
('[Value: 4]', '<__main__.addstr instance at 0x00B35EF0>')
Вследствие этого, если вам необходимо обеспечить единое отображение
во всех контекстах, лучше использовать метод __repr__. Однако, опреде
лив оба метода, вы обеспечите поддержку вывода в различных контек
стах. Например, перед конечным пользователем объект будет отобра
жаться с помощью метода __str__, а перед программистом будет выво
диться информация более низкого уровня с помощью метода __repr__:
>>> class addboth(adder):
... def __str__(self):
... return '[Value: %s]' % self.data # Удобочитаемая строка
... def __repr__(self):
... return 'addboth(%s)' % self.data # Строка программного кода
...
>>> x = addboth(4)
>>> x + 1
>>> x # Вызывает __repr__
addboth(5)
>>> print x # Вызывает __str__
[Value: 5]
>>> str(x), repr(x)
('[Value: 5]', 'addboth(5)')
Похоже, что метод __str__ (и его низкоуровневый родственник __repr__)
является вторым по частоте использования после __init__ среди методов
перегрузки операторов в сценариях на языке Python – всякий раз, когда
вам приходится видеть адаптированное отображение при выводе объек
та, это значит, что скорее всего был использован один из этих методов.
_ _radd_ _ обрабатывает правостороннее сложение
C технической точки зрения метод __add__, который использовался
в примерах выше, не поддерживает использование объектов экземп
ляров справа от оператора +. Чтобы реализовать поддержку таких вы
ражений и тем самым обеспечить допустимость перестановки операн
дов, необходимо создать метод __radd__. Интерпретатор вызывает ме
тод __radd__, только когда экземпляр вашего класса появляется справа
от оператора +, а объект слева не является экземпляром вашего класса.
Во всех других случаях, когда объект появляется слева, вызывается
метод __add__:
>>> class Commuter:
... def __init__(self, val):
... self.val = val
... def __add__(self, other):
... print 'add', self.val, other
... def __radd__(self, other):
... print 'radd', self.val, other
...
620 Глава 24. Подробнее о программировании классов
>>> x = Commuter(88)
>>> y = Commuter(99)
>>> x + 1 # __add__: экземпляр + не_экземпляр
add 88 1
>>> 1 + y # __radd__: не_экземпляр + экземпляр
radd 99 1
>>> x + y # __add__: экземпляр + не_экземпляр
add 88 <__main__.Commuter instance at 0x0086C3D8>
Обратите внимание на изменение порядка следования операндов в вы
зове метода __radd__: аргумент self в действительности находится спра
ва от оператора +, а аргумент other – слева. Любой двухместный опера
тор имеет похожий правосторонний метод перегрузки (например,
__mul__ и __rmul__). Обычно правосторонний метод, такой как __radd__,
просто изменяет порядок следования операндов и повторно выполняет
операцию сложения, чтобы вызвать метод __add__, в котором находит
ся основная реализация операции. Кроме того, следует заметить, что
здесь x и y – это экземпляры одного и того же класса – когда в выраже
нии участвуют экземпляры разных классов, интерпретатор предпочи
тает вызывать метод экземпляра, расположенного слева.
Правосторонние методы – это достаточно сложная тема, и на практике
они используются очень редко – к ним требуется обращаться только
в том случае, когда необходимо обеспечить для оператора возмож
ность перестановки операндов, и если вообще необходима реализация
поддержки этого оператора. Например, эти методы могут использо
ваться в классе Vector, но в таких классах, как Employee или Button, ско
рее всего, они не нужны.
_ _call_ _ обрабатывает вызовы
Метод __call__ вызывается при вызове вашего экземпляра. Это не повто
ряющееся определение – если метод __call__ присутствует, интерпрета
тор будет вызывать его, когда экземпляр вызывается как функция. Это
позволяет экземплярам классов имитировать поведение функций:
>>> class Prod:
... def __init__(self, value):
... self.value = value
... def __call__(self, other):
... return self.value * other
...
>>> x = Prod(2)
>>> x(3)
6
>>> x(4)
8
В этом примере реализация метода __call__ может показаться ненуж
ной. То же самое поведение можно реализовать с помощью простого
метода:
Перегрузка операторов 621
>>> class Prod:
... def __init__(self, value):
... self.value = value
... def comp(self, other):
... return self.value * other
...
>>> x = Prod(3)
>>> x.comp(3)
9
>>> x.comp(4)
12
Однако метод __call__ может оказаться удобнее при взаимодействии
с прикладными интерфейсами, где ожидается функция, – это позволя
ет создавать объекты, совместимые с ожидающими получить функцию
интерфейсами, которые к тому же способны сохранять информацию
о своем состоянии между вызовами. Фактически этот метод занимает
третье место среди наиболее часто используемых методов перегрузки
операторов – после конструктора __init__ и методов форматирования
__str__ и __repr__.
Функциональные интерфейсы и программный
код обратного вызова
Инструментальный набор для создания графического интерфейса
Tkinter, с которым мы познакомимся далее в этой книге, позволяет ре
гистрировать функции как обработчики событий (они же – функции
обратного вызова); когда возникают какиелибо события, Tkinter вы
зывает зарегистрированные объекты. Если вам необходимо реализо
вать обработчик событий, способный сохранять свое состояние между
вызовами, вы можете зарегистрировать либо связанный метод класса,
либо экземпляр класса, который с помощью метода __call__ обеспечи
вает совместимость с функциональным интерфейсом. В программном
коде этого раздела оба варианта – x.comp из второго примера и экземп
ляр x из первого – могут передаваться в виде объектов функций.
В следующей главе я более подробно расскажу о связанных методах,
а пока разберем гипотетический пример использования метода __call__
для построения графического интерфейса. Следующий класс опреде
ляет объект, поддерживающий функциональный интерфейс, и, кроме
того, имеет информацию о состоянии, сохраняя цвет, в который долж
на окрашиваться нажатая кнопка:
class Callback:
def __init__(self, color): # Функция + информация о состоянии
self.color = color
def __call__(self): # Поддерживает вызовы без аргументов
print 'turn', self.color
Теперь мы можем зарегистрировать экземпляры этого класса в контек
сте графического интерфейса как обработчики событий для кнопок,
622 Глава 24. Подробнее о программировании классов
несмотря на то что реализация графического интерфейса предполагает
вызывать обработчики событий как обычные функции без аргументов:
cb1 = Callback('blue') # 'Запомнить' голубой цвет
cb2 = Callback('green')
B1 = Button(command=cb1) # Зарегистрировать обработчик
B2 = Button(command=cb2) # Зарегистрировать обработчик
Когда позднее кнопка будет нажата, объект экземпляра будет вызван
как простая функция, точно как в следующих ниже вызовах. А по
скольку он сохраняет информацию о состоянии в атрибутах экземпля
ра, он помнит, что необходимо сделать:
cb1() # По событию: выведет 'blue'
cb2() # Выведет 'green'
Фактически это один из лучших способов сохранения информации
о состоянии в языке Python – он намного лучше способов, обсуждав
шихся ранее и применявшихся к функциям (глобальные переменные,
ссылки в область видимости объемлющей функции и изменяемые аргу
менты со значениями по умолчанию). Благодаря ООП состояние можно
сохранять явно, посредством присваивания значений атрибутам.
Прежде чем двинуться дальше, рассмотрим еще два способа, которые
используются программистами для сохранения информации о состоя
нии в функциях обратного вызова. В первом варианте используется
lambdaфункция с аргументами, имеющими значения по умолчанию:
cb3 = (lambda color='red': 'turn ' + color) # Или: по умолчанию
print cb3()
Во втором используются связанные методы класса и некий объект, ко
торый запоминает экземпляр self и ссылку на функцию, так что потом
можно вызывать простую функцию без использования экземпляра:
class Callback:
def __init__(self, color): # Класс с информацией о состоянии
self.color = color
def changeColor(self): # Обычный именованный метод
print 'turn', self.color
cb1 = Callback('blue')
cb2 = Callback('yellow')
B1 = Button(command=cb1.changeColor) # Ссылка, не вызов
B2 = Button(command=cb2.changeColor) # Запоминаются функция+self
Когда позднее кнопка будет нажата, имитируется поведение графиче
ского интерфейса и вызывается метод changeColor, который обработает
информацию о состоянии объекта:
object = Callback('blue')
cb = object.changeColor # Регистрация обработчика событий
cb() # По событию выведет 'blue'
Перегрузка операторов 623
Этот прием является более простым, но менее универсальным, чем пе
регрузка операции вызова с помощью метода __call__. Еще раз напом
ню, что подробнее о связанных методах будет рассказываться в сле
дующей главе.
Кроме того, в главе 26 будет представлен еще один пример использова
ния метода __call__, который будет использоваться для реализации
так называемого декоратора функции – вызываемого объекта, добав
ляющего уровень логики поверх внедренной функции. Поскольку ме
тод __call__ позволяет присоединять информацию о состоянии к вызы
ваемым объектам, этот прием является естественным для реализации
функций, которые должны запоминать и вызывать другие функции.
_ _del_ _ – это деструктор
Конструктор __init__ вызывается во время создания экземпляра. Проти
воположный ему метод __del__ вызывается автоматически, когда освобо
ждается память, занятая объектом (то есть во время «сборки мусора»):
>>> class Life:
... def __init__(self, name='unknown'):
... print 'Hello', name
... self.name = name
... def __del__(self):
... print 'Goodbye', self.name
...
>>> brian = Life('Brian')
Hello Brian
>>> brian = 'loretta'
Goodbye Brian
Здесь, когда переменной brian присваивается строка, теряется послед
няя ссылка на экземпляр класса Life, что приводит к вызову деструк
тора. Этот метод удобно использовать для реализации некоторых за
вершающих действий (таких как завершение соединения с сервером).
Однако в языке Python по целому ряду причин деструкторы использу
ются не так часто, как в других объектноориентированных языках
программирования.
С одной стороны, интерпретатор автоматически освобождает память, за
нятую экземпляром, поэтому нет нужды выполнять очистку памяти
в деструкторах.1 С другой стороны, не всегда бывает возможным пред
сказать, когда произойдет уничтожение экземпляра, поэтому часто луч
1 В текущей реализации Python на языке C кроме всего прочего нет необхо
димости закрывать файлы в деструкторах, потому что они автоматически
закрываются при уничтожении объектов файлов. Однако, как упомина
лось в главе 9, лучше всетаки явно закрывать файлы, потому что «автома
тическое закрытие при уничтожении объекта» – это особенность реализа
ции, а не самого языка (в Jython это поведение может отличаться).
624 Глава 24. Подробнее о программировании классов
ше выполнять завершающие действия в явно вызываемом методе (или
в инструкции try/finally, которая описывается в следующей части кни
ги) – в некоторых случаях в системных таблицах могут сохраняться
ссылки на ваши объекты, что будет препятствовать вызову деструктора.
Я привел достаточно много примеров использования перегрузки опе
раторов. Большая часть других методов перегрузки работают похо
жим образом, и все они – всего лишь ловушки для перехвата встроен
ных операций. Некоторые методы перегрузки, например, имеют уни
кальные списки аргументов или возвращаемые значения. Далее в кни
ге вы увидите еще несколько примеров, но полный охват этой темы
я оставляю за другими источниками информации.
Пространства имен: окончание истории
Теперь, когда мы уже исследовали объекты классов и экземпляров,
повествование о пространствах имен в языке Python можно считать за
вершенным. Для справки я напомню здесь все правила, используемые
при разрешении имен. Первое, что вам нужно запомнить: составные
и простые имена интерпретируются поразному, и некоторые области
видимости служат для инициализации пространств имен объектов:
• Простые имена (например, X) располагаются в областях видимости.
• Составные имена атрибутов (например, object.X) принадлежат объ
ектам пространств имен.
• Некоторые области видимости инициализируют пространства имен
объектов (в модулях и классах).
Простые имена: глобальные, пока не выполняется
присваивание
Поиск неполных простых имен выполняется в соответствии с правилом
лексической видимости LEGB, выведенном для функций в главе 16:
Присваивание (X = value)
Операция присваивания делает имена локальными: создает или из
меняет имя X в текущей локальной области видимости, если имя не
объявлено глобальным.
Ссылка (X)
Пытается отыскать имя X в текущей локальной области видимости,
затем в области видимости каждой из вмещающих функций, затем
в текущей глобальной области видимости и, наконец, во встроен
ной области видимости.
Имена атрибутов: пространства имен объектов
Полные (составные) имена атрибутов ссылаются на атрибуты конкрет
ных объектов и к ним применяются правила, предназначенные для
Пространства имен: окончание истории 625
модулей и классов. Для объектов классов и экземпляров эти правила
дополняются включением процедуры поиска в дереве наследования:
Присваивание (object.X = value)
Создает или изменяет атрибут с именем X в пространстве имен объ
екта object, и ничего больше. Восхождение по дереву наследования
происходит только при попытке получить ссылку на атрибут, но не
при выполнении операции присваивания.
Ссылка (object.X)
Для объектов, созданных на основе классов, поиск атрибута X про
изводится сначала в объекте object, затем во всех классах, располо
женных выше в дереве наследования. В случае объектов, которые
создаются не из классов, таких как модули, атрибут X извлекается
непосредственно из объекта object.
«Дзен» пространств имен в Python: классификация
имен происходит при присваивании
Изза различий в процедурах поиска простых и составных имен и не
скольких уровней поиска в обеих процедурах иногда бывает трудно
сказать, где будет найдено имя. В языке Python место, где выполняет
ся присваивание, имеет крайне важное значение – оно полностью оп
ределяет область видимости или объект, где будет размещаться имя.
Файл manynames.py ниже иллюстрирует, как эти принципы перево
дятся в программный код, и обобщает идеи, касающиеся пространств
имен, с которыми мы встречались на протяжении книги:
# manynames.py
X = 11 # Глобальное (в модуле) имя/атрибут (X, или manynames.X)
def f():
print X # Обращение к глобальному имени X (11)
def g():
X = 22 # Локальная (в функции) переменная (X, скрывает имя X в модуле)
print X
class C:
X = 33 # Атрибут класса (C.X)
def m(self):
X = 44 # Локальная переменная в методе (X)
self.X = 55 # Атрибут экземпляра (instance.X)
В этом файле пять раз выполняется присваивание одному и тому же
имени X. Однако, так как присваивание выполняется в пяти разных
местах, все пять имен X в этой программе представляют совершенно
разные переменные. Сверху вниз присваивание имени X приводит
к созданию: атрибута модуля (11), локальной переменной в функции
(22), атрибута класса (33), локальной переменной в методе (44) и атри
бута экземпляра (55). Все пять переменных имеют одинаковые имена,
626 Глава 24. Подробнее о программировании классов
однако они создаются в разных местах программного кода или в раз
ных объектах, что делает их уникальными переменными.
Не следует торопиться тщательно изучать этот пример, потому что в нем
собраны идеи, которые мы исследовали на протяжении последних не
скольких частей этой книги. Когда до вас дойдет его смысл, вы достиг
нете своего рода нирваны пространств имен в языке Python. Конечно,
существует и другой путь к нирване – просто запустите программу
и посмотрите, что произойдет. Ниже приводится остаток этого файла,
где создается экземпляр и выводятся значения всех имеющихся пере
менных X:
# manynames.py, продолжение
if __name__ == '__main__':
print X # 11: модуль (за пределами файла manynames.X)
f() # 11: глобальная
g() # 22: локальная
print X # 11: переменная модуля не изменилась
obj = C() # Создать экземпляр
print obj.X # 33: переменная класса, унаследованная экземпляром
obj.m() # Присоединить атрибут X к экземпляру
print obj.X # 55: экземпляр
print C.X # 33: класс (она же obj.X, если в экземпляре нет X)
#print c.m.X # ОШИБКА: видима только в методе
#print f.X # ОШИБКА: видима только в функции
В комментариях отмечено, что будет выведено на экран после запуска
этого файла, – прочитайте их, чтобы увидеть, к какой переменной X вы
полняется обращение в том или ином случае. Обратите также внима
ние, что мы можем добраться до атрибута класса (C.X), но мы никогда
не сможем получить доступ к локальным переменным в функциях или
методах вне соответствующих инструкций def. Локальные переменные
видимы только программному коду внутри инструкции def и существу
ют в памяти только во время выполнения функции или метода.
Некоторые из имен, определяемых этим файлом, видимы и за преде
лами файла, в других модулях, но не забывайте, что мы всегда долж
ны сначала выполнять операцию импортирования, чтобы получить
доступ к именам в другом файле – в конце концов, в этом заключается
главная особенность модулей.
# otherfile.py
import manynames
X = 66
Print X # 66: здешняя глобальная переменная
print manynames.X # 11: глобальная, ставшая атрибутом в результате импорта
manynames.f() # 11: X в manynames, не здешняя глобальная!
manynames.g() # 22: локальная в функции, в другом файле
Пространства имен: окончание истории 627
print manynames.C.X # 33: атрибут класса в другом модуле
I = manynames.C()
print I.X # 33: все еще атрибут класса
I.m()
print I.X # 55: а теперь атрибут экземпляра!
Обратите внимание, что manynames.f() выводит значение переменной X
из модуля manynames, а не переменной из текущего модуля – область ви
димости всегда определяется местоположением инструкции присваи
вания в программном коде (то есть лексически) и не зависит от того,
что импортируется и куда импортируется. Кроме того, обратите внима
ние, что собственный атрибут X в экземпляре отсутствовал, пока не был
вызван метод I.m() – атрибуты, как и любые другие переменные, появ
ляются на свет во время операции присваивания, а не до нее. Обычно
атрибуты экземпляра создаются за счет присваивания им начальных
значений в конструкторе __init__, но это не единственная возможность.
Конечно, вы не должны использовать одно и то же имя для обозначе
ния всех переменных в своем сценарии! Но этот пример демонстриру
ет, что если даже вы поступите так, пространства имен в языке Python
предотвратят случайный конфликт имен, используемых в одном кон
тексте, с именами, используемыми в другом контексте.
Словари пространств имен
В главе 19 мы узнали, что пространства имен модулей фактически реа
лизуются как словари и доступны в виде встроенного атрибута
__dict__. То же относится к объектам классов и экземпляров: обраще
ние к составному имени атрибута фактически является операцией дос
тупа к элементу словаря, а механизм наследования атрибута работает
лишь как поиск в связанных словарях. Фактически объекты экземп
ляра и класса – это в значительной степени просто словари со ссылка
ми, ведущими вглубь интерпретатора. Интерпретатор Python обеспе
чивает возможность доступа к этим словарям, а также к ссылкам меж
ду ними для использования в особых случаях (например, при созда
нии инструментальных средств).
Чтобы понять внутреннее устройство атрибутов, давайте с помощью ин
терактивной оболочки проследим, как растут словари пространств имен,
когда в игру вступают классы. Сначала определим суперкласс и под
класс с методами, которые сохраняют данные в своих экземплярах:
>>> class super:
... def hello(self):
... self.data1 = 'spam'
...
>>> class sub(super):
... def hola(self):
... self.data2 = 'eggs'
...
628 Глава 24. Подробнее о программировании классов
Когда мы создаем экземпляр подкласса, он начинает свое существова
ние с пустым словарем пространства имен, но имеет ссылку на класс,
стоящий выше в дереве наследования. Фактически дерево наследова
ния доступно в виде специальных атрибутов, которые вы можете прове
рить. В экземплярах имеется атрибут __class__, который ссылается на
класс, а классы имеют атрибут __bases__, который является кортежем,
содержащим ссылки на суперклассы выше в дереве наследования:
>>> X = sub()
>>> X.__dict__
{ }
>>> X.__class__
<class __main__.sub at 0x00A48448>
>>> sub.__bases__
(<class __main__.super at 0x00A3E1C8>,)
>>> super.__bases__
()
Так как в классах выполняется присваивание атрибутам аргумента
self, тем самым они заполняют объекты экземпляров, то есть атрибу
ты включаются в словари пространств имен экземпляров, но не клас
сов. В пространство имен объекта экземпляра записываются данные,
которые могут отличаться для разных экземпляров, и аргумент self
является точкой входа в это пространство имен:
>>> Y = sub()
>>> X.hello()
>>> X.__dict__
{'data1': 'spam'}
>>> X.hola()
>>> X.__dict__
{'data1': 'spam', 'data2': 'eggs'}
>>> sub.__dict__
{'__module__': '__main__', '__doc__': None, 'hola': <function hola at
0x00A47048>}
>>> super.__dict__
{'__module__': '__main__', 'hello': <function hello at 0x00A3C5A8>,
'__doc__': None}
>>> sub.__dict__.keys(), super.__dict__.keys()
(['__module__', '__doc__', 'hola'], ['__module__', 'hello', '__doc__'])
>>> Y.__dict__
{ }
Обратите внимание на имена в словарях классов, содержащие симво
лы подчеркивания, – эти имена определяются интерпретатором авто
матически. Большинство из них обычно не используются в програм
Пространства имен: окончание истории 629
мах, но существуют такие инструменты, которые используют некото
рые из этих имен (например, __doc__ хранит строки документирова
ния, обсуждавшиеся в главе 14).
Кроме того, обратите внимание, что второй экземпляр Y, созданный
в начале сеанса, попрежнему имеет пустой словарь пространства
имен несмотря на то, что словарь экземпляра X заполнялся инструк
циями присваивания в методах. Напомню еще раз, что у каждого эк
земпляра имеется свой, независимый словарь, который изначально
пуст и может быть заполнен совершенно другими атрибутами, чем
пространства имен других экземпляров того же самого класса.
Так как атрибуты фактически являются ключами словаря, существу
ет два способа получать и изменять их значения – по составным име
нам или индексированием по ключу:
>>> X.data1, X.__dict__['data1']
('spam', 'spam')
>>> X.data3 = 'toast'
>>> X.__dict__
{'data1': 'spam', 'data3': 'toast', 'data2': 'eggs'}
>>> X.__dict__['data3'] = 'ham'
>>> X.data3
'ham'
Однако такая эквивалентность применяется только к атрибутам, фак
тически присоединенным к экземпляру. Так как обращение по состав
ному имени также вызывает запуск процедуры поиска в дереве насле
дования, такой способ может обеспечить доступ к атрибутам, которые
нельзя получить индексированием словаря. Например, унаследован
ный атрибут X.hello недоступен через выражение X.__dict__['hello'].
Наконец, ниже показано, что дает применение функции dir, с которой
мы встречались в главах 4 и 14, к объектам экземпляров. Эта функция
применяется к объектам, имеющим атрибуты: dir(object), напомина
ет вызов object.__dict__.keys(). Однако обратите внимание, что функ
ция dir сортирует свой список и включает в него некоторые системные
атрибуты – начиная с версии Python 2.2, функция dir также автомати
чески собирает унаследованные атрибуты:1
>>> X.__dict__
{'data1': 'spam', 'data3': 'ham', 'data2': 'eggs'}
1 Содержимое словарей атрибутов и результаты вызова функции dir могут
отличаться. Например, т.к. теперь интерпретатор позволяет встроенным
типам классифицировать себя как классы, для встроенных типов функция
dir включает информацию о методах перегрузки операторов. Вообще, име
на атрибутов, начинающиеся и завершающиеся двумя символами подчер
кивания, являются особенностью интерпретатора. Подклассы типов будут
рассматриваться в главе 26.
630 Глава 24. Подробнее о программировании классов
>>> X.__dict__.keys()
['data1', 'data3', 'data2']
>>>> dir(X)
['__doc__', '__module__', 'data1', 'data2', 'data3', 'hello', 'hola']
>>> dir(sub)
['__doc__', '__module__', 'hello', 'hola']
>>> dir(super)
['__doc__', '__module__', 'hello']
Поэкспериментируйте самостоятельно с этими специальными атрибу
тами, чтобы получить представление о том, как в действительности ве
дется работа с атрибутами. Даже если вы никогда не будете использо
вать их в своих программах, понимание того, что пространства имен –
это всего лишь обычные словари, поможет лишить покрова таинствен
ности само понятие пространств имен.
Ссылки на пространства имен
В предыдущем разделе были представленны атрибуты экземпляра
и класса __class__ и __bases__, но не объяснялось, зачем они могут по
надобиться. В двух словах, эти атрибуты позволяют осматривать ие
рархии наследования в вашем программном коде. Например, их мож
но использовать для отображения дерева классов на экране, как в сле
дующем примере:
# classtree.py
def classtree(cls, indent):
print '.'*indent, cls.__name__ # Вывести имя класса
for supercls in cls.__bases__: # Рекурсивный обход всех суперклассов
classtree(supercls, indent+3) # Каждый суперкласс может быть
# посещен более одного раза
def instancetree(inst):
print 'Tree of', inst # Показать экземпляр
classtree(inst.__class__, 3) # Взойти к его классу
def selftest():
class A: pass
class B(A): pass
class C(A): pass
class D(B,C): pass
class E: pass
class F(D,E): pass
instancetree(B())
instancetree(F())
if __name__ == '__main__': selftest()
Функция classtree в этом сценарии является рекурсивной – она выво
дит имя класса, используя атрибут __name__, и затем начинает подъем
к суперклассам, вызывая саму себя. Это позволяет функции выпол
нять обход деревьев классов произвольной формы – в процессе рекур
Более реалистичный пример 631
сии выполняется подъем по дереву и заканчивается по достижении
корневых суперклассов, у которых атрибут __bases__ пуст. Большую
часть этого файла занимает программный код самотестирования – ес
ли запустить файл как самостоятельный сценарий, он построит пустое
дерево классов, создаст в нем два экземпляра и выведет структуры
классов, соответствующие им:
% python classtree.py
Tree of <__main__.B instance at 0x00ACB438>
... B
...... A
Tree of <__main__.F instance at 0x00AC4DA8>
... F
...... D
......... B
............ A
......... C
............ A
...... E
Отступы, отмеченные точками, обозначают высоту в дереве классов.
Конечно, мы могли бы улучшить формат вывода и даже отобразить де
рево в графическом интерфейсе.
Мы можем импортировать эти функции везде, где нам может потребо
ваться быстро отобразить дерево классов:
>>> class Emp: pass
...
>>> class Person(Emp): pass
...
>>> bob = Person()
>>> import classtree
>>> classtree.instancetree(bob)
Tree of <__main__.Person instance at 0x00AD34E8>
... Person
...... Emp
Независимо от того, будете вы создавать и использовать нечто подобное
в своей практике или нет, этот пример демонстрирует один из многих
способов использования специальных атрибутов, которые создаются
внутренними механизмами интерпретатора. Еще один пример вы уви
дите в разделе «Множественное наследование» в главе 25, где будет
реализован класс общего назначения для получения списка атрибутов.
Более реалистичный пример
Большая часть примеров, которые мы видели до сих пор, были искус
ственными и ограниченными и были предназначены, чтобы помочь
вам сосредоточить свое внимание на основах. Однако мы закончим эту
главу большим примером, в котором воедино собирается многое из то
632 Глава 24. Подробнее о программировании классов
го, что мы уже изучили. Я включил этот пример по большей части как
упражнение для самостоятельного изучения – попробуйте вниматель
но прочитать программный код примера и понять, как разрешаются
вызовы методов.
Если говорить двух словах, следующий модуль, person.py, определяет
три класса:
• GenericDisplay – это смешанный класс, который предоставляет уни
версальный метод __str__; для любого класса, который будет насле
довать его, данный метод возвращает строку, содержащую имя
класса, из которого был создан данный экземпляр, а также пары
«имя = значение» для всех атрибутов в дереве наследования. Для
построения списка пар «имя = значение» он использует атрибут
пространства имен __dict__. А для определения имени класса ис
пользуется встроенный атрибут __name__ атрибута экземпляра
__class__. Так как инструкция print вызывает метод __str__, при вы
воде всех экземпляров, наследующих поведение этого класса, будет
использован собственный формат вывода. Это общий инструмент.
• Person хранит общую информацию о человеке и предоставляет два
метода, которые используются для изменения информации о со
стоянии объекта. Кроме того, от своего суперкласса он наследует
логику вывода в нестандартном формате. Экземпляр класса Person
имеет два атрибута и два метода, управляющие этим классом.
• Employee – это адаптация класса Person, которая наследует извлече
ние отчества и вывод в нестандартном формате, а также добавляет
новый метод, с помощью которого выполняется увеличение зарпла
ты служащего, и переопределяет операцию изменения возраста
(очевидно, служащие стареют быстрее, чем другие люди). Обратите
внимание, что конструктор суперкласса вызывается вручную – нам
необходимо выполнить версию суперкласса, чтобы заполнить атри
буты name и age.
По мере изучения программного кода этого модуля вы увидите, что ка
ждый экземпляр имеет свою собственную информацию о состоянии.
Обратите внимание, как используется наследование для адаптации
поведения и как используется перегрузка операторов для инициализа
ции и вывода экземпляров:
# person.py
class GenericDisplay:
def gatherAttrs(self):
attrs = '\n'
for key in self.__dict__:
attrs += '\t%s=%s\n' % (key, self.__dict__[key])
return attrs
def __str__(self):
return '<%s: %s>' % (self.__class__.__name__, self.gatherAttrs())
class Person(GenericDisplay):
Более реалистичный пример 633
def __init__(self, name, age):
self.name = name
self.age = age
def lastName(self):
return self.name.split()[1]
def birthDay(self):
self.age += 1
class Employee(Person):
def __init__(self, name, age, job=None, pay=0):
Person.__init__(self, name, age)
self.job = job
self.pay = pay
def birthDay(self):
self.age += 2
def giveRaise(self, percent):
self.pay *= (1.0 + percent)
if __name__ == '__main__':
bob = Person('Bob Smith', 40)
print bob
print bob.lastName()
bob.birthDay()
print bob
sue = Employee('Sue Jones', 44, job='dev', pay=100000)
print sue
print sue.lastName()
sue.birthDay()
sue.giveRaise(.10)
print sue
Чтобы проверить этот программный код, его можно импортировать
и создать экземпляры в интерактивной оболочке. Ниже приводится
пример класса Person в действии. Создание экземпляра вызывает ме
тод __init__, вызов именованных методов использует или изменяет ин
формацию о состоянии экземпляра (атрибутов), а попытка вывести эк
земпляр вызывает унаследованный метод __str__, что обеспечивает
единообразный формат вывода всех атрибутов:
>>> from person import Person
>>> ann = Person('Ann Smith', 45)
>>> ann.lastName()
'Smith'
>>> ann.birthDay()
>>> ann.age
46
>>> print ann
<Person:
age=46
name=Ann Smith
>
634 Глава 24. Подробнее о программировании классов
Наконец, ниже приводятся результаты выполнения программного ко
да самопроверки (в нижней части файла, вслед за проверкой атрибута
__name__), который создает экземпляры классов Person и Employee и из
меняет каждый из них. Как обычно, программный код самопроверки
выполняется, только если файл запускается как самостоятельный
сценарий, а не импортируется как библиотечный модуль. Обратите
внимание, как класс Employee наследует реализацию операции форма
тированного вывода и извлечения отчества, добавляет дополнитель
ную информацию о состоянии, добавляет метод для получения надбав
ки и адаптирует версию метода увеличения возраста (сотрудники ста
реют в два раза быстрее!):
% python person.py
<Person:
age=40
name=Bob Smith
>
Smith
<Person:
age=41
name=Bob Smith
>
<Employee:
job=dev
pay=100000
age=44
name=Sue Jones
>
Jones
<Employee:
job=dev
pay=110000.0
age=46
name=Sue Jones
>
Проследите, как работает программный код в этом примере, чтобы по
нять, как эти результаты отражают вызовы методов, – в этом примере
сведена воедино большая часть идей, составляющих основу ООП.
Теперь, когда вы познакомились с классами в языке Python, вы навер
няка оцените тот факт, что использованные здесь классы – это немно
гим более, чем пакеты функций, которые внедряют и манипулируют
встроенными объектами, присоединенными к атрибутам экземпляра
в качестве информации о состоянии. Например, когда метод lastName
разбивает строку и извлекает последнюю часть, он просто применяет
встроенные операции обработки строки и списка к объекту, управляе
мому классом.
Перегрузка операторов и наследование – автоматический поиск атри
бутов в подразумеваемом дереве классов – это главные механизмы
В заключение 635
ООП. В конечном итоге именно они позволяют классу Employee, нахо
дящемуся в самом низу дерева, получать большую часть своего поведе
ния «просто так», что составляет главную идею ООП.
В заключение
В этой главе был предпринят второй, более глубокий тур по механиз
мам ООП в языке Python. Мы узнали еще больше о классах и методах,
о наследовании и методах перегрузки операторов. Мы также закончи
ли повествование о пространствах имен в языке Python, расширив это
понятие, чтобы охватить его применение к классам. По пути мы рас
смотрели еще несколько дополнительных концепций, таких как абст
рактные суперклассы, атрибуты данных класса и вызов методов и кон
структоров суперкласса вручную. В заключение мы изучили большой
пример, соединяющий в себе многое из того, что мы уже знаем об ООП.
Теперь, когда мы знаем все о программировании классов в языке Py
thon, в следующей главе мы обратимся к некоторым распространенным
шаблонам проектирования – способам использования и комбинирова
ния классов для оптимизации многократного использования программ
ного кода. Часть сведений в этой главе напрямую не связана с языком
Python, но ее необходимо знать для грамотной работы с классами. Одна
ко, прежде чем приступить к чтению, ответьте на обычные контрольные
вопросы, чтобы освежить в памяти все, о чем говорилось в этой главе.
Закрепление пройденного
Контрольные вопросы
1. Что такое абстрактный суперкласс?
2. Какие два метода перегрузки операторов можно использовать для
поддержки итераций в классах?
3. Что произойдет, когда простая инструкция присваивания появится
на верхнем уровне в инструкции class?
4. Зачем может потребоваться в классе вручную вызывать метод
__init__ суперкласса?
5. Как можно расширить унаследованный метод вместо полного его
замещения?
6. Какие методы вызываются в последнем примере этой главы, когда
выводится экземпляр sue класса Employee?
7. Назовите… столицу Ассирии.
Ответы
1. Абстрактный суперкласс – это класс, который вызывает методы, но
не наследует и не определяет их. Он ожидает, что методы будут реа
636 Глава 24. Подробнее о программировании классов
лизованы в подклассах. Часто такой прием используется для обоб
щения классов, когда поведение будущих подклассов трудно пред
сказать заранее. Платформы ООП также используют этот прием
для выполнения операций, определяемых клиентом.
2. Классы могут обеспечить поддержку итераций, определив (или унас
ледовав) метод __getitem__ или __iter__. Во всех итерационных кон
текстах интерпретатор Python сначала пытается использовать метод
__iter__ (который возвращает объект, поддерживающий итерацион
ный протокол в виде метода next): если метод __iter__ не будет най
ден в результате поиска по дереву наследования, интерпретатор воз
вращается к использованию метода извлечения элемента по его ин
дексу __getitem__ (который вызывается многократно и при каждом
вызове получает постоянно увеличивающиеся значения индексов).
3. Когда простой оператор присваивания (X = Y) появляется на верх
нем уровне в инструкции class, он присоединяет к классу атрибут
данных (Class,X). Как и все атрибуты класса, этот атрибут будет со
вместно использоваться всеми экземплярами. При этом атрибуты
данных не являются вызываемыми методами.
4. Вручную вызывать метод __init__ суперкласса может потребовать
ся, когда класс определяет свой собственный конструктор __init__
и при этом необходимо, чтобы выполнялись действия, предусмот
ренные конструктором суперкласса. Интерпретатор Python автома
тически вызывает только один конструктор – самый нижний в де
реве наследования. Конструктор суперкласса вызывается через
имя класса, и ему вручную передается аргумент self: Super
class.__init__(self, ...).
5. Чтобы расширить унаследованный метод вместо полного его заме
щения, нужно переопределить его в подклассе и при этом вручную
вызвать версию метода суперкласса из нового метода в подклассе.
То есть вручную передать версии метода суперкласса аргумент self:
Superclass.method(self, ...).
6. В конечном итоге при выводе экземпляра sue будет вызван метод Ge
nericDisplay.__str__, который в свою очередь вызовет метод Gene
ricDisplay.gatherAttrs. Подробнее, при печати экземпляра sue инст
рукция print преобразует информацию в объекте в удобочитаемую
строку, передавая объект встроенной функции str. Для класса это
означает попытку отыскать в дереве наследования метод перегрузки
оператора __str__ и, в случае успеха, его вызов. Объект sue является
экземпляром класса Employee, который сам не имеет метода __str__,
поэтому следующий цикл поиска производится в классе Person и ме
тод __str__ будет найден в конце концов в классе GenericDisplay.
7. Ашшур (или КалатШеркат), Калах (или Нимруд), короткое время
был столицей ДурШаррукин (или Хорсабад) и, наконец, Ниневия.
25
Шаблоны проектирования с классами
До сих пор в этой части книги мы все свое внимание уделяли использо
ванию объектноориентированных инструментов языка Python –
классов. Но ООП – это еще и задача проектирования: как использовать
классы для моделирования полезных объектов. В этой главе мы кос
немся некоторых базовых идей ООП и рассмотрим несколько дополни
тельных примеров, более реалистичных, чем мы видели до сих пор.
Многие термины, упоминающиеся здесь (делегирование, композиция,
фабрики и другие), требуют более подробного пояснения, чем я приво
дил ранее в этой книге. Если эта тема вызывает у вас интерес, я пред
лагаю в качестве следующего шага взяться за изучение книг, посвя
щенных шаблонам проектирования в ООП.
Python и ООП
Реализацию ООП в языке Python можно свести к трем следующим
идеям:
Наследование
Наследование основано на механизме поиска атрибутов в языке Py
thon (в выражении X.name).
Полиморфизм
Назначение метода method в выражении X.method зависит от типа
(класса) X.
Инкапсуляция
Методы и операторы реализуют поведение; сокрытие данных – это
соглашение по умолчанию.
К настоящему времени вы уже должны иметь представление о том, что
такое наследование в языке Python. Кроме того, мы уже несколько раз
говорили о полиморфизме в языке Python – он произрастает из отсутст
638 Глава 25. Шаблоны проектирования с классами
вия объявления типов в языке Python. Поскольку разрешение имен ат
рибутов производится на этапе выполнения, объекты, реализующие
одинаковые интерфейсы, являются взаимозаменяемыми – клиентам
не требуется знать тип объекта, реализующего вызываемый метод.
Инкапсуляция в языке Python означает упаковывание – то есть со
крытие подробностей реализации за интерфейсом объекта. Это не оз
начает принудительное сокрытие, как будет показано в главе 26. Ин
капсуляция позволяет изменять реализацию интерфейсов объекта, не
оказывая влияния на пользователей этого объекта.
Использование перегрузки путем сигнатур вызова
(или отказ от нее)
В некоторых объектноориентированных языках под полиморфизмом
также понимается возможность перегрузки функций, основанной на
сигнатурах типов их аргументов. Но, так как в языке Python отсутст
вуют объявления типов, эта концепция в действительности здесь не
применима – полиморфизм в языке Python основан на интерфейсах
объектов, а не на типах.
Вы можете попробовать выполнить перегрузку методов, изменяя спи
ски их аргументов, как показано ниже:
class C:
def meth(self, x):
...
def meth(self, x, y, z):
...
Это вполне работоспособный программный код, но, так как инструк
ция def просто присваивает объект имени в области видимости класса,
сохранено будет только последнее определение метода (это все равно,
что записать две инструкции подряд: X = 1, а затем X = 2, в результате
чего X будет иметь значение 2).
Выбор на основе типа всегда можно реализовать с помощью идеи про
верки типа, с которой мы встречались в главах 4 и 9, или с помощью
возможности передачи списка аргументов, обсуждавшейся в главе 16:
class C:
def meth(self, *args):
if len(args) == 1:
...
elif type(arg[0]) == int:
...
Однако обычно этого следует избегать, потому что, как описывалось
в главе 15, следует писать такой код, который полагается на интер
фейс объекта, а не на конкретный тип данных. Такой подход полезнее,
так как охватывает более широкие категории типов и приложений,
как нынешних, так и тех, что появятся в будущем:
Классы как записи 639
class C:
def meth(self, x):
x.operation() # Предполагается, что x работает правильно
Кроме того, считается, что лучше выбирать разные имена для методов,
выполняющих разные операции, и не полагаться на сигнатуры вызова
(при этом неважно, какой язык программирования вы используете).
Классы как записи
В главе 8 демонстрировалось, как использовать словари для хранения
записей свойств сущностей в программах. Рассмотрим этот прием бо
лее подробно. Ниже приводится пример использования записи на ос
нове словаря, использовавшийся ранее:
>>> rec = {}
>>> rec['name'] = 'mel'
>>> rec['age'] = 40
>>> rec['job'] = 'trainer/writer'
>>>
>>> print rec['name']
mel
Этот фрагмент имитирует инструмент, напоминающий записи и струк
туры в других языках программирования. Однако, как мы видели
в главе 23, существует еще множество способов сделать то же самое с по
мощью классов. Ниже приводится, пожалуй, самый простой из них:
>>> class rec: pass
...
>>> rec.name = 'mel'
>>> rec.age = 40
>>> rec.job = 'trainer/writer'
>>>
>>> print rec.age
40
Этот вариант существенно компактнее, чем эквивалент на базе слова
ря. Здесь для создания объекта пустого пространства имен использует
ся пустая инструкция class (обратите внимание на инструкцию pass –
этого требует синтаксис, так как в данном случае класс не содержит
никакой логики, которую необходимо было бы реализовать). Создав
пустой класс, мы заполняем его, присваивая значения его атрибутам.
Этот прием работает, но для каждой отдельной записи придется писать
новую инструкцию class. Пожалуй, более удобным будет создавать эк
земпляры класса всякий раз, когда нам потребуется новая запись:
>>> class rec: pass
...
>>> pers1 = rec()
>>> pers1.name = 'mel'
640 Глава 25. Шаблоны проектирования с классами
>>> pers1.job = 'trainer'
>>> pers1.age = 40
>>>
>>> pers2 = rec()
>>> pers2.name = 'dave'
>>> pers2.job = 'developer'
>>>
>>> pers1.name, pers2.name
('mel', 'dave')
Здесь из одного и того же класса были созданы две записи – экземпля
ры класса начинают свое существование пустыми, как и классы. По
сле этого производится заполнение записей путем присваивания зна
чений атрибутам. Однако на этот раз существует два отдельных объек
та и, соответственно, два разных атрибута name. Фактически у экземп
ляров одного и того же класса не обязательно должны быть одинаковые
наборы имен атрибутов. В данном примере один из экземпляров имеет
уникальный атрибут age. Экземпляры класса действительно являются
разными пространствами имен: каждый из них имеет свой словарь ат
рибутов. Обычно экземпляры единообразно наполняются атрибутами
в методах класса, тем не менее, они обладают большей гибкостью, чем
можно было бы ожидать.
Наконец, для реализации записи мы могли бы написать более полно
ценный класс:
>>> class Person:
... def __init__(self, name, job):
... self.name = name
... self.job = job
... def info(self):
... return (self.name, self.job)
...
>>> mark = Person('ml', 'trainer')
>>> dave = Person('da', 'developer')
>>>
>>> mark.job, dave.info()
('trainer', ('da', 'developer'))
Такая схема также допускает создание множества экземпляров, но на
этот раз класс уже не пустой: мы добавили в него логику (методы) ини
циализации экземпляров на этапе создания и сбора атрибутов в кор
теж. Конструктор налагает некоторые ограничения целостности, тре
буя значения для двух атрибутов – name и job.
Мы могли бы продолжить расширение этой реализации, добавляя ме
тоды для вычисления зарплаты, разбора имен и т. д. (как это делается,
описывается в примере в конце главы 24). В конечном итоге мы могли
бы связать класс в иерархию, чтобы обеспечить наследование набора
существующих методов через процедуру автоматического поиска ат
рибутов классов, и даже записывать экземпляры класса в файл, чтобы
ООП и наследование: взаимосвязи типа «является» 641
обеспечить их постоянное хранение (подробнее о сохранении объектов
рассказывается во врезке «Придется держать в уме: классы и их хра
нение», ниже в этой книге). Наконец, несмотря на всю гибкость таких
типов, как словари, классы позволяют наделять объекты поведением
таким способом, который встроенными типами и простыми функция
ми напрямую не поддерживается.
ООП и наследование: взаимосвязи
типа «является»
Мы уже достаточно подробно исследовали механизм наследования, но
мне хотелось бы показать пример того, как может использоваться мо
дель отношений реального мира. С точки зрения программиста, насле
дование вступает в игру с момента появления составного имени атри
бута, при разрешении которого запускается поиск имен в экземплярах,
в их классах и затем в суперклассах. С точки зрения проектировщика,
наследование – это способ указать принадлежность к некоторому набо
ру: класс определяет набор свойств, которые могут быть унаследованы
и адаптированы более специализированными наборами (то есть под
классами).
Чтобы проиллюстрировать сказанное, давайте вернемся к машине по
изготовлению пиццы, о которой мы говорили в начале этой части кни
ги. Предположим, что мы исследовали альтернативные варианты раз
вития своей карьеры и решили открыть пиццерию. Первое, что нам
предстоит сделать, – это нанять работников для обслуживания клиен
тов, для приготовления блюд и т. д. Будучи в глубине души инженера
ми, мы решили сконструировать робота по приготовлению пиццы, но,
будучи также политически и кибернетически корректными, мы реши
ли сделать нашего робота полноправным служащим, которому выпла
чивается заработная плата.
Наш коллектив работников пиццерии можно определить четырьмя
классами из файла примера employees.py. Самый общий класс, Employ
ee, реализует поведение, общее для всех работников, такое как повы
шение заработной платы (giveRaise) и вывод на экран (__repr__). Суще
ствует два типа служащих и, соответственно, два подкласса, насле
дующих класс Employee: Chef (повар) и Server (официант). Оба подкласса
переопределяют унаследованный метод work, чтобы обеспечить вывод
более специализированных сообщений. Наконец, наш робот по приго
товлению пиццы моделируется еще более специализированным клас
сом PizzaRobot, наследующим класс Chef, который в свою очередь на
следует класс Employee. В терминах ООП мы называем такие взаимоот
ношения «является»: робот является поваром, а повар – служащим.
Ниже приводится содержимое файла employees.py:
class Employee:
def __init__(self, name, salary=0):
642 Глава 25. Шаблоны проектирования с классами
self.name = name
self.salary = salary
def giveRaise(self, percent):
self.salary = self.salary + (self.salary * percent)
def work(self):
print self.name, "does stuff"
def __repr__(self):
return "<Employee: name=%s, salary=%s>" % (self.name, self.salary)
class Chef(Employee):
def __init__(self, name):
Employee.__init__(self, name, 50000)
def work(self):
print self.name, "makes food"
class Server(Employee):
def __init__(self, name):
Employee.__init__(self, name, 40000)
def work(self):
print self.name, "interfaces with customer"
class PizzaRobot(Chef):
def __init__(self, name):
Chef.__init__(self, name)
def work(self):
print self.name, "makes pizza"
if __name__ == "__main__":
bob = PizzaRobot('bob') # Создать робота с именем bob
print bob # Вызвать унаследованный метод __repr__
bob.work() # Выполнить действие, зависящее от типа
bob.giveRaise(0.20) # Увеличить роботу зарплату на 20%
print bob; print
for klass in Employee, Chef, Server, PizzaRobot:
obj = klass(klass.__name__)
obj.work()
Когда выполняется программный код самопроверки, включенный в со
став модуля, создается робот по приготовлению пиццы с именем bob,
который наследует атрибуты трех классов: PizzaRobot, Chef и Employee.
Например, при попытке вывести экземпляр bob вызывается метод Em
ployee.__repr__, а прибавка роботу зарплаты производится методом Em
ployee.giveRaise, потому что этот метод обнаруживается в процессе по
иска в дереве наследования именно в этом классе:
C:\python\examples> python employees.py
<Employee: name=bob, salary=50000>
bob makes pizza
<Employee: name=bob, salary=60000.0>
Employee does stuff
Chef makes food
Server interfaces with customer
PizzaRobot makes pizza
ООП и композиция: взаимосвязи типа «имеет» 643
В иерархиях классов, подобных этой, обычно можно создавать экземп
ляры любого класса, а не только того, что находится в самом низу. На
пример, в коде самопроверки этого модуля в цикле for создаются экзем
пляры всех четырех классов, каждый из которых работает поразному,
потому что все они имеют различные методы work. В действительности
эти классы пока лишь имитируют объекты реального мира – в текущей
реализации метод work просто выводит сообщение, но позднее его мож
но расширить так, что он будет выполнять настоящую работу.
ООП и композиция: взаимосвязи типа «имеет»
Понятие композиции в этой книге было введено в главе 22. С точки
зрения программиста, композиция – это прием встраивания других
объектов в объектконтейнер и использование их для реализации ме
тодов контейнера. Для проектировщика композиция – это один из
способов представить взаимоотношения в прикладной области. Но
вместо того, чтобы определять принадлежность к множеству, при ком
позиционном подходе все части объединяются в единое целое.
Кроме того, композиция отражает взаимоотношения между частями,
которые обычно называются отношениями типа «имеет». В некоторых
книгах, посвященных объектноориентированному проектированию,
композиция называется агрегированием (и различие между терминами
состоит в том, что термин «агрегирование» используется для описания
более слабой зависимости между контейнером и его содержимым);
в этой книге термин «композиция» используется лишь для обозначения
коллекции встраиваемых объектов. Вообще составные классы реализу
ют все свои интерфейсы, управляя работой встраиваемых объектов.
Теперь, когда у нас имеются реализации классов работников, объеди
ним их в коллектив пиццерии и позволим им приступить к работе. На
ша пиццерия – это составной объект: в нем имеется печь и работники,
такие как официанты и повара. Когда приходит клиент и делает заказ,
все компоненты пиццерии начинают действовать – официант прини
мает заказ, повар делает пиццу и т. д. Следующий пример (файл pizza+
shop.py) имитирует все объекты и взаимоотношения между ними:
from employees import PizzaRobot, Server
class Customer:
def __init__(self, name):
self.name = name
def order(self, server):
print self.name, "orders from", server
def pay(self, server):
print self.name, "pays for item to", server
class Oven:
def bake(self):
print "oven bakes"
644 Глава 25. Шаблоны проектирования с классами
class PizzaShop:
def __init__(self):
self.server = Server('Pat') # Встроить другие объекты
self.chef = PizzaRobot('Bob') # Робот по имени bob
self.oven = Oven()
def order(self, name):
customer = Customer(name) # Активизировать другие объекты
customer.order(self.server) # Клиент делает заказ официанту
self.chef.work()
self.oven.bake()
customer.pay(self.server)
if __name__ == "__main__":
scene = PizzaShop() # Создать составной объект
scene.order('Homer') # Имитировать заказ клиента Homer
print '...'
scene.order('Shaggy') # Имитировать заказ клиента Shaggy
Класс PizzaShop – это контейнер и контроллер – это конструктор, кото
рый создает и встраивает экземпляры классов работников, написан
ные нами в предыдущем разделе, а также экземпляры класса Oven, ко
торый определен здесь. Когда программный код самопроверки этого
модуля вызывает метод order класса PizzaShop, встроенным объектам
предлагается приступить к выполнению своих обязанностей. Обратите
внимание, что для каждого клиента мы создаем новый экземпляр
класса Customer и передаем встроенный объект Server (официант) мето
дам класса Customer (клиент) – клиенты приходят и уходят, а офици
ант остается частью коллектива пиццерии. Кроме того, обратите вни
мание, что работники попрежнему вовлечены во взаимосвязи насле
дования – композиция и наследование – это взаимодополняющие ин
струменты. Если запустить этот модуль, наша пиццерия обслужит два
заказа – один от Гомера (Homer) и другой от Шагги (Shaggy):
C:\python\examples> python pizzashop.py
Homer orders from <Employee: name=Pat, salary=40000>
Bob makes pizza
oven bakes
Homer pays for item to <Employee: name=Pat, salary=40000>
...
Shaggy orders from <Employee: name=Pat, salary=40000>
Bob makes pizza
oven bakes
Shaggy pays for item to <Employee: name=Pat, salary=40000>
Это всего лишь игрушечная имитация, но объекты и взаимодействия
между ними наглядно демонстрируют составные объекты в действии.
Классы могут представлять практически любые объекты и взаимоот
ношения между ними, которые можно выразить словами; для этого
просто замените имена существительные классами, глаголы – мето
дами, и вы получите первый черновой набросок проекта.
ООП и композиция: взаимосвязи типа «имеет» 645
Еще раз об обработке потоков
Рассмотрим более реалистичный пример использования приема ком
позиции. Вспомните универсальную функцию обработки потоков дан
ных, которая частично была реализована во введении в ООП в главе 22:
def processor(reader, converter, writer):
while 1:
data = reader.read()
if not data: break
data = converter(data)
writer.write(data)
Однако вместо простой функции мы могли бы реализовать обработку
в виде класса, который использует прием композиции, чтобы обеспе
чить поддержку наследования и более удобную конструкцию про
граммного кода. Одна из возможных реализаций этого класса содер
жится в файле streams.py и приводится в ниже:
class Processor:
def __init__(self, reader, writer):
self.reader = reader
self.writer = writer
def process(self):
while 1:
data = self.reader.readline()
if not data: break
data = self.converter(data)
self.writer.write(data)
def converter(self, data):
assert 0, 'converter must be defined'
При таком подходе объекты чтения и записи встраиваются в экземп
ляр класса (композиция), а логика преобразования поставляется в ви
де подкласса, а не в виде отдельной функции (наследование). Ниже
приводится содержимое файла converters.py:
from streams import Processor
class Uppercase(Processor):
def converter(self, data):
return data.upper()
if __name__ == '__main__':
import sys
Uppercase(open('spam.txt'), sys.stdout).process()
Здесь класс Uppercase наследует логику цикла обработки потока дан
ных (и все остальное, что может присутствовать в суперклассах). В нем
необходимо определить лишь то, что будет уникальным для него – ло
гику преобразования данных. Если запустить этот файл, он создаст
и запустит экземпляр класса Uppercase, который прочитает содержимое
файла spam.txt, преобразует все символы в верхний регистр и выведет
их в поток stdout:
646 Глава 25. Шаблоны проектирования с классами
C:\lp3e> type spam.txt
spam
Spam
SPAM!
C:\lp3e> python converters.py
SPAM
SPAM
SPAM!
Для обработки потоков различных видов достаточно передать конст
руктору класса объекты требуемых типов. Ниже приводится пример
реализации вывода в файл вместо стандартного потока вывода:
C:\lp3e> python
>>> import converters
>>> prog = converters.Uppercase(open('spam.txt'), open('spamup.txt', 'w'))
>>> prog.process()
C:\lp3e> type spamup.txt
SPAM
SPAM
SPAM!
Но, как предлагалось ранее, мы могли бы также реализовать объекты,
обернутые в классы, которые определяют необходимые интерфейсные
методы ввода и вывода. Ниже приводится простой пример, где вывод
осуществляется через класс, который обертывает выводимый текст
в теги HTML:
C:\lp3e> python
>>> from converters import Uppercase
>>>
>>> class HTMLize:
... def write(self, line):
... print '<PRE>%s</PRE>' % line[:
1]
...
>>> Uppercase(open('spam.txt'), HTMLize()).process()
<PRE>SPAM</PRE>
<PRE>SPAM</PRE>
<PRE>SPAM!</PRE>
Если проследить порядок выполнения этого примера, можно заметить,
что было получено два варианта преобразований – приведение симво
лов к верхнему регистру (наследованием) и преобразование в формат
HTML (композицией), хотя основная логика обработки в оригиналь
ном суперклассе Processor ничего не знает ни об одном из них. Про
граммному коду, выполняющему обработку, нужны только метод
write – в классах, выполняющих запись, и метод convert. Его совер
шенно не интересует, что делают эти методы. Такой полиморфизм
и инкапсуляция логики составляют основу такой мощи классов.
ООП и композиция: взаимосвязи типа «имеет» 647
В этом примере суперкласс Processor предоставляет только цикл ска
нирования файла. Для выполнения более существенных действий его
можно было бы расширить, чтобы обеспечить поддержку дополни
тельных инструментов в его подклассах и постепенно превратить все
это в полноценную платформу. Создав такой инструмент один раз, вы
Придется держать в уме: классы и их хранение
В этой части книги я уже несколько раз упоминал о возможности
сохранения объектов, потому что этот метод особенно хорошо ра
ботает с экземплярами классов. Например, помимо возможности
имитировать взаимодействия в реальном мире, классы, разрабо
танные для пиццерии, могли бы также использоваться как осно
ва базы данных пиццерии. Экземпляры классов могут сохранять
ся на диск за одно действие – с помощью модулей pickle или
shelve. Интерфейс модуля pickle очень прост в использовании:
import pickle
object = someClass()
file = open(filename, 'wb') # Создать внешний файл
pickle.dump(object, file) # Сохранить объект в файле
import pickle
file = open(filename, 'rb')
object = pickle.load(file) # Позднее извлечь обратно
Модуль pickle преобразует объекты, находящиеся в памяти, в по
следовательные потоки байтов, которые можно сохранять в фай
лах, передавать по сети и т. д. При извлечении объектов проис
ходит обратное преобразование: из последовательного потока
байтов в идентичные объекты в памяти. Модуль shelve реализует
похожую возможность, но он автоматически сохраняет объекты
в базе данных с доступом по ключу, которая предоставляет ин
терфейс, похожий на интерфейс словаря:
import shelve
object = someClass()
dbase = shelve.open('filename')
dbase['key'] = object # Сохранить под ключом key
import shelve
dbase = shelve.open('filename')
object = dbase['key'] # Позднее извлечь обратно
В нашем примере использование классов для моделирования ра
ботников означает, что можно достаточно легко создать простую
базу данных сотрудников и пиццерий: записывая экземпляры
объектов в файл, мы сможем сохранять их между запусками
программы. Более подробную информацию о сохранении ищите
в руководстве к стандартной библиотеке.
648 Глава 25. Шаблоны проектирования с классами
сможете многократно использовать его во всех своих программах. Да
же в этом простом примере благодаря тому, что с помощью классов
можно упаковать и унаследовать так много, все, что нам пришлось
сделать – это реализовать этап преобразования в формат HTML, а все
остальное у нас уже и так имелось.
Еще один пример композиции в действии приводится в упражнении 9
в конце главы 26, а его решение – в приложении B. Он напоминает
пример с пиццерией. В этой книге мы сосредоточились на наследова
нии, потому что это основной инструмент, который обеспечивает объ
ектноориентированные возможности в языке Python. Однако на
практике прием композиции используется ничуть не реже, чем насле
дование, в качестве способа организации классов, особенно в крупных
системах. Как мы видели, наследование и композиция – часто взаимо
дополняющие (а иногда и альтернативные) приемы.
Композиция – это проблема проектирования, которая далеко выходит
за рамки языка Python и этой книги, поэтому полный охват этой темы
я оставляю за другими источниками информации.
ООП и делегирование
В ООП часто используется термин делегирование, под которым обычно
подразумевается наличие объектаконтроллера, куда встраиваются
другие объекты, получающие запросы на выполнение операций. Кон
троллеры могут решать административные задачи, такие как слеже
ние за попытками доступа и т. д. В языке Python делегирование часто
реализуется с помощью метода __getattr__, потому что он перехваты
вает попытки доступа к несуществующим атрибутам. Класс+обертка
(иногда называется проксиклассом) может использовать метод
__getattr__ для перенаправления обращений к обернутому объекту.
Классобертка имеет интерфейс обернутого объекта и может добавлять
дополнительные операции.
В качестве примера рассмотрим файл trace.py:
class wrapper:
def __init__(self, object):
self.wrapped = object # Сохранить объект
def __getattr__(self, attrname):
print 'Trace:', attrname # Отметить факт извлечения
return getattr(self.wrapped, attrname) # Делегировать извлечение
В главе 24 говорилось, что метод __getattr__ получает имя атрибута
в виде строки. В этом примере для извлечения из обернутого объекта
атрибута, имя которого представлено в виде строки, используется
встроенная функция getattr; вызов getattr(X, N) аналогичен выраже
нию X.N за исключением того, что N – это выражение, которое во время
выполнения представлено строкой, а не именем переменной. Фактиче
ски вызов getattr(X, N) по его действию можно сравнить с выражени
Множественное наследование 649
ем X.__dict__[N], только в первом случае дополнительно выполняется
поиск в дереве наследования, как в выражении X.N, а во втором – нет
(подробнее об атрибуте __dict__ рассказывается в разделе «Словари
пространств имен» в главе 24).
Такой прием, реализованный в этом классеобертке, можно использо
вать для управления доступом к любому объекту с атрибутами – спи
скам, словарям и даже к классам и экземплярам. Ниже приводится
класс wrapper, который просто выводит сообщение при каждом обраще
нии к атрибуту и делегирует этот запрос обернутому объекту wrapped:
>>> from trace import wrapper
>>> x = wrapper([1,2,3]) # Обернуть список
>>> x.append(4) # Делегировать операцию методу списка
Trace: append
>>> x.wrapped # Вывести обернутый объект
[1, 2, 3, 4]
>>> x = wrapper({"a": 1, "b": 2}) # Обернуть словарь
>>> x.keys() # Делегировать операцию методу словаря
Trace: keys
['a', 'b']
В результате интерфейс обернутого объекта расширяется за счет мето
дов классаобертки. Этот подход может использоваться для регистра
ции вызовов методов, перенаправления вызовов методов дополнитель
ному или адаптированному программному коду и т. д.
В главе 26 мы еще вернемся к обернутым объектам и делегированию
операций как к одному из способов расширения встроенных типов. Ес
ли шаблон проектирования с делегированием заинтересовал вас, тогда
смотрите обсуждение декораторов функций в главе 26 – это очень
близкая концепция, призванная обеспечить расширение отдельных
функций и методов, а не всего интерфейса объекта.
Множественное наследование
В строке заголовка инструкции class в круглых скобках может быть
перечислено более одного суперкласса. В этом случае используется то,
что называется множественным наследованием, – класс и его экземп
ляры наследуют имена всех перечисленных суперклассов.
При поиске атрибутов интерпретатор Python выполняет обход супер
классов, указанных в строке заголовка класса, слева направо, пока не
будет найдено первое совпадение. С технической точки зрения поиск
сначала продолжается по направлению снизу вверх всеми возможными
путями, вплоть до вершины дерева наследования, а затем слева направо,
потому что любой суперкласс может иметь собственные суперклассы.
Вообще множественное наследование хорошо использовать для модели
рования объектов, принадлежащих более чем одной группе. Например,
650 Глава 25. Шаблоны проектирования с классами
человек может быть инженером, писателем, музыкантом и т. д., и на
следовать свойства всех этих групп.
Пожалуй, самый распространенный случай, где используется множе
ственное наследование, – это «смешивание» методов общего назначе
ния из нескольких суперклассов. Обычно такие суперклассы называ
ются классами+смесями – они предоставляют методы, которые добав
ляются в прикладные классы наследованием. Например, способ выво
да экземпляра класса, используемый в Python по умолчанию, не
отличается информативностью:
>>> class Spam:
... def __init__(self): # Нет метода __repr__
... self.data1 = "food"
...
>>> X = Spam()
>>> print X # По умолчанию: класс, адрес
<__main__.Spam instance at 0x00864818>
Как было отмечено в предыдущем разделе, где рассматривалась пере
грузка оператора, существует возможность с помощью метода __repr__
реализовать свою собственную операцию вывода. Но вместо того чтобы
воспроизводить метод __repr__ в каждом классе, который предполагает
ся выводить на экран, почему бы не написать его всего один раз в классе
инструментов общего назначения и не наследовать его во всех ваших
классах?
Для этого и используются классысмеси. В следующем файле my+
tools.py определяется класссмесь с именем Lister, переопределяющий
метод __repr__ в каждом классе, который наследует его. Он просто ска
нирует словарь атрибутов экземпляра (экспортируется в виде атрибу
та __dict__) и собирает строку из имен и значений всех атрибутов эк
земпляра. Так как классы – это объекты, логика форматирования
класса Lister может использоваться и для экземпляров любых под
классов – это универсальный инструмент.1
Класс Lister использует два специальных приема, чтобы получить из
экземпляра имя класса и адрес. Каждый экземпляр имеет встроенный
атрибут __class__, указывающий на класс, из которого он был создан,
и каждый класс имеет атрибут __name__, указывающий на имя в заго
ловке, поэтому выражение self.__class__.__name__ возвращает имя
класса экземпляра. Получить адрес экземпляра в памяти можно с по
мощью встроенной функции id, способной возвращать адрес любого
объекта (по определению, уникальный идентификатор объекта):
1 Альтернативный способ реализации похожего поведения можно найти
в примере модуля person.py в конце главы 24. В нем также просматривают
ся словари пространств имен, но там не предполагается пропуск имен, на
чинающихся и заканчивающихся двумя символами подчеркивания.
Множественное наследование 651
############################################################################
# Lister можно подмешивать в любые классы, чтобы обеспечить форматированный
# вывод экземпляров через наследование метода __repr__, реализованного здесь;
# self – это экземпляр самого нижнего класса.
############################################################################
class Lister:
def __repr__(self):
return ("<Instance of %s, address %s:\n%s>" %
(self.__class__.__name__, # Имя класса
id(self), # Адрес
self.attrnames()) ) # Список имя=значение
def attrnames(self):
result = ''
for attr in self.__dict__.keys(): # Словарь имен экземпляра
if attr[:2] == '__':
result = result + "\tname %s=<builtin>\n" % attr
else:
result = result+"\tname %s=%s\n" % (attr, self.__dict__ [attr])
return result
Экземпляры, унаследовавшие этот класс, при выводе будут автомати
чески отображать свои атрибуты, давая о себе больше информации,
чем просто свой адрес:
>>> from mytools import Lister
>>> class Spam(Lister):
... def __init__(self):
... self.data1 = 'food'
...
>>> x = Spam()
>>> x
<Instance of Spam, address 8821568:
name data1=food
>
Класс Lister будет полезен для наследования любыми вашими класса
ми, у которых уже есть суперкласс. Это тот случай, где удобно исполь
зовать множественное наследование: добавляя класс Lister в список су
перклассов в строке заголовка класса (вмешивая его), вы получаете
в свое распоряжение его метод __repr__, что не мешает наследовать дру
гой существующий суперкласс. Это демонстрирует файл testmixin.py:
from mytools import Lister # Получить класс с инструментами
class Super:
def __init__(self): # Метод суперкласса __init__
self.data1 = "spam"
class Sub(Super, Lister): # Наследовать __repr__ из классасмеси
def __init__(self): # Lister имеет доступ к self
Super.__init__(self)
self.data2 = "eggs" # Дополнительные атрибуты экземпляра
self.data3 = 42
652 Глава 25. Шаблоны проектирования с классами
if __name__ == "__main__":
X = Sub()
print X # __repr__ из классасмеси
Здесь класс Sub наследует имена из двух классов, Super и Lister – этот
объект состоит из своих собственных имен и из имен обоих суперклас
сов. Если создать и вывести экземпляр класса Sub, автоматически будет
получено адаптированное представление, подмешанное из класса Lister:
C:\lp3e> python testmixin.py
<Instance of Sub, address 7833392:
name data3=42
name data2=eggs
name data1=spam
>
Метод класса Lister будет работать в любом классе, унаследовавшем
его, потому что аргумент self ссылается на экземпляр подкласса, ко
торый наследует Lister, каким бы этот подкласс ни был. Если позднее
вы решите усовершенствовать класс Lister, чтобы метод __repr__ выво
дил также все атрибуты класса, которые были унаследованы экземп
ляром, вы без опаски сможете сделать это – так как это наследуемый
метод, изменение в реализации Lister.__repr__ автоматически начнет
действовать и во всех подклассах, которые импортируют его.1
В некотором смысле, классысмеси – это классы, эквивалентные моду
лям, потому что они упаковывают методы, которые будут полезны са
мым разным клиентам. Ниже демонстрируется работа класса Lister
в режиме единственного наследования с экземплярами различных
классов:
>>> from mytools import Lister
>>> class x(Lister):
... pass
...
>>> t = x()
1 Если вам любопытно, как это произойдет, вернитесь назад к разделу «Слова
ри пространств имен» в главе 24. Там мы видели, что у каждого класса име
ется свой атрибут __bases__, который является кортежем объектов супер
классов. Универсальный класс просмотра иерархии может выполнять обход
дерева наследования от экземпляра класса __class__ к его классу и затем с по
мощью атрибута __bases__ ко всем его суперклассам рекурсивно, как это де
лается в модуле classtree.py, показанном ранее. В версии Python 2.2 и более
поздних реализовать это можно еще проще, поскольку теперь встроенная
функция dir автоматически включает имена унаследованных атрибутов. Ес
ли не требуется отображать структуру дерева наследования, то можно просто
сканировать список, получаемый от функции dir, вместо просмотра списка
ключей словаря и использовать функцию getattr для получения значения
атрибута по его имени, заданному в виде строки, вместо обхода словаря. Мы
еще вернемся к этой идее в одном из заключительных примеров к этой части.
Классы – это объекты: фабрики универсальных объектов 653
>>> t.a = 1; t.b = 2; t.c = 3
>>> t
<Instance of x, address 7797696:
name b=2
name a=1
name c=3
>
ООП тесно связано с повторным использованием программного кода,
и классысмеси в этом отношении представляют собой мощный инст
румент. Как почти все в программировании, множественное наследо
вание может быть благом при грамотном применении; но при неакку
ратном и чрезмерном употреблении эта возможность может осложнить
вам жизнь. Мы вернемся к этому вопросу как к одной из типичных
проблем в конце следующей главы. В этой главе мы также познако
мимся с возможностью (в классах нового стиля) изменять порядок по
иска для одного специального случая множественного наследования.
Классы – это объекты:
фабрики универсальных объектов
Классы – это объекты, поэтому их легко можно передавать между ком
понентами программы, сохранять в структурах данных и т. д. Можно
также передавать классы функциям, которые создают объекты произ
вольных типов, – в кругах, связанных с ООП, такие функции иногда на
зывают фабриками. В языках со строгой типизацией, таких как C++,
реализация таких функций – достаточно сложная задача, но в языке
Python она становится почти тривиальной. Функция apply и новейшая
синтаксическая конструкция, с которыми мы познакомились в гла
ве 17, могут вызывать любые классы с любым числом аргументов кон
структоров за один присест, генерируя экземпляр любого типа:1
def factory(aClass, *args): # Кортеж переменного числа аргументов
return apply(aClass, args) # Вызывайте aClass, или: aClass(*args)
class Spam:
def doit(self, message):
print message
class Person:
def __init__(self, name, job):
self.name = name
self.job = job
1 Фактически функция apply может вызывать любой вызываемый объект,
включая функции, классы и методы. Функция factory в этом примере так
же может вызывать любые вызываемые объекты, а не только классы (не
смотря на имя аргумента). Кроме того, обратите внимание: в последних
версиях Python синтаксис вызова aClass(*args) вообще предпочтительнее,
чем вызов встроенной функции apply(aClass, args).
654 Глава 25. Шаблоны проектирования с классами
object1 = factory(Spam) # Создать объект Spam
object2 = factory(Person, "Guido", "guru") # Создать объект Person
В этом фрагменте определена функциягенератор объектов с именем
factory. Она ожидает получить объект класса (любого) вместе с одним
или более аргументов конструктора класса. Она создает экземпляр
с помощью функции apply и возвращает его.
Остальная часть примера просто определяет два класса и генерирует
экземпляры этих классов, передавая функции factory. И это единст
венная фабричная функция, которую вам придется написать на языке
Python, – она работает с любыми классами и с любыми аргументами
конструктора.
Следует заметить, что здесь возможно одно небольшое улучшение, ко
торое заключается в обеспечении поддержки именованных аргумен
тов конструктора; фабричная функция может собрать их в аргумент
**args и передать функции apply в виде третьего аргумента:
def factory(aClass, *args, **kwargs): # +kwargs
return apply(aClass, args, kwargs) # Вызвать aClass
К настоящему времени вы должны знать, что в языке Python все явля
ется «объектом», включая и сами классы, которые в других языках,
таких как С++, являются лишь объявлениями для компилятора. Од
нако, как упоминалось в начале шестой части книги, в языке Python
только объекты, созданные из классов, являются субъектами ООП.
Зачем нужны фабрики?
Итак, чем же хороша функция factory (помимо иллюстрации того, что
классы являются объектами)? К сожалению, довольно сложно проде
монстрировать применение этого шаблона проектирования, потому
что для этого необходимо привести фрагмент программного кода боль
ший, чем позволяет пространство книги. Тем не менее, такая фабрика
могла бы помочь изолировать программный код от динамически на
страиваемой конструкции объекта.
Вспомним пример функции processor, представленный в главе 22, и за
тем пример применения принципа композиции в этой главе. В обоих
случаях принимаются объекты, выполняющие чтение и запись обра
батываемого потока данных.
В оригинальной версии этого примера мы вручную передавали экзем
пляры специализированных классов, таких как FileWriter и Socket
Reader, для адаптации под обрабатываемые потоки данных – позднее
мы передавали жестко заданные объекты файла, потока и преобразо
вания. В других случаях внешние источники данных могут опреде
ляться настройками в конфигурационных файлах или в элементах
управления графического интерфейса.
В таком динамическом мире не представляется возможным жестко за
давать в сценарии объекты, реализующие интерфейс к потоку дан
Методы – это объекты: связанные и несвязанные методы 655
ных, но вполне возможно создавать их во время выполнения, в соот
ветствии с содержимым конфигурационных файлов.
Например, в файле с настройками может определяться имя класса по
тока, который должен быть импортирован из модуля, и дополнитель
ные аргументы конструктора. В этой ситуации могла бы пригодиться
фабричная функция или эквивалентный ей фрагмент программного
кода, потому что они могли бы позволить нам получить и передать
классы, не определяя их заранее в программе. В действительности воз
можно представить себе, что требуемые классы даже не существовали
в тот момент, когда мы писали свой программный код:
classname = ...определяется конфигурационным файлом...
classarg = ...определяется конфигурационным файлом...
import streamtypes # Специализированный программный код
aclass = getattr(streamtypes, classname) # Извлечь из модуля
reader = factory(aclass, classarg) # Получить экземпляр aclass(classarg)
processor(reader, ...)
Здесь встроенная функция getattr снова используется для извлечения
атрибута модуля, имя которого задано в виде строки (это все равно,
что записать выражение obj.attr, где attr – это строка). Так как этот
фрагмент предполагает наличие у конструктора единственного аргу
мента, то, строго говоря, здесь не требуется ни функция factory, ни
функция apply – мы могли бы просто создать экземпляр класса обра
щением aclass(classarg). Эти функции более полезны в случаях, когда
количество аргументов неизвестно заранее, то есть когда универсаль
ная фабричная функция способна повысить гибкость реализации. За
дополнительной информацией по этой теме обращайтесь к книгам, ко
торые посвящены вопросам ООП и шаблонам проектирования.
Методы – это объекты:
связанные и несвязанные методы
Методы – это разновидность объектов, напоминающая функции. Дос
туп к методам класса осуществляется через экземпляр класса или че
рез сам класс и, следовательно, в языке Python имеется две разновид
ности методов:
Несвязанные методы класса: без аргумента self
Попытка обращения к функциональному атрибуту класса через
имя класса возвращает объект несвязанного метода. Чтобы вызвать
этот метод, необходимо явно передать ему объект экземпляра в ви
де первого аргумента.
Связанные методы экземпляра: пара self + функция
Попытка обращения к функциональному атрибуту класса через
имя экземпляра возвращает объект связанного метода. Интерпре
656 Глава 25. Шаблоны проектирования с классами
татор автоматически упаковывает экземпляр с функцией в связан
ный объект метода, поэтому вам не требуется передавать экземпляр
в вызов метода.
Обе разновидности методов – это полноценные объекты. Они могут пе
редаваться между программными компонентами, сохраняться в спи
сках и т. д. При запуске оба требуют наличия экземпляра в первом ар
гументе (то есть значения для аргумента self). Именно по этой причине
в предыдущей главе было необходимо явно передавать экземпляр при
вызове методов суперкласса из методов подкласса – с технической точ
ки зрения такие вызовы порождают объекты несвязанных методов.
Вызывая объект связанного метода, интерпретатор автоматически под
ставляет экземпляр, который использовался при создании объекта свя
занного метода. Это означает, что объекты связанных методов обычно
взаимозаменяемы с объектами простых функций и создание их особенно
полезно в случае интерфейсов, изначально ориентированных на исполь
зование функций (реалистичный пример приводится во врезке «При
дется держать в уме: связанные методы и функции обратного вызова»).
Чтобы проиллюстрировать вышесказанное, предположим, что имеет
ся следующее определение класса:
class Spam:
def doit(self, message):
print message
В обычной ситуации мы создаем экземпляр и сразу же вызываем его
метод для вывода содержимого аргумента:
object1 = Spam()
object1.doit('hello world')
Однако в действительности попутно создается объект связанного мето
да – как раз перед круглыми скобками в вызове метода. Т.е. мы можем
получить связанный метод и без его вызова. Составное имя object.name –
это выражение, которое возвращает объект. В следующем примере это
выражение возвращает объект связанного метода, в котором упакова
ны вместе экземпляр (object1) и метод (Spam.doit). Мы можем присво
ить этот связанный метод другому имени и затем использовать это имя
для вызова, как простую функцию:
object1 = Spam()
x = object1.doit # Объект связанного метода: экземпляр+функция
x('hello world') # То же, что и object1.doit('...')
С другой стороны, если для получения метода doit использовать имя
класса, мы получим объект несвязанного метода, который просто ссы
лается на объект функции. Чтобы вызвать метод этого типа, необходи
мо явно передавать экземпляр класса в первом аргументе:
object1 = Spam()
t = Spam.doit # Объект несвязанного метода
t(object1, 'howdy') # Передать экземпляр
Еще раз о строках документирования 657
Те же самые правила действуют внутри методов класса, когда использу
ются атрибуты аргумента self, которые ссылаются на функции в клас
се. Выражение self.method возвращает объект связанного метода, пото
му что self – это объект экземпляра:
class Eggs:
def m1(self, n):
print n
def m2(self):
x = self.m1 # Еще один объект связанного метода
x(42) # Выглядит как обычная функция
Eggs().m2() # Выведет 42
Чаще всего вы будете вызывать методы немедленно, сразу же после
указания составного имени, поэтому вы не всегда будете замечать, что
попутно создается объект метода. Но как только вы начнете писать
программный код, который вызывает объекты единообразным спосо
бом, то сразу обратите внимание на несвязанные методы, потому что
обычно они требуют явной передачи экземпляра в первом аргументе.1
Теперь, когда вы понимаете суть объектной модели методов, озна
комьтесь с примерами применения связанных методов во врезке
«Придется держать в уме: связанные методы и функции обратного вы
зова» и еще раз прочитайте раздел предыдущей главы «__call__ обра
батывает вызовы», где обсуждаются функции обратного вызова.
Еще раз о строках документирования
Строки документирования, которые мы подробно рассматривали в гла
ве 14, – это литералы строк, которые присутствуют на верхнем уровне
различных структур и автоматически сохраняются интерпретатором
Python в атрибутах __doc__ соответствующих им объектов. Строки до
кументирования могут присутствовать в модулях, в инструкциях def,
а также в определениях классов и методов. Теперь, когда мы ближе
познакомились с классами и методами, можно изучить короткий, но
емкий пример docstr.py – здесь демонстрируются места в программном
коде, где могут появляться строки документирования. Все они могут
представлять собой блоки в тройных кавычках:
"I am: docstr.__doc__"
class spam:
"I am: spam.__doc__ or docstr.spam.__doc__"
def method(self, arg):
"I am: spam.method.__doc__ or self.method.__doc__"
1 Смотрите обсуждение статических методов класса в главе 26, которые
представляют собой исключение из этого правила. Подобно связанным ме
тодам, они также могут выглядеть как обычные функции, потому что они
не ожидают получить экземпляр в первом аргументе.
658 Глава 25. Шаблоны проектирования с классами
pass
def func(args):
"I am: docstr.func.__doc__"
pass
Основное преимущество строк документирования состоит в том, что
их содержимое доступно во время выполнения. То есть, если текст был
оформлен в виде строки документирования, можно будет обратиться
к атрибуту __doc__ объекта, чтобы получить его описание:
Придется держать в уме: связанные методы
и функции обратного вызова
В объектах связанных методов вместе с функцией автоматически
сохраняется экземпляр класса, поэтому они могут использовать
ся везде, где используются обычные функции. Одно из обычных
мест, где можно увидеть эту идею в действии, – это программный
код, регистрирующий методы как обработчики событий в интер
фейсе Tkinter GUI. Ниже приводится простейший случай:
def handler():
... сохраняет информацию о состоянии в глобальных переменных...
...
widget = Button(text='spam', command=handler)
Чтобы зарегистрировать обработчик события щелчка на кнопке,
мы обычно передаем в аргументе с именем command вызываемый
объект, который не имеет входных аргументов. Здесь часто ис
пользуются имена простых функций (и lambdaвыражения), но
можно также передавать и методы классов – при условии, что
они будут связанными методами:
class MyWidget:
def handler(self):
...сохраняет информацию о состоянии в self.attr...
def makewidgets(self):
b = Button(text='spam', command=self.handler)
Здесь обработчик события – это объект связанного метода, где со
храняются self и MyWidget.handler. Так как аргумент self ссылает
ся на оригинальный экземпляр, то когда метод handler будет вы
зван для обработки события, он получит доступ к атрибутам эк
земпляра, где может сохраняться информация о состоянии меж
ду событиями. При использовании обычных функций для этих
целей, как правило, используются глобальные переменные. Дру
гой способ обеспечения совместимости классов с прикладным ин
терфейсом, основанным на применении функций, приводится
в главе 24, где обсуждается метод перегрузки операторов __call__.
Классы и модули 659
>>> import docstr
>>> docstr.__doc__
'I am: docstr.__doc__'
>>> docstr.spam.__doc__
'I am: spam.__doc__ or docstr.spam.__doc__'
>>> docstr.spam.method.__doc__
'I am: spam.method.__doc__ or self.method.__doc__'
>>> docstr.func.__doc__
'I am: docstr.func.__doc__'
В главе 14 также обсуждается PyDoc – инструмент, который позволяет
формировать отчеты из всех этих строк.
Строки документирования доступны во время выполнения, но синтак
сически они менее гибки, чем комментарии # (которые могут находить
ся в любом месте программы). Обе формы несут пользу, и любая доку
ментация к программе – это хорошо (при условии, что она точная).
Классы и модули
Мы завершаем эту главу кратким сравнением предметов обсуждения
двух последних частей книги: модулей и классов. Так как оба пред
ставляют собой пространства имен, различия между ними бывает
трудно заметить сразу. В двух словах:
Модули
• Это пакеты данных и исполняемого кода.
• Создаются как файлы с программным кодом на языке Python или
как расширения на языке C.
• Задействуются операцией импортирования.
Классы
• Реализуют новые объекты.
• Создаются с помощью инструкции class.
• Задействуются операцией вызова.
• Всегда располагаются внутри модуля.
Кроме того, классы поддерживают дополнительные возможности, не
доступные в модулях, такие как перегрузка операторов, создание мно
жества экземпляров и наследование. Несмотря на то, что и классы, и мо
дули являются пространствами имен, к настоящему времени вы долж
ны четко понимать, что между ними имеются существенные различия.
В заключение
В этой главе мы рассмотрели подборку типичных способов комбиниро
вания классов для получения наибольшей пользы от их повторного ис
660 Глава 25. Шаблоны проектирования с классами
пользования и возможности разбивать крупные задачи на более мел
кие части, что обычно относится к проблемам проектирования, кото
рые часто рассматриваются вне зависмости от конкретного языка про
граммирования (хотя язык Python способен облегчить их решение).
Мы изучили приемы делегирования (обертывание объектов в классы
обертки), композиции (управление встраиваемыми объектами), насле
дования (приобретение поведения от других классов) и некоторые дру
гие не совсем обычные концепции, такие как множественное наследо
вание, связанные методы и фабрики.
Следующая глава завершает изучение классов и ООП рассмотрением бо
лее сложных тем, связанных с классами. Часть этого материала может
быть более интересна для тех, кто пишет инструментальные средства,
а не прикладные программы, но эти сведения все же заслуживают того,
чтобы с ними ознакомились большинство тех, кто занимается ООП на
языке Python. Однако сначала ответьте на контрольные вопросы.
Закрепление пройденного
Контрольные вопросы
1. Что такое множественное наследование?
2. Что такое делегирование?
3. Что такое композиция?
4. Что такое связанные методы?
Ответы
1. Множественное наследование имеет место, когда класс наследует
более одного суперкласса, – это удобно для объединения пакетов
программного кода, оформленных в виде классов.
2. Делегирование подразумевает обертывание объекта классомоберт
кой, который расширяет функциональные возможности обернуто
го объекта и передает ему выполнение части операций. Класс
обертка сохраняет интерфейс обернутого объекта.
3. Композиция – это прием, который подразумевает наличие контрол
лера, куда встраиваются и которым управляются несколько объек
тов. Класс контроллера предоставляет все интерфейсы как свои
собственные – это один из способов создания крупных структур
с помощью классов.
4. Связанные методы объединяют экземпляр класса и функцию мето
да – их можно вызывать, не передавая объект экземпляра в первом
аргументе, потому что внутри таких методов попрежнему доступен
оригинальный экземпляр.
26
Дополнительные возможности классов
Эта глава завершает шестую часть книги и наше изучение ООП на язы
ке Python представлением нескольких более сложных тем, связанных
с использованием классов: мы рассмотрим возможность создания под
классов встроенных типов, псевдочастные (pseudoprivate) атрибуты,
классы нового стиля, статические функции, декораторы функций
и многое другое.
Как мы уже знаем, модель ООП в языке Python чрезвычайно проста,
а некоторые из приемов, представленных в этой главе, настолько слож
ны и совершенно необязательны к использованию, что вы, возможно,
не слишком часто будете встречать их в своей карьере прикладного
программиста на языке Python. Тем не менее в интересах законченно
сти обсуждения, мы завершим наше обсуждение классов кратким обзо
ром этих возможностей.
Как обычно, т.к. это последняя глава в этой части, она завершается
сводкой типичных проблем, с которыми сталкиваются программисты
при использовании классов, и набором упражнений к этой части. Я со
ветую вам обязательно проработать эти упражнения, чтобы прочнее
ухватить идеи, которые мы изучали в этой части. Я также предлагаю
вам самостоятельно познакомиться с крупными объектноориентиро
ванными проектами на языке Python в дополнение к этой книге. Как
и все в программировании, преимущества ООП становятся более оче
видными с обретением опыта.
Расширение встроенных типов
Помимо реализации объектов новых типов классы иногда использу
ются для расширения функциональных возможностей встроенных ти
пов языка Python с целью обеспечения поддержки более экзотических
структур данных. Например, чтобы добавить в списки дополнитель
662 Глава 26. Дополнительные возможности классов
ные методы вставки и удаления, можно создать класс, который оберты
вает (встраивает) объект списка и экспортирует методы вставки и уда
ления, которые особым образом обрабатывают список, подобно тому,
как реализуется прием делегирования, рассмотренный в главе 25. На
чиная с версии Python 2.2 для специализации встроенных типов мож
но также использовать наследование. Следующие два раздела демон
стрируют оба приема в действии.
Расширение типов встраиванием
Помните те функции для работы со множествами, которые мы написа
ли в четвертой части книги? Ниже показано, как они выглядят, реани
мированные в виде класса на языке Python. Следующий пример (файл
setwrapper.py) реализует новый тип объектов за счет перемещения не
скольких функций в методы и добавления перегрузки нескольких ос
новных операторов. По большей части этот класс просто обертывает
список, добавляя дополнительные операции. Поскольку это класс, он
также поддерживает возможность создания множества экземпляров
и адаптацию своего поведения наследованием в подклассах:
class Set:
def __init__(self, value = []): # Конструктор
self.data = [] # Управляет списком
self.concat(value)
def intersect(self, other): # other – любая последовательность
res = [] # self – подразумеваемый объект
for x in self.data:
if x in other: # Выбрать общие элементы
res.append(x)
return Set(res) # Вернуть новый экземпляр Set
def union(self, other): # other – любая последовательность
res = self.data[:] # Копировать список
for x in other: # Добавить элементы из other
if not x in res:
res.append(x)
return Set(res)
def concat(self, value): # Аргумент value: список, Set...
for x in value: # Удалить дубликаты
if not x in self.data:
self.data.append(x)
def __len__(self): return len(self.data) # len(self)
def __getitem__(self, key): return self.data[key] # self[i]
def __and__(self, other): return self.intersect(other) # self & other
def __or__(self, other): return self.union(other) # self | other
def __repr__(self): return 'Set:' + `self.data` # Вывод
Перегрузка операции доступа к элементам по их индексам позволяет
экземплярам нашего класса Set выглядеть как настоящие списки.
В упражнениях в конце этой главы вам будет предложено организо
Расширение встроенных типов 663
вать взаимодействие с этим классом и расширить его, поэтому подроб
нее об этом фрагменте мы поговорим в приложении B.
Расширение типов наследованием
Начиная с версии Python 2.2 все встроенные типы можно наследовать.
Функции преобразования типов, такие как list, str, dict и tuple, пре
вратились в имена встроенных типов. Теперь вызов функции преобра
зования типа (например, list('spam')) в действительности является
вызовом конструктора типа.
Это изменение позволяет адаптировать или расширять поведение встро
енных типов с помощью инструкций class: достаточно просто создать
подклассы с новыми именами типов, где реализовать необходимые из
менения. Экземпляры вашего нового подкласса могут использоваться
везде, где допускается использовать оригинальный встроенный тип. На
пример, предположим, вас не устраивает тот факт, что стандартные спи
ски начинают отсчет элементов с 0, а не с 1. Это не проблема – вы всегда
можете создать свой подкласс, который изменяет эту характерную осо
бенность списков. В файле typesubclass.py показано, как это делается:
# Подкласс встроенного типа/класса list.
# Отображает диапазон 1..N на 0..N1; вызывает встроенную версию.
class MyList(list):
def __getitem__(self, offset):
print '(indexing %s at %s)' % (self, offset)
return list.__getitem__(self, offset  1)
if __name__ == '__main__':
print list('abc')
x = MyList('abc') # __init__ наследуется из списка
print x # __repr__ наследуется из списка
print x[1] # MyList.__getitem__
print x[3] # Изменяет поведение метода суперкласса
x.append('spam'); print x # Атрибуты, унаследованные
# от суперкласса списка
x.reverse(); print x
В этом файле подкласс MyList расширяет метод __getitem__ встроенных
списков простым отображением диапазона значений от 1 до N на необ
ходимый спискам диапазон от 0 до N1. Уменьшение индекса на еди
ницу и вызов версии метода из суперкласса – вот все, что в действи
тельности делается, но этого вполне достаточно для достижения по
ставленной цели:
% python typesubclass.py
['a', 'b', 'c']
['a', 'b', 'c']
(indexing ['a', 'b', 'c'] at 1)
a
(indexing ['a', 'b', 'c'] at 3)
664 Глава 26. Дополнительные возможности классов
c
['a', 'b', 'c', 'spam']
['spam', 'c', 'b', 'a']
В эти результаты включен текст, который выводит метод класса при
выполнении индексирования. Является ли изменение способа индек
сирования универсально хорошей идеей, это уже другой вопрос: поль
зователи вашего класса MyList могут быть повергнуты в недоумение та
ким отступлением от общепринятого поведения последовательностей
в языке Python. Однако возможность адаптировать встроенные типы
подобным образом может оказаться мощным инструментом.
Например, такой шаблон дает начало новому способу реализации мно
жеств – в виде подкласса встроенного списка, а не в виде самостоятель
ного класса, который управляет встроенным в него объектом списка.
Следующий пример реализации класса в файле setsubclass.py адапти
рует списки, добавляя методы и операторы, используемые для работы
с множествами. Все остальное поведение наследуется от суперкласса
list, поэтому альтернатива получилась более короткой и простой:
class Set(list):
def __init__(self, value = []): # Конструктор
list.__init__([]) # Адаптирует список
self.concat(value) # Копировать изменяемый аргумент по умолчанию
def intersect(self, other): # other – любая последовательность
res = [] # self – подразумеваемый объект
for x in self:
if x in other: # Выбрать общие элементы
res.append(x)
return Set(res) # Вернуть новый экземпляр Set
def union(self, other): # other – любая последовательность
res = Set(self) # Копировать меня и мой список
res.concat(other)
return res
def concat(self, value): # аргумент value: list, Set...
for x in value: # Удалить дубликаты
if not x in self:
self.append(x)
def __and__(self, other): return self.intersect(other)
def __or__(self, other): return self.union(other)
def __repr__(self): return 'Set:' + list.__repr__(self)
if __name__ == '__main__':
x = Set([1,3,5,7])
y = Set([2,1,4,5,6])
print x, y, len(x)
print x.intersect(y), y.union(x)
print x & y, x | y
x.reverse(); print x
Псевдочастные атрибуты класса 665
Ниже приводится вывод, полученный в результате выполнения кода
самопроверки, находящегося в конце файла. Поскольку проблема на
следования встроенных типов достаточно сложна, я опущу дальней
шие подробности, но я предлагаю внимательно посмотреть на полу
ченные результаты, чтобы изучить поведение подкласса:
% python setsubclass.py
Set:[1, 3, 5, 7] Set:[2, 1, 4, 5, 6] 4
Set:[1, 5] Set:[2, 1, 4, 5, 6, 3, 7]
Set:[1, 5] Set:[1, 3, 5, 7, 2, 4, 6]
Set:[7, 5, 3, 1]
Есть и более эффективные способы реализации множеств – с помощью
словарей, позволяющих заменить последовательное сканирование, ис
пользуемое в данной реализации, на операцию обращения по ключу
(хеширование) и тем самым повысить скорость работы. (За дополни
тельной информацией обращайтесь к книге «Programming Python».)
Если вас заинтересовали множества, тогда вам также стоит взглянуть
на тип объектов set, который рассматривался в главе 5, – этот встроен
ный тип реализует операции над множествами. Реализация операций
над множествами прекрасно подходит для нужд обучения, но создавать
такие реализации в современных версиях Python больше не требуется.
В качестве другого примера наследования можно привести новый тип
bool, появившийся в Python 2.3. Как упоминалось ранее в этой книге,
bool – это подкласс типа int с двумя экземплярами (True и False), кото
рые ведут себя как целые числа 1 и 0, но наследуют измененные вер
сии методов вывода, особым образом отображающие их имена.
Псевдочастные атрибуты класса
В четвертой части книги мы узнали, что все имена, для которых вы
полняется присваивание на верхнем уровне модуля, становятся гло
бальными для этого модуля. То же самое по умолчанию относится
и к классам – сокрытие данных регулируется соглашениями, и клиен
ты могут получать и изменять любые атрибуты класса или экземпляра
по своему усмотрению. Фактически все атрибуты являются «общедос
тупными» (public) и «виртуальными» (virtual), если говорить в терми
нах языка C++, – они доступны отовсюду и динамически отыскивают
ся во время выполнения.1
1 Это излишне пугает программистов, работающих с языком C++. В языке
Python возможно даже изменить или полностью удалить метод класса во
время выполнения программы. С другой стороны, почти никто не исполь
зует такие возможности на практике. Как язык сценариев, Python больше
печется о том, чтобы позволить, а не запретить. Кроме того, вспомните об
суждение перегрузки операторов в главе 24, где говорилось, что методы
__getattr__ и __setattr__ могут использоваться для имитации поведения ча
стных атрибутов, но на практике эта возможность обычно не используется.
666 Глава 26. Дополнительные возможности классов
На сегодняшний день все это пока так и есть. Однако Python поддержи
вает такое понятие, как «искажение» («mangling») имен (то есть рас
ширение), с целью придать им черты локальных имен класса. Иска
женные имена иногда ошибочно называют частными атрибутами, но
в действительности это всего лишь способ ограничить доступ к име
нам в классе – искажение имен не предотвращает доступ из программ
ного кода, находящегося за пределами класса. Эта особенность в ос
новном предназначена, чтобы избежать конфликтов имен в экземпля
рах, а не для ограничения доступа к именам – поэтому искаженные
имена лучше называть «псевдочастными», чем «частными».
Псевдочастные имена – это совершенно необязательная возможность
и вы, скорее всего, не найдете в ней особого смысла, пока не начнете
писать крупные иерархии классов в проектах, над которыми трудятся
несколько программистов. Но так как использование этой возможно
сти может встретиться в программном коде других программистов,
вам следует знать о ней, даже если вы сами не используете ее.
Об искажении имен в общих чертах
Здесь описывается, как действует искажение имен: имена внутри ин
струкции class, которые начинаются с двух символов подчеркивания,
но не заканчиваются двумя символами подчеркивания, автоматически
расширяются за счет включения имени вмещающего класса. Напри
мер, такое имя как __X в классе с именем Spam автоматически изменится
на _Spam__X: к оригинальному имени будет добавлен префикс, состоя
щий из символа подчеркивания и имени вмещающего класса, и в ре
зультате будет получено достаточно уникальное имя, которое не будет
вступать в конфликт с именами в других классах иерархии.
Искажение имен происходит только внутри инструкций class и толь
ко для имен, которые начинаются двумя символами подчеркивания.
Однако это происходит со всеми именами, которые начинаются двумя
символами подчеркивания, включая имена методов и имена атрибу
тов экземпляров (например, в нашем примере с классом Spam ссылка на
атрибут экземпляра self.__X будет преобразована в self._Spam__X). По
скольку экземпляр может получать атрибуты более чем из одного
класса, такое искажение позволяет избежать конфликтов, но чтобы
понять, как это происходит, нам нужно рассмотреть пример.
Для чего нужны псевдочастные атрибуты?
Задача, которую призваны решить псевдочастные атрибуты, состоит
в том, чтобы обеспечить способ сохранения атрибутов экземпляра.
В языке Python все атрибуты экземпляра принадлежат единственно
му объекту экземпляра, расположенному внизу дерева наследования.
Это существенно отличается от модели языка C++, где каждый класс
обладает своим собственным набором членов данных, которые он опре
деляет.
Псевдочастные атрибуты класса 667
В языке Python всякий раз, когда в пределах метода класса выполняет
ся присваивание атрибуту аргумента self (например, self.attr = value),
создается или изменяется атрибут экземпляра (поиск в дереве насле
дования выполняется только при попытке получить ссылку, а не при
своить значение). Это верно, даже когда несколько классов в иерархии
выполняют присваивание одному и тому же атрибуту, поэтому кон
фликты имен вполне возможны.
Например, предположим, что, когда программист писал класс, он
предполагал, что экземпляры этого класса будут владеть атрибутом X.
В методах класса выполняется присваивание этому атрибуту и позднее
извлекается его значение:
class C1:
def meth1(self): self.X = 88 # Предполагается, что X  это мой атрибут
def meth2(self): print self.X
Далее предположим, что другой программист, работающий отдельно,
исходил из того же предположения, когда писал свой класс:
class C2:
def metha(self): self.X = 99 # И мой тоже
def methb(self): print self.X
Каждый класс по отдельности работает нормально. Проблема возника
ет, когда оба класса оказываются в одном дереве наследования:
class C3(C1, C2): ...
I = C3() # У меня только один атрибут X!
Теперь значение, которое получит каждый класс из выражения self.X,
будет зависеть от того, кто из них последним присвоил значение. Все
операции присваивания атрибуту self.X будут воздействовать на один
и тот же экземпляр, у которого может быть только один атрибут X – I.X –
независимо от того, сколько классов используют это имя.
Чтобы гарантировать принадлежность атрибута тому классу, который
его использует, достаточно в начале имени атрибута поставить два сим
вола подчеркивания везде, где оно используется классом, как в сле
дующем файле private.py:
class C1:
def meth1(self): self.__X = 88 # Теперь X  мой атрибут
def meth2(self): print self.__X # Превратится в _C1__X
class C2:
def metha(self): self.__X = 99 # И мой тоже
def methb(self): print self.__X # Превратится в _C2__X
class C3(C1, C2): pass
I = C3() # У меня два имени X
I.meth1(); I.metha()
print I.__dict__
I.meth2(); I.methb()
668 Глава 26. Дополнительные возможности классов
При наличии такой приставки имена атрибутов X будут дополнены
именами их классов, прежде чем будут добавлены в экземпляр. Если
вызвать функцию dir, чтобы просмотреть перечень атрибутов экземп
ляра I, или просмотреть содержимое его словаря пространства имен
после того, как атрибутам будут присвоены значения, можно увидеть
измененные имена _C1__X и _C2__X, но не X. Такое дополнение придаст
именам уникальность внутри экземпляра, поэтому разработчики клас
сов могут рассчитывать на то, что все имена, начинающиеся с двух
символов подчеркивания, действительно принадлежат их классам:
% python private.py
{'_C2__X': 99, '_C1__X': 88}
88
99
Этот прием помогает избежать конфликтов имен в экземплярах, но за
метьте, что он не обеспечивает настоящего сокрытия данных. Если вы
знаете имя атрибута внутри класса, вы сможете обратиться к нему из
любой точки программы, где имеется ссылка на экземпляр, используя
для этого расширенное имя (например, I._C1__X = 77). С другой сторо
ны, эта особенность делает менее вероятным, что вы случайно вступи
те в конфликт с существующими именами в классе.
Еще раз отмечу, что эта особенность более полезна для крупных проек
тов, в которых участвует несколько программистов, и только для от
дельных имен. Не торопитесь загромождать свой программный код
лишними символами без нужды – используйте эту особенность, толь
ко когда действительно необходимо обеспечить принадлежность атри
бута единственному классу. Для простых программ этот прием будет
излишеством.
Кроме того, посмотрите, как имитируется сокрытие атрибутов
в главе 24, в разделе с описанием метода __getattr__. Несмотря на
то, что в языке Python вполне возможно организовать управление
доступом к атрибутам классов, тем не менее, этот прием редко ис
пользуется на практике, даже в крупных программах.
Классы нового стиля
В версии Python 2.2 появилась новая разновидность классов, извест
ная как классы «нового стиля». Классы, рассматривавшиеся до сих
пор в этой части книги, называют «классическими классами», когда
сравнивают их с новой разновидностью.
Классы нового стиля лишь немного отличаются от классических клас
сов, и эти отличия совершенно незаметны для подавляющего большин
ства пользователей Python. Кроме того, классическая модель классов,
используемая в языке Python на протяжении последних 15 лет, по
прежнему работает именно так, как было описано выше.
Классы нового стиля 669
Классы нового стиля практически сохраняют обратную совместимость
с классическими классами в синтаксисе и в поведении – они привно
сят лишь несколько новых особенностей. Однако, т.к. они изменили
один особый случай наследования, их следует представлять как от
дельный инструмент, чтобы избежать нежелательных воздействий на
любой существующий программный код, работоспособность которого
зависит от прежнего поведения классов.
Классы нового стиля создаются с помощью привычной синтаксиче
ской конструкции, которую мы уже изучили. Главное отличие состоит
в том, что новые классы объявляются как подклассы встроенных ти
пов (например, list). Если ни один из встроенных типов не подходит
для наследования, тогда новые классы в качестве суперкласса должны
указывать новое встроенное имя object:
class newstyle(object):
...обычная реализация класса...
Если говорить более широко, любой класс, наследующий object или
любой другой встроенный тип, автоматически будет рассматриваться
как класс нового стиля. (Под наследованием я подразумеваю все под
классы object, подклассы подклассов object, и т. д. – если гдето в дере
ве наследования в качестве суперкласса присутствует встроенный тип,
класснаследник будет рассматриваться как класс нового стиля.) Клас
сы, не наследующие встроенные типы, считаются классическими.
Согласно утверждениям Гвидо ван Россума (Guido van Rossum),
создателя языка Python, начиная с версии Python 3.0 все классы
автоматически будут считаться классами нового стиля, поэтому
требование наследования встроенных типов отпадет автоматиче
ски. Даже самостоятельные классы будут считаться классами но
вого стиля, к тому же классы нового стиля сохранят обратную со
вместимость с классическими классами, поэтому для большинст
ва программистов эти изменения будут малозаметны.
В прошлом имелось некоторое беспокойство, что в Python 3.0
классы верхнего уровня необходимо будет наследовать от object.
Однако недавно Гвидо (Guido) заявил, что этого не потребуется.
Для большинства программистов все классы в версии 3.0 будут ра
ботать так, как описывается в этой книге, но с некоторыми новы
ми особенностями, свойственными классам нового стиля. Тем не
менее, я не берусь предсказывать будущее, поэтому за дополни
тельной информацией обращайтесь к примечаниям к выпуску 3.0.
Ромбоидальное наследование
Пожалуй, самым ощутимым изменением в классах нового стиля явля
ется немного отличная интерпретация наследования – так называемая
ромбоидальная схема в деревьях множественного наследования, когда
более одного суперкласса наследует один и тот же суперкласс более
высокого уровня. Ромбоидальная схема – это сложная концепция про
670 Глава 26. Дополнительные возможности классов
ектирования, которую мы даже не обсуждали при изучении обычных
классов.
Проще говоря, в классической модели процедура поиска в дереве насле
дования сначала движется строго вверх по дереву, а потом слева напра
во – сначала интерпретатор поднимается вверх всеми возможными пу
тями по левой стороне дерева, затем возвращается назад и начинает по
иск с первого суперкласса, расположенного правее предыдущего. В но
вой модели в таких случаях поиск сначала производится в ширину –
интерпретатор сначала просматривает все суперклассы, стоящие пра
вее того, где поиск уже произведен, и только потом начинает подъем
всеми возможными путями к общему суперклассу. Вследствие такого
изменения суперклассы, расположенные ниже, получают возмож
ность переопределять атрибуты суперклассов, стоящих выше, незави
симо от вида деревьев множественного наследования.
Пример ромбоидального наследования
В качестве иллюстрации рассмотрим следующую упрощенную реали
зацию ромбоидального наследования для классических классов:
>>> class A: attr = 1 # Классическая модель
>>> class B(A): pass
>>> class C(A): attr = 2
>>> class D(B,C): pass # Сначала поиск дойдет до A, потом до C
>>> x = D()
>>> x.attr
1
В этом случае атрибут attr будет найден в суперклассе A, потому что
в классической модели поиск в дереве наследования сначала произво
дится в высоту, и только потом происходит смещение вправо – интер
претатор выполнит поиск в классах в следующем порядке: D, B, A и за
тем C (впрочем, поиск прекратится, как только атрибут attr будет най
ден в суперклассе A, расположенном выше суперкласса B). В классах
нового стиля, наследующих встроенный тип, такой как object, прежде
чем просмотреть суперкласс A, интерпретатор сначала выполнит поиск
в суперклассе C (правее суперкласса B), то есть, в следующем порядке:
D, B, C и затем A (но в этом случае поиск остановится в суперклассе C):
>>> class A(object): attr = 1 # Новый стиль
>>> class B(A): pass
>>> class C(A): attr = 2
>>> class D(B,C): pass # Сначала поиск дойдет до C, потом до A
>>> x = D()
>>> x.attr
2
Это изменение процедуры поиска основано на предположении, что ес
ли вы добавляете класс C в дерево ниже, это значит, что вы хотите по
лучить его атрибуты раньше, чем атрибуты класса A. Кроме того, это
Классы нового стиля 671
изменение предполагает, что класс C всегда будет иметь возможность
переопределить атрибуты класса A, что, скорее всего, верно, когда пи
шется самостоятельный класс, но совсем неверно, когда в ромбоидаль
ной схеме принимают участие классические классы – вы можете даже
не подозревать, что класс C может участвовать в подобной схеме насле
дования, когда пишете его.
Явное разрешение конфликтов имен
Проблема с предположениями – в том, что они всего лишь предположе
ния. Если такое отклонение в процедуре поиска кажется вам слишком
трудным для запоминания или вам требуется более полное управление
процедурой поиска, вы всегда можете произвести выбор желаемого ат
рибута из любого места в дереве, выполнив присваивание или както
иначе обозначив его там, где может возникнуть смешение классов:
>>> class A: attr = 1 # Классическая модель
>>> class B(A): pass
>>> class C(A): attr = 2
>>> class D(B,C): attr = C.attr # Выбрать C, справа
>>> x = D()
>>> x.attr # Работает как класс нового стиля
2
Здесь дерево классических классов имитирует порядок поиска, приня
тый в модели классов нового стиля: присваивание атрибуту attr
в классе D явно выбирает версию атрибута из класса C, благодаря чему
нарушается обычный порядок поиска в дереве наследования (атрибут
D.attr находится ниже в дереве). Точно так же классы нового стиля мо
гут имитировать порядок поиска в классической модели, выбирая тре
буемый атрибут там, где может происходить смешение:
>>> class A(object): attr = 1 # Новый стиль
>>> class B(A): pass
>>> class C(A): attr = 2
>>> class D(B,C): attr = B.attr # Выбрать A.attr, выше
>>> x = D()
>>> x.attr # Работает как классический класс
1
Если вам необходимо всегда явно разрешать конфликты, подобные
этим, вы можете просто игнорировать различия в порядке поиска и не
полагаться на предположения о том, что имеется в виду, когда вы пи
шете свои классы. Естественно, такой способ выбора атрибутов может
также применяться и к методам, потому что методы – это обычные
объекты:
>>> class A:
... def meth(s): print 'A.meth'
>>> class C(A):
... def meth(s): print 'C.meth'
672 Глава 26. Дополнительные возможности классов
>>> class B(A):
... pass
>>> class D(B,C): pass # Использовать порядок поиска по умолчанию
>>> x = D() # Зависит от типа класса
>>> x.meth() # По умолчанию используется классический порядок поиска
A.meth
>>> class D(B,C): meth = C.meth # Выбрать метод класса C: новый стиль
>>> x = D()
>>> x.meth()
C.meth
>>> class D(B,C): meth = B.meth # Выбрать метод класса B:
# классическая модель
>>> x = D()
>>> x.meth()
A.meth
Здесь мы явно выбираем методы, выполняя присваивание именам, на
ходящимся ниже в дереве. Мы могли бы просто вызвать метод желае
мого класса явно; на практике этот подход, возможно, является более
принятым, в особенности при работе с конструкторами:
class D(B,C):
def meth(self): # Переопределяется ниже
...
C.meth(self) # Вызовом выбрать метод класса C
Такой выбор путем присваивания или вызова в точках смешения мо
жет эффективно обезопасить ваш программный код от возможных
различий между разными моделями классов. Явное разрешение кон
фликтов таким способом гарантирует, что правильная работа вашего
программного кода не будет зависеть от версии Python в будущем (не
зависимо от необходимости наследовать встроенные типы, чтобы ис
пользовать новую модель).1
Итак, поиск в ромбоидальной схеме наследования выполняется по
разному в классической и в новой моделях, и это изменение нарушает
обратную совместимость. Однако имейте в виду, что это изменение за
1 Даже если не учитывать расхождения между классической и новой моде
лями, данная методика иногда может пригодиться в случаях множествен
ного наследования. Если вам необходимо получить часть атрибутов от су
перкласса слева, а часть – от суперкласса справа, вам может потребоваться
указать интерпретатору Python, какие именно атрибуты следует выбирать,
выполняя явное присваивание в подклассах. Мы еще вернемся к этому во
просу в разделе с описанием типичных проблем в конце этой главы. Кроме
того, обратите внимание, что ромбоидальные схемы наследования в неко
торых случаях могут доставлять еще больше хлопот, чем я описал здесь
(например, что если оба конструктора классов B и C вызывают конструктор
класса A, и при этом необходимо вызывать оба наследуемых конструктора
в подклассе?), но это лежит за пределами рассмотрения данной книги.
Классы нового стиля 673
трагивает только ромбоидальные схемы наследования – во всех дру
гих схемах принцип действия модели наследования нового стиля не
изменился. Кроме того, вполне возможно, что вся эта проблема будет
носить скорее теоретический характер, чем практический, – с выхо
дом версии Python 2.2 эти изменения не оказали достаточно сущест
венного влияния, и потому маловероятно, что они затронут значитель
ную часть программного кода на языке Python.
Другие расширения в классах нового стиля
Помимо изменения порядка поиска в ромбоидальной схеме (что само
по себе слишком неясно, чтобы иметь большое значение для большин
ства читателей этой книги) классы нового стиля привносят несколько
еще более сложных возможностей. Ниже приводится краткий обзор
каждой из них.
Статические методы и методы класса
Начиная с версии Python 2.2 появилась возможность определять мето
ды класса, которые могут вызываться без участия экземпляра: ста+
тические методы работают почти так же, как обычные функции, толь
ко расположенные внутри класса, а методы класса получают сам
класс вместо экземпляра. Чтобы сделать возможными эти режимы ра
боты методов, внутри класса должны вызываться специальные встро
енные функции staticmethod и classmethod. Несмотря на то, что эта осо
бенность была добавлена вместе с классами нового стиля, ее можно ис
пользовать и в классических классах тоже. Вследствие этого отложим
обсуждение данной темы до следующего раздела.
Слоты экземпляров
Присваивая список имен атрибутов в виде строк специальному атрибу
ту __slots__ класса, в классах нового стиля можно ограничить множе
ство разрешенных атрибутов для экземпляров класса. Обычно этот ат
рибут устанавливается присваиванием переменной __slots__ на верх
нем уровне в инструкции class: только имена, перечисленные в списке
__slots__, смогут использоваться как атрибуты экземпляра. Однако,
как и в случае с любыми именами в языке Python, прежде чем полу
чить доступ к атрибутам экземпляра им должны быть присвоены зна
чения, даже если они перечислены в списке __slots__. Например:
>>> class limiter(object):
... __slots__ = ['age', 'name', 'job']
...
>>> x = limiter()
>>> x.age # Присваивание должно быть выполнено раньше использования
AttributeError: age
>>> x.age = 40
>>> x.age
40
674 Глава 26. Дополнительные возможности классов
>>> x.ape = 1000 # Недопустимое имя: отсутствует в слотах
AttributeError: 'limiter' object has no attribute 'ape'
(AttributeError: объект 'limiter' не имеет атрибута 'ape')
Эта особенность должна помочь ликвидировать ошибки, обусловлен
ные простыми «опечатками» (обнаруживается попытка присваивания
атрибутам, отсутствующим в списке __slots__) и обеспечить некото
рую оптимизацию (атрибуты слота могут сохраняться не в словаре,
а в кортеже, обеспечивая тем самым более высокую скорость поиска).
Однако слоты – это своего рода нарушение динамической природы
языка Python, которая диктует, что операция присваивания может
создавать любые имена. Кроме того, у них имеются дополнительные
ограничения и следствия, которые слишком сложны, чтобы обсуж
дать их здесь. Например, некоторые экземпляры со слотами могут не
иметь атрибут словаря __dict__, что может сделать некоторые метапро
граммы, которые мы создавали в этой книге, более сложными, напри
мер, инструментам, выполняющим поиск атрибутов, скорее всего при
дется искать имена в двух источниках вместо одного. За дополнитель
ной информацией обращайтесь к документации к выпуску Python 2.2
и стандартному набору руководств по языку Python.
Свойства класса
Механизм, известный как свойства, обеспечивает в классах нового
стиля еще один способ определения методов, вызываемых автоматиче
ски при обращении или присваивании атрибутам экземпляра. Эта осо
бенность во многих случаях представляет собой альтернативу методам
перегрузки операторов __getattr__ и __setattr__, которые мы рассмат
ривали в главе 24. Свойства обладают тем же эффектом, что и эти два
метода, только в этом случае выполняется вызов метода даже при про
стом обращении к атрибуту, что бывает полезно для атрибутов, значе
ния которых вычисляются динамически. Свойства (и слоты) основаны
на новом понятии дескрипторов атрибутов – темы слишком сложной,
чтобы обсуждать ее здесь.
Проще говоря, свойства – это тип объектов, который присваивается
именам атрибутов класса. Они создаются вызовом встроенной функ
ции property с тремя методами (обработчиками операций получения,
присваивания и удаления) и строкой документирования – если в ка
комлибо аргументе передается значение None, следовательно, эта опе
рация не поддерживается. Определение свойств обычно производится
на верхнем уровне в инструкции class (например, name = property(...)).
Когда выполняется такое присваивание, при попытке доступа к атри
буту класса (то есть, obj.name) автоматически будет вызываться один
из методов доступа. Например, метод __getattr__ позволяет классам
перехватывать попытки доступа к неопределенным атрибутам класса:
>>> class classic:
... def __getattr__(self, name):
Классы нового стиля 675
... if name == 'age':
... return 40
... else:
... raise AttributeError
...
>>> x = classic()
>>> x.age # Запустит метод __getattr__
40
>>> x.name # Запустит метод __getattr__
AttributeError
Ниже тот же пример, но уже с использованием свойств:
>>> class newprops(object):
... def getage(self):
... return 40
... age = property(getage, None, None, None) # get,set,del,docs
...
>>> x = newprops()
>>> x.age # Запустит метод getage
40
>>> x.name # Нормальная операция извлечения
AttributeError: newprops instance has no attribute 'name'
(AttributeError: экземпляр newprops не имеет атрибута 'name')
В некоторых случаях свойства могут быть менее сложными и работать
быстрее, чем при использовании традиционных подходов. Например,
когда добавляется поддержка операции присваивания атрибуту, свой
ства становятся более привлекательными – программный код выгля
дит компактнее и в операцию присваивания не вовлекаются дополни
тельные вызовы методов, если не требуется производить дополнитель
ных вычислений:
>>> class newprops(object):
... def getage(self):
... return 40
... def setage(self, value):
... print 'set age:', value
... self._age = value
... age = property(getage, setage, None, None)
...
>>> x = newprops()
>>> x.age # Запустит метод getage
40
>>> x.age = 42 # Запустит метод setage
set age: 42
>>> x._age # Нормальная операция извлечения; нет вызова getage
42
>>> x.job = 'trainer' # Нормальная операция присваивания; нет вызова
setage
>>> x.job # Нормальная операция извлечения; нет вызова getage
'trainer'
676 Глава 26. Дополнительные возможности классов
При эквивалентном классическом решении проблемы класс мог бы
производить лишние вызовы метода и, возможно, выполнять присваи
вание значения атрибуту с использованием словаря, чтобы избежать
зацикливания:
>>> class classic:
... def __getattr__(self, name): # При ссылке на неопределенный атрибут
... if name == 'age':
... return 40
... else:
... raise AttributeError
... def __setattr__(self, name, value): # Для всех операций присваивания
... print 'set:', name, value
... if name == 'age':
... self.__dict__['_age'] = value
... else:
... self.__dict__[name] = value
...
>>> x = classic()
>>> x.age # Запустит метод __getattr__
40
>>> x.age = 41 # Запустит метод __setattr__
set: age 41
>>> x._age # Определен: нет вызова __getattr__
41
>>> x.job = 'trainer' # Запустит метод __setattr__ опять
>>> x.job # Определен: нет вызова __getattr__
Для этого примера свойства обладают неоспоримым преимуществом.
Однако в некоторых приложениях методы __getattr__ и __setattr__ по
прежнему могут быть востребованы для обеспечения более динамич
ных или универсальных интерфейсов, чем можно реализовать с помо
щью свойств. Например, во многих случаях невозможно заранее опре
делить набор поддерживаемых атрибутов, которые могут даже не суще
ствовать вообще в какомлибо виде на момент написания класса (напри
мер, при делегировании ссылок на произвольные методы в обернутых/
встроенных объектах). В таких случаях использование более универ
сальных методов обслуживания атрибутов __getattr__ и __setattr__, ко
торым передаются имена атрибутов, может оказаться предпочтитель
нее. Кроме того, простейшие ситуации могут обслуживаться этими об
работчиками, поэтому свойства следует рассматривать как дополни
тельное и необязательное к использованию расширение.
Новый метод перегрузки _ _getattribute_ _
Метод __getattribute__ имеется только в классах нового стиля и позво
ляет классам перехватывать все попытки обращения к атрибутам, а не
только к неопределенным (как метод __getattr__). Кроме того, этот ме
тод более сложен в обращении, чем __getattr__ и __setattr__ (изза бо
лее высокой вероятности зацикливания). Полное описание этого мето
да я оставляю за стандартной документацией по языку Python.
Статические методы и методы класса 677
Помимо всех этих особенностей классы нового стиля интегрируются
с понятием расширения типов, упоминавшимся выше в этой главе, –
возможность расширения типов и классы нового стиля были введены
вместе с разделением тип/класс в версии Python 2.2 и выше.
Поскольку особенности классов нового стиля – это достаточно слож
ные темы, мы не будем углубляться в подробности в этой книге. За до
полнительной информацией обращайтесь к документации к выпуску
Python 2.2 и справочным руководствам по языку.
Статические методы и методы класса
До выхода версии Python 2.2 методы класса никогда нельзя было вызы
вать без передачи экземпляра в качестве аргумента. В Python 2.2 и более
поздних версиях такое поведение также используется по умолчанию, но
существует возможность изменить такое положение дел с помощью но
вой дополнительной особенности, получившей название статические
методы – простые функции без аргумента self, вложенные в определе
ние класса и предназначенные для работы с атрибутами класса, а не эк
земпляра. Такие методы обычно используются для обработки информа
ции, которая имеет отношение ко всем экземплярам (например, число
созданных экземпляров), а не для реализации поведения экземпляров.
В предыдущей главе мы говорили о несвязанных методах: когда мы из
влекаем функцию по имени класса (а не экземпляра), мы получаем
объект несвязанного метода. Хотя объекты несвязанных методов опре
деляются с помощью инструкции def, они не являются простыми функ
циями – они не могут вызываться без передачи им экземпляра класса.
Например, предположим, что необходимо использовать атрибуты
класса для подсчета числа экземпляров, созданных из класса (как по
казано в следующем файле spam.py). Не забывайте, что атрибуты клас
са совместно используются всеми экземплярами, поэтому мы можем
хранить счетчик непосредственно в объекте класса:
class Spam:
numInstances = 0
def __init__(self):
Spam.numInstances = Spam.numInstances + 1
def printNumInstances():
print "Number of instances created: ", Spam.numInstances
Но такая реализация не будет работать – метод printNumInstances по
прежнему ожидает получить экземпляр при вызове, потому что функ
ция ассоциирована с классом (даже при том, что в заголовке инструк
ции def отсутствуют какиелибо аргументы):
>>> from spam import *
>>> a = Spam()
>>> b = Spam()
>>> c = Spam()
678 Глава 26. Дополнительные возможности классов
>>> Spam.printNumInstances()
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: unbound method must be called with class instance 1st argument
(TypeError: несвязанный метод должен вызываться с экземпляром класса
в 1м аргументе)
Проблема состоит в том, что несвязанные методы экземпляра – это не
то же самое, что простые функции. Эта проблема главным образом яв
ляется проблемой знания особенностей языка. Самая простая мысль,
которая приходит в голову, – сделать метод обычной функцией, а не
методом класса. При таком способе функции не требуется передавать
экземпляр класса:
def printNumInstances():
print "Number of instances created: ", Spam.numInstances
class Spam:
numInstances = 0
def __init__(self):
Spam.numInstances = Spam.numInstances + 1
>>> import spam
>>> a = spam.Spam()
>>> b = spam.Spam()
>>> c = spam.Spam()
>>> spam.printNumInstances()
Number of instances created: 3
>>> spam.Spam.numInstances
3
Поскольку имя класса доступно простой функции в виде глобальной
переменной, все работает прекрасно. Кроме того, обратите внимание,
что имя самой функции также является глобальным, но только в этом
единственном модуле – оно не будет конфликтовать с именами в дру
гих модулях программы.
Мы могли бы сделать то же самое, вызывая функцию через экземпляр,
как обычно, хотя это не очень удобно, особенно если создание экземп
ляра приводит к изменениям в данных класса:
class Spam:
numInstances = 0
def __init__(self):
Spam.numInstances = Spam.numInstances + 1
def printNumInstances(self):
print "Number of instances created: ", Spam.numInstances
>>> from spam import Spam
>>> a, b, c = Spam(), Spam(), Spam()
>>> a.printNumInstances()
Number of instances created: 3
>>> b.printNumInstances()
Number of instances created: 3
Статические методы и методы класса 679
>>> Spam().printNumInstances()
Number of instances created: 4
До появления статических методов в Python 2.2 некоторые теоретики
языка утверждали, что в языке Python отсутствуют методы класса –
только методы экземпляра. Я полагаю, в действительности они имели
в виду, что классы в языке Python работают совсем не так, как в других
языках программирования. Что в действительности имеется в языке
Python, так это связанные и несвязанные методы с четкой семантикой –
при обращении к методу через имя класса вы получаете несвязанный
метод, который представляет собой особую разновидность функций.
В языке Python имеются атрибуты класса, но функции в классе ожи
дают получить экземпляр в виде аргумента.
Кроме того, в языке Python уже имеются модули, которые играют
роль инструмента разделения пространства имен, поэтому обычно не
возникает необходимости упаковывать функции в классы, если они не
реализуют функциональность объектов. Простые функции внутри мо
дуля обычно способны решать большую часть задач, которые возлага
ются на методы класса. Например, в первом фрагменте в этом разделе
функция printNumInstances уже связана с классом, потому что распола
гается в том же самом модуле. Единственный недостаток этой функ
ции состоит в том, что она имеет более широкую область видимости –
весь модуль, а не класс.
Использование статических методов и методов класса
На сегодняшний день существует еще одна возможность писать про
стые функции, связанные с классом. Начиная с версии Python 2.2
имеется возможность создавать классы со статическими методами
и с методами класса, ни один из которых не требует передачи экземпля
ра класса в виде аргумента. Чтобы определить такие методы, в классах
необходимо вызывать встроенные функции staticmethod и classmethod,
как упоминалось в обсуждении классов нового стиля. Например:
class Multi:
def imeth(self, x): # Обычный метод экземпляра
print self, x
def smeth(x): # Статический метод: экземпляр не передается
print x
def cmeth(cls, x): # Метод класса: получает класс, но не экземпляр
print cls, x
smeth = staticmethod(smeth) # Сделать smeth статичнским методом
cmeth = classmethod(cmeth) # Сделать cmeth методом класса.
Обратите внимание, как две последние операции присваивания в этом
фрагменте просто переприсваивают имена методов smeth и cmeth. Ат
рибуты создаются и изменяются с помощью операции присваивания
в инструкции class, поэтому эти заключительные операции присваи
вания переопределяют инструкции def, выполненные ранее.
680 Глава 26. Дополнительные возможности классов
С технической точки зрения, язык Python теперь поддерживает три раз
новидности методов классов: методы экземпляра, статические методы
и методы класса. Методы экземпляра – это обычные (и используемые
по умолчанию) методы, которые мы видели в этой книге. Для воздейст
вия на объект экземпляра всегда следует вызывать методы экземпляра.
Когда методы вызываются через экземпляр, интерпретатор автоматиче
ски передает экземпляр в первом аргументе – когда метод вызывается
через имя класса, экземпляр необходимо передавать методам вручную:
>>> obj = Multi() # Создать экземпляр
>>> obj.imeth(1) # Обычный вызов, через экземпляр
<__main__.Multi instance...> 1
>>> Multi.imeth(obj, 2) # Обычный вызов, через класс
<__main__.Multi instance...> 2
Статические методы, напротив, вызываются без аргумента с экземп
ляром класса – их имена ограничены областью видимости класса, в ко
тором они определяются и могут отыскиваться механизмом наследо
вания. Главным образом они действуют как обычные функции, кото
рые просто находятся внутри класса:
>>> Multi.smeth(3) # Вызов статического метода, через имя класса
3
>>> obj.smeth(4) # Вызов статического метода, через экземпляр
4
Методы класса похожи на них, но интерпретатор автоматически пе
редает методам класса сам класс (а не экземпляр) в первом аргументе:
>>> Multi.cmeth(5) # Вызов метода класса, через имя класса
__main__.Multi 5
>>> obj.cmeth(6) # Вызов метода класса, через экземпляр
__main__.Multi 6
Статические методы и методы класса являются новыми дополнитель
ными особенностями языка с узко специализированным назначением,
для описания которого у нас недостаточно места в этой книге. Статиче
ские методы обычно используются для работы с атрибутами класса
и управления информацией, которая касается всех экземпляров, соз
данных из класса. Например, чтобы вести подсчет количества создан
ных экземпляров класса (как в примере выше), можно было бы ис
пользовать статический метод, управляющий счетчиком, присоеди
ненным к классу в виде атрибута. Такой счетчик не имеет ничего об
щего ни с одним из экземпляров, поэтому было бы неудобно иметь
методы, которые обслуживают его, вызываемые через экземпляр (тем
более, что создание экземпляра для доступа к счетчику может изме
нить этот счетчик). Кроме того, близость статических методов к клас
су обеспечивает более естественное решение, чем ориентированные на
класс функции за пределами класса.
Ниже приводится реализация статического метода, эквивалентного
оригинальному примеру этого раздела:
Декораторы функций 681
class Spam:
numInstances = 0
def __init__(self):
Spam.numInstances += 1
def printNumInstances():
print "Number of instances:", Spam.numInstances
printNumInstances = staticmethod(printNumInstances)
>>> a = Spam()
>>> b = Spam()
>>> c = Spam()
>>> Spam.printNumInstances()
Number of instances: 3
>>> a.printNumInstances()
Number of instances: 3
По сравнению с простым перемещением printNumInstances за пределы
класса, как описывалось ранее, эта версия требует дополнительный
вызов функции staticmethod. При этом здесь область видимости имени
функции ограничена классом (имя не будет вступать в конфликт с дру
гими именами в модуле) и программный код перемещен туда, где он
используется (внутрь инструкции class). Судите сами, является ли это
чистым усовершенствованием или нет.
В последних версиях Python определение статических методов выпол
няется еще проще; следующий раздел описывает – как.
Декораторы функций
Прием с вызовом функции staticmethod, описанный в предыдущем раз
деле, выглядит малопонятным для некоторых пользователей, поэтому
была добавлена возможность, упрощающая эту операцию. Декорато+
ры функций обеспечивают способ определять специальные режимы
работы для функций, обертывая их дополнительным слоем логики,
реализованной в виде других функций.
Декораторы функций представляют собой более универсальные инст
рументы: их удобно использовать для добавления самой разной логи
ки к функциям, помимо статических методов. Например, их можно
использовать для расширения функций программным кодом, выпол
няющим регистрацию вызовов этих функций, проверяющим типы пе
редаваемых аргументов в процессе отладки и т. д. В некоторой степени
декораторы функций напоминают шаблон проектирования делегирова+
ния, исследованный нами в главе 25, но их главная цель состоит в том,
чтобы расширять определенные функции или методы, а не весь интер
фейс объекта.
Язык Python предоставляет несколько встроенных декораторов функ
ций для выполнения таких действий, как создание статических мето
дов, но программисты также имеют возможность создавать свои собст
венные декораторы. Несмотря на то, что они строго не привязаны
682 Глава 26. Дополнительные возможности классов
к классам, тем не менее, пользовательские декораторы функций часто
оформляются как классы, в которых сохраняется оригинальная функ
ция наряду с другими данными, такими как информация о состоянии.
Синтаксически декоратор функции – это разновидность объявления
функции времени выполнения. Декоратор функции записывается
в строке непосредственно перед строкой с инструкцией def, которая
определяет функцию или метод, и состоит из символа @, за которым
следует то, что называется метафункцией, – функция (или другой вы
зываемый объект), которая управляет другой функцией. В настоящее
время статические методы, к примеру, могут быть оформлены в виде
декораторов, как показано ниже:
class C:
@staticmethod
def meth():
...
С технической точки зрения, это объявление имеет тот же эффект, что
и фрагмент ниже (передача функции декоратору и присваивание ре
зультата первоначальному имени функции):
class C:
def meth():
...
meth = staticmethod(meth) # Повторное присваивание имени
В результате вызов метода по имени функции фактически будет при
водить к вызову результата, полученному от декоратора staticmethod.
Декоратор может возвращать объекты любого типа, поэтому данный
прием позволяет декоратору вставлять дополнительный уровень логи
ки, который будет запускаться при каждом вызове. Декоратор функ
ции может возвращать как оригинальную функцию, так и новый объ
ект, в котором хранится оригинальная функция, переданная декора
тору, которая будет вызываться косвенно после того, как будет выпол
нен дополнительный слой логики.
Синтаксис декораторов поддерживает добавление нескольких слоев
обертывающей логики к декорируемой функции или методу. В этом
случае строка с декоратором выглядит следующим образом:
@A @B @C
def f():
...
что эквивалентно следующему фрагменту:
def f():
...
f = A(B(C(f)))
Здесь оригинальная функция проходит через три различных декора
тора, а результат присваивается оригинальному имени. Напомню еще
Декораторы функций 683
раз, что в результате всего этого, когда происходит обращение к ориги
нальному имени функции, вызываются три слоя логики, дополняю
щие оригинальную функцию.
Пример декоратора
Ниже приводится пример декоратора, определяемого пользователем.
Вспомните, как в главе 24 говорилось, что метод перегрузки оператора
__call__ реализует интерфейс вызова функций в экземплярах классов.
В следующем примере этот метод используется в определении класса,
который сохраняет декорируемую функцию в экземпляре и перехва
тывает вызовы по оригинальному имени. А так как это класс, кроме
всего прочего в нем имеется возможность хранить информацию о со
стоянии (счетчик произведенных вызовов):
class tracer:
def __init__(self, func):
self.calls = 0
self.func = func
def __call__(self, *args):
self.calls += 1
print 'call %s to %s' % (self.calls, self.func.__name__)
self.func(*args)
@tracer
def spam(a, b, c): # Обертывает spam в объектдекоратор
print a, b, c
spam(1, 2, 3) # В действительности вызывается объектобертка
spam('a', 'b', 'c') # То есть вызывается метод __call__ в классе
spam(4, 5, 6) # Метод __call__ выполняет дополнительные действия
# и вызывает оригинальную функцию
Функция spam передается декоратору tracer, поэтому, когда произво
дится вызов к оригинальному имени spam, в действительности вызыва
ется метод __call__ в классе. Этот метод подсчитывает и регистрирует
вызовы, а затем вызывает оригинальную обернутую функцию. Обра
тите внимание, как используется синтаксис аргумента *name для упа
ковки аргументов, передаваемых функции, – благодаря этому данный
декоратор может использоваться для обертывания любой функции
с любым числом аргументов.
В результате к оригинальной функции spam добавляется слой дополни
тельной логики. Ниже приводится вывод, полученный от сценария, –
первая строка создана классом tracer, а вторая – функцией spam:
call 1 to spam
1 2 3
call 2 to spam
a b c
call 3 to spam
4 5 6
684 Глава 26. Дополнительные возможности классов
Исследуйте программный код этого примера повнимательнее, чтобы
вникнуть в его суть.
Декораторы функций являют собой универсальный механизм, и, тем не
менее, эта дополнительная особенность представляет интерес в первую
очередь для разработчиков инструментальных средств, а не для при
кладных программистов, поэтому я снова отсылаю вас за более подроб
ной информацией к стандартному набору руководств по языку Python.
Типичные проблемы при работе с классами
Большая часть типичных проблем, связанных с классами, сводится
к проблемам, связанным с пространствами имен (особенно если
учесть, что классы – это всего лишь пространства имен с некоторыми
дополнительными особенностями). Некоторые темы, которые мы за
тронем в этом разделе, скорее являются передовыми приемами ис
пользования классов, чем проблемами, а решение однойдвух их этих
проблем было упрощено в последних версиях Python.
Изменение атрибутов класса может приводить
к побочным эффектам
Теоретически классы (и экземпляры классов) относятся к категории
изменяемых объектов. Подобно таким встроенным типам, как списки
и словари, они могут изменяться непосредственно, путем присваива
ния значений атрибутам и, как и в случае со списками и словарями,
это означает, что изменение класса или экземпляра может оказывать
влияние на множественные ссылки на них.
Обычно это именно то, что нам требуется (так объекты изменяют свое
состояние), но, изменяя атрибуты, об этом необходимо помнить. Все
экземпляры класса совместно используют одно и то же пространство
имен класса, поэтому любые изменения на уровне класса будут отра
жаться на всех экземплярах, если, конечно, они не имеют собствен
ных версий атрибутов класса.
Классы, модули и экземпляры – это всего лишь объекты с пространст
вами имен атрибутов, поэтому во время выполнения они обычно изме
няются с помощью операций присваивания. Рассмотрим следующий
класс. В теле класса выполняется присваивание имени a, в результате
чего создается атрибут X.a, который во время выполнения располагает
ся в объекте класса и будет унаследован всеми экземплярами класса X:
>>> class X:
... a = 1 # Атрибут класса
...
>>> I = X()
>>> I.a # Унаследован экземпляром
1
>>> X.a
1
Типичные проблемы при работе с классами 685
Пока все неплохо – это обычный случай. Но, обратите внимание, что
происходит, когда атрибут класса изменяется динамически, изза его
пределов: это приводит к одновременному изменению атрибута во всех
объектах, наследующих его от класса. Кроме того, новые экземпляры
класса, созданные в ходе интерактивного сеанса или во время работы
программы, получают динамически установленное значение незави
симо от того, что написано в исходном программном коде класса:
>>> X.a = 2 # Может измениться не только в классе X
>>> I.a # Я тоже изменился
2
>>> J = X() # J наследует значение, установленное во время выполнения
>>> J.a # (но присваивание имени J.a изменяет a в J, но не в X или I)
2
Что это – полезная особенность или опасная ловушка? Решать вам.
Фактически вы можете выполнять все необходимые действия по изме
нению атрибутов класса, не создавая ни единого экземпляра – с помо
щью этого приема можно имитировать «записи» и «структуры» дан
ных, имеющиеся в других языках программирования. Чтобы осве
жить воспоминания, рассмотрим следующую не совсем обычную, но
вполне допустимую программу на языке Python:
class X: pass # Создать несколько пространств имен атрибутов
class Y: pass
X.a = 1 # Использовать атрибуты класса как переменные
X.b = 2 # В программе нет ни одного экземпляра класса
X.c = 3
Y.a = X.a + X.b + X.c
for X.i in range(Y.a): print X.i # Выведет 0..5
Здесь классы X и Y работают как модули «без файлов» – пространства
имен для хранения переменных, которые не конфликтуют между со
бой. Это совершенно допустимый прием на языке Python, но он не под
ходит для применения к классам, написанным другими программи
стами, – вы не всегда можете быть уверены, что атрибуты класса, ко
торые вы изменяете, не являются критически важными для внутрен
них механизмов класса. Если вы имитируете структуру на языке C,
лучше изменять экземпляры, а не класс, поскольку в этом случае из
менения будут касаться единственного объекта:
class Record: pass
X = Record()
X.name = 'bob'
X.job = 'Pizza maker'
Множественное наследование: порядок имеет значение
Это достаточно очевидно, но тем не менее, стоит подчеркнуть: в случае
использования множественного наследования порядок, в котором пе
686 Глава 26. Дополнительные возможности классов
речислены суперклассы в строке заголовка инструкции class, может
иметь критическое значение. В ходе поиска интерпретатор всегда про
сматривает суперклассы слева направо в соответствии с порядком их
следования в заголовке инструкции.
Например, в примере множественного наследования, который был про
демонстрирован в главе 25, предположим, что класс Super тоже реали
зует метод __repr__. От какого класса мы унаследовали бы метод – от
класса Lister или Super? Это зависело бы от того, какой класс стоит
первым в заголовке объявления класса Sub, так как поиск унаследо
ванных атрибутов производится слева направо. Очевидно, мы поста
вили бы класс Lister первым в списке, потому что его основная цель
состоит в предоставлении метода __repr__:
class Lister:
def __repr__(self): ...
class Super:
def __repr__(self): ...
class Sub(Lister, Super): # Будет унаследован метод __repr__ класса
# Lister, так как он стоит в списке первым
А теперь предположим, что классы Super и Lister имеют свои собствен
ные версии еще одного одноименного атрибута. Если необходимо, что
бы одно имя наследовалось от класса Super, а другое от класса Lister,
изменение порядка их расположения в заголовке инструкции опреде
ления подкласса уже не поможет – мы должны вручную переопреде
лить результат наследования, явно выполнив присваивание имени ат
рибута в классе Sub:
class Lister:
def __repr__(self): ...
def other(self): ...
class Super:
def __repr__(self): ...
def other(self): ...
class Sub(Lister, Super): # Унаследует __repr__ класса Lister,
# так как он первый в списке
other = Super.other # Явно выбирается версия атрибута из класса Super
def __init__(self):
...
x = Sub() # Поиск сначала выполняется в Sub и только потом в Super/Lister
Здесь присваивание атрибуту с именем other в классе Sub создает атри
бут Sub.other – ссылку на объект Super.other. Поскольку эта ссылка на
ходится ниже в дереве классов, это не позволит механизму наследова
ния выбрать версию атрибута Lister.other, который был обнаружен
первым при обычных обстоятельствах. Точно так же, если бы класс Su
per стоял первым в списке, то, чтобы атрибут other наследовался обыч
Типичные проблемы при работе с классами 687
ным образом, нам могло бы потребоваться явно выбрать метод __repr__
класса Lister:
class Sub(Super, Lister): # Получить Super.other по наследованию
__repr__ = Lister.__repr__ # Явно выбрать Lister.__repr__
Множественное наследование – это довольно сложная тема. Даже если
вы поняли предыдущий параграф, все равно этот прием лучше исполь
зовать осторожно и только в случае крайней необходимости. В против
ном случае могут возникать ситуации, когда значение имени атрибута
будет зависеть от порядка следования классов в инструкции определе
ния подкласса. (Еще один пример этого приема в действии приводится
в этой же главе в разделе «Классы нового стиля», где обсуждалось яв
ное разрешение конфликтов имен.)
Как правило, множественное наследование дает лучшие результаты, ко
гда суперклассы являются максимально автономными, – поскольку они
могут использоваться в разных контекстах, они не должны делать ка
кихлибо предположений об именах, связанных с другими классами
в дереве. Псевдочастные атрибуты, которые были изучены нами ранее,
могут помочь в локализации имен, на владение которыми опирается
класс, и ограничить вероятность появления конфликтов имен в супер
классах, которые вы добавляете в список наследуемых классов. Напри
мер, в данном случае класс Lister служит только для того, чтобы экспор
тировать метод __repr__, поэтому он мог бы дать своему второму методу
имя __other, чтобы избежать конфликтов с именами в других классах.
Методы, классы и вложенные области видимости
Эта проблема была ликвидирована в Python 2.2 введением областей
видимости вложенных функций, но я сохранил это описание исклю
чительно ради истории, для тех из вас, кому приходилось работать
с более старыми версиями Python и с целью продемонстрировать, что
происходит в случае вложения функций, когда один из уровней вло
женности является классом.
Классы, как и функции, обладают своими локальными областями ви
димости, поэтому области видимости обладают сходными проявления
ми в теле инструкции class. Кроме того, методы, по сути, являются
вложенными функциями, поэтому здесь имеют место те же самые про
блемы. Похоже, что путаница особенно часто возникает, когда имеют
ся классы, вложенные друг в друга.
В следующем примере (файл nester.py) функция generate возвращает
экземпляр вложенного класса Spam. Внутри этой функции имя класса
Spam находится в локальной области видимости функции generate. Но
в версиях Python, появившихся до версии 2.2, внутри метода method
имя класса Spam недоступно – method имеет доступ только к своей ло
кальной области видимости, к области видимости модуля, вмещающе
го окружающую функцию generate, и к встроенным именам:
688 Глава 26. Дополнительные возможности классов
def generate():
class Spam:
count = 1
def method(self): # Имя Spam недоступно:
print Spam.count # Не локальное (def), не глобальное (модуль),
# не встроенное
return Spam()
generate().method()
C:\python\examples> python nester.py
Traceback (innermost last):
File "nester.py", line 8, in ?
generate().method()
File "nester.py", line 5, in method
print Spam.count # Не локальное (def), не глобальное (модуль),
NameError: Spam # не встроенное
Этот пример будет работать в версии Python 2.2 и выше, потому что все
локальные области вмещающих функций автоматически видимы для
вложенных функций (включая и вложенные методы, как в данном
примере). Но он не работал в версиях Python, вышедших до версии 2.2
(некоторые возможные решения приводятся ниже).
Обратите внимание, что даже в версии 2.2 методам недоступна локаль
ная область видимости вмещающего класса – им доступны только об
ласти видимости вмещающих функций. Именно по этой причине ме
тоды должны использовать аргумент self с экземпляром или имя
класса, чтобы вызывать другие методы или обращаться к другим атри
бутам, определенным во вмещающей инструкции class. Например,
программный код метода не может использовать простое имя count, он
должен использовать имя self.count или Spam.count.
Если вам приходится работать с версией ниже 2.2, скажу, что сущест
вует несколько способов заставить предыдущий пример работать. Са
мый простой заключается в том, чтобы переместить имя Spam в область
видимости вмещающего модуля с помощью глобального объявления.
Поскольку методу method доступны глобальные имена в модуле, попыт
ка сослаться на Spam уже не будет вызывать ошибку:
def generate():
global Spam # Перенести имя Spam в область видимости модуля
class Spam:
count = 1
def method(self):
print Spam.count # Работает: глобальное имя (вмещающий модуль)
return Spam()
generate().method() # Выведет 1
Лучше было бы реструктурировать программный код так, чтобы вме
сто использования объявления global определение класса Spam находи
лось на верхнем уровне модуля. После этого вложенный метод method
Типичные проблемы при работе с классами 689
и функция generate будут отыскивать класс Spam в глобальной области
видимости:
def generate():
return Spam()
class Spam: # Определение на верхнем уровне в модуле
count = 1
def method(self):
print Spam.count # Работает: глобальное имя (вмещающий модуль)
generate().method()
В действительности такой подход рекомендуется использовать во всех
версиях Python – программный код выглядит проще, если в нем отсут
ствуют вложенные классы и функции.
Если вам требуется нечто более сложное и замысловатое, то можно
просто избавиться от ссылки на имя Spam в методе method, используя
специальный атрибут __class__, который возвращает класс объекта эк
земпляра:
def generate():
class Spam:
count = 1
def method(self):
print self.__class__.count # Работает: используется атрибут
return Spam() # для получения класса
generate().method()
«Многослойное обертывание»
При грамотном использовании способность объектноориентированно
го программного кода к многократному использованию поможет су
щественно снизить затраты времени на его разработку. Однако иногда
неправильное использование потенциала абстракции ООП может серь
езно осложнить понимание программного кода. Если классы наслоены
друг на друга слишком глубоко, программный код становится малопо
нятным – возможно, вам придется изучить множество классов, чтобы
выяснить, что делает единственная операция.
Например, однажды мне пришлось работать с библиотекой, написан
ной на языке C++, содержащей тысячи классов (часть которых была
сгенерирована машиной) и до 15 уровней наследования. Расшифровка
вызовов методов в такой сложной системе классов часто оказывалась
неподъемной задачей: даже в простейшую операцию оказывались во
влеченными сразу несколько классов. Логика системы оказалась та
кой многослойной, что в некоторых случаях, чтобы понять принцип
действия какоголибо участка программного кода, требовалось не
сколько дней копаться в нескольких файлах.
Здесь также вполне применимо одно из самых универсальных правил
языка Python: не усложняйте решение задачи, если оно не является
690 Глава 26. Дополнительные возможности классов
таковым. Обертывание программного кода несколькими слоями клас
сов на грани непостижимости – всегда плохая идея. Абстракция – это
основа полиморфизма и инкапсуляции, и при грамотном использова
нии она может быть весьма эффективным инструментом. Однако вы
упростите отладку и сопровождение, если сделаете интерфейсы своих
классов интуитивно понятными. Избегайте чрезмерной абстракции
и сохраняйте иерархии своих классов короткими и плоскими, если не
существует веских причин сделать иначе.
В заключение
В этой главе было представлено несколько расширенных возможностей
классов, включая наследование встроенных типов, псевдочастные атри
буты, классы нового стиля, статические методы и декораторы функций.
Большинство из них являются необязательными расширениями моде
ли ООП в языке Python, но они могут стать более полезными, когда вы
начнете создавать крупные объектноориентированные программы.
Это конец части, посвященной классам, поэтому ниже вы найдете обыч
ные в этом случае упражнения – обязательно проработайте их, чтобы
получить некоторую практику создания настоящих классов. В следую
щей главе мы начнем изучение последней базовой темы – исключе
ний. Исключения – это механизм взаимодействий с ошибками и дру
гими ситуациями, возникающими в программном коде. Это относи
тельно несложная тема, но я оставил ее напоследок, потому что в на
стоящее время исключения оформлены в виде классов. Но прежде чем
заняться этой последней темой, ознакомьтесь с контрольными вопро
сами к этой главе и выполните упражнения.
Закрепление пройденного
Контрольные вопросы
1. Назовите два способа расширения встроенных типов.
2. Для чего используются декораторы функций?
3. Как создать класс нового стиля?
4. Чем отличаются классы нового стиля и классические классы?
5. Чем отличаются обычные и статические методы?
6. Сколько секунд нужно выждать, прежде чем бросить «Пресвятую
ручную гранату»?
Ответы
1. Можно заключать встроенные классы в классыобертки или насле
довать встроенные типы в подклассах. Последний вариант проще,
так как в этом случае подклассы наследуют большую часть поведе
ния оригинальных классов.
Закрепление пройденного 691
2. Декораторы функций обычно используются для добавления допол
нительного слоя логики к существующим функциям, который за
пускается при каждом вызове функции. Они могут использоваться
для регистрации вызовов этих функций, проверки типов передавае
мых аргументов и т. д. Кроме того, они используются для «объявле
ния» статических методов – простых функций в классе, которым не
передается экземпляр класса.
3. Классы нового стиля создаются наследованием встроенного класса
object (или любого другого встроенного типа). В Python 3.0 все
классы по умолчанию будут классами нового стиля.
4. При использовании ромбоидальной схемы наследования в классах
нового стиля поиск в дереве наследования выполняется иначе – сна
чала производится поиск в ширину, а не в высоту. Кроме того, клас
сы нового стиля поддерживают ряд новых дополнительных особен
ностей, включая свойства и список атрибутов экземпляра __slots__.
5. Обычные методы (экземпляра) принимают аргумент self (подразу
меваемый экземпляр), а статические методы – нет. Статические ме
тоды – это простые функции, вложенные в объект класса. Чтобы
превратить обычный метод в статический, необходимо передать его
специальной встроенной функции, или декоратору, с использова
нием правил декорирования.
6. Три секунды. (Или, если быть более точным: «И сказал Господь:
Допреже всего Пресвятую чеку извлечь долженствует. Опосля же
того, сочти до трех, не более и не менее. Три есть цифирь, до коей
счесть потребно, и сочтенья твои суть три. До четырех счесть не мо
ги, паче же до двух, опричь токмо коли два предшествует трём.
О пяти и речи быть не может. Аще же достигнешь ты цифири три,
что есть и пребудет третьею цифирью, брось Пресвятою антиохий
скою гранатою твоею во врага твоего, и оный враг, будучи ничто
жен пред лицем моим, падёт.»1).
Упражнения к шестой части
В этих упражнениях вам будет предложено написать несколько клас
сов и поэкспериментировать с существующим программным кодом.
Единственная проблема существующего кода состоит в том, что он дол
жен существовать. Чтобы поупражняться с набором классов в упраж
нении 5, вам нужно либо загрузить файл с исходными текстами из Ин
тернета (читайте Предисловие) или ввести его вручную (он достаточно
короткий). Поскольку программы становятся все сложнее, обязатель
но ознакомьтесь с решениями в конце книги. Решения вы найдете
в приложении B в разделе «Часть VI. Классы и ООП».
1 Цитата из фильма «Monty Python and the Holy Grail». Перевод взят из Ви
кипедии. В русском переводе фильм вышел под названием «Монти Пайтон
иСвященный Грааль». – Примеч. перев.
692 Глава 26. Дополнительные возможности классов
1. Наследование. Напишите класс с именем Adder, экспортирующий
метод add(self, x, y), который выводит сообщение «Not Implement
ed» («Не реализовано»). Затем определите два подкласса класса
Adder, которые реализуют метод add:
ListAdder
С методом add, который возвращает результат конкатенации
двух списков из аргументов.
DictAdder
С методом add, который возвращает новый словарь, содержащий
элементы из обоих словарей, передаваемых как аргументы (по
дойдет любое определение сложения).
Поэкспериментируйте с экземплярами всех трех классов в инте
рактивной оболочке, вызывая их методы add.
Теперь расширьте суперкласс Adder, добавив сохранение объекта
в экземпляре с помощью конструктора (например, присваивая спи
сок или словарь атрибуту self.data), и реализуйте перегрузку опе
ратора + с помощью метода __add__ так, чтобы он автоматически вы
зывал ваш метод add (например, выражение X + Y должно приводить
к вызову метода X.add(X.data, Y)). Где лучше разместить методы
конструктора и перегрузки оператора (то есть в каком из классов)?
Объекты какого типа смогут складывать ваши классы?
На практике гораздо проще написать метод add, который принима
ет один действительный аргумент (например, add(self, y)) и склады
вает его с текущими данными экземпляра (например, self.data + y).
Будет ли в такой реализации больше смысла, чем в реализации, ко
торая принимает два аргумента? Можно ли сказать, что это делает
ваши классы более «объектноориентированными»?
2. Перегрузка операторов. Напишите класс с именем Mylist, который
«обертывает» списки языка Python: он должен перегружать основ
ные операторы действий над списками, включая +, доступ к элемен
там по индексу, итерации, извлечение среза и такие методы списка,
как append и sort. Полный перечень методов, поддерживаемых спи
сками, вы найдете в справочном руководстве по языку Python. Кроме
того, напишите конструктор для своего класса, который принимает
существующий список (или экземпляр класса Mylist) и копирует его
в атрибут экземпляра. Поэкспериментируйте со своим классом в ин
терактивной оболочке. В ходе экспериментов выясните следующее:
a. Почему здесь так важно копировать начальное значение?
b. Можно ли использовать пустой срез (например, start[:]) для ко
пирования начального значения, если им является Mylist?
c. Существует ли универсальный способ передачи управления
унаследованным методам списка?
d. Можно ли складывать Mylist и обычный список? А список и My
list?
Закрепление пройденного 693
e. Объект какого типа должны возвращать операции сложения и из
влечения среза? А операции извлечения элементов по индексу?
f. Если у вас достаточно новая версия Python (2.2 или выше), вы
сможете реализовать такого рода классобертку, встраивая на
стоящий список в отдельный класс или наследуя класс list. Ка
кой из двух способов проще и почему?
3. Подклассы. Напишите подкласс с именем MylistSub от класса Mylist
из упражнения 2, который расширяет класс Mylist возможностью
вывода сообщения на stdout перед выполнением каждой перегру
женной операции и подсчета числа вызовов. Класс MylistSub дол
жен наследовать методы Mylist. При сложении MylistSub с последо
вательностями должно выводиться сообщение, увеличиваться счет
чик вызовов операции сложения и вызываться метод суперкласса.
Кроме того, добавьте новый метод, который будет выводить счетчи
ки операций на stdout, и поэкспериментируйте с этим классом в ин
терактивной оболочке. Как работают ваши счетчики – считают ли
они операции для всего класса (для всех экземпляров класса) или
для каждого экземпляра в отдельности? Как бы вы реализовали ка
ждый из этих случаев? (Подсказка: зависит от того, в каком объек
те производится присваивание значения счетчика: атрибут класса
используется всеми экземплярами, а атрибуты аргумента self хра
нят данные экземпляра.)
4. Методы метакласса. Напишите класс с именем Meta с методами,
которые перехватывают все обращения к атрибутам (как получение
значения, так и присваивание) и выводят сообщения, перечисляю
щие их аргументы, на stdout. Создайте экземпляр класса Meta и по
экспериментируйте с ним в интерактивной оболочке. Что произой
дет, если попытаться использовать экземпляр класса в выраже
нии? Попробуйте выполнить над своим классом операции сложе
ния, доступа к элементам по индексу и получения среза.
5. Объекты множеств. Поэкспериментируйте с набором классов,
описанных в разделе «Расширение типов встраиванием». Выпол
ните команды, которые выполняют следующие операции:
a. Создайте два множества целых чисел и найдите их пересечение
и объединение с помощью операторов & и |.
b. Создайте множество из строки и поэкспериментируйте с извле
чением элементов множества по индексу. Какой метод в классе
при этом вызывается?
c. Попробуйте выполнить итерации через множество, созданное из
строки, с помощью цикла for. Какой метод вызывается на этот
раз?
d. Попробуйте найти пересечение и объединение множества, соз
данного из строки, и простой строки. Возможно ли это?
e. Теперь расширьте класс множества наследованием, чтобы под
класс мог обрабатывать произвольное число операндов, исполь
694 Глава 26. Дополнительные возможности классов
зуя для этого форму аргумента *args. (Подсказка: вернитесь
к рассмотрению этих алгоритмов в главе 16.) Найдите пересече
ние и объединение нескольких операндов с помощью вашего
подкласса множества. Как можно реализовать вычисление пере
сечения трех и более множеств, если оператор & работает всего
с двумя операндами?
f. Как бы вы реализовали другие операции над списками в классе
множества? (Подсказка: метод __add__ перехватывает операцию
конкатенации, а метод __getattr__ может передавать большинст
во вызовов методов списка в обернутый список.)
6. Связи в дереве классов. В разделе «Пространства имен: окончание
истории» в главе 24 и в разделе «Множественное наследование»
в главе 25 я упоминал, что классы имеют атрибут __bases__, кото
рый возвращает кортеж объектов суперклассов (тех, что перечисле
ны в круглых скобках в заголовке инструкции class). Используя
атрибут __bases__, расширьте класс Lister (глава 25) так, чтобы он
выводил имена прямых суперклассов экземпляров класса. При
этом первая строка в этом выводе должна выглядеть, как показано
ниже (значение адреса у вас может отличаться):
<Instance of Sub(Super, Lister), address 7841200:
Как бы вы реализовали вывод значений унаследованных атрибу
тов? (Подсказка: у классов имеется атрибут __dict__.) Попробуйте
расширить класс Lister так, чтобы он выводил список всех доступ
ных суперклассов и их атрибуты (подсказка: порядок подъема по
дереву наследования описывается в примере classtree.py в главе 24
и в сноске об использовании функций dir и getattr в Python 2.2
в разделе «Множественное наследование» в главе 25).
7. Композиция. Сымитируйте сценарий оформления заказа в рестора
не быстрого питания, определив четыре класса:
Lunch
Вмещающий и управляющий класс.
Customer
Действующее лицо, покупающее блюдо.
Employee
Действующее лицо, принимающее заказ.
Food
То, что приобретает заказчик.
Чтобы вам было с чего начать, определите следующие классы и ме
тоды:
class Lunch:
def __init__(self) # Создает и встраивает Customer и Employee
def order(self, foodName) # Имитирует прием заказа
def result(self) # Запрашивает у клиента название блюда
Закрепление пройденного 695
class Customer:
def __init__(self) # Инициализирует название блюда
# значением None
def placeOrder(self, foodName, employee) # Передает заказ официанту
def printFood(self) # Выводит название блюда
class Employee:
def takeOrder(self, foodName) # Возвращает блюдо с указанным названием
class Food:
def __init__(self, name) # Сохраняет название блюда
Имитация заказа работает следующим образом:
a. Конструктор класса Lunch должен создать и встроить экземпляр
класса Customer и экземпляр класса Employee, кроме того, экспор
тировать метод с именем order. При вызове этот метод должен
имитировать прием заказа у клиента (Customer) вызовом метода
placeOrder. Метод placeOrder класса Customer должен в свою оче
редь имитировать получение блюда (новый объект Food) у офици
анта (Employee) вызовом метода takeOrder класса Employee.
b. Объекты типа Food должны сохранять строку с названием блю
да (например, «буррито»), которое передается через Lunch.order
в Customer.placeOrder, затем в Employee.takeOrder и, наконец,
в конструктор класса Food. Кроме того, класс Lunch должен еще
экспортировать метод result, который предлагает клиенту (Cus
tomer) вывести название блюда, полученного от официанта (Em
ployee) в результате выполнения заказа (этот метод может ис
пользоваться для проверки имитации).
Обратите внимание: экземпляр класса Lunch должен передавать
клиенту (Customer) либо экземпляр класса Employee (официант), либо
себя самого, чтобы клиент (Customer) мог вызвать метод официанта
(Employee).
Поэкспериментируйте с получившимися классами в интерактив
ной оболочке, импортируя класс Lunch и вызывая его метод order,
чтобы запустить имитацию, а также метод result, чтобы проверить,
что клиент (Customer) получил именно то, что заказывал. При жела
нии можете добавить в файл с классами программный код самотес
тирования, используя прием с атрибутом __name__ из главы 21.
В этой имитации активность проявляет клиент (Customer); как бы
вы изменили свои классы, чтобы инициатором взаимодействий ме
жду клиентом и официантом был официант (Employee)?
8. Классификация животных в зоологии. Изучите дерево классов,
представленное на рис. 26.1. Напишите шесть инструкций class,
которые моделировали бы эту модель классификации средствами
наследования в языке Python. Затем добавьте к каждому из классов
метод speak, который выводил бы уникальное сообщение, и метод
reply в суперклассе Animal, являющемся вершиной иерархии, кото
рый просто вызывал бы self.speak, чтобы вывести текст сообщения,
696 Глава 26. Дополнительные возможности классов
характерного для каждой категории в подклассах, расположенных
ниже (это вынудит начинать поиск в дереве наследования от экзем
пляра self). Наконец, удалите метод speak из класса Hacker, чтобы
для него по умолчанию выводилось сообщение, унаследованное от
класса выше. Когда вы закончите, ваши классы должны работать
следующим образом:
% python
>>> from zoo import Cat, Hacker
>>> spot = Cat()
>>> spot.reply() # Animal.reply; вызывается Cat.speak
meow
>>> data = Hacker() # Animal.reply; вызывается Primate.speak
>>> data.reply()
Hello world!
9. Сценка с мертвым попугаем. Изучите схему встраивания объек
тов, представленную на рис. 26.2. Напишите набор классов на язы
ке Python, которые реализовали бы эту схему средствами компози
ции. Класс Scene (сцена) должен определять метод action и встраи
вать в себя экземпляры классов Customer (клиент), Clerk (клерк)
и Parrot (попугай), каждый из которых должен определять метод
line, выводящий уникальное сообщение. Встраиваемые объекты
могут наследовать один общий суперкласс, определяющий метод
line, который просто выводит текст указанного ему сообщения, или
определяют собственные реализации метода line. В конечном итоге
ваши классы должны действовать, как показано ниже:
% python
>>> import parrot
>>> parrot.Scene().action() # Активировать встроенные объекты
customer: "that's one exbird!"
clerk: "no it isn't..."
parrot: None
Hacker (хакер)
Animal (животное)
Mammal (млекопитающее)
Cat (кошка) Dog (собака) Primate (примат)
Рис. 26.1. Классификация животных в зоологии, составленная из классов,
связанных в дерево наследования. Класс Animal имеет общий метод «reply»,
но каждый из классов имеет свой собственный метод «speak», который
вызывается методом «reply»
Закрепление пройденного 697
Parrot (попугай)
Scene (сцена)
Customer (клиент) Clerk (клерк)
action
line
Рис. 26.2. Составная сцена, представленная управляющим классом (Scene),
который встраивает и управляет экземплярами трех других классов
(Customer, Clerk, Parrot). Встроенные экземпляры классов могут также
участвовать в иерархии наследования – композиция и наследование часто
являются одинаково полезными способами организации классов с целью
обеспечения возможности повторного использования программного кода
Придется держать в уме:
ООП глазами специалистов
Когда я рассказываю о классах в языке Python, я все время обна
руживаю, что в середине лекции о классах люди, имевшие опыт
ООП в прошлом, заметно активизируются, а те, кто такого опы
та не имеет, начинают сникать (или вообще засыпают). Преиму
щества этой технологии не так очевидны.
В такой книге, как эта, у меня есть уникальная возможность
включить обзорный материал, которой я воспользовался в гла
ве 22 – настоятельно рекомендую вам перечитать эту главу, как
только вам начинает казаться, что ООП – это всего лишь неко
торое украшение в программировании.
В реальной аудитории, чтобы привлечь (и удержать) внимание
начинающих программистов, я обычно останавливаюсь и спра
шиваю у присутствующих опытных специалистов, почему они
используют ООП. Ответы, которые они дают, могут пролить свет
на цели, которые преследует ООП для тех, кто плохо знаком
с этой темой.
Ниже приводятся лишь самые общие причины, побуждающие
использовать ООП, которые были высказаны моими студентами
за эти годы:
Повторное использование программного кода
Это самая простая (и самая основная) причина использования
ООП. Возможность наследования в классах позволяет про
граммисту писать программы, адаптируя существующий
программный код, а не писать каждый новый проект с самого
начала.
698 Глава 26. Дополнительные возможности классов
Инкапсуляция
Сокрытие деталей реализации за интерфейсом объекта предо
храняет пользователей класса от необходимости изменять
свой программный код.
Организация
Классы предоставляют новые локальные области видимости,
которые минимизируют вероятность конфликтов имен. Кро
ме того, они обеспечивают место для естественного размеще
ния программного кода реализации и управления состоянием
объекта.
Поддержка
Классы обеспечивают естественное разделение программного
кода, что позволяет уменьшить его избыточность. Благодаря
организации и возможности повторного использования про
граммного кода в случае необходимости бывает достаточно
изменить всего одну копию программного кода.
Непротиворечивость
Классы и возможность наследования позволяют реализовать
общие интерфейсы и, следовательно, обеспечить единообразие
вашего программного кода – такой код легко поддается отлад
ке, выглядит более осмысленно и прост в сопровождении.
Полиморфизм
Это скорее свойство ООП, чем причина его использования, но
благодаря поддержке общности программного кода полимор
физм делает код более гибким, расширяет область его приме
нения и, следовательно, увеличивает его шансы на повторное
использование.
Другие
И, конечно, причина номер один состоит в том, что упомина
ние о владении приемами ООП увеличивает шанс быть при
нятым на работу! (Согласен, я привел эту причину в шутку,
но, если вы собираетесь работать на ниве программирования,
для вас очень важно будет иметь знакомство с ООП.)
И в заключение, не забывайте, что я говорил в начале шестой
части: вы не сможете полностью оценить достоинства ООП, пока
не будете использовать его какоето время. Выберите себе проект,
изучите большие примеры, поработайте над упражнениями – это
заставит вас попотеть над объектноориентированным про
граммным кодом, но оно стоит того.
VII
Исключения и инструменты

27
Основы исключений
В последней части книги рассказывается об исключениях, которые, по
сути, являются событиями, способными изменить ход выполнения
программы. Исключения в языке Python возбуждаются автоматиче
ски, когда программный код допускает ошибку, а также могут возбу
ждаться и перехватываться самим программным кодом. Обрабатыва
ются исключения четырьмя инструкциями. Эти инструкции мы и бу
дем изучать в данной части книги. Первая из инструкций имеет две
разновидности (ниже они перечислены отдельно), а последняя – явля
ется дополнительным расширением до выхода версии Python 2.6:
try/except
Перехватывает исключения, возбужденные интерпретатором или
вашим программным кодом, и выполняет восстановительные опе
рации.
try/finally
Выполняет заключительные операции независимо от того, возник
ло ли исключение или нет.
raise
Дает возможность возбудить исключение программно.
assert
Дает возможность возбудить исключение программно, при выпол
нении определенного условия.
with/as
Реализует менеджеры контекста в версии Python 2.6 и выше (в вер
сии 2.5 является дополнительным расширением).
Эта тема была оставлена напоследок потому, что для работы с исклю
чениями необходимо знание классов. Тем не менее, за несколькими
702 Глава 27. Основы исключений
исключениями (преднамеренная игра слов), как будет показано ниже,
обработка исключений в языке Python выполняется очень просто, по
тому что они интегрированы непосредственно в сам язык, как и другие
высокоуровневые средства.
Одно техническое примечание перед началом: после выхода первого
издания этой книги в исключениях произошли два изменения – пред
ложение finally может теперь присутствовать в инструкции try вместе
с предложениями except и else, а исключения, определяемые програм
мой, теперь должны быть экземплярами классов, а не простыми стро
ками. В этом издании я опишу и старый, и новый способы работы с ис
ключениями, потому что в существующем программном коде вам еще
часто будут встречаться изначальные приемы. Попутно я расскажу,
какими путями шло развитие в этой области. Я также опишу новую
инструкцию with несмотря на то, что ее официальное появление ожи
дается только в следующем выпуске Python.
Зачем нужны исключения?
В двух словах, исключения позволяют перепрыгнуть через фрагмент
программы произвольной длины. Рассмотрим пример с машиной по
приготовлению пиццы, о которой говорилось ранее в этой книге.
Предположим, что мы более чем серьезно отнеслись к этой идее и дей
ствительно построили такую машину. Чтобы приготовить пиццу, наш
кулинарный автомат должен выполнить программу, написанную на
языке Python: она должна принимать заказ, приготовить тесто, вы
брать добавки, выпечь основу и т. д.
Теперь предположим, что чтото пошло совсем не так во время «выпе
кания основы». Возможно, сломалась печь или, возможно, наш робот
ошибся в расчетах расстояния до печи и воспламенился. Совершенно
очевидно, что нам необходимо предусмотреть быстрый переход к про
граммному коду, который быстро обрабатывает такие ситуации. Кроме
того, поскольку в таких необычных условиях у нас нет никакой надеж
ды на успешное окончание процесса приготовления пиццы, мы могли
бы также вообще отказаться от выполнения всего плана целиком.
Это именно то, что позволяют делать исключения: программа может
перейти к обработчику исключения за один шаг, отменив все вызовы
функций. Исключение – это своего рода «суперgoto».1 Обработчик ис
ключений (инструкция try) ставит метку и выполняет некоторый про
граммный код. Если затем гденибудь в программе возникает исключе
1 Если вы использовали язык C, вам будет интересно узнать, что исключе
ния в языке Python немного похожи на стандартную для языка C пару
функций setjmp/longjmp: инструкция try действует как функция setjmp,
а инструкция raise как longjmp. Только в языке Python исключения основа
ны на объектах и являются стандартной частью модели исполнения.
Зачем нужны исключения? 703
ние, интерпретатор немедленно возвращается к метке, отменяя все ак
тивные вызовы функций, которые были произведены после установки
метки. Код в обработчике исключения может соответствующим обра
зом отреагировать на ситуацию (вызвать пожарных, например). Кроме
того, переход к обработчику исключения выполняется немедленно, по
этому обычно нет никакой необходимости проверять коды возврата ка
ждой вызванной функции, которая могла потерпеть неудачу.
Назначение исключений
В программах на языке Python исключения могут играть разные роли.
Ниже приводятся некоторые из них, являющиеся наиболее типичными:
Обработка ошибок
Интерпретатор возбуждает исключение всякий раз, когда обнаружи
вает ошибку во время выполнения программы. Программа может пе
рехватывать такие ошибки и обрабатывать их или просто игнориро
вать. Если ошибка игнорируется, интерпретатор выполняет дейст
вия, предусмотренные по умолчанию, – останавливает выполнение
программы и выводит сообщение об ошибке. Если такое поведение по
умолчанию является нежелательным, можно добавить инструкцию
try, которая позволит перехватывать обнаруженные ошибки и про
должить выполнение программы после инструкции try.
Уведомления о событиях
Исключения могут также использоваться для уведомления о насту
плении некоторых условий, что устраняет необходимость переда
вать кудалибо флаги результата или явно проверять их. Например,
функция поиска может возбуждать исключение в случае неудачи,
вместо того чтобы возвращать целочисленный признак в виде ре
зультата (и надеяться, что этот признак всегда будет интерпретиро
ваться правильно).
Обработка особых ситуаций
Некоторые условия могут наступать так редко, что было бы слиш
ком расточительно предусматривать проверку наступления таких
условий с целью их обработки. Нередко такие проверки необычных
ситуаций можно заменить обработчиками исключений.
Заключительные операции
Как будет показано далее, инструкция try/finally позволяет гаран
тировать выполнение завершающих операций независимо от нали
чия исключений.
Необычное управление потоком выполнения
И, наконец, так как исключения это своего рода оператор «goto»,
их можно использовать как основу для экзотического управления
потоком выполнения программы. Например, обратная трассировка
не является частью самого языка, но она может быть реализована
704 Глава 27. Основы исключений
с помощью исключений и некоторой логики поддержки, выпол
няющей раскручивание операций присваивания.1
Далее в этой части книги мы увидим примеры этих типичных приме
нений. А пока начнем с обзора средств языка Python, предназначен
ных для обработки исключений.
Обработка исключений: краткий обзор
В сравнении с некоторыми другими основными возможностями, кото
рые рассматривались в этой книге, исключения в языке Python пред
ставляют собой чрезвычайно легкий инструмент. Поскольку они так
просты, перейдем сразу к первому примеру. Предположим, что мы пи
шем следующую функцию:
>>> def fetcher(obj, index):
... return obj[index]
...
Эта функция делает не так много – она просто извлекает элемент из
объекта по заданному индексу. При нормальном стечении обстоя
тельств она возвращает результат:
>>> x = 'spam'
>>> fetcher(x, 3) # Все равно, что x[3]
'm'
Однако, если передать функции индекс, выходящий за пределы стро
ки, то при попытке выполнить выражение obj[index] будет возбужде
но исключение. Обнаруживая выход за пределы последовательности,
интерпретатор сообщает об этом, возбуждая встроенное исключение
IndexError:
>>> fetcher(x, 4)
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "<stdin>", line 2, in fetcher
IndexError: string index out of range
(IndexError: выход индекса за пределы строки)
Поскольку наш программный код не перехватывает это исключение яв
но, оно возвращает выполнение на верхний уровень программы и вызы
1 Настоящая обратная трассировка – это довольно сложная тема, и данная
возможность не является частью самого языка Python (даже с появлением
функцийгенераторов в версии 2.2), поэтому я не буду больше говорить об
этом. Грубо говоря, обратная трассировка отменяет все вычисления перед
переходом – исключения этого не делают (то есть в переменных, которым
было выполнено присваивание между моментом выполнения инструкции
try и до момента возбуждения исключения, прежние значения не восста
навливаются). Если вам любопытна эта тема, обращайтесь к книгам по ис
кусственному интеллекту или языкам программирования Prolog или Icon.
Обработка исключений: краткий обзор 705
вает обработчик исключений по умолчанию, который просто выводит
стандартное сообщение об ошибке. К настоящему моменту вы наверняка
видели в своих программах подобные сообщения об ошибках. Они вклю
чают тип исключения, а также диагностическую информацию – список
строк и функций, которые были активны в момент появления исключе
ния. При работе в интерактивной оболочке файлом является «stdin»
(стандартный поток ввода) или «pyshell» (в IDLE), поэтому в данном
случае номера строк не несут скольконибудь полезной информации.
В настоящей программе, запущенной не в интерактивной оболочке,
обработчик кроме этого по умолчанию завершает работу программы.
Такое действие имеет смысл для простых сценариев – как правило,
ошибки в таких сценариях должны быть фатальными и лучшее, что
можно сделать при их появлении, – это ознакомиться с текстом сооб
щения. Но иногда это совсем не то, что нам требуется. Например, сер
верные программы обычно должны оставаться активными даже после
появления внутренних ошибок. Если вам требуется избежать реакции
на исключение по умолчанию, достаточно просто перехватить исклю
чение, обернув вызов функции инструкцией try:
>>> try:
... fetcher(x, 4)
... except IndexError:
... print 'got exception'
...
got exception
>>>
Теперь, когда исключение будет возникать при выполнения инструк
ций в блоке try, интерпретатор будет автоматически переходить к ва
шему обработчику (блок под предложением except, в котором указано
имя исключения). При работе в интерактивной оболочке, как в приме
ре выше, после выполнения блока except происходит возврат в пригла
шение к вводу. В настоящих программах инструкции try не только пе
рехватывают исключения, но и выполняют действия по восстановле+
нию после ошибок:
>>> def catcher():
... try:
... fetcher(x, 4)
... except IndexError:
... print 'got exception'
... print 'continuing'
...
>>> catcher()
got exception
continuing
>>>
На этот раз после того, как исключение было перехвачено и обработа
но, программа продолжила выполнение ниже всей инструкции try –
706 Глава 27. Основы исключений
именно поэтому в данном примере было выведено сообщение «continu
ing». Стандартное сообщение об ошибке не появилось на экране, и про
грамма продолжила работу как ни в чем не бывало.
Исключения могут возбуждаться интерпретатором или самой про
граммой, и могут перехватываться или не перехватываться. Чтобы
возбудить исключение вручную, достаточно просто выполнить инст
рукцию raise (или assert, с условным выражением, возвращающим
ложь). Исключения, определяемые программой, перехватываются
точно так же, как и встроенные исключения:
>>> bad = 'bad'
>>> try:
... raise bad
... except bad:
... print 'got bad'
...
got bad
Если исключение, определяемое программой, не перехватывается, оно
будет передано обработчику исключений по умолчанию, что приведет
к завершению программы с выводом стандартного сообщения об ошиб
ке. В данном случае стандартное сообщение включает текст строки,
использовавшейся для идентификации исключения:
>>> raise bad
Traceback (most recent call last):
File "<pyshell#18>", line 1, in ?
raise bad
bad
В других случаях сообщение об ошибке может включать текст, предос
тавляемый классами, использованными для идентификации исклю
чений. Как будет показано в следующей главе, исключения, опреде
ляемые в программе, могут определяться в виде строк или классов, но
в отличие от строк, исключения на базе классов позволяют сценариям
создавать категории исключений, наследовать поведение и добавлять
к ним информацию о состоянии. Исключения на базе классов более
предпочтительны, чем исключения на базе строк, а кроме того, они
станут обязательными в Python 3.0:
>>> class Bad(Exception): pass
...
>>> def doomed(): raise Bad()
...
>>> try:
... doomed()
... except Bad:
... print 'got Bad'
...
got Bad
>>>
Обработка исключений: краткий обзор 707
Наконец, инструкции try могут включать блоки finally. Комбинация
try/finally определяет завершающие действия, которые всегда выпол
няются «на выходе», независимо от того, возникло исключение в бло
ке try или нет:
>>> try:
... fetcher(x, 3)
... finally:
... print 'after fetch'
...
'm'
after fetch
Здесь, если блок try выполнится без ошибок, будет выполнен блок fi
nally и программа продолжит свою работу дальше. В этом случае дан
ная инструкция кажется бессмысленной – мы могли бы просто доба
вить инструкцию print сразу вслед за вызовом функции и вообще уб
рать инструкцию try:
fetcher(x, 3)
print 'after fetch'
Однако в таком подходе имеется одна проблема: если в функции воз
никнет исключение, инструкция print не будет выполнена. Комбина
ция try/finally позволяет ликвидировать эту проблему – когда в блоке
try действительно произойдет исключение, блок finally будет выпол
нен, пока программа будет раскручиваться:
>>> def after():
... try:
... fetcher(x, 4)
... finally:
... print 'after fetch'
... print 'after try?'
...
>>> after()
after fetch
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "<stdin>", line 3, in after
File "<stdin>", line 2, in fetcher
IndexError: string index out of range
(IndexError: выход индекса за пределы строки)
Здесь мы не получили сообщение «after try?», потому что работа про
граммы не была продолжена после блока try/finally, когда возникло
исключение. Вместо этого интерпретатор выполнил действия, преду
смотренные блоком finally, после чего исключение достигло предыду
щего обработчика (в данном случае – обработчик по умолчанию). Если
изменить вызов внутри функции action, чтобы он не вызывал исклю
чение, блок finally все равно будет выполнен, но программа продол
жит работу после выхода из инструкции try:
708 Глава 27. Основы исключений
>>> def after():
... try:
... fetcher(x, 3)
... finally:
... print 'after fetch'
... print 'after try?'
...
>>> after()
after fetch
after try?
>>>
На практике комбинацию try/except удобно использовать для перехвата
и восстановления после исключений, а комбинацию try/finally – в слу
чаях, когда необходимо гарантировать выполнение заключительных
действий независимо от того, возникло исключение в блоке try или нет.
Например, комбинацию try/except можно было бы использовать для пе
рехвата ошибок, возникающих в импортированной библиотеке, создан
ной сторонним разработчиком, а комбинацию try/finally – чтобы га
рантировать закрытие файлов и соединений с сервером. Некоторые из
таких практических примеров будут показаны далее в этой книге.
Несмотря на то, что эти две комбинации служат двум различным це
лям, тем не менее, начиная с версии Python 2.5, появилась возмож
ность смешивать предложения except и finally в одной и той же инст
рукции try – блок finally будет выполняться всегда, независимо от то
го, было ли перехвачено исключение предложением except.
Такое поведение составляет основу исключений – исключения дейст
вительно являются очень простым инструментом. Далее в этой части
книги мы подробнее поговорим о самих инструкциях, исследуем раз
ные виды предложений, которые могут появляться в инструкции try,
и обсудим объекты исключений, основанные на строках и классах.
Исключения в языке Python – это высокоуровневый инструмент управ
ления потоком выполнения. Они могут возбуждаться интерпретато
ром или самой программой – в любом из этих случаев их можно игно
рировать (что вызовет срабатывание обработчика по умолчанию) или
перехватывать с помощью инструкций try (для обработки в своем про
граммном коде). Инструкция try может использоваться в двух логиче
ских разновидностях, которые, начиная с версии Python 2.5, могут
комбинироваться – одна разновидность выполняет обработку исклю
чений, а другая выполняет завершающий программный код независи
мо от того, возникло исключение или нет. Исключения можно возбуж
дать вручную, с помощью инструкций raise и assert. А теперь, полу
чив общее представление, рассмотрим подробнее общие формы упо
требления этих инструкций.
Инструкция try/except/else 709
Инструкция try/except/else
Для начала я представлю try/except/else и try/finally как разные ин
струкции, потому что они имеют разное предназначение и не могут
комбинироваться в версиях Python ниже, чем 2.5. Как уже говори
лось, начиная с этой версии, except и finally могут смешиваться в од
ной инструкции try – я объясню суть этого изменения после того, как
будут исследованы две оригинальные формы по отдельности.
Инструкция try – это составная инструкция. Полная ее форма приво
дится ниже. Она начинается со строки заголовка try, вслед за которой
располагается блок инструкций (как правило) с отступами, затем сле
дует одно или более предложений except, которые определяют пере
хватываемые исключения, и затем следует необязательное предложе
ние else. Слова try, except и else должны располагаться с одним и тем
же отступом (то есть должны быть выровнены по вертикали). Для
справки ниже приводится полный формат инструкции:
try:
<statements> # Сначала выполняются эти действия
except <name1>:
<statements> # Запускается, если в блоке try возникло исключение name1
except <name2>, <data>:
<statements> # Запускается в случае исключения name2
# и получает дополнительные данные
except (name3, name4):
<statements> # Запускается, если возникло любое из этих исключений
except:
<statements> # Запускается для всех (остальных) возникших исключений
else:
<statements> # Запускается, если в блоке try не возникло исключения
В этой инструкции блок под заголовком try представляет основное дей+
ствие инструкции – программный код, который следует попытаться
выполнить. Предложения except определяют обработчики исключе
ний, возникших в ходе выполнения блока try, а предложение else (ес
ли присутствует) определяет обработчик для случая отсутствия ис
ключений. Элемент <data> имеет отношение к особенности инструкций
raise, которая будет обсуждаться далее в этой главе.
Ниже описывается принцип действия инструкции try. Когда запуска
ется инструкция try, интерпретатор помечает текущий контекст про
граммы, чтобы вернуться к нему, если возникнет исключение. В пер
вую очередь выполняются инструкции, расположенные под заголов
ком try. Что произойдет дальше, зависит от того, будет ли возбуждено
исключение в блоке try:
• Если исключение возникнет во время выполнения инструкций в бло
ке try, интерпретатор вернется к инструкции try и выполнит первое
предложение except, соответствующее возбужденному исключе
нию. После выполнения блока except управление будет передано
710 Глава 27. Основы исключений
первой инструкции, находящейся за всей инструкцией try (при ус
ловии, что в блоке except не возникло другого исключения).
• Если в блоке try возникло исключение, и не было найдено ни одного
соответствия среди предложений except, исключение будет переда
но инструкции try, стоящей выше в программе, или на верхний
уровень процесса (что вынудит интерпретатор аварийно завершить
работу программы и вывести сообщение об ошибке по умолчанию).
• Если в процессе выполнения блока try не возникло исключение,
интерпретатор выполнит инструкции в блоке else (если имеется)
и затем выполнение продолжится с первой инструкции, находя
щейся за всей инструкцией try.
Другими словами, предложения except перехватывают любые исклю
чения, которые могут возникнуть при выполнении блока try, а блок
else выполняется только в случае отсутствия исключений в блоке try.
В предложениях except находятся обработчики исключений – они пе
рехватывают исключения, которые возникли только в инструкциях
блока try. Однако инструкции в блоке try могут вызывать функции,
расположенные в разных частях программы, поэтому сам источник ис
ключения может располагаться за пределами самой инструкции try.
Мы еще поговорим об этом, когда будем исследовать вложенные инст
рукции try в главе 29.
Предложения инструкции try
В инструкции try могут присутствовать разные предложения, распола
гающиеся вслед за блоком try. В табл. 27.1 приводятся все возможные
формы, из которых хотя бы одна должна присутствовать. Мы уже
встречали некоторые из них: как вы уже знаете, предложение except
перехватывает исключения, предложение finally выполняется при вы
ходе из инструкции, а предложение else выполняется, когда в блоке
try не возникло исключение. С точки зрения синтаксиса, в инструкции
может присутствовать несколько предложений except, но только одно
предложение else. Вплоть до версии Python 2.4 предложение finally
должно быть единственным (без предложений else или except); в дейст
вительности это отдельная инструкция. Однако, начиная с версии Py
thon 2.5, предложение finally может присутствовать в той же инструк
ции, что и предложения except и else.
Таблица 27.1. Различные формы предложений в инструкции try
Форма предложения Интерпретация
except: Перехватывает все (остальные) типы исключений.
except name: Перехватывает только указанное исключение.
except name, value: Перехватывает указанное исключение и получает со
ответствующие ему дополнительные данные (или эк
земпляр).
Инструкция try/except/else 711
Исследованием дополнительного значения value мы займемся, когда
будем рассматривать инструкцию raise. Новыми здесь для нас явля
ются первая и четвертая строки в табл. 27.1:
• Предложения except, в которых отсутствуют имена исключений
(except:), перехватывают все исключения, ранее не перечисленные
в инструкции try.
• Предложения except, где в круглых скобках перечислены имена ис
ключений (except (e1, e2, e3):), перехватывают любое из перечис
ленных исключений.
Интерпретатор Python просматривает предложения except сверху вниз
в поисках соответствия, поэтому версию предложения с круглыми
скобками можно рассматривать как аналог нескольким отдельным
выражениям except, по одному для каждого исключения из списка,
только в этом случае тело обработчика является общим для всех ука
занных исключений. Ниже приводится пример использования не
скольких предложений except, который демонстрирует порядок опре
деления обработчиков:
try:
action()
except NameError:
...
except IndexError
...
except KeyError:
...
except (AttributeError, TypeError, SyntaxError):
...
else:
...
В этом примере, если при выполнении функции action возникает ис
ключение, интерпретатор возвращается к инструкции try и пытается
отыскать первое предложение except, в котором указано возникшее ис
ключение. Поиск среди предложений except ведется сверху вниз, слева
направо, и выполняются инструкции в первом найденном совпадении.
Если совпадений не будет найдено, исключение продолжит распростра
нение выше этой инструкции try. Обратите внимание, что блок else вы
полняется только при отсутствии исключения в функции action –
except (name1, name2): Перехватывает любое из перечисленных исключений.
except (name1, name2),
value:
Перехватывает любое из перечисленных исключений
и получает соответствующие им дополнительные дан
ные.
else: Выполняется, если не было исключений.
finally: Этот блок выполняется всегда.
Форма предложения Интерпретация
712 Глава 27. Основы исключений
этот блок не выполняется при наличии исключения, которому не было
найдено соответствующее предложение except.
Если вам действительно необходимо организовать перехват всех ис
ключений, используйте пустое предложение:
try:
action()
except NameError:
... # Обработать исключение NameError
except IndexError:
... # Обработать исключение IndexError
except:
... # Обработать все остальные исключения
else:
... # Обработка случая отсутствия исключений
Предложение except без имени исключения – это своего рода шаблон
ный символ, потому что оно перехватывает любые исключения, что по
зволяет вам создавать и универсальные, и специфичные обработчики,
по своему усмотрению. В некоторых случаях эта форма может быть бо
лее удобна, чем перечисление всех возможных исключений в инструк
ции try. Например, в следующем примере выполняется перехват всех
исключений:
try:
action()
except:
... # Перехватить все возможные исключения
Однако применение пустых предложений except влечет за собой опре
деленные проблемы проектирования. Несмотря на удобство, они мо
гут перехватывать нежелательные системные исключения, не связан
ные с работой вашего программного кода, и по случайности прерывать
распространение исключений, предназначенных для других обработ
чиков. Например, даже выход из программы в языке Python возбуж
дает исключение, и поэтому было бы желательно, чтобы это исключе
ние было пропущено. Но пока я скажу лишь, что предложение except
требует внимательного отношения.
В версии Python 3.0 предполагается изменить форму, представ
ленную в третьей строке табл. 27.1: except name, value: планиру
ется преобразовать в форму except name as value:. Этим изменени
ем предполагается ликвидировать возможность перепутать эту
форму со случаем, когда в предложении except указывается кор
теж имен исключений – в версии Python 3.0 форма в четвертой
строке табл. 27.1 больше не будет требовать наличия круглых
скобок. Это изменение также приведет к изменению правил об
ласти видимости: с введением новой синтаксической конструк
ции as переменная value будет удаляться в конце блока except.
Кроме того, в версии 3.0 разновидность инструкции raise E, V
должна будет записываться как raise E(V), чтобы явно обозначить
Инструкция try/except/else 713
создание класса, который будет играть роль возбуждаемого исклю
чения. Предыдущая форма будет сохранена для обратной совмес
тимости со строковыми исключениями в Python 2.x. (Далее в этой
главе подробнее рассказывается об инструкции raise, а в следую
щей главе рассказывается об исключениях на базе классов.)
В настоящее время невозможно использовать форму as предложе
ния except в Python 2.x, чтобы подготовить свой программный
код к грядущим изменениям, однако в составе Python 3.0 будет
распространяться инструмент преобразования «2to3», который
автоматически будет выполнять преобразования предложения
except и инструкции raise в написанном для версии Python 2.x
программном коде.
Предложение try/else
Назначение предложения else в инструкции try на первый взгляд не
всегда очевидно для тех, кто только начинает осваивать язык Python.
Тем не менее, без этого предложения нет никакого другого способа уз
нать (не устанавливая и не проверяя флаги) – выполнение программы
продолжилось потому, что исключение в блоке try не было возбужде
но, или потому, что исключение было перехвачено и обработано:
try:
...выполняемый код...
except IndexError:
...обработка исключения...
# Программа оказалась здесь потому, что исключение было обработано
# или потому, что его не возникло?
Точно так же, как предложение else в операторах цикла делает причи
ну выхода из цикла более очевидной, предложение else в инструкции
try однозначно и очевидно сообщает о произошедшем:
try:
...выполняемый код...
except IndexError:
...обработка исключения...
else:
...исключение не было возбуждено...
То же самое поведение можно имитировать, переместив содержимое
блока else в блок try:
try:
...выполняемый код...
...исключение не было возбуждено...
except IndexError:
...обработка исключения...
Но это может привести к некорректной классификации исключения.
Если какаялибо из инструкций в блоке «исключение не было возбуж
дено» приведет к появлению исключения IndexError, оно будет зареги
стрировано как ошибка в блоке try и, соответственно, ошибочно будет
714 Глава 27. Основы исключений
передано обработчику исключения ниже (тонко, но верно!). При явном
использовании выражения else логика выполнения становится более
очевидной и гарантируется, что обработчики исключений будут вызы
ваться только для обработки истинных ошибок в блоке, обернутом ин
струкцией try, а не при выполнении действий, предусматриваемых
в блоке else.
Пример: поведение по умолчанию
Поскольку объяснить порядок выполнения программы проще на язы
ке Python, чем на естественном языке, рассмотрим несколько приме
ров, иллюстрирующих основы исключений. Я уже упоминал, что ис
ключения, не перехваченные инструкциями try, распространяются до
самого верхнего уровня процесса и запускают логику обработки ис
ключений по умолчанию (то есть интерпретатор аварийно завершает
работающую программу и выводит стандартное сообщение об ошиб
ке). Рассмотрим пример. При попытке запустить следующий модуль
bad.py возникает исключение деления на ноль:
def gobad(x, y):
return x / y
def gosouth(x):
print gobad(x, 0)
gosouth(1)
Так как программа сама не обрабатывает это исключение, интерпрета
тор завершает ее и выводит сообщение:1
% python bad.py
Traceback (most recent call last):
File "bad.py", line 7, in <module>
gosouth(1)
File "bad.py", line 5, in gosouth
print gobad(x, 0)
File "bad.py", line 2, in gobad
return x / y
ZeroDivisionError: integer division or modulo by zero
(ZeroDivisionError: целочисленное деление или деление по модулю на ноль)
Сообщение состоит из содержимого стека и имени (с дополнительны
ми данными) исключения. В содержимом стека перечислены все стро
ки, которые были активны в момент появления исключения, в поряд
ке от более старых к более новым. Обратите внимание: так как в дан
ном случае мы работаем в командной строке системы, а не в интерак
1 Текст сообщений и отладочная информация время от времени немного из
меняются. Поэтому не надо беспокоиться, если ваши сообщения не соответ
ствуют в точности тем, что приводятся здесь. Например, когда я запускал
этот пример в среде IDLE, входящей в состав Python 2.5, в тексте сообще
ния выводились полные пути к файлам.
Инструкция try/except/else 715
тивной оболочке интерпретатора, имена файлов и номера строк
содержат полезную для нас информацию. Например, здесь видно, что
ошибка произошла во 2 строке в файле bad.py, в инструкции return.
Так как интерпретатор Python определяет и сообщает обо всех ошиб
ках, появившихся во время выполнения программы, возбуждая ис
ключения, эти исключения тесно связаны с идеями обработки ошибок
и отладки вообще. Если вы работали с примерами из этой книги, вы
без сомнений встречались с несколькими исключениями – даже опе
чатки нередко приводят к возбуждению исключения SyntaxError или
других при импортировании и выполнении файла (то есть, когда за
пускается компилятор). По умолчанию интерпретатор выводит полез
ное информативное сообщение, как показано выше, которое позволяет
легко отыскать источник проблем.
Чаще всего для разрешения проблем достаточно стандартных сообще
ний об ошибках. Для более надежной отладки своих программ вы мо
жете перехватывать исключения с помощью инструкций try или ис
пользовать средства отладки, которые будут представлены в главе 29,
такие как модуль pdb из стандартной библиотеки.
Пример: перехват встроенных исключений
Обработка исключений, которая выполняется интерпретатором по
умолчанию, зачастую удовлетворяет всем нашим потребностям, осо
бенно для программного кода верхнего уровня, где ошибки должны
приводить к немедленному завершению программы. Для большинства
программ нет никакой необходимости предусматривать какието осо
бые варианты обработки ошибок.
Однако иногда бывает необходимо перехватить ошибку и выполнить
восстановительные действия после нее. Если для вас нежелательно,
чтобы программа завершалась, когда интерпретатор возбуждает ис
ключение, достаточно просто перехватить его, обернув участок про
граммы в инструкцию try. Это очень важная возможность для таких
программ, как серверы сети, которые должны продолжать работать
постоянно. Например, следующий фрагмент перехватывает и обраба
тывает исключение TypeError, которое возбуждается интерпретатором
при попытке выполнить операцию конкатенации для списка и строки
(оператор + требует, чтобы слева и справа были указаны последова
тельности одного и того же типа):
def kaboom(x, y):
print x + y # Возбуждает исключение TypeError
try:
kaboom([0,1,2], "spam")
except TypeError: # Исключение перехватывается и обрабатывается здесь
print 'Hello world!'
print 'resuming here' # Программа продолжает работу, независимо от того,
# было ли исключение или нет
716 Глава 27. Основы исключений
Когда в функции kaboom возникает исключение, управление передает
ся предложению except в инструкции try, где выводится текст сообще
ния. После того как исключение перехватывается, оно становится не
актуальным, поэтому программа продолжает выполнение ниже инст
рукции try вместо того, чтобы завершиться. Программный код дейст
вительно обрабатывает и ликвидирует ошибку.
Обратите внимание: как только ошибка будет перехвачена, выполне
ние продолжается с того места, где ошибка была перехвачена (то есть
после инструкции try), – нет никакой возможности вернуться к тому
месту, где возникла ошибка (в данном случае – в функцию kaboom).
В некотором смысле это делает исключения более похожими на инст
рукции перехода, чем на вызовы функций – нет никакой возможности
вернуться к программному коду, вызвавшему ошибку.
Инструкция try/finally
Другая разновидность инструкции try специализируется на выполне
нии завершающих действий. Если в инструкцию try включено предло
жение finally, интерпретатор всегда будет выполнять этот блок инст
рукций при «выходе» из инструкции try независимо от того, произош
ло ли исключение во время выполнения инструкций в блоке try. Об
щая форма этой инструкции имеет следующий вид:
try:
<инструкции> # Выполнить эти действия первыми
finally:
<инструкции> # Всегда выполнять этот блок кода при выходе из инструкции
При использовании этой инструкции интерпретатор Python в первую
очередь выполняет инструкции в блоке try. Что произойдет дальше,
зависит от того, возникло ли исключение в блоке try:
• Если во время выполнения инструкций в блоке try исключение не
возникло, интерпретатор переходит к выполнению блока finally
и затем продолжает выполнять программу ниже инструкции try.
• Если во время выполнения инструкций в блоке try возникло ис
ключение, интерпретатор также выполнит инструкции в блоке fi
nally, но после этого исключение продолжит свое распространение
до вышестоящей инструкции try или до обработчика исключений
по умолчанию – программа не будет выполняться вслед за инструк
цией try. То есть инструкции в блоке finally будут выполнены, да
же если исключение будет возбуждено, но в отличие от предложе
ния except, finally не завершает распространение исключения – оно
остается актуальным после выполнения блока finally.
Форма try/finally бывает удобна, когда необходимо гарантировать вы
полнение некоторых действий независимо от реакции программы на
исключение. С практической точки зрения эта форма инструкции по
Инструкция try/finally 717
зволяет определять завершающие действия, которые должны выпол
няться всегда, такие как закрытие файлов или закрытие соединений
с сервером.
Обратите внимание: в Python 2.4 и в более ранних версиях предложе
ние finally не может использоваться в той же инструкции try, где уже
используется предложение except или else, поэтому форму try/finally
лучше считать отдельной формой инструкции при работе со старыми
версиями. Однако в Python 2.5 предложение finally может присутст
вовать в инструкции try вместе с предложениями except и else, поэто
му в настоящее время существует единая инструкция try, которая мо
жет употребляться с несколькими необязательными предложениями
(вскоре мы поговорим об этом подробнее). Однако какую бы версию
Python вы не использовали, назначение предложения funally остается
прежним – определить завершающие действия, которые должны вы
полняться всегда, независимо от возникновения исключений.
Как будет показано далее в этой главе, в версии Python 2.6, инст
рукция with и контекстные менеджеры обеспечивают объектно
ориентированный подход к выполнению аналогичных завершаю
щих действий, но кроме того, эта инструкция поддерживает воз
можность выполнения действий по инициализации.
Пример: реализация завершающих действий
с помощью инструкции try/finally
Выше мы видели несколько простых примеров применения инструк
ции try/finally. Ниже приводится более близкий к реальности при
мер, иллюстрирующий типичное применение этой инструкции:
class MyError(Exception): pass
def stuff(file):
raise MyError()
file = open('data', 'w') # Открыть файл для вывода
try:
stuff(file) # Возбуждает исключение
finally:
file.close() # Всегда закрывать файл, чтобы вытолкнуть буферы
... # Продолжить с этого места,
# только если не было исключения
В этом фрагменте мы обернули вызов функции в инструкцию try,
с предложением finally, чтобы гарантировать, что файл будет закрыт
при любых обстоятельствах, независимо от того, будет возбуждено ис
ключение в функции или нет. При таком подходе расположенный да
лее программный код может быть уверен, что содержимое выходных
буферов файла было вытолкнуто из памяти на диск. Подобная структу
ра программного кода может гарантировать закрытие соединения с сер
вером и т. д.
718 Глава 27. Основы исключений
Функция в этом примере не делает ничего полезного (она просто возбу
ждает исключение), но обернув ее в инструкцию try/finally, мы гаран
тируем, что действия по завершению будут выполняться всегда. На
помню еще раз, что интерпретатор всегда выполняет программный код
в блоке finally независимо от того, было возбуждено исключение в бло
ке try или нет.1
Когда функция в этом примере возбуждает исключение, управление
передается обратно инструкции try и начинает выполняться блок fi
nally, в котором производится закрытие файла. После этого исключе
ние продолжает свое распространение либо пока не встретит другую
инструкцию try, либо пока не будет достигнут обработчик по умолча
нию, который выведет стандартное сообщение об ошибке и остановит
работу программы; инструкция, находящая ниже инструкции try, ни
когда не будет достигнута. Если бы функция в этом примере не возбу
ждала исключение, программа точно так же выполнила бы блок final
ly, чтобы закрыть файл, и затем продолжила бы свое выполнение ни
же инструкции try.
Кроме того, обратите внимание, что здесь исключение опять определе
но как класс – как будет показано в следующей главе, в настоящее вре
мя все исключения должны быть классами.
Объединенная инструкция try/except/finally
Во всех версиях Python, вышедших до версии 2.5 (в течение первых
15 лет жизни, или чтото около того), инструкция try существовала
в двух разновидностях, и в действительности имелось две отдельные
инструкции. Мы могли либо использовать предложение finally, чтобы
гарантировать выполнение завершающего программного кода, либо
писать блоки except, чтобы перехватывать определенные исключения
и выполнять действия по восстановлению после них и, при желании,
использовать предложение else, которое выполняется в случае отсут
ствия исключений.
То есть предложение finally нельзя было смешивать с предложениями
except и else. Такое положение дел сохранялось отчасти изза проблем
с реализацией, а отчасти изза неясности смысла такого смешивания –
перехват и восстановление после исключений выглядит никак не свя
занным с выполнением действий по завершению.
Однако в Python 2.5 (эта версия Python используется в данном изда
нии книги) две инструкции были объединены. Сейчас у нас имеется
1 Если, конечно, сам интерпретатор не завершит свою работу аварийно. Раз
работчики Python упорно трудятся над тем, чтобы избежать подобного раз
вития событий, проверяя все возможные ошибки во время работы. Полное
обрушение программы вместе с интерпретатором часто происходит изза
ошибок в расширениях, написанных на языке C, которые выполняются не
под управлением Python.
Объединенная инструкция try/except/finally 719
возможность смешивать предложения funally, except и else в одной
и той же инструкции. То есть теперь мы можем написать инструкцию,
имеющую следующий вид:
try:
основное действие
except Exception1:
обработчик1
except Exception2:
обработчик2
...
else:
блок else
finally:
блок finally
Первым, как обычно, выполняется программный код в блоке основное
действие. Если при выполнении этого блока возбуждается исключение,
выполняется проверка всех блоков except, одного за другим, в поисках
блока, соответствующего возникшему исключению. Если было возбу
ждено исключение Exception1, будет выполнен блок обработчик1, ис
ключение Exception2 приведет к запуску обработчика2 и т. д. Если ис
ключение не было возбуждено, будет выполнен блок else.
Независимо от того, что происходило раньше, блок finally будет вы
полнен только после выполнения основных действий, и после обработ
ки любых возникших исключений. В действительности, блок finally
будет выполнен, даже если исключение возникнет в самом обработчи
ке исключения или в блоке else.
Как всегда, предложение finally не прекращает распространение ис
ключения – если к моменту выполнения блока finally имеется актив
ное исключение, оно продолжает свое распространение после выпол
нения блока finally и управление передается кудато в другое место
программы (другой инструкции try или обработчику по умолчанию).
Если к моменту, когда блок finally будет выполнен, нет активного ис
ключения, выполнение программы продолжится сразу же вслед за ин
струкцией try.
Таким образом, блок finally выполняется всегда, когда:
• В блоке основного действия возникло исключение и было обработано.
• В блоке основного действия возникло исключение и не было обрабо
тано.
• В блоке основного действия не возникло исключение.
• В одном из обработчиков возникло новое исключение.
Напомню еще раз, предложение finally служит, чтобы организовать
выполнение завершающих действий, которые должны выполняться
всегда при выходе из инструкции try, независимо от того, было ли воз
буждено исключение и было ли оно обработано.
720 Глава 27. Основы исключений
Объединение finally и except вложением
До появления версии Python 2.5 существовала возможность объеди
нять предложения finally и except в инструкции try за счет вложения
инструкции try/except в блок try инструкции try/finally (более полно
этот прием будет рассматриваться в главе 29). В действительности
фрагмент ниже имеет тот же эффект, что и новая форма инструкции,
представленная в предыдущем разделе:
try:
try:
основное действие
except Exception1:
обработчик1
except Exception2:
обработчик2
...
else:
нет ошибок
finally:
завершающие действия
Здесь также блок finally всегда выполняется при выходе из инструкции
try независимо от того, что произошло в блоке основного действия, и не
зависимо от того, выполнялись ли обработчики исключений во вложен
ной инструкции try (представьте, как в этом случае будут развиваться
четыре варианта событий, перечисленные выше, и вы увидите, что все
будет выполняться точно так же). Однако этот эквивалент выглядит ме
нее понятным, чем новая, объединенная форма инструкции. Смешан
ная форма инструкции проще в написании и выглядит понятнее, поэто
му такая форма записи считается в настоящее время предпочтительной.
Пример использования объединенной инструкции try
Ниже приводится пример использования объединенной формы инст
рукции try. Здесь представлены четыре типичных варианта с инструк
циями print, описывающими значение каждого из них:
print '' * 30, '\nEXCEPTION RAISED AND CAUGHT'
try:
x = 'spam'[99]
except IndexError:
print 'except run'
finally:
print 'finally run'
print 'after run'
print '' * 30, '\nNO EXCEPTION RAISED'
try:
x = 'spam'[3]
except IndexError:
print 'except run'
Объединенная инструкция try/except/finally 721
finally:
print 'finally run'
print 'after run'
print '' * 30, '\nNO EXCEPTION RAISED, ELSE RUN'
try:
x = 'spam'[3]
except IndexError:
print 'except run'
else:
print 'else run'
finally:
print 'finally run'
print 'after run'
print '' * 30, '\nEXCEPTION RAISED BUT NOT CAUGHT'
try:
x = 1 / 0
except IndexError:
print 'except run'
finally:
print 'finally run'
print 'after run'
После запуска этот пример выводит на экран следующий ниже текст.
Исследуйте программный код, чтобы понять, как работает каждый из
вариантов:

EXCEPTION RAISED AND CAUGHT
except run
finally run
after run

NO EXCEPTION RAISED
finally run
after run

NO EXCEPTION RAISED, ELSE RUN
else run
finally run
after run

EXCEPTION RAISED BUT NOT CAUGHT
finally run
Traceback (most recent call last):
File "C:/Python25/mergedexc.py", line 32, in <module>
x = 1 / 0
ZeroDivisionError: integer division or modulo by zero
(ZeroDivisionError: целочисленное деление или деление по модулю на ноль)
Этот пример для возбуждения исключений в основном действии ис
пользует встроенные операции и полагается на тот факт, что интер
722 Глава 27. Основы исключений
претатор всегда определяет появление ошибок во время выполнения
программного кода. В следующем разделе будет показано, как возбуж
дать исключения вручную.
Инструкция raise
Чтобы явно возбудить исключение, можно использовать инструкцию
raise. В общем виде она имеет очень простую форму записи – инструк
ция raise состоит из слова raise, за которым могут следовать имя воз
буждаемого исключения и дополнительный элемент данных, переда
ваемый вместе с исключением:
raise <name> # Возбуждает исключение
raise <name>, <data> # Передает дополнительные данные для обработчика
raise # Повторно возбуждает самое последнее исключение
Вторая форма позволяет передавать дополнительные данные вместе
с исключением, чтобы сообщить обработчику о некоторых подробно
стях. Данные, указанные после имени исключения в инструкции
raise, передаются обратно в инструкцию try в виде переменной. Если
инструкция try включает предложение except name, X:, то дополнитель
ный элемент данных, указанный в инструкции raise, будет присвоен
переменной X. Третья форма инструкции raise просто повторно возбу
ждает текущее исключение – это удобно, когда возникает необходи
мость передать перехваченное исключение другому обработчику.
А что используется в качестве имени исключения? Это может быть
имя встроенного исключения из встроенной области видимости (на
пример, IndexError) или имя любого строкового объекта в программе.
Это может быть также ссылка на класс или экземпляр класса – данная
возможность позволяет еще больше обобщить формат инструкции
raise. Я не буду касаться подробностей такого обобщения, пока мы не
приступим к изучению классов исключений в следующей главе
Независимо от того, какие исключения будут использованы, они всегда
идентифицируются обычными объектами и только одно исключение
может быть активным в каждый конкретный момент времени. Как
только исключение перехватывается предложением except, находя
щимся в любом месте программы, исключение деактивируется (то есть
оно не будет передано другой инструкции try), если не будет повторно
возбуждено при помощи инструкции raise или в результате ошибки.
Пример: возбуждение и обработка
собственных исключений
Программы на языке Python с помощью инструкции raise могут воз
буждать как встроенные, так и собственные исключения. В настоящее
время собственные исключения в программе должны быть представле
ны объектами экземпляров классов, как, например, MyBad в следую
щем примере:
Инструкция raise 723
class MyBad: pass
def stuff():
raise MyBad() # Возбудить исключение вручную
try:
stuff() # Возбуждает исключение
except MyBad:
print 'got it' # Здесь выполняется обработка исключения
... # С этого места продолжается выполнение программы
На этот раз исключение происходит внутри функции, но в действитель
ности это не имеет никакого значения – управление немедленно пере
дается блоку except. Обратите внимание, что инструкция try перехва
тывает собственные исключения программы точно так же, как и встро
енные исключения.
Пример: передача дополнительных данных
инструкции raise
Как утверждалось выше, инструкция raise может передавать дополни
тельные данные в месте с исключением для использования в обработ
чике. Дополнительные данные позволяют передавать обработчику
контекстную информацию об исключении. Например, если вы пишете
программу анализа содержимого файла, то в случае нахождения ошиб
ки можно было бы возбуждать исключение синтаксической ошибки
и вместе с этим исключением передавать обработчику объект, вклю
чающий в себя строку и информацию о файле (такой пример будет рас
сматриваться в главе 28).
Это бывает полезно, потому что после того, как исключение будет воз
буждено, оно может быть перехвачено в другом модуле, то есть инст
рукция raise, возбудившая исключение, и инструкция try, перехва
тившая его, могут находиться в совершенно разных файлах. Поэтому
вообще может оказаться невозможным использовать глобальные пере
менные для сохранения дополнительной информации об исключении,
потому что инструкция try может даже не знать, в каком модуле нахо
дятся эти переменные. Возможность передачи данных непосредствен
но с самим исключением обеспечивает более надежный доступ к ним
в инструкции try. Строго говоря, дополнительные данные имеются
у каждого исключения: как в случае с возвращаемыми значениями
функций, если данные не были переданы явно, то в качестве таких
данных используется специальный объект None. Следующий фраг
мент, raisedata.py, иллюстрирует действие этой концепции на приме
ре простых исключений на базе строк:
myException = 'Error' # Строковый объект
def raiser1():
raise myException, "hello" # Возбудить исключение, передать данные
def raiser2():
724 Глава 27. Основы исключений
raise myException # Возбудить исключение, предполагается None
def tryer(func):
try:
func() # Вызвать func
except myException, extraInfo: # перехватить исключение с данными
print 'got this:', extraInfo
% python
>>> from raisedata import *
>>> tryer(raiser1) # Данные были переданы явно
got this: hello
>>> tryer(raiser2) # Дополнительные данные  None по умолчанию
got this: None
Здесь функция tryer всегда запрашивает получение объекта с допол
нительными данными – он поступает из функции raiser1 в виде явно
заданной строки, а из функции raiser2 – в виде объекта None, исполь
зуемого по умолчанию.
В следующей главе мы увидим, что тот же самый прием может исполь
зоваться для организации доступа к экземплярам при использовании
исключений на базе классов – в этом случае переменной в предложе
нии except присваивается ссылка на экземпляр класса исключения,
который обеспечивает доступ к присоединенной информации и к мето
дам класса.
Пример: повторное возбуждение исключений
с помощью инструкции raise
Инструкция raise, в которой отсутствует имя исключения или допол
нительные данные, просто повторно возбуждает текущее исключение.
В таком виде она обычно используется, когда необходимо перехватить
и обработать исключение, но при этом не требуется деактивировать ис
ключение:
>>> try:
... raise IndexError, 'spam'
... except IndexError:
... print 'propagating'
... raise
...
propagating
Traceback (most recent call last):
File "<stdin>", line 2, in ?
IndexError: spam
При таком использовании инструкция raise повторно возбуждает ис
ключение, которое затем передается обработчику более высокого уров
ня или обработчику по умолчанию, который останавливает выполне
ние программы и выводит стандартное сообщение об ошибке.
Инструкция assert 725
Инструкция assert
Язык Python включает инструкцию assert в качестве особого случая
возбуждения исключений. Это сокращенная форма типичного шабло
на использования инструкции raise, которая представляет собой ус+
ловную инструкцию raise. Инструкция в форме:
assert <test>, <data> # Часть <data> является необязательной
представляет собой эквивалент следующего фрагмента:
if __debug__:
if not <test>:
raise AssertionError, <data>
Другими словами, если условное выражение возвращает ложное зна
чение, интерпретатор возбуждает исключение: элемент данных (если
присутствует) играет роль дополнительных данных исключения. Как
и все исключения, исключение AssertionError приводит к завершению
программы, если не будет перехвачено инструкцией try.
Существует дополнительная возможность удалить все инструкции as
sert из скомпилированного байткода программы за счет использования
флага командной строки O при запуске интерпретатора и тем самым оп
тимизировать программу. Исключение AssertionError является встроен
ным исключением, а имя __debug__ – встроенным флагом, который авто
матически получает значение 1 (истина), когда не используется флаг O.
Пример: проверка соблюдения ограничений
(но не ошибок)
Обычно инструкция assert используется для проверки условий выпол
нения программы во время разработки. При отображении в текст сооб
щений об ошибках, полученных в результате выполнения инструкции
assert, автоматически включается информация из строки исходного
программного кода и значения, перечисленные в инструкции. Рас
смотрим файл asserter.py:
def f(x):
assert x < 0, 'x must be negative'
return x ** 2
% python
>>> import asserter
>>> asserter.f(1)
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "asserter.py", line 2, in f
assert x < 0, 'x must be negative'
AssertionError: x must be negative
Важно не забывать, что инструкция assert главным образом предна
значена для проверки соблюдения ограничений, накладываемых про
726 Глава 27. Основы исключений
граммистом, а не для перехвата настоящих ошибок. Так как интер
претатор Python в состоянии сам выявлять ошибки во время выполне
ния программы, обычно нет необходимости использовать assert для
выявления таких проблем, как выход индекса за допустимые преде
лы, несоответствие типов или деление на ноль:
def reciprocal(x):
assert x != 0 # Бесполезная инструкция assert!
return 1 / x # Интерпретатор автоматически проверит на равенство нулю
Такие инструкции assert являются лишними, потому что встретив
ошибку, интерпретатор автоматически возбудит исключение и вы
вполне могли бы положиться в этом на него.1 Еще один пример типич
ного использования инструкции assert приводится в примере абст
рактного суперкласса в главе 24 – там инструкция assert использова
лась для того, чтобы вызов неопределенных методов приводил к ис
ключению с определенным текстом сообщения.
Контекстные менеджеры with/as
В версии Python 2.6 (на момент, когда писалась эта книга, данная вер
сия еще не вышла) появится новая инструкция, имеющая отношение
к исключениям – with, с необязательным предложением as. Эта инст
рукция предназначена для работы с объектами контекстных менедже
ров, которые поддерживают новый протокол взаимодействия, осно
ванный на использовании методов.
Проще говоря, инструкция with/as может использоваться как альтер
натива известной идиомы try/finally; подобно этой инструкции она
предназначена для выполнения завершающих действий независимо
от того, возникло ли исключение на этапе выполнения основного дей
ствия. Однако, в отличие от инструкции try/finally, инструкция with
поддерживает более богатый возможностями протокол, позволяющий
определять как предварительные, так и заключительные действия
для заданного блока программного кода.
Язык Python дополняет некоторые встроенные средства контекстны
ми менеджерами, например, файлы, которые закрываются автомати
чески, или блокировки потоков выполнения, которые автоматически
запираются и отпираются. Однако программист также может созда
вать с классами и свои контекстные менеджеры.
1 По крайней мере, в большинстве случаев. Как предлагалось в четвертой
части книги, проверка на наличие ошибки может использоваться в функ
ции, выполняющей расчеты длительное время или необратимые действия.
Но даже в этом случае старайтесь не использовать чрезмерно специализи
рованные или чрезмерно ограничительные проверки, т. к. в противном
случае это ограничит область применения вашего программного кода.
Контекстные менеджеры with/as 727
Основы использования
Данная функциональная возможность официально станет частью язы
ка Python, только начиная с версии 2.6. В Python 2.5 по умолчанию
она еще не доступна – ее следует активировать с помощью специаль
ной инструкции импорта, с которой мы уже встречались в этой книге
при изучении модулей (так как появятся два новых зарезервирован
ных слова with и as, это новшество, как обычно, вводится постепенно):
from __future__ import with_statement
Когда эта инструкция import выполняется в Python 2.5, появляется
возможность использовать новую инструкцию with и два новых заре
зервированных слова. Основная форма инструкции with выглядит,
как показано ниже:
with выражение [as переменная]:
блок with
Здесь предполагается, что выражение возвращает объект, поддержи
вающий протокол контекстного менеджера (вскоре я расскажу об этом
протоколе подробнее). Этот объект может возвращать значение, кото
рое будет присвоено переменной, если присутствует необязательное
предложение as.
Обратите внимание, что результат выражения не присваивается перемен
ной – результатом выражения является объект, который поддерживает
контекстный протокол, а переменной может быть присвоено некоторое
другое значение. Объект, возвращаемый выражением, может затем выпол
нять предварительные действия перед тем, как будет запущен блок with,
а также завершающие действия после того, как этот блок будет выпол
нен, независимо от того, было ли возбуждено исключение при его вы
полнении.
Некоторые встроенные объекты языка Python были дополнены под
держкой протокола управления контекстом и потому могут использо
ваться в инструкции with. Например, объекты файлов снабжены ме
неджером контекста, который автоматически закрывает файл после
выполнения блока with независимо от того, было ли возбуждено ис
ключение при его выполнении:
with open(r'C:\python\scripts') as myfile:
for line in myfile:
print line
line = line.replace('spam', 'SPAM')
...остальной программный код...
Здесь вызываемая функция open возвращает объект файла, который
присваивается имени myfile. Применительно к переменной myfile мы
можем использовать обычные средства, предназначенные для работы
с файлами, – в данном случае с помощью итератора выполняется чте
ние строки за строкой в цикле for.
728 Глава 27. Основы исключений
Однако данный объект поддерживает протокол управления контек
стом, используемый инструкцией with. После того как инструкция
with начнет выполнение, механизм управления контекстом гарантиру
ет, что объект файла, на который ссылается переменная myfile, будет
закрыт автоматически, даже если в цикле for во время обработки фай
ла произойдет исключение.
Мы не будем рассматривать в этой книге многопоточную модель вы
полнения в языке Python (за дополнительной информацией по этой те
ме вам следует обращаться к книгам, посвященным прикладному про
граммированию, таким как «Programming Python»), но блокировка
и средства синхронизации посредством условных переменных также
поддерживаются инструкцией with за счет обеспечения поддержки
протокола управления контекстом:
lock = threading.Lock()
with lock:
# Критическая секция программного кода
...доступ к совместно используемым ресурсам...
Здесь механизм управления контекстом гарантирует, что блокировка
автоматически будет приобретена до того, как начнет выполняться
блок, и освобождена по завершении работы блока.
Модуль decimal (подробнее о числах с фиксированной точностью пред
ставления рассказывается в главе 5) также использует менеджеры
контекста для упрощения сохранения и восстановления текущего
контекста вычислений, определяющего параметры точности и округ
ления, используемые в вычислениях.
Протокол управления контекстом
Интерфейс, который должны реализовать объекты для использования
совместно с инструкцией with, достаточно сложен, хотя большинству
программистов достаточно лишь знать, как используются существую
щие контексты менеджеров. Однако разработчикам программных ин
струментов может потребоваться знание правил создания новых ме
неджеров, поэтому коротко рассмотрим основные принципы. Ниже
описывается, как в действительности работает инструкция with:
1. Производится вычисление выражения, возвращающего объект, из
вестный как менеджер контекста, который должен иметь методы
__enter__ и __exit__.
2. Вызывается метод __enter__ менеджера контекста. Возвращаемое
значение метода присваивается переменной – при наличии предло
жения as, в противном случае оно просто уничтожается.
3. Затем выполняется блок программного кода, вложенный в инст
рукцию with.
4. Если при выполнении блока возбуждается исключение, вызывает
ся метод __exit__(тип, значение, диагностическая_информация), которо
Контекстные менеджеры with/as 729
му передается подробная информация об исключении. Обратите
внимания, что это те же самые значения, которые возвращает
функция sys.exc_info, описываемая в руководстве по языку Python
и далее в этой книге. Если этот метод возвращает ложное значение,
исключение возбуждается повторно, в противном случае исключе
ние деактивируется. Обычно исключение следует возбуждать по
вторно, чтобы оно могло выйти за пределы инструкции with.
5. Если в блоке with исключение не возникает, метод __exit__ все рав
но вызывается, но в аргументах тип, значение и диагностическая_ин
формация ему передается значение None.
Рассмотрим небольшой пример, демонстрирующий работу протокола.
Следующий фрагмент определяет объект менеджера контекста, кото
рый сообщает о входе и выходе из блока программного кода любой ин
струкции with, с которой он используется:
from __future__ import with_statement # Требуется в Python 2.5
class TraceBlock:
def message(self, arg):
print 'running', arg
def __enter__(self):
print 'starting with block'
return self
def __exit__(self, exc_type, exc_value, exc_tb):
if exc_type is None:
print 'exited normally\n'
else:
print 'raise an exception!', exc_type
return False # propagate
with TraceBlock() as action:
action.message('test 1')
print 'reached'
with TraceBlock() as action:
action.message('test 2')
raise TypeError
print 'not reached'
Обратите внимание, что метод __exit__ должен возвращать False, чтобы
разрешить дальнейшее распространение исключения – отсутствие ин
струкции return обеспечивает тот же самый эффект, потому что в этом
случае по умолчанию возвращается значение None, которое по опреде
лению является ложным. Кроме того, следует заметить, что метод
__enter__ возвращает сам объект self, который присваивается пере
менной в предложении as; при желании этот метод может возвращать
совершенно другой объект.
При запуске этого фрагмента менеджер контекста с помощью своих
методов __enter__ и __exit__ отмечает моменты входа и выхода из блока
инструкции with:
730 Глава 27. Основы исключений
% python withas.py
starting with block
running test 1
reached
exited normally
starting with block
running test 2
raise an exception! <type 'exceptions.TypeError'>
Traceback (most recent call last):
File "C:/Python25/withas.py", line 22, in <module>
raise TypeError
TypeError
Менеджеры контекста являются новейшими инструментами, которые
официально еще не стали частью языка Python, поэтому мы не будем
рассматривать здесь дополнительные подробности (за полной информа
цией обращайтесь к стандартным руководствам по языку; например,
новый стандартный модуль contextlib содержит дополнительные сред
ства, которые могут использоваться для создания менеджеров контек
стов). В более простых случаях инструкция try/finally обеспечивает
достаточную поддержку для выполнения завершающих действий.
Придется держать в уме: проверка ошибок
Один из способов увидеть, насколько полезными могут быть ис
ключения, состоит в том, чтобы сравнить стили программирова
ния на языке Python и на языке, не имеющем исключений. На
пример, если вы хотите написать надежную программу на языке
C, вам потребуется проверять возвращаемые значения или коды
состояния после выполнения каждой операции, которая может
быть выполнена с ошибкой, и передавать результаты проверок
в ходе выполнения программы:
doStuff()
{ # Программа на языке C
if (doFirstThing() == ERROR) # Проверить наличие ошибки
return ERROR; # даже если здесь она не обрабатывается
if (doNextThing() == ERROR)
return ERROR;
...
return doLastThing();
}
main()
{
if (doStuff() == ERROR)
badEnding();
В заключение 731
В заключение
В этой главе мы приступили к изучению вопросов обработки исключе
ний и к исследованию инструкций, связанных с исключениями: инст
рукция try используется для перехвата исключений, raise используется
для их возбуждения, assert используется для возбуждения исключений
по условию и with используется для обертывания программного кода
менеджерами контекстов, определяющими действия на входе и выходе.
Пока исключения выглядят достаточно простым инструментом, впро
чем, таковым они и являются, – единственная сложность заключается
в их идентификации. Следующая глава продолжит наши исследова
ния описанием реализации наших собственных объектов исключений,
где будет показано, что классы позволяют создавать исключения более
else
goodEnding();
}
Фактически в настоящих программах на языке C значительная
доля всего программного кода выполняет проверку наличия
ошибок. Но в языке Python такая настойчивость и методичность
не требуется. Достаточно просто обернуть произвольные участки
программы обработчиками исключений и писать эти участки
в предположении, что никаких ошибок возникать не будет:
def doStuff(): # Программный код на языке Python
doFirstThing() # Нас не беспокоят возможные исключения,
doNextThing() # поэтому можно не выполнять проверку
...
doLastThing()
if__name__ == '__main__':
try:
doStuff() # Здесь нас интересуют возможные результаты,
except: # поэтому это единственное место, где нужна проверка
badEnding()
else:
goodEnding
Так как в случае исключения управление немедленно будет пере
дано обработчику, здесь нет никакой необходимости разбрасывать
проверки по всему программному коду, чтобы обезопасить себя от
ошибок. Кроме того, благодаря тому, что интерпретатор Python
автоматически обнаруживает ошибки, ваши программы обычно
не требуют выполнять подобные проверки вообще. Таким обра
зом, исключения позволяют в значительной степени игнорировать
возможные необычные ситуации и отказаться от использования
программного кода, выполняющего проверки на наличие ошибок.
732 Глава 27. Основы исключений
полезные, чем простые строки. Однако, прежде чем двинуться вперед,
ответьте на контрольные вопросы по темам, охваченным в этой главе.
Закрепление пройденного
Контрольные вопросы
1. Для чего служит инструкция try?
2. Какие две основные разновидности инструкции try существуют?
3. Для чего служит инструкция raise?
4. Для чего служит инструкция assert и какую другую инструкцию
она напоминает?
5. Для чего служит инструкция with/as и какие другие инструкции
она напоминает?
Ответы
1. Инструкция try служит для перехвата исключений и проведения
восстановительных действий после них. Она определяет блок вы
полняемого программного кода и один или более обработчиков ис
ключений, которые могут возникнуть в ходе выполнения блока.
2. Существует две основные разновидности инструкции try – это try/ex
cept/else (используется для перехвата исключений) и try/finally (ис
пользуется для указания завершающих действий, которые должны
быть выполнены независимо от того, возникло ли исключение или
нет). В версии Python 2.4 это две отдельные инструкции, которые
можно объединить вложением друг в друга. В версии 2.5 и выше бло
ки except и finally могут смешиваться в одной и той же инструкции,
то есть две формы инструкции объединены в одну. В объединенной
форме блок finally попрежнему выполняется при выходе из инст
рукции try независимо от того, было обработано исключение или нет.
3. Инструкция raise возбуждает (запускает) исключение. Интерпре
татор посредством внутренних механизмов возбуждает встроенные
исключения, а ваши сценарии с помощью инструкции raise могут
возбуждать как встроенные, так и свои собственные исключения.
4. Инструкция assert возбуждает исключение AssertionError, когда ус
ловное выражение возвращает ложное значение. Она напоминает
инструкцию raise, обернутую инструкций if.
5. Инструкция with/as предназначена для автоматического запуска
программного кода, выполняющего предварительные и завершаю
щие действия перед входом и после выхода из обернутого блока
программного кода. Она в общих чертах напоминает инструкцию
try/finally, так как тоже выполняет действия на выходе независи
мо от того, возникло исключение или нет, но в отличие от послед
ней позволяет определять действия на входе и на выходе, исполь
зуя для этого протокол, основанный на использовании объектов.
28
Объекты исключений
До сих пор я преднамеренно умалчивал о том, чем в действительности
являются исключения. В языке Python понятие исключения было
обобщено – как уже упоминалось в предыдущей главе, они могут
идентифицироваться строковыми объектами или объектами экземп
ляра класса. В настоящее время предпочтительнее использовать объ
екты экземпляров класса, но в скором будущем они станут обязатель
ными. У обоих подходов имеются свои достоинства, но классы обеспе
чивают лучшее решение, когда дело доходит до поддержки иерархий
исключений.
Проще говоря, исключения на основе классов позволяют создавать ис
ключения, организованные в категории, включающие информацию
о состоянии и поддерживающие наследование. Если говорить более
подробно, по сравнению со строками, классы исключений:
• Лучше поддерживают возможные изменения в будущем – добавле
ние новых исключений в будущем вообще не будет требовать изме
нений в инструкциях try.
• Предоставляют естественное место для хранения информации, дос
тупной для обработчиков в инструкции try. Они могут включать
как информацию о состоянии, так и методы, доступные через эк
земпляры класса.
• Позволяют исключениям принимать участие в иерархиях наследо
вания с целью обладания общим поведением – наследовать методы
отображения, например, чтобы обеспечить единый стиль сообще
ний об ошибках.
Вследствие этих отличий исключения в виде классов лучше поддер
живают возможность развития программ и крупных систем, чем ис
ключения на основе строк. Строковые исключения на первый взгляд
выглядят более простыми в использовании, пока программы имеют
734 Глава 28. Объекты исключений
небольшой размер, но пользоваться ими становится значительно
сложнее по мере роста размеров программ. В действительности, по
причинам, указанным выше, все встроенные исключения идентифи
цируются классами и организованы в виде дерева наследования. Вы
можете избрать такой же подход при создании своих собственных ис
ключений.
В интересах обратной совместимости я представлю здесь и строковые
исключения, и исключения на основе классов. В настоящее время мо
гут использоваться оба вида исключений, однако строковые исключе
ния генерируют предупреждения о нежелательности их использова
ния в текущей версии Python (2.5) и не будут поддерживаться в версии
Python 3.0. Мы будем их рассматривать, потому что они наверняка бу
дут встречаться вам в существующем программном коде, но новые ис
ключения, которые вам придется определять, уже в настоящее время
должны оформляться в виде классов отчасти потому, что реализация
на основе классов обладает неоспоримыми преимуществами, а отчасти
потому, что вам едва ли захочется вносить изменения в свой про
граммный код после выхода Python 3.0.
Исключения на основе строк
Во всех примерах, что мы видели до сих пор, исключения, определяе
мые программой, были оформлены в виде строк. Это простейший спо
соб создать исключение. Например:
>>> myexc = "My exception string"
>>> try:
... raise myexc
... except myexc:
... print 'caught'
...
Caught
Любое строковое значение может использоваться для идентификации
исключения. С технической точки зрения исключение идентифициру
ется строковым объектом, а не значением – вы должны использовать
одно и то же имя переменной (то есть ссылку) при возбуждении и при
перехвате исключения (подробнее об этой идее я расскажу в разделе,
описывающем типичные проблемы, в конце седьмой части). В этом
примере исключение myexc – это обычная переменная, она может им
портироваться другими модулями, и т. д. Текст строки практически
не играет никакой роли за исключением того, что он выводится как
текст сообщения об ошибке:
>>> raise myexc
Traceback (most recent call last):
File "<stdin>", line 1, in ?
My exception string
Исключения на основе классов 735
Если учесть, что текст строковых исключений может выводиться
на экран, вы наверняка предпочтете использовать более осмыс
ленный текст, чем в примерах, показанных в этой книге.
Строковые исключения уходят в прошлое!
Как уже упоминалось ранее, строковые исключения попрежнему
можно использовать, но в версии Python 2.5 они генерируют предупре
ждения и, как предполагается, вообще не будут поддерживаться в Py
thon 3.0, если не раньше. Ниже приводится истинный результат рабо
ты предыдущего фрагмента в среде разработки IDLE, входящей в со
став Python 2.5:
>>> myexc = 'My exception string'
>>> try:
raise myexc
except myexc:
print 'caught'
Warning (from warnings module):
File "__main__", line 2
DeprecationWarning: raising a string exception is deprecated
(DeprecationWarning: возбуждение строковых исключений не приветствуется)
caught
Вы можете запретить вывод таких предупреждений, но они выводятся
для того, чтобы дать вам знать, что строковые исключения в будущем
будут рассматриваться как ошибка и потому станут недопустимыми.
В этой книге строковые исключения описываются лишь для того, что
бы дать вам возможность понимать программный код, написанный
в прошлом; в настоящее время все встроенные исключения являются
экземплярами классов, и все исключения, определяемые в программе,
также должны создаваться на основе классов. В следующем разделе
объясняется – почему.
Исключения на основе классов
Строки обеспечивают самый простой способ определения исключений.
Однако, как описывалось ранее, классы предоставляют дополнитель
ные преимущества, которые заслуживают того, чтобы познакомиться
с ними. Наиболее важное преимущество заключается в том, что клас
сы позволяют организовать исключения в категории и они обладают
большей гибкостью, чем простые строки. Кроме того, классы обеспе
чивают естественный способ присоединения к исключениям дополни
тельной информации и поддерживают наследование. Они обеспечива
ют лучшее решение и поэтому в скором будущем будут представлять
единственную возможность определения новых исключений.
Помимо отличий в программном коде главное различие между строко
выми исключениями и исключениями на базе классов заключается
736 Глава 28. Объекты исключений
в способе идентификации возбужденных исключений в предложени
ях except инструкции try:
• Строковые исключения идентифицируются по идентичности объ+
екта: идентификация возбужденного исключения в предложении
except выполняется с помощью оператора is (а не ==).
• Исключения на основе классов идентифицируются отношением
наследования: возбужденное исключение считается соответствую
щим предложению except, если в данном предложении указан
класс исключения или любой из его суперклассов.
То есть, когда в инструкции try предложение except содержит супер
класс, оно будет перехватывать экземпляры этого суперкласса, а так
же экземпляры всех его подклассов, расположенных ниже в дереве на
следования. Благодаря этому исключения на основе классов поддер
живают возможность создания иерархий исключений: суперклассы
превращаются в имена категорий, а подклассы становятся различны
ми видами исключений внутри категории. Используя имя общего су
перкласса, предложение except сможет перехватывать целую катего
рию исключений – каждый конкретный подкласс будет соответство
вать этому предложению.
В дополнение к этой идее исключения на основе классов обеспечивают
лучшую поддержку информации о состоянии (присоединенной к эк
земплярам), и позволяют исключениям принимать участие в иерархи+
ях наследования (с целью обрести общие черты поведения). Они пред
ставляют собой более мощную альтернативу строковым исключениям
при незначительном увеличении объемов программного кода.
Пример исключениякласса
Давайте рассмотрим на примере программного кода, как работают ис
ключенияклассы. В следующем файле classexc.py определяется су
перкласс с именем General и два подкласса с именами Specific1
и Specific2. Этот пример иллюстрирует понятие категорий исключе
ний, где General – это имя категории, а два подкласса – это определен
ные типы исключений внутри категории. Обработчики, которые пере
хватывают исключение General, также будут перехватывать и все его
подклассы, в том числе Specific1 и Specific2:
class General: pass
class Specific1(General): pass
class Specific2(General): pass
def raiser0():
X = General() # Возбуждает экземпляр суперкласса исключения
raise X
def raiser1():
X = Specific1() # Возбуждает экземпляр подкласса исключения
raise X
Исключения на основе классов 737
def raiser2():
X = Specific2() # Возбуждает экземпляр другого подкласса исключения
raise X
for func in (raiser0, raiser1, raiser2):
try:
func()
except General: # Перехватывает исключения General и любые его подклассы
import sys
print 'caught:', sys.exc_info()[0]
C:\python> python classexc.py
caught: __main__.General
caught: __main__.Specific1
caught: __main__.Specific2
Мы еще вернемся к используемой здесь функции sys.exc_info в сле
дующей главе – с ее помощью можно получить информацию о самом
последнем исключении. А пока коротко замечу, что первый элемент
результата, возвращаемого функцией, – это имя класса возбужденно
го исключения, а второй – фактический экземпляр класса исключе
ния. Кроме этого метода нет никакого другого способа определить точ
но, что произошло, в пустом предложении except, которое перехваты
вает все исключения.
Обратите внимание, что здесь для использования в инструкциях raise
создаются экземпляры классов – как будет показано ниже в этом раз
деле, когда будет приводиться формализованное описание инструк
ции raise, при возбуждении исключений на основе классов всегда ис
пользуются экземпляры. В этом фрагменте также присутствуют функ
ции, которые возбуждают исключения всех трех классов, а кроме того
на верхнем уровне имеется инструкция try, в которой производится
вызов функций и осуществляется перехват исключения General (та же
самая инструкция try перехватывает и два более специфичных исклю
чения, потому что они являются подклассами класса General).
Еще одно замечание: текущая документация по языку Python указы
вает, что предпочтительнее (но не обязательно) создавать свои собст
венные классы исключений, наследуя встроенный класс исключения
с именем Exception. Для этого нам придется переписать первую строку
файла classexc.py, как показано ниже:
class General(Exception): pass
class Specific1(General): pass
class Specific2(General): pass
Хотя это не является обязательным требованием, и в настоящее время
отдельные классы прекрасно справляются с ролью исключений, тем
не менее, этот предпочтительный способ со временем станет обязатель
ным. Если вы хотите, чтобы ваш программный код был готов к буду
щим изменениям в языке, создавайте свои корневые суперклассы, на
следуя класс Exception, как показано здесь. Кроме всего прочего, при
738 Глава 28. Объекты исключений
таком подходе ваши классы приобретают по наследству некоторые по
лезные интерфейсы. Например, класс Exception имеет конструктор
__init__, который автоматически присоединяет к экземплярам свои
аргументы.
В чем преимущества классов исключений?
Поскольку в примере предыдущего раздела имеется всего три возмож
ных исключения, он действительно не может продемонстрировать все
преимущества применения классов исключений. На самом деле мы
могли бы достичь того же эффекта, указав в предложении except спи
сок имен строковых исключений в круглых скобках. Как это можно
сделать, показано в файле stringexc.py:
General = 'general'
Specific1 = 'specific1'
Specific2 = 'specific2'
def raiser0(): raise General
def raiser1(): raise Specific1
def raiser2(): raise Specific2
for func in (raiser0, raiser1, raiser2):
try:
func()
except (General, Specific1, Specific2): # Перехватывает любые из этих
import sys
print 'caught:', sys.exc_info()[0]
C:\python> python stringexc.py
caught: general
caught: specific1
caught: specific2
Однако в случае больших или глубоких иерархий исключений может
оказаться гораздо проще перехватывать категории, используя классы,
чем перечислять в предложении except все исключения, входящие в ка
тегорию. Кроме того, иерархии категорий можно расширять, добавляя
новые подклассы, не ломая при этом существующий программный код.
Предположим, что вы занимаетесь разработкой библиотеки, реали
зующей функции обработки числовой информации, которая использу
ется широким кругом людей. Во время работы над библиотекой вы об
наруживаете две ситуации, которые могут приводить к таким ошиб
кам, как деление на ноль и переполнение. Вы описываете эти ошибки
как исключения, которые могут возбуждаться этой библиотекой, и оп
ределяете их как простые строки:
# mathlib.py
divzero = 'Division by zero error in library'
oflow = 'Numeric overflow error in library'
...
Исключения на основе классов 739
def func():
...
raise divzero
Теперь те, кто будет использовать вашу библиотеку, будут стремиться
обертывать вызовы ваших функций или классов инструкцией try, что
бы перехватывать два ваших исключения (если они не будут перехва
тывать их, эти исключения будут приводить к аварийному заверше
нию программ):
# client.py
import mathlib
...
try:
mathlib.func(...)
except (mathlib.divzero, mathlib.oflow):
...вывод сообщения и восстановление после ошибки...
Все работает просто замечательно и многие начинают использовать ва
шу библиотеку. Однако шесть месяцев спустя вы обнаруживаете еще
одну ситуацию, которая может приводить к другой ошибке – потере
значимых разрядов, после чего добавляете новое строковое исключе
ние:
# mathlib.py
divzero = 'Division by zero error in library'
oflow = 'Numeric overflow error in library'
uflow = 'Numeric underflow error in library'
К сожалению, выпуском новой версии своей библиотеки вы создаете
проблему для тех, кто ею пользуется. Если они явно указывали имена
ваших исключений, теперь им придется вернуться к своим програм
мам и внести соответствующие изменения везде, где производятся об
ращения к вашей библиотеке, чтобы включить вновь добавленное имя
исключения:
# client.py
import mathlib
...
try:
mathlib.func(...)
except (mathlib.divzero, mathlib.oflow, mathlib.uflow):
...вывод сообщения и восстановление после ошибки...
Вероятно, это не конец света. Если ваша библиотека предназначена
исключительно для внутреннего использования, вы могли бы внести
все необходимые изменения самостоятельно. Вы могли бы также на
писать сценарий, который попытается ликвидировать проблему авто
матически (едва ли такой сценарий будет насчитывать более дюжины
строк, и на его создание уйдет совсем немного времени). Однако, если
многим людям придется изменять свой программный код всякий раз,
740 Глава 28. Объекты исключений
когда вы изменяете свой набор исключений, такая политика обновле
ния определенно не будет расцениваться как самая вежливая.
Ваши пользователи могут попытаться избежать этой ловушки, опре
деляя пустые предложения except, которые перехватывают все исклю
чения:
# client.py
try:
mathlib.func(...)
except: # Перехватывать все исключения
...вывод сообщения и восстановление после ошибки...
Но при таком решении могут перехватываться посторонние исключе
ния, даже такие, которые вызваны опечатками в именах переменных,
ошибками работы с памятью, и исключения, генерируемые програм
мой при завершении, а для вас было бы нежелательно, чтобы перехва
ченные исключения ошибочно классифицировались как ошибки в биб
лиотеке. Как правило, при обработке исключений чем больше опреде
ленности, тем лучше (к этой идее мы еще вернемся в разделе с описа
нием типичных проблем, в следующей главе).1
Так как же быть? Исключения на основе классов полностью ликвиди
руют эту проблему. Вместо того чтобы определять библиотечные ис
ключения как простой набор строк, их можно оформить в виде дерева
классов с одним общим суперклассом, охватывающим целую катего
рию исключений:
# mathlib.py
class NumErr(Exception): pass
class Divzero(NumErr): pass
class Oflow(NumErr): pass
...
def func():
...
raise DivZero()
1 Как было предложено одним моим сообразительным студентом, в модуле
библиотеки можно было бы определить кортеж, содержащий все исключе
ния, которые могут быть возбуждены библиотекой. Тогда клиент мог бы
импортировать этот кортеж и использовать его имя в предложении except,
чтобы перехватывать все библиотечные исключения (вспомните, что при
использовании кортежа в предложении except будут перехватываться все
перечисленные в нем исключения). Когда позднее в библиотеку добавляет
ся новое исключение, можно просто расширять экспортируемый кортеж.
Такой прием будет работать, но тогда вам придется постоянно обновлять
кортеж с именами исключений внутри модуля библиотеки. Кроме того, ис
ключения, основанные на классах, несут в себе гораздо больше преиму
ществ по сравнению со строковыми исключениями, чем простое деление на
категории, – они поддерживают возможность присоединять информацию
о состоянии, обладают методами и используют механизм наследования.
Исключения на основе классов 741
При таком подходе пользователям вашей библиотеки достаточно бу
дет указать общий суперкласс (то есть категорию), чтобы перехваты
вать все исключения, возбуждаемые библиотекой, причем, как суще
ствующие, так и те, что появятся в будущем:
# client.py
import mathlib
...
try:
mathlib.func(...)
except mathlib.NumErr:
...вывод сообщения и восстановление после ошибки...
Когда вы опять вернетесь к работе над библиотекой, новые исключения
можно будет добавлять как новые подклассы от общего суперкласса:
# mathlib.py
...
class Uflow(NumErr): pass
В результате программный код пользователей, перехватывающий ис
ключения вашей библиотеки, останется работоспособным без каких+
либо изменений. Вы свободно сможете добавлять, удалять и изменять
исключения произвольным образом – пока клиенты используют имя
суперкласса, они могут не беспокоиться об изменениях в вашем наборе
исключений. Другими словами, исключения на основе классов лучше
отвечают требованиям сопровождения, чем строки. Кроме того, ис
ключения на основе классов могут поддерживать хранение информа
ции о состоянии и наследование, чего не скажешь о строках – эти кон
цепции мы будем исследовать на примере ниже в этой главе.
Классы встроенных исключений
Примеры в предыдущем разделе в действительности возникли не на
пустом месте. Исключения, определяемые программой, могут быть
представлены как в виде строк, так и в виде классов, однако все встро
енные исключения, которые могут возбуждаться самим интерпретато
ром Python, представляют собой объекты классов, а не строки. Кроме
того, они организованы в неглубокую иерархию с общими суперклас
сами категорий и подклассами определенных типов исключений,
практически так же, как в примере выше.
Все знакомые исключения, с которыми нам уже приходилось встре
чаться (например, SyntaxError), в действительности являются обычными
классами, доступными в виде встроенных имен (в модуле __builtin__)
и в виде атрибутов модуля exceptions, входящего в состав стандартной
библиотеки. Кроме того, в языке Python встроенные исключения орга
низованы в иерархию с целью поддержки различных режимов пере
хвата исключений. Например:
742 Глава 28. Объекты исключений
Exception
Корневой суперкласс всех исключений.
StandardError
Суперкласс всех встроенных исключений.
ArithmeticError
Суперкласс всех арифметических ошибок.
OverflowError
Подкласс, идентифицирующий конкретную арифметическую
ошибку.
И так далее. Подробнее познакомиться с этой структурой можно либо
в справочном руководстве по библиотеке Python, либо в тексте справки
в модуле exceptions (описание функции help приводится в главах 4 и 14):
>>> import exceptions
>>> help(exceptions)
...объемный текст справки опущен...
Дерево встроенных классов позволяет определять, насколько конкрет
ными или универсальными будут ваши обработчики исключений. На
пример, встроенное исключение ArithmeticError – это суперкласс для
таких более конкретных исключений, как OverflowError и ZeroDivision
Error. Указав имя ArithmeticError в инструкции try, вы будете перехва
тывать все арифметические ошибки, а указав имя OverflowError, вы бу
дете перехватывать только ошибки определенного типа и никакие
другие.
Точно так же можно использовать StandardError, имя суперкласса всех
встроенных исключений, для организации выбора между встроенны
ми исключениями и исключениями, определяемыми программой, на
пример:
try:
try:
action()
except StandardError:
...обработка встроенных исключений...
except:
... обработка исключений, определяемых программой...
else:
...обработка случая отсутствия исключения...
Используя имя корневого класса Exception, можно очень близко ими
тировать поведение пустого предложения except (которое перехваты
вает любые исключения). Однако это будет не полная имитация, так
как в этом случае не будут перехватываться строковые исключения
и исключения на основе отдельных классов, которые пока не обяза
тельно должны быть подклассами корневого класса Exception.
Исключения на основе классов 743
Неважно, будете вы использовать категории в дереве встроенных
классов или нет, этот подход служит отличным примером; при исполь
зовании подобных методов к созданию своих собственных исключений
вы сможете реализовать гибкие наборы исключений, которые легко
можно изменять.
Во всех других отношениях встроенные исключения практически не
отличимы от первоначальной модели строковых исключений. Обычно
вам даже не придется беспокоиться по поводу имеющихся различий,
если, конечно, вы не исходите из предположения, что встроенные ис
ключения являются строками, и не пытаетесь использовать их в опе
рации конкатенации без необходимого преобразования (например, вы
ражение KeyError + "spam" будет приводить к ошибке, а выражение
str(KeyError) + "spam" вполне допустимо).
Определение текста исключения
Когда в начале главы мы знакомились с исключениями на основе
строк, мы видели, что текст строки выводится в стандартный поток
вывода сообщений об ошибках, когда исключение не обрабатывается
программой (то есть, когда исключение достигает обработчика по
умолчанию). Но какое сообщение будет выводиться в случае исключе
нийклассов? По умолчанию выводится имя класса и не очень удобо
читаемая информация об объекте экземпляра:
>>> class MyBad: pass
>>> raise MyBad()
Traceback (most recent call last):
File "<pyshell#13>", line 1, in <module>
raise MyBad()
MyBad: <__main__.MyBad instance at 0x00BB5468>
Чтобы улучшить сообщение, необходимо переопределить в классе ис
ключения метод __repr__ или __str__, чтобы возвращалась желаемая
строка, которая будет отображаться, когда ваше исключение будет
достигать обработчика по умолчанию:
>>> class MyBad:
... def __repr__(self):
... return "Sorry

my mistake!"
...
>>> raise MyBad()
Traceback (most recent call last):
File "<pyshell#28>", line 1, in <module>
raise MyBad()
MyBad: Sorrymy mistake!
Как мы уже знаем, метод перегрузки __repr__, используемый здесь, вы
зывается при выводе и при преобразовании экземпляра класса в стро
ку; метод __str__ реализует дружественное строковое представление,
744 Глава 28. Объекты исключений
которому инструкции print отдают предпочтение. (Подробнее о мето
дах преобразования в строку рассказывается в разделе «Перегрузка
операторов» в главе 24.)
Обратите внимание, что если наследовать встроенные классы исклю
чений, как рекомендовалось выше, текст сообщения об ошибке немно
го изменится – аргументы конструктора автоматически сохраняются
в экземпляре и отображаются в тексте сообщения:
>>> class MyBad(Exception): pass
>>> raise MyBad()
Traceback (most recent call last):
File "<pyshell#18>", line 1, in <module>
raise MyBad()
MyBad
>>> class MyBad(Exception): pass
>>> raise MyBad('the', 'bright', 'side', 'of', 'life')
Traceback (most recent call last):
File "<pyshell#22>", line 1, in <module>
raise MyBad('the', 'bright', 'side', 'of', 'life')
MyBad: ('the', 'bright', 'side', 'of', 'life')
Если ваши конечные пользователи могут видеть сообщения об ошиб
ках, порождаемые исключениями, у вас наверняка появится желание
определить собственные методы форматирования сообщений на основе
перегрузки операторов, как показано здесь. Возможность автоматиче
ского присоединения информации о состоянии к экземплярам – очень
удобная особенность, о чем подробнее рассказывается в следующем
разделе.
Передача данных и поведения в экземплярах
Помимо поддержки гибких иерархий классы исключений также яв
ляются удобным местом для хранения дополнительной информации
в виде атрибутов экземпляров. Когда возбуждается исключение на ос
нове класса, вместе с исключением интерпретатор автоматически пе
редает объект экземпляра класса в виде элемента дополнительных
данных. Так же, как и в случае строковых исключений, вы можете по
лучить доступ к экземпляру, указав дополнительную переменную в ин
струкции try. Это обеспечивает естественный способ передачи допол
нительных данных и функциональных возможностей обработчику ис
ключения.
Пример: передача дополнительных данных
в исключениях на основе классов и строк
Давайте рассмотрим возможность передачи дополнительных данных
на примере и попутно сравним подходы, основанные на использовании
классов и строк. Программа, выполняющая анализ файлов, может со
Исключения на основе классов 745
общать об ошибке форматирования, возбуждая экземпляр исключе
ния, который заполняется дополнительной информацией об ошибке:
>>> class FormatError:
... def __init__(self, line, file):
... self.line = line
... self.file = file
...
>>> def parser():
... # когда обнаруживается ошибка
... raise FormatError(42, file='spam.txt')
...
>>> try:
... parser()
... except FormatError, X:
... print 'Error at', X.file, X.line
...
Error at spam.txt 42
В этом примере переменной X в предложении except присваивается
ссылка на экземпляр, который был сгенерирован во время возбужде
ния исключения.1 Однако с практической точки зрения этот способ не
имеет заметных преимуществ перед возможностью передачи составных
объектов (например, кортежей, списков или словарей) в виде дополни
тельных данных строковых исключений, и сам по себе не выглядит дос
таточным побудительным мотивом к использованию исключений на
основе классов. Ниже приводится эквивалентный фрагмент, в котором
используются строковые исключения:
>>> formatError = 'formatError'
>>> def parser():
... # когда обнаруживается ошибка
... raise formatError, {'line':42, 'file':'spam.txt'}
...
>>> try:
... parser()
... except formatError, X:
... print 'Error at', X['file'], X['line']
...
Error at spam.txt 42
На этот раз переменной X в предложении except присваивается словарь
с дополнительной информацией, который передается инструкции
1 Как будет показано в следующей главе, доступ к объекту экземпляра клас
са исключения обеспечивается также вторым элементом кортежа, возвра
щаемого функцией sys.exc_info – инструментом, который возвращает ин
формацию о самом последнем исключении. Если в предложении except не
указано имя переменной, можно использовать эту функцию, когда возни
кает необходимость обратиться к исключению за получением присоединен
ных к нему данных или для вызова его методов.
746 Глава 28. Объекты исключений
raise. Результат получается тот же самый, но при этом нет необходи
мости писать определение класса. Однако подход, основанный на ис
пользовании классов, может оказаться более удобным, когда исключе
ние должно обладать еще и поведением. Класс исключения определяет
еще и методы, которые можно вызывать из обработчика:
class FormatError:
def __init__(self, line, file):
self.line = line
self.file = file
def logerror(self):
log = open('formaterror.txt', 'a')
print >> log, 'Error at', self.file, self.line
def parser():
raise FormatError(40, 'spam.txt')
try:
parser()
except FormatError, exc:
exc.logerror()
При использовании классов методы (такие как loggeror) могут наследо
ваться подклассами, а атрибуты экземпляра (такие как line и file)
предоставляют возможность сохранения информации о состоянии,
обеспечивая дополнительный контекст для последующих вызовов ме
тодов. Мы могли бы имитировать этот эффект, передавая простые
функции вместе со строковыми исключениями, но это приведет к чрез
мерному усложнению программного кода:
formatError = "formatError"
def logerror(line, file):
log = open('formaterror.txt', 'a')
print >> log, 'Error at', file, line
def parser():
raise formatError, (41, 'spam.txt', logerror)
try:
parser()
except formatError, data:
data[2](data[0], data[1]) # Или просто: logerror()
Естественно, такие функции не могут быть унаследованы как методы
класса и не способны хранить информацию о состоянии в атрибутах
экземпляра класса (lambdaвыражения и глобальные переменные – это
самое лучшее, что можно использовать с функциями). Конечно, мож
но было бы передать экземпляр класса в виде дополнительных данных
строковых исключений, чтобы добиться того же самого эффекта, но
если мы зашли так далеко, чтобы имитировать исключения на основе
классов, лучше уж принять их – нам и так пришлось писать определе
ние класса.
Общие формы инструкции raise 747
Как уже упоминалось ранее, исключения на основе классов станут
единственно возможными в будущей версии Python. Но даже если бы
это было не так, существуют веские основания использовать их. Вооб
ще говоря, строковые исключения представляют собой простой инст
румент, предназначенный для решения простых задач. Исключения на
основе классов полезны для определения категорий, и они выглядят
предпочтительнее в более сложных приложениях, когда можно из
влечь выгоду из возможности сохранять информацию о состоянии и на
следовать атрибуты. Не в каждом приложении требуется мощь ООП,
но преимущества исключений на основе классов становятся более оче
видными с ростом и расширением программ.
Общие формы инструкции raise
С учетом исключений на основе классов инструкция raise может при
нимать следующие пять форм. Первые две возбуждают строковые ис
ключения, следующие две – исключения на основе классов, и послед
няя повторно возбуждает текущее исключение (что очень удобно, ко
гда необходимо обеспечить дальнейшее распространение произволь
ных исключений):
raise string # Соответствует предложению except с тем же объектом
raise string, data # Передает дополнительные данные (по умолчанию = None)
raise instance # То же, что и: raise instance.__class__, instance
raise class, instance # Соответствует предложению except с тем же
# именем класса или его суперкласса
raise # Повторно возбуждает текущее исключение
В наши дни наиболее часто используется третья форма. В случае исклю
чений на основе классов Python всегда требует указывать экземпляр
класса. Возбуждая экземпляр, интерпретатор в действительности воз
буждает исключение, соответствующее классу экземпляра, а экземпляр
передается вместе с исключением в виде элемента дополнительных дан
ных (как мы уже видели, это отличное место для хранения информа
ции, которая может использоваться обработчиком). Для обратной со
вместимости с версиями Python, в которых исключения реализованы на
основе строк, можно использовать следующие формы инструкции raise:
raise class # То же, что и: raise class()
raise class, arg # То же, что и: raise class(arg)
raise class, (arg, arg, ...) # То же, что и: raise class(arg, arg, ...)
Все они соответствуют форме raise class(arg, ...) и, следовательно,
соответствуют форме raise instance выше. В частности, если вместо эк
земпляра в инструкции raise указывается класс, и дополнительный
элемент данных не является экземпляром указанного класса, интер
претатор автоматически вызовет класс с дополнительными элемента
ми данных в качестве аргументов конструктора, чтобы создать и воз
будить экземпляр класса исключения.
748 Глава 28. Объекты исключений
Например, можно возбудить экземпляр встроенного исключения Key
Error, просто записав инструкцию raise KeyError: даже при том, что
KeyError в настоящее время является классом, – интерпретатор вызо
вет KeyError, чтобы создать необходимый экземпляр. Фактически ис
ключение KeyError и любые другие исключения на основе классов мож
но возбудить различными способами:
raise KeyError() # Обычная форма: возбуждается экземпляр
raise KeyError, KeyError() # Класс, экземпляр: используется экземпляр
raise KeyError # Класс: будет создан экземпляр
raise KeyError, "bad spam" # Класс, аргумент: будет создан экземпляр
Для всех этих пяти форм инструкция try, имеющая следующую форму:
try:
...
except KeyError, X:
...
присвоит переменной X объект экземпляра класса KeyError.
Если это объяснение показалось вам малопонятным, просто запомните,
что исключения могут идентифицироваться строкой или экземпляром
класса. В случае строк вместе с исключением можно передавать допол
нительные данные. В случае классов, если объект экземпляра не пере
дается инструкции raise, интерпретатор создаст его автоматически.
В версии Python 2.5 можно вообще отказаться от использования стро
ковых форм инструкции raise, потому что при возбуждении строко
вых исключений генерируются предупреждения, а, кроме того, они
будут недоступны в следующей версии Python. Но, к сожалению, об
ратная совместимость все еще принимается во внимание в книгах, ко
торые обучают языку программирования, используемому более чем
одним миллионом человек!
В заключение
В этой главе мы занялись созданием собственных исключений. Здесь
мы узнали, что исключения могут быть реализованы как строковые
объекты или как экземпляры классов. Однако в настоящее время
предпочтение следует отдавать экземплярам классов, а в будущей вер
сии Python классы станут единственно возможным способом реализа
ции исключений. Классы исключений предпочтительнее потому, что
они поддерживают концепцию создания иерархий исключений (что
положительно сказывается на удобстве сопровождения), позволяют
присоединять к исключениям дополнительные данные и поведение
в виде атрибутов и методов экземпляров, а также обеспечивают насле
дование атрибутов и методов от суперклассов.
Мы видели, что перехватывая суперкласс в инструкции try, мы пере
хватываем этот класс, а также все его подклассы, расположенные ни
Закрепление пройденного 749
же в дереве наследования; суперклассы начинают играть роль назва
ний категорий, а подклассы становятся определенными типами ис
ключений в этих категориях. Мы также видели, что инструкция raise
поддерживает несколько форматов, хотя большинство современных
программ просто создают и возбуждают экземпляры классов.
В этой главе мы исследовали обе альтернативы – исключения на основе
строк и на основе классов. Тем не менее, объекты исключений проще
запомнить, если ограничиться только рекомендуемой моделью, осно
ванной на использовании классов, – описывайте свои исключения как
классы, наследуйте класс Exception как вершину своих деревьев исклю
чений, – и вы сможете забыть старую альтернативу на основе строк.
Следующая глава завершает эту часть книги и всю книгу в целом ис
следованием некоторых типичных случаев использования исключе
ний и рассмотрением инструментов, наиболее часто используемых
программистами на языке Python. Однако, прежде чем двинуться
дальше, ответьте на контрольные вопросы к этой главе.
Закрепление пройденного
Контрольные вопросы
1. Как определяется соответствие строковых исключений и обработ
чиков?
2. Как определяется соответствие исключений на основе классов и об
работчиков?
3. Как можно присоединить контекстную информацию к исключени
ям на основе классов и как ее можно использовать в обработчиках?
4. Как можно определить текст сообщения об ошибке в исключениях
на основе классов?
5. Почему в настоящее время нежелательно использовать исключе
ния на основе строк?
Ответы
1. Соответствие строковых исключений выявляется по идентичности
объекту (технически, с помощью оператора is), а не по значению
объекта (оператор ==). Поэтому будет недостаточно использовать то
же самое значение – необходимо иметь ссылку на тот же самый объ
ект (обычно переменную). Короткие строки в языке Python кэши
руются с целью многократного использования, поэтому использо
вание одного и того же значения может иногда работать, но вы не
должны полагаться на это (подробнее об этой проблеме будет рас
сказываться в конце следующей главы).
2. Соответствие исключений на основе классов определяется отноше
нием к суперклассу: при использовании имени суперкласса в обра
750 Глава 28. Объекты исключений
ботчике исключения будут перехватываться экземпляры этого
класса, а также экземпляры всех его подклассов, расположенных
ниже в дереве наследования. Благодаря этому суперклассы можно
интерпретировать как категории исключений, а подклассы – как
более специфичные типы исключений в этих категориях.
3. Присоединение дополнительной информации к исключениям на ос
нове классов производится путем заполнения атрибутов объекта эк
земпляра исключения, часто внутри конструкторов классов. В обра
ботчиках исключений указывается переменная, которой присваи
вается экземпляр исключения, после этого имя переменной может
использоваться для доступа к присоединенной информации и для
вызова любых унаследованных методов класса.
4. Текст сообщения об ошибках в исключениях на основе классов мож
но определить с помощью метода перегрузки __repr__ или __str__.
Если вы наследуете свои классы от встроенного класса Exception,
в тексте сообщения автоматически будут отображаться все аргумен
ты, переданные конструктору.
5. Потому что, как заявил Гвидо (Guido), в будущей версии Python
планируется вообще убрать их. На самом деле, для этого есть весьма
серьезные основания: строковые исключения не поддерживают де
ление на категории, не позволяют присоединять информацию о со
стоянии или наследовать поведение, как исключения на основе
классов. С практической точки зрения строковые исключения про
ще в использовании на первых порах, пока программы достаточно
маленькие, но их становится сложно использовать, как только про
граммы становятся больше.
29
Использование исключений
Данная глава завершает эту часть книги рассмотрением некоторых
тем, связанных с проектированием исключений и примеров их исполь
зования. Далее следует раздел с описанием типичных проблем и уп
ражнения. Поскольку эта глава к тому же является последней главой
книги, здесь приводится краткий обзор средств разработки, которые
помогут вам пройти путь от начинающего программиста до разработ
чика приложений на языке Python.
Вложенные обработчики исключений
До сих пор в наших примерах для перехвата исключений использова
лась единственная инструкция try, но что произойдет, если одну инст
рукцию try вложить внутрь другой? И, раз уж на то пошло, что про
изойдет, если в инструкции try вызывается функция, которая выпол
няет другую инструкцию try? С технической точки зрения инструк
ции могут вкладываться друг в друга как синтаксически, так и по
пути следования потока управления через программный код.
Оба эти варианта проще будет понять, если вы узнаете, что интерпре
татор складывает инструкции try стопкой во время выполнения. Ко
гда возникает исключение, интерпретатор возвращается к самой по
следней инструкции try, содержащей соответствующее предложение
except. Поскольку каждая инструкция try оставляет метку, интерпре
татор может возвращаться к более ранним инструкциям try, двигаясь
по стопке меток. Такое вложение активных обработчиков и есть то,
что подразумевается, когда мы говорим о распространении исключе
ний вверх, к обработчикам «более высокого уровня». Эти обработчики
являются обычными инструкциями try, в которые поток управления
ходом выполнения программы вошел раньше.
752 Глава 29. Использование исключений
Рисунок 29.1 иллюстрирует, что происходит, когда возникает вложе
ние инструкций try/except во время выполнения. Объем программного
кода, который выполняется в инструкции try, может оказаться весьма
существенным (например, он может содержать вызовы функций) и не
редко вызывает другой программный код, который готов перехватить
те же самые исключения. Когда исключение наконец возбуждается,
интерпретатор переходит к самой последней инструкции try, в кото
рой указано имя исключения, запускает блок except и продолжает вы
полнение программы ниже этой инструкции try.
Как только такое исключение будет перехвачено, его жизнь заканчива
ется – управление не передается всем соответствующим инструкциям
try, содержащим имя исключения, – только первая из них получает
возможность обработать исключение. Например, на рис. 29.1 инструк
ция raise в функции func2 возвращает управление обработчику в функ
ции func1, после чего программа продолжает выполнение внутри func1.
Напротив, когда исключение возникает во вложенных инструкциях
try/finally, выполняется каждый блок finally по очереди – интерпре
татор продолжает передавать исключение вверх по цепочке вложен
ных инструкций try, пока не будет достигнут обработчик по умолча
нию верхнего уровня (который выводит стандартные сообщения об
ошибках). Как показано на рис. 29.2, предложения finally не останав
ливают распространение исключений – они лишь определяют про
граммный код, который должен выполняться на выходе из инструк
ции try в процессе движения исключения. Если к моменту возникно
вения исключения имелось несколько активных инструкций try/fi
nally, они все будут выполнены, если гдето на пути исключения не
встретится инструкция try/except, которая перехватит его.
Другими словами, куда будет выполнен переход при возникновении
исключения, полностью зависит от того, где оно возникло, – это опре
деляется ходом выполнения программы, а не только синтаксисом.
try:
func1()
except E:
...
def func1():
try:
func2()
except E:
...
def func2():
...
raise E
...
Рис. 29.1. Вложенные инструкции try/except: когда возбуждается
исключение (программой или интерпретатором), происходит возврат
к самой последней инструкции try с соответствующим предложением except
и программа продолжает выполнение после этой инструкции try.
Предложения except перехватывают и останавливают дальнейшее
распространение исключений – это место, где выполняются
восстановительные операции после исключения
Вложенные обработчики исключений 753
Распространение исключения, по сути, происходит в порядке, обрат
ном вхождениям в инструкции try. Это движение останавливается,
когда управление переходит к соответствующему блоку except, и про
должается когда управление проходит через предложения finally.
Пример: вложение в потоке управления
Обратимся к примеру, чтобы рассмотреть этот тип вложения более кон
кретно. В следующем файле модуля nestexc.py определяются две функ
ции. Функция action2 возбуждает исключение (нельзя складывать чис
ла и последовательности), функция action1 обертывает вызов функции
action2 в инструкцию try, которая перехватывает исключение:
def action2():
print 1 + [ ] # Возбуждает исключение TypeError
def action1():
try:
action2()
except TypeError: # Самая последняя соответствующая инструкция try
print 'inner try'
try:
action1()
except TypeError: # Этот обработчик будет выполнен, только если
print 'outer try' # action1 повторно возбудит исключение
% python nestexc.py
inner try
Обратите внимание, что на верхнем уровне модуля, внизу файла, вы
зов функции action1 также обернут инструкцией try. Когда функция
action2 возбуждает исключение TypeError, существует две активные ин
try:
func1()
finally:
...
def func1():
try:
func2()
finally:
...
def func2():
...
raise E
...
Рис. 29.2. Вложенные инструкции try/finally: когда возбуждается
исключение, управление возвращается самой последней инструкции try
и выполняется ее блок finally, после этого исключение продолжит свое
распространение по блокам finally во всех активных инструкциях try,
пока в конечном счете не будет достигнут обработчик по умолчанию,
где производится вывод сообщения об ошибке. Предложения finally
перехватывают (но не останавливают) исключения – они определяют
действия, которые должны выполняться «на выходе»
754 Глава 29. Использование исключений
струкции try – одна в функции action1 и одна в программном коде на
верхнем уровне модуля. Интерпретатор выбирает и запускает самую
последнюю инструкцию try с соответствующим предложением except,
которой в данном случае является инструкция try в функции action1.
Как уже говорилось, место, куда будет выполнен переход в случае ис
ключения, зависит от того, в каком месте программы находится поток
управления. Поэтому, чтобы знать, куда будет выполнен переход, не
обходимо знать место, где находится управление. В данном случае вы
бор места, где будет обработано исключение, больше зависит от того,
где находится поток управления, чем от синтаксиса. Однако мы мо
жем организовать синтаксическое вложение обработчиков – эквива
лентный случай рассматривается в следующем разделе.
Пример: синтаксическое вложение
В главе 27, когда рассматривалась новая объединенная инструкция
try/except/finally, я уже говорил, что вполне возможно вкладывать ин
струкции try синтаксически, задавая вложение в программном коде:
try:
try:
action2()
except TypeError: # Самая последняя соответствующая инструкция try
print 'inner try'
except TypeError: # Этот обработчик будет выполнен, только если
print 'outer try' # вложенный обработчик повторно возбудит исключение
Этот программный код задает ту же структуру вложенных обработчи
ков, что и предыдущий пример (и ведущую себя точно так же). Факти
чески инструкции, вложенные синтаксически, работают точно так
же, как показано на рис. 29.1 и 29.2; единственное отличие заключа
ется в том, что вложенные обработчики физически объединены в бло
ке инструкции try, а не находятся в разных функциях. Например, ис
ключение пройдет через все блоки finally независимо от того, вложе
ны они синтаксически или в ходе выполнения программы происходит
вложение физически отдельных фрагментов программного кода:
>>> try:
... try:
... raise IndexError
... finally:
... print 'spam'
... finally:
... print 'SPAM'
...
spam
SPAM
Traceback (most recent call last):
File "<stdin>", line 3, in ?
IndexError
Вложенные обработчики исключений 755
Графическая иллюстрация порядка выполнения этого фрагмента по
казана на рис. 29.2 – результат получается тот же самый, но сама ло
гика выполнения в данном случае образована вложенными инструк
циями. Более интересный пример синтаксического вложения в дейст
вии приводится в следующем файле except+finally.py:
def raise1(): raise IndexError
def noraise(): return
def raise2(): raise SyntaxError
for func in (raise1, noraise, raise2):
print '\n', func
try:
try:
func()
except IndexError:
print 'caught IndexError'
finally:
print 'finally run'
Этот фрагмент перехватывает исключение, если оно будет возбужде
но, и выполняет завершающие действия в блоке finally независимо от
того, возникло исключение или нет. Чтобы понять это, может потребо
ваться некоторое время на изучение фрагмента, но результат очень на
поминает объединение предложений except и finally в одной современ
ной инструкции try (не забывайте, что такая инструкция была недо
пустимой до появления версии Python 2.5):
% python except
finally.py
<function raise1 at 0x00BA2770>
caught IndexError
finally run
<function noraise at 0x00BB47F0>
finally run
<function raise2 at 0x00BB4830>
finally run
Traceback (most recent call last):
File "C:/Python25/exceptfinally.py", line 9, in <module>
func()
File "C:/Python25/exceptfinally.py", line 3, in raise2
def raise2(): raise SyntaxError
SyntaxError: None
Как мы видели в главе 27, начиная с версии Python 2.5, появилась воз
можность использовать предложения except и finally в одной инструк
ции try. Это делает описанный здесь прием синтаксического вложения
ненужным, однако он попрежнему работает, его можно встретить
в программном коде, написанном до выхода версии Python 2.5, и он
может использоваться для реализации альтернативных конструкций
обработки исключений.
756 Глава 29. Использование исключений
Идиомы исключений
Мы рассмотрели внутренний механизм исключений. Теперь рассмот
рим некоторые другие типичные способы их использования.
Исключения не всегда являются ошибками
В языке Python все ошибки являются исключениями, но не все исклю
чения являются ошибками. Например, в главе 9 мы видели, что по дос
тижении конца файла метод чтения объекта файла возвращает пустую
строку. Напротив, встроенная функция raw_input (с которой мы впер
вые встретились в главе 3 и которую использовали в интерактивном
цикле в главе 10) читает по одной строке текста при каждом вызове из
стандартного потока ввода sys.stdin и возбуждает исключение EOFError
по достижении конца файла. В отличие от методов объекта файла дан
ная функция не возвращает пустую строку; пустая строка, полученная
от функции raw_input, означает всего лишь пустую строку. Несмотря на
свое название, исключение EOFError в данном контексте – это всего
лишь сигнал, а не ошибка. По этой причине, чтобы избежать прежде
временного завершения работы сценария, функцию raw_input обертыва
ют инструкцией try, которую вкладывают в цикл, как показано ниже:
while 1:
try:
line = raw_input() # Прочитать строку из потока stdin
except EOFError:
break # Выход по достижении конца файла
else:
...обработка следующей строки...
Существуют и другие встроенные исключения, которые являются сиг
налами, а не ошибками. В языке Python имеется также ряд встроен
ных исключений, которые являются скорее предупреждениями, чем
ошибками. Некоторые из них применяются, чтобы сообщить о неже
лательности использования некоторых особенностей языка (которые
вскоре будут удалены). За дополнительной информацией по предупре
ждениям обращайтесь к описанию встроенных исключений в руково
дстве по стандартной библиотеке и к модулю warnings.
Передача сигналов из функций по условию
Исключения, определяемые программой, также могут служить сигна
лами об условиях, которые не являются ошибками. Например, проце
дура поиска может предусматривать возбуждение исключения в слу
чае нахождения соответствия вместо того, чтобы возвращать флаг со
стояния, который должен интерпретироваться вызывающей програм
мой. В следующем примере инструкция try/except/else играет роль
инструкции if/else, предназначенной для проверки возвращаемого
значения:
Идиомы исключений 757
class Found(Exception): pass
def searcher():
if ...успех...:
raise Found()
else:
return
try:
searcher()
except Found: # Исключение, если элемент найден
...успех...
else: # иначе: элемент не найден
...неудача...
В более широком смысле такая организация программного кода мо
жет с успехом использоваться для любой функции, которая не может
вернуть специальный признак, свидетельствующий об успехе или не
удаче. Например, если любое возвращаемое значение является допус
тимым, невозможно выбрать какоето одно значение, которое сигна
лизировало бы о необычных состояниях. Исключения обеспечивают
способ подать сигнал, не возвращая значение:
class Failure(Exception): pass
def searcher():
if ...успех...:
return ...найденный_элемент...
else:
raise Failure()
try:
item = searcher()
except Failure:
...сообщение о неудаче...
else:
...обработка найденного элемента...
Поскольку язык Python является динамически типизированным и в сво
ей основе поддерживает полиморфизм, исключения, а не возвращение
специального признака, являются более предпочтительным способом
сообщать о таких состояниях.
Отладка с помощью внешних инструкций try
Обработчики исключений можно также использовать как замену об
работчика по умолчанию. Обернув всю программу (или вызов ее) во
внешнюю инструкцию try, можно перехватывать любые исключения,
которые только будут возникать во время работы программы, отменяя
тем самым способ завершения программы, заданный по умолчанию.
В следующем фрагменте пустое предложение except перехватывает
любые необработанные исключения, возникшие в ходе выполнения
программы. Чтобы получить доступ непосредственно к самому исклю
758 Глава 29. Использование исключений
чению, вызовите встроенную функцию sys.exc_info из модуля sys –
она возвращает кортеж, в котором первые два элемента содержат имя
исключения и дополнительные данные (если имеются). Для исключе
ний на основе классов эти два элемента представляют имя класса ис
ключения и экземпляр класса возбужденного исключения соответст
венно (вскоре мы подробнее рассмотрим функцию sys.exc_info):
try:
...запуск программы...
except: # Сюда попадут все необработанные исключения
import sys
print 'uncaught!', sys.exc_info()[0], sys.exc_info()[1]
Этот прием часто используется во время разработки, так как он позво
ляет сохранить программу активной даже после ошибки – он позволяет
производить дополнительные проверки без необходимости перезапус
кать программу. Это прием может также использоваться для тестиро
вания другого программного кода, как описано в следующем разделе.
Запуск тестов в рамках единого процесса
Некоторые из приемов, которые мы только что рассмотрели, можно
было бы объединить в тестовом приложении, которое позволяет тести
ровать другой программный код в рамках одного и того же процесса:
import sys
log = open('testlog', 'a')
from testapi import moreTests, runNextTest, testName
def testdriver():
while moreTests():
try:
runNextTest()
except:
print >> log, 'FAILED', testName(), sys.exc_info()[:2]
else:
print >> log, 'PASSED', testName()
testdriver()
Здесь функция testdriver выполняет в цикле серию тестов (модуль te
stapi – некая абстракция в этом примере). Поскольку в обычной ситуа
ции необработанное исключение приводило бы к завершению самого
тестового приложения, можно обернуть вызовы очередного теста инст
рукцией try, чтобы обеспечить продолжение процесса тестирования по
сле неудачного завершения любого из тестов. Здесь, как обычно, пустое
предложение except перехватывает любые необработанные исключения,
возникшие в ходе выполнения теста, и регистрирует в файле информа
цию об исключении, полученную с помощью функции sys.exc_info.
Такой подход типичен для систем, которые тестируют функции, моду
ли и классы, запуская их в рамках того же самого процесса, что и само
Идиомы исключений 759
тестовое приложение. Однако на практике тестирование может ока
заться процедурой гораздо более сложной, чем показано здесь. Напри
мер, чтобы протестировать внешнюю программу, может потребоваться
проверять коды состояния или вывод, создаваемый такими средствами
запуска программ, как os.system и os.popen, описания которых вы най
дете в стандартном руководстве по библиотеке (такие инструменты во
обще не возбуждают исключений в случае появления ошибок во внеш
ней программе – фактически тест выполняется параллельно с програм
мой, выполняющей тестирование).
В конце этой главы мы познакомимся с некоторыми законченными
платформами, предназначенными для проведения тестов, такими как
Doctest и PyUnit, которые обеспечивают возможность сравнения ожи
даемого вывода с фактическими результатами.
Подробнее о функции sys.exc_info
Функция sys.exc_info, результаты которой использовались в послед
них двух разделах, является предпочтительным способом доступа к по
следнему возбужденному исключению. Если в момент ее вызова ника
кое исключение не обрабатывается, функция возвращает кортеж с тре
мя объектами None. В противном случае возвращаются (тип, значение,
трассировочная_информация), где:
• Тип – это тип обрабатываемого исключения (объект класса для ис
ключений на основе классов).
• Значение – это параметр исключения (ассоциированное значение
или второй аргумент инструкции raise, который всегда является
экземпляром класса, если типом исключения является объект
класса).
• Трассировочная информация – это объект, который представляет
стек вызовов в точке, где возникло исключение (в документации
к модулю traceback описываются инструменты, которые могут ис
пользоваться вместе с этим объектом для создания сообщений об
ошибках вручную).
Для извлечения типа и значения самого последнего исключения по
прежнему могут использоваться более старые инструментальные сред
ства, такие как sys.exc_type и sys.exc_value, но они могут использо
ваться только применительно к единственному исключению, глобаль
ному для всего процесса. В то время как более предпочтительная
функция sys.exc_info запоминает информацию об исключениях в каж
дом потоке выполнения. Конечно, это имеет значение только при ис
пользовании нескольких потоков выполнения в программах на языке
Python (тема, которая далеко выходит за рамки этой книги). За допол
нительной информацией обращайтесь к справочному руководству по
библиотеке языка Python и к другим специализированным книгам.
760 Глава 29. Использование исключений
Советы по применению исключений
Вообще говоря, исключения в языке Python очень просты в обраще
нии. Настоящее искусство их использования заключается в принятии
решения, насколько универсальными должны быть предложения ex
cept и какой объем программного кода должен быть обернут инструк
циями try. Рассмотрим сначала вторую проблему.
Что должно быть обернуто
В принципе, можно было бы обернуть каждую инструкцию в сценарии
в свою собственную инструкцию try, но это будет выглядеть достаточ
но глупо (тогда инструкции try тоже следовало бы обернуть в инструк
ции try!). Это настоящая проблема проектирования, которая никак не
связана с конкретным языком программирования и становится более
очевидной на практике. Однако, ниже приводится несколько правил,
выработанных на практике:
• В инструкции try следует заворачивать операции, которые обычно
терпят неудачу. Например, операции, взаимодействующие с систе
мой (открытие файлов, взаимодействия с сокетами и т. д.), являют
ся первыми кандидатами для заключения их в инструкции try.
• При этом из первого правила есть исключение – в простых сценари
ях бывает желательно, чтобы подобные неудачи приводили к завер
шению работы программы. Это особенно верно, когда неудачи ожи
даемы. Неудачи в языке Python приводят к выводу полезных сооб
щений (только не в случае краха программы), и они часто представ
ляют собой лучший результат, на который только можно надеяться.
• Завершающие операции должны заключаться в инструкции try/
finally, чтобы гарантировать их выполнение. Эта форма инструк
ции позволяет выполнять программный код независимо от того,
возникло исключение или нет.
• Иногда более удобно завернуть вызов крупной функции в единст
венную инструкцию try, чем засорять эту функцию несколькими
инструкциями try. При таком подходе все исключения, возникшие
в функции, будут перехвачены инструкцией try, окружающей вы
зов, за счет чего можно уменьшить объем программного кода внут
ри самой функции.
Влияние на количество обработчиков исключений нередко оказывает
тип программы. Например, серверные программы должны работать
постоянно, и поэтому в них инструкции try наверняка будут необходи
мы, чтобы перехватывать исключения и выполнять восстановитель
ные операции после них. В программах тестирования, таких как мы
видели в этой главе, также необходимо выполнять обработку исключе
ний. Однако в более простых сценариях часто можно вообще игнори
ровать исключения, потому что неудача на любом этапе выполнения
требует прекращения работы сценария.
Советы по применению исключений 761
Не перехватывайте слишком много:
избегайте пустых предложений except
К вопросу о степени универсальности обработчика. Язык Python по
зволяет явно указывать, какие исключения должны перехватываться,
и иногда бывает необходимо проявлять осторожность, чтобы не пере
хватывать слишком много. Например, вы уже знаете, что пустое пред
ложение except перехватывает все исключения, которые только могут
возникнуть в блоке try.
Сделать это несложно и иногда даже желательно, но это может привес
ти к тому, что будет перехвачена ошибка, обработка которой преду
смотрена в инструкции try на более высоком уровне вложенной струк
туры. В предлагаемом примере обработчик исключения перехватыва
ет и деактивирует все исключения, которые достигнут его, независимо
от того, ожидает ли какиелибо исключения обработчик уровнем выше:
def func():
try:
... # Здесь возбуждается исключение IndexError
except:
... # Но все исключения попадают сюда!
try:
func()
except IndexError: # Исключение должно обрабатываться здесь
...
Что еще хуже, такой программный код может перехватывать исклю
чения, которые вообще не имеют никакого отношения к программе.
Даже такие ситуации, как ошибки работы с памятью, настоящие
ошибки в программном коде, остановки итераций и выход из програм
мы, возбуждают исключения. Обычно такие исключения не должны
перехватываться.
Например, сценарии обычно завершают работу, когда поток управле
ния достигает конца главного файла. Однако в языке Python имеется
специальная функция sys.exit(statuscode), с помощью которой можно
завершить работу программы. Чтобы завершить программу, эта функ
ция в действительности возбуждает исключение SystemExit, благодаря
чему имеется возможность предусмотреть возможность выполнения
завершающих операций в инструкции try/finally, а в специализиро
ванных программах – перехватить это событие.1 По этой причине
1 Похожая функция os._exit также завершает работу программы, но делает
это непосредственно – она пропускает этап выполнения завершающих дей
ствий и не может быть перехвачена с помощью инструкций try/except или
try/finally. Обычно эта функция используется в дочерних процессах, опи
сание которых выходит далеко за рамки этой книги. За дополнительной
информацией обращайтесь к справочному руководству по библиотеке язы
ка Python и к другим специализированным книгам.
762 Глава 29. Использование исключений
инструкция try с пустым предложением except может непреднамерен
но перехватить такое важное исключение, как показано в следующем
файле (exiter.py):
import sys
def bye():
sys.exit(40) # Серьезная ошибка: завершить работу программы немедленно!
try:
bye()
except:
print 'got it' # Ой! Мы проигнорировали команду на завершение
print 'continuing...'
% python exiter.py
got it
continuing...
Вы просто не сможете предугадать все исключения, которые могут
произойти во время выполнения операции.
Вероятно, хуже всего то, что пустое предложение except может пере
хватить настоящие ошибки в программном коде, которым желательно
было бы позволить пройти дальше. Фактически пустые предложения
except могут отключать механизм интерпретатора, предназначенный
для вывода сообщений об ошибках, скрывая возможные ошибки
в программном коде. Например, рассмотрим такой фрагмент:
mydictionary = {...}
...
try:
x = myditctionary['spam'] # Ой: опечатка
except:
x = None # А мы предполагаем, что получили KeyError
...продолжение работы с x...
Здесь программист предполагает, что в данной ситуации возможен
единственный тип ошибки – это ошибка отсутствующего ключа. Но
поскольку в имени словаря myditctionary была допущена опечатка
(должно быть mydictionary), интерпретатор возбуждает исключение
NameError, встретив ссылку на неопределенное имя, которое благопо
лучно будет перехвачено и проигнорировано обработчиком. Обработ
чик неправильно запишет в переменную значение по умолчанию, за
маскировав ошибку в программе. Если этот программный код будет
находиться достаточно далеко от места, где используется выбранное
значение, его отладка превратится в весьма захватывающую задачу!
Возьмите за правило специализировать свои обработчики, насколько
это возможно – пустые предложения except удобны в использовании,
но они потенциально опасны. Так, в последнем примере было бы луч
ше использовать предложение except KeyError:, чтобы более явно обо
значить свои намерения и избежать возможности перехвата посторон
Советы по применению исключений 763
них событий. В более простых сценариях подобные проблемы могут
иметь не такое существенное значение, чтобы перевесить удобство ис
пользования, но в общем универсальные обработчики обычно достав
ляют массу неприятностей.
Не перехватывайте слишком мало:
используйте категории
С другой стороны, было бы нежелательно делать обработчики слиш
ком узкоспециализированными. Когда в инструкции try перечисля
ются конкретные исключения, перехватываться будут только те ис
ключения, которые были перечислены. Это не обязательно плохо, но
если в процессе развития программы появится новое исключение, вам
может потребоваться вернуться и добавить это исключение в список
обрабатываемых в своем программном коде.
Например, следующий обработчик интерпретирует исключения myerror1
и myerror2 как нормальную ситуацию, а все остальные – как ошибку.
Если в будущем будет добавлено исключение myerror3, оно будет обра
батываться как ошибка, если не добавить его в список исключений:
try:
...
Except (myerror1, myerror2): # Работает неправильно при добавлении myerror3
... # Нет ошибки
else:
... # Рассматривается как ошибка
К счастью, при осторожном использовании исключений на основе
классов, обсуждавшихся в главе 28, можно полностью избавиться от
этой ловушки. Как мы уже видели, если перехватывать общий супер
класс, в будущем можно будет добавлять и возбуждать более конкрет
ные подклассы исключений без необходимости изменять список ис
ключений в предложении except; суперкласс становится легко расши
ряемой категорией исключений:
try:
...
except SuccessCategoryName: # Работает правильно при добавлении myerror3
... # Нет ошибки
else:
... # Рассматривается как ошибка
Если вы используете иерархии исключений на основе классов, порой
придется пройти длинный путь, чтобы найти оптимальное решение.
Мораль этой истории состоит в том, что вам следует с особым тщанием
подходить к выбору степени детализации, чтобы обработчики исклю
чений не были как слишком универсальными, так и слишком узкоспе
циализированными. Политика исключений должна быть составной
частью общего дизайна, особенно в крупных программах,
764 Глава 29. Использование исключений
Типичные проблемы при работе с исключениями
Вам едва ли часто придется сталкиваться с проблемами при работе
с исключениями и, тем не менее, здесь я дам две общих рекомендации
по их использованию (одна из которых касается концепций, с которы
ми мы уже встречались).
Соответствие строковым исключениям определяется
идентичностью объектов, а не равенством значений
Теперь, когда исключения, как предполагается, идентифицируются
классами, а не строками, эта проблема уходит в разряд устаревших
проблем. Однако вам все еще могут встретиться исключения на основе
строк в существующем программном коде, поэтому вам стоит знать об
этой проблеме. Когда возбуждается исключение (вашей программой
или самим интерпретатором), интерпретатор пытается отыскать бли
жайшую инструкцию try с соответствующим предложением except –
то есть предложение except, в котором указан тот же самый строковый
объект (в случае исключений на основе строк) или тот же самый класс,
или его суперкласс (для исключений на основе классов). В случае ис
пользования строковых исключений важно знать, что соответствие
определяется с помощью операции идентичности, а не равенства.
Например, предположим, что мы определили два строковых объекта,
которые будут использоваться в качестве исключений:
>>> ex1 = 'The Spanish Inquisition'
>>> ex2 = 'The Spanish Inquisition'
>>> ex1 == ex2, ex1 is ex2
(True, False)
Оператор == возвращает значение True, потому что объекты имеют оди
наковые значения, но оператор is возвращает False, потому что это
разные строковые объекты (предполагается, что строки имеют доста
точную длину, чтобы устранить влияние внутреннего механизма кэ
ширования строк, описанного в главе 6). Таким образом, предложение
except, указывающее на тот же самый строковый объект, всегда будет
считаться соответствующим:
>>> try:
... raise ex1
... except ex1:
... print 'got it'
...
got it
но предложение, где указан объект с тем же значением, но не идентич
ный строковому объекту исключения, не будет считаться соответст
вующим:
Типичные проблемы при работе с исключениями 765
>>> try:
... raise ex1
... except ex2:
... print 'Got it'
...
Traceback (most recent call last):
File "<pyshell#43>", line 2, in <module>
raise ex1
The Spanish Inquisition
Здесь исключение не было перехвачено, потому что объекты не иден
тичны. В результате исключение поднимается на верхний уровень про
цесса и автоматически выводится содержимое стека и текст исключе
ния. Однако, как я уже говорил раньше, в некоторых случаях может
получаться так, что различные строковые объекты с одинаковыми зна
чениями будут считаться идентичными изза влияния механизма кэ
ширования небольших строк в Python (как описывается в главе 6):
>>> try:
... raise 'spam'
... except 'spam':
... print 'got it'
...
got it
Этот пример работает правильно, потому что две строки отображаются
на один и тот же объект в кэше. Напротив, в следующем примере ис
пользуются строки достаточной длины, чтобы не попасть в кэш:
>>> try:
... raise 'spam' * 8
... except 'spam' * 8:
... print 'got it'
...
Traceback (most recent call last):
File "<pyshell#58>", line 2, in <module>
raise 'spam' * 8
spamspamspamspamspamspamspamspam
Если эти два примера кажутся вам непонятными, просто запомните:
в случае применения строк в инструкциях raise и try необходимо ис
пользовать один и тот же объект, а не одно и то же значение.
Для исключений на основе классов (рекомендуемая ныне методика)
все работает точно так же, но язык Python обобщает понятие соответ
ствия исключению, добавляя отношение к суперклассу, поэтому та
кой проблемы в случае с классами не наблюдается – еще одна причина
использовать исключения на основе классов!
766 Глава 29. Использование исключений
Перехват ненужных исключений
Пожалуй, самая типичная проблема, имеющая отношение к исключе
ниям, связана с общими рекомендациями по проектированию, рас
сматривавшимися в предыдущем разделе. Старайтесь избегать ис
пользования пустых предложений except (можно перехватить такие
события, как завершение программы), а также слишком узкоспециа
лизированных предложений except (используйте суперклассы катего
рий, чтобы избежать проблем сопровождения в будущем, когда в про
грамме появятся новые исключения).
Заключение по основам языка
Поздравляю! Этим разделом заканчивается ваше изучение основ язы
ка программирования Python. Если вы забрались так далеко, что чи
таете эти строки, можете смело считать себя Официальным Програм
мистом на языке Python (и можете не стесняться упоминать о знании
этого языка в своих резюме). Вы уже видели почти все, что можно уви
деть в самом языке, и получили знания более глубокие, чем имели
многие практикующие программисты на языке Python в начале своего
пути. Вы изучили встроенные типы, инструкции и исключения, а так
же инструменты, которые используются для создания крупных эле
ментов программ (функции, модули и классы). Кроме того, вы иссле
довали ряд важных проблем, связанных с проектированием, ООП, ар
хитектуру программы и многое другое.
Набор инструментальных средств языка Python
Начиная с этого момента, ваша будущая карьера программиста на
языке Python в значительной степени будет состоять из овладения ин+
струментальными средствами, доступными для прикладного про
граммирования на языке Python. Это может занять немало времени.
Стандартная библиотека, например, содержит сотни модулей, а разра
ботчиками сообщества предлагается еще больше. Чтобы познакомить
ся со всеми этими инструментами, может потребоваться лет десять,
а то и больше, особенно если учесть, что постоянно появляются новые
(можете мне поверить!).
Вообще говоря, Python обеспечивает следующую иерархию инстру
ментальных средств:
Встроенные
Встроенные типы, такие как строки, списки и словари, помогают
быстро создавать несложные программы.
Расширения на языке Python
Для решения более сложных задач вы можете расширить возможно
сти Python своими собственными функциями, модулями и классами.
Заключение по основам языка 767
Компилируемые расширения
Хотя мы и не касались данной темы в этой книге, тем не менее, воз
можности Python можно расширять с помощью модулей, написан
ных на других языках программирования, таких как C или C++.
Благодаря такой многоуровневой организации инструментальных
средств вы можете выбирать, насколько глубоко погружаться в эту ие
рархию при создании своих программ, – для простых сценариев доста
точно будет встроенных средств, для крупных программ могут потре
боваться дополнительные расширения на языке Python, а компили
руемые расширения – для решения необычных задач. В этой книге мы
охватили первые две категории, и этого вполне достаточно, чтобы на
чать писать на языке Python серьезные программы.
В табл. 29.1 приводятся некоторые из встроенных и других функцио
нальных возможностей, доступных в языке Python, исследованием
которых вы будете заниматься остаток вашей карьеры программиста
на языке Python. До настоящего момента наши примеры были очень
маленькими и самостоятельными. Главная их цель состояла в том,
чтобы помочь вам освоить основы. Но теперь, когда вы узнали все о ба
зовом языке, настало время учиться использовать встроенные интер
фейсы Python, чтобы быть в состоянии выполнять настоящую работу.
Вы обнаружите, что такой простой язык, как Python, делает решение
наиболее распространенных задач намного более легким делом, чем
можно было бы ожидать.
Таблица 29.1. Категории инструментальных средств в языке Python
Инструменты разработки крупных проектов
Как только вы овладеете основами языка, вы обнаружите, что ваши
программы становятся существенно больше, чем примеры, с которы
ми вы экспериментировали до сих пор. Для разработки крупных про
грамм и в Python, и в общем доступе имеется целый набор инструмен
тов разработки. Некоторые из них вы видели в действии, некоторые
я только упомянул. Чтобы помочь вам на вашем нелегком пути, я при
веду краткое описание некоторых наиболее часто используемых инст
рументов:
Категория Примеры
Типы объектов Списки, словари, файлы, строки
Функции len, range, apply, open
Исключения IndexError, KeyError
Модули os, Tkinter, pickle, re
Атрибуты __dict__, __name__, __class__
Внешние инструменты NumPy, SWIG, Jython, IronPython и другие
768 Глава 29. Использование исключений
PyDoc и строки документирования
Функция help и HTMLинтерфейсы модуля PyDoc были представле
ны в главе 14. Модуль PyDoc реализует систему документирования
для модулей и объектов и интегрирован со строками документиро
вания. Это стандартная часть системы Python, поэтому за дополни
тельными подробностями обращайтесь к справочному руководству
по библиотеке. Кроме того, в главе 14 даются подсказки с указани
ем на источники документации и другие информационные ресурсы
по языку Python.
PyChecker
Python – это динамический язык программирования, поэтому не
которые ошибки сложно обнаружить, пока программа не будет вы
полнена (например, синтаксические ошибки можно выявить при
запуске или во время импортирования файла). Это не такой боль
шой недостаток – как и для большинства языков программирова
ния это лишь означает, что прежде чем распространять свой про
граммный код, его необходимо тестировать. Кроме того, динамиче
ская природа языка Python, автоматический вывод сообщений об
ошибках и модель исключений в языке Python позволяют быстрее
и проще отыскивать и исправлять ошибки, чем в других языках
программирования (например, в отличие от языка C, интерпрета
тор Python не вызывает крах системы при появлении ошибок).
Система PyChecker обеспечивает возможность выявления широко
го круга наиболее часто встречающихся ошибок еще до того, как
сценарий будет запущен. Она играет роль, похожую на ту, какую
играет программа «lint» в разработке на языке C. Некоторые кол
лективы разработчиков проверяют свой программный код на языке
Python с помощью PyChecker еще до его тестирования или распро
странения, чтобы выявить все скрытые проблемы. В действитель
ности даже стандартная библиотека языка Python регулярно
проверяется с помощью PyChecker перед выпуском. PyChecker –
это сторонний пакет, распространяемый с открытыми исходными
текстами. Найти его можно по адресу http://www.python.org или на
вебсайте проекта Vaults of Parnassus.
PyUnit (он же unittest)
В пятой части книги мы видели, как в файлы модулей добавляется
программный код самопроверки, который использует результат
проверки __name__ == '__main__'. Дополнительно для нужд тестиро
вания в состав Python входят два инструмента. Первый, PyUnit
(в руководстве по библиотеке называется unittest), обеспечивает
комплект классов, с помощью которых можно определить и настро
ить варианты тестов и указать ожидаемые результаты. Он напоми
нает платформу JUnit в языке Java. Это сложная основанная на
классах, система, подробное описание которой вы найдете в спра
вочном руководстве по библиотеке Python.
Заключение по основам языка 769
Doctest
Модуль doctest, входящий в состав стандартной библиотеки, реали
зует второй и более простой подход к регрессивному тестированию.
Он основан на использовании строк документирования в языке Py
thon. В первом приближении, чтобы воспользоваться модулем
doctest, следует скопировать результаты тестирования в интерак
тивном сеансе в строки документирования в файле с исходным тек
стом. После этого модуль doctest извлечет эти строки документиро
вания, вычленит из них описание тестов с ожидаемыми результата
ми и повторно выполнит тесты, чтобы сравнить полученные резуль
таты с ожидаемыми. Функциональные возможности doctest могут
использоваться разными способами, о чем подробнее рассказывает
ся в справочном руководстве по библиотеке Python.
Интегрированные среды разработки
В главе 3 мы уже рассматривали интегрированные среды разработки
для языка Python. Такие интегрированные среды, как IDLE, обеспе
чивают графический интерфейс для редактирования, запуска, от
ладки и просмотра программ на языке Python. Некоторые мощные
интегрированные среды разработки, такие как Eclipse и Komodo,
поддерживают решение дополнительных задач разработки, включая
интеграцию с системами контроля версий, интерактивные построи
тели графического интерфейса, создание файлов проектов и многих
других. Список интегрированных сред разработки и построителей
графических интерфейсов для языка Python вы найдете в главе 3,
а также на сайтах http://www.python.org и Vaults of Parnassus.
Профилировщики
Поскольку язык Python является высокоуровневым и динамиче
ским языком программирования, интуитивные представления
о производительности, которые следуют из опыта работы с другими
языками программирования, неприменимы к программному коду
на языке Python. Чтобы выявить узкие места в программе, вам не
обходимо добавить логику, выполняющую замеры временных ин
тервалов с помощью инструментов, определяемых в модулях time
или timeit, или запустить свой программный код под управлением
модуля profile. Мы уже видели модули измерения времени в дейст
вии, когда сравнивали скорость работы итерационных инструмен
тов в главе 17.
Модуль profile – это модуль стандартной библиотеки, который реа
лизует профилирование исходных текстов программ на языке Py
thon. Он выполняет строку, которую вы ему передадите (например,
импорт файла или вызов функции), и затем по умолчанию выводит
в стандартный поток вывода отчет, в котором собрана информация
о производительности – количество вызовов каждой функции, вре
мя, потраченное каждой функцией, и многое другое. Модуль pro
filer допускает дополнительную настройку, например, он может
770 Глава 29. Использование исключений
сохранять полученную информацию в файле для последующего
анализа с помощью модуля pstats.
Отладчики
Стандартная библиотека языка Python включает модуль отладчика
исходных текстов с именем pdb. Этот модуль работает подобно от
ладчику командной строки в языке C (например, dbx, gdb): вы им
портируете модуль, запускаете программный код вызовом функ
ции из модуля pdb (например, pdb.run("main()")) и затем вводите ко
манды отладчика в интерактивном режиме. Кроме того, модуль pdb
включает полезную функцию для проведения послеаварийного
анализа – pdb.pm, которая позволяет выполнять отладку после появ
ления исключения. Многие интегрированные среды разработки,
такие как IDLE, включают интерфейсы «указал и щелкнул», поэто
му pdb в наши дни используется относительно редко – советы по ис
пользованию отладчика с графическим интерфейсом в IDLE вы
найдете в главе 3.1
Варианты распространения
В главе 2 были представлены инструменты, используемые для упа
ковки программ на языке Python. Такие инструменты, как py2exe,
PyInstaller и freeze, могут упаковывать байткод и виртуальную ма
шину с интерпретатором Python в «фиксированные двоичные фай
лы», которые способны выполняться как самостоятельные про
граммы, не требуют установки Python и полностью скрывают про
граммный код. Кроме того, в главе 2 и в пятой части книги мы узна
ли, что программы на языке Python могут распространяться в виде
исходных текстов (.py) или в виде байткода (.pyc), а также о суще
ствовании программных ловушек, обеспечивающих возможность
реализации специализированных приемов работы с пакетами, та
ких как автоматическое извлечение файлов из архивов в формате
.zip и шифрование байткода. Мы также познакомились с модулем
distutils, входящим в состав стандартной библиотеки, который
обеспечивает упаковку модулей и пакетов на языке Python и рас
ширений, написанных на языке C, – за дополнительной информа
цией обращайтесь к справочным руководствам по языку Python.
1 Честно говоря, отладчик интегрированной среды IDLE тоже используется
не слишком часто. Большинство практикующих программистов предпочи
тают отлаживать свой программный код вставкой инструкций print в кри
тических точках. Поскольку промежуток времени от изменения до выпол
нения в языке Python очень короткий, добавление инструкций print вы
полняется быстрее, чем ввод команды отладчика pdb или запуск сеанса от
ладки в среде разработки с графическим интерфейсом. Еще один прием
отладки, который вообще не требует никаких действий, основан на исполь
зовании сообщений, которые выводит интерпретатор в случае ошибки.
Обычно эти сообщения дают достаточно информации, чтобы проанализи
ровать и исправить ошибку.
В заключение 771
Недавно появившаяся в языке Python система подготовки дистри
бутивов «eggs» представляет собой другую альтернативу, которая
позволяет учитывать зависимости, – дополнительную информацию
о ней ищите в Сети.
Способы оптимизации
В главе 2 была описана система Psyco, позволяющая оптимизиро
вать программы по скорости выполнения. Она предоставляет дина
мический компилятор, выполняющий трансляцию байткода в дво
ичный машинный код. Кроме того имеется система Shedskin, кото
рая представляет собой транслятор исходных текстов с языка Python
на язык C++. Иногда вам могут встретиться файлы .pyo с оптимизи
рованным байткодом, которые создаются при запуске интерпрета
тора Python с ключом командной строки –O (обсуждается в главе 18),
но так как этот способ обеспечивает весьма скромное увеличение
производительности, он обычно не используется. Наконец, для по
вышения производительности можно отдельные части своих про
грамм перенести на компилирующий язык программирования, та
кой как C, – подробнее о расширениях на языке C рассказывается
в книге «Programming Python» и в стандартных руководствах по
языку Python. Вообще говоря, скорость работы интерпретатора Py
thon постоянно увеличивается, поэтому старайтесь использовать
самую свежую его версию, когда это возможно (например, версия
Python 2.3 обеспечила прирост производительности на 15–20 про
центов по сравнению с версией 2.2).
Другие советы по разработке крупных проектов
Кроме всего прочего, в этой книге мы познакомились с различными
особенностями языка, удобство которых особенно ярко проявляется
при работе с крупными проектами. Среди них: пакеты модулей (гла
ва 20); исключения на основе классов (глава 28); псевдочастные ат
рибуты класса (глава 25); строки документирования (глава 14); фай
лы с настройками пути поиска модулей (глава 18); сокрытие имен,
импортируемых инструкцией from * с помощью списков __all__
и имен в формате _X (глава 21); добавление программного кода само
проверки с использованием приема __name__ == '__main__' (глава 21);
использование общих правил проектирования при создании функ
ций и модулей (главы 16, 17 и 21) и т. д.
Узнать о других общедоступных разнообразных инструментах разра
ботки можно на страницах вебсайта Vaults of Parnassus.
В заключение
Эта глава завершила часть книги, описывающую исключения (и всю
книгу в целом) кратким обзором типичных случаев использования ис
ключений и инструментальных средств разработки. Поскольку это ко
нец книги, глава заканчивается единственным контрольным вопросом.
772 Глава 29. Использование исключений
Как обычно, обязательно выполните упражнения к этой части, чтобы
закрепить знания, полученные в последних нескольких главах. В сле
дующих далее приложениях даются подсказки по установке Python
и ответы к упражнениям.
Чтобы получить представление о том, что читать после этой книги,
просмотрите список литературы, рекомендуемой для дальнейшего
чтения в предисловии. Вы достигли того момента, когда язык Python
действительно становится увлекательным, но на этом данная книга
заканчивается. Теперь вы неплохо подготовлены к изучению других
книг и ресурсов, которые помогут вам решать задачи прикладного
программирования, такие как создание программ с графическим ин
терфейсом, разработка вебсайтов, интерфейсов к базам данных и мно
гие другие. Удачи вам в вашем путешествии и, конечно, «всегда смот
рите на светлую сторону жизни»!
Закрепление пройденного
Контрольные вопросы
1. (Этот вопрос уже задавался в контрольных вопросах к главе 1 – ви
дите, я же говорил, что это будет просто.) Почему слово spam так
часто появляется в примерах в этой книге?
Ответы
1. Язык Python получил свое название в честь английской комик
группы Монти Пайтона (Monty Python) (согласно опросам, которые
я проводил среди своих студентов, это «самая большая тайна»
в мире Python!). Слово «spam» взято из пародии Монти Пайтона
(Monty Python), где герои сериала пытаются заказать блюдо в кафе
терии, а их заглушает хор викингов, поющих песню о консервах
(spam). И если бы я мог вставить сюда аудиофрагмент из этой песни
в качестве заключительных титров, я бы сделал это…
Упражнения к седьмой части
Мы достигли конца этой части книги, поэтому настало время выпол
нить несколько упражнений на применение исключений, чтобы по
практиковаться в основах. Исключения действительно являются
очень простым инструментом – если вы пользуетесь ими, значит вы
владеете ими в полной мере.
Решения вы найдете в приложении B, в разделе «Часть VII, Исключе
ния и инструменты».
1. try/except. Напишите функцию с именем oops, которая при вызове
явно возбуждает исключение IndexError. Затем напишите другую
функцию, которая вызывает функцию oops внутри инструкции try/
Закрепление пройденного 773
except, которая перехватывает ошибку. Что произойдет, если изме
нить функцию oops так, чтобы вместо IndexError она возбуждала ис
ключение KeyError? Где располагаются имена KeyError и IndexError?
(Подсказка: вспомните, что все простые несоставные имена находят
ся в одной из четырех областей видимости согласно правилу LEGB.)
2. Объекты исключений и списки. Измените функцию oops, которую
вы только что написали так, чтобы она возбуждала ваше собствен
ное исключение с именем MyError и передавала бы дополнительные
данные вместе с исключением. Вы можете определеить свое исклю
чение на основе строки или класса. Затем расширьте инструкцию
try в функции, которая вызывает функцию oops, так чтобы кроме
исключения IndexError она перехватывала бы еще и это исключе
ние, извлекала бы дополнительные данные и выводила бы их на эк
ран. Наконец, если вы использовали исключение на основе строки,
вернитесь назад и измените исключение, так чтобы оно было осно
вано на классе, – что теперь будет передаваться обработчику в виде
дополнительных данных?
3. Обработка ошибок. Напишите функцию safe(func, *args), которая
запускает указанную функцию с помощью функции apply (или с ис
пользованием более нового синтаксиса вызова *name), перехватывает
любые исключения, возникающие в ходе выполнения этой функции
и выводит информацию об исключении с использованием атрибутов
exc_type и exc_value модуля sys (или с помощью более современной
функции sys.exc_info). Затем с помощью своей функции safe запус
тите функцию oops из упражнения 1 или 2. Поместите функцию
safe в модуль с именем tools.py и передайте ей функцию oops в инте
рактивном режиме. Какие сообщения об ошибках вы получили?
Наконец, расширьте свою функцию safe так, чтобы при возникно
вении исключения она выводила содержимое стека вызовов с помо
щью встроенной функции print_exc, расположенной в стандартном
модуле traceback (за дополнительной информацией обращайтесь
к руководству по библиотеке языка Python).
4. Примеры для самостоятельного изучения. В конец Приложения B
я добавил несколько примеров сценариев, разработанных в ходе
выполнения упражнений моими студентами, чтобы вы могли само
стоятельно изучить и опробовать их, попутно изучая набор стан
дартных руководств по языку Python. Эти примеры не содержат
описаний, и в них используются инструменты из стандартной биб
лиотеки языка Python, которые вам потребуется отыскать. Для
многих читателей эти примеры помогут увидеть, как концепции,
которые мы обсуждали в этой книге, объединяются в реальных
программах. Если эти примеры возбудят у вас интерес, вы сможете
отыскать множество более реалистичных примеров программ на
языке Python в последующих книгах, таких как «Programming Py
thon», и в Сети.

VIII
Приложения

A
Установка и настройка
В этом приложении описываются подробности установки и настройки
в помощь тем, кто впервые делает это.
Установка интерпретатора Python
Для запуска сценариев на языке Python необходимо иметь интерпрета
тор Python, поэтому первым шагом к использованию этого языка явля
ется установка Python. Если он еще не установлен у вас на компьютере,
вам необходимо получить и установить последнюю версию Python на
свой компьютер и, возможно, настроить его. Для каждого компьютера
эту процедуру необходимо выполнить всего один раз, а если вы запус
каете фиксированные двоичные файлы (описываемые в главе 2), вам
вообще не потребуется устанавливать интерпретатор.
Возможно, Python уже установлен?
Прежде чем приступать к установке, проверьте, возможно, на вашем
компьютере уже установлена свежая версия Python. Если вы работаете
в операционной системе Linux, Mac OS X или UNIX, вполне вероятно,
что Python уже установлен на вашем компьютере. Введите в командной
строке (иногда называется окном терминала) команду python и посмот
рите, что произойдет. Можно попробовать поискать подкаталог python
в обычных местах – в каталогах /usr/bin, /usr/local/bin и других.
В операционной системе Windows поищите пункт Python в меню кноп
ки Пуск (Start), расположенной в левом нижнем углу экрана. Если ин
терпретатор установлен, убедитесь, что он имеет версию 2.5 или выше.
Несмотря на то, что для работы с этой книгой подойдет любая доста
точно свежая версия, тем не менее, для запуска некоторых примеров
вам потребуется версия не ниже 2.5.
778 Приложение A
Где получить Python
Если вы не нашли Python у себя на компьютере, вам придется устано
вить его. Могу вас обрадовать, Python является программным обеспе
чением, распространяемым с открытыми исходным текстами, и его
можно свободно загрузить из Сети, к тому же на большинстве плат
форм Python устанавливается достаточно просто.
Самую свежую и лучшую версию Python всегда можно получить на
официальном вебсайте проекта http://www.python.org – воспользуй
тесь ссылкой «Download» (загрузить) на этой странице и выберите вер
сию для своей платформы. Здесь вы найдете уже собранные выполняе
мые (достаточно распаковать и запустить) файлы дистрибутивов для
Windows (чтобы запустить установку, достаточно щелкнуть мышью на
ярлыке файла), пакеты в формате RPM для Linux (установка произво
дится с помощью утилиты rpm), дистрибутивы с полными исходными
текстами (которые требуется скомпилировать, чтобы установить интер
претатор) и другие. Ссылки на другие вебстраницы, с которых можно
загрузить версии для некоторых платформ, таких как PalmOS, сотовые
телефоны Nokia и Windows Mobile можно найти либо на сайте проекта
Python.org, либо воспользовавшись поисковой службой Google.
Интерпретатор Python можно также обнаружить на компактдисках
с дистрибутивами Linux, в составе некоторых программных продук
тов и как приложение к некоторым книгам по языку Python. Обычно
они немного отстают от текущей версии, но это отставание, как прави
ло, не очень велико.
Кроме того, компания ActiveState распространяет Python в составе сво
его пакета ActivePython. В состав пакета входят CPython с расширения
ми для разработки программ в операционной системе Windows, интег
рированная среда разработки PythonWin (описывается в главе 3) и дру
гие часто используемые расширения. Дополнительную информацию
о пакете ActivePython вы найдете на вебсайте компании ActiveState.
Наконец, если вам интересны альтернативные реализации Python, по
ищите в Сети Jython (версия Python для среды Java) и IronPython (вер
сия Python для среды C#/.NET); обе версии были описаны в главе 2, од
нако установка этих систем выходит далеко за рамки этой книги.
Установка
Загрузив дистрибутив Python, его необходимо установить. Порядок
установки сильно зависит от платформы, и поэтому ниже приводятся
некоторые рекомендации по установке в некоторых основных плат
формах:
Windows
Для операционной системы Wimdows дистрибутив Python постав
ляется в виде инсталляционного файла в формате MSI – просто
Установка и настройка 779
щелкните дважды на ярлыке этого файла и отвечайте на вопросы
нажатием кнопок Yes (Да) или Next (Далее), чтобы выполнить установ
ку с параметрами по умолчанию. Установка по умолчанию включа
ет в себя комплект документации, поддержку библиотеки построе
ния графических интерфейсов Tkinter и базы данных shelve, а так
же среду разработки IDLE с графическим интерфейсом. Обычно Py
thon 2.5 устанавливается в каталог C:\Python25, хотя во время
установки можно указать другой каталог.
После установки в подменю Все программы (All Programs), в меню кноп
ки Пуск (Start), появляется дополнительное меню Python, в котором
имеется пять пунктов, обеспечивающих быстрый доступ к наиболее
типичным задачам: запуск IDLE, чтение документации, запуск ин
терактивного сеанса, чтение стандартных руководств по языку Py
thon в вебброузере и удаление. Большинство этих действий связаны
с концепциями, которые детально рассматривались в этой книге.
После установки интерпретатор Python автоматически регистриру
ет себя в качестве программы, предназначенной для открытия фай
лов Python щелчком мыши (этот прием запуска программ описыва
ется в главе 3). Существует возможность собрать Python из исход
ных текстов в Windows, но обычно это не делается.
Одно замечание для пользователей Windows Vista: особенности сис
темы безопасности текущей версии Windows Vista изменили некото
рые из правил использования инсталляционных файлов MSI. Обра
щайтесь за помощью к тексту врезки «Установка Python 2.5 из уста
новочного файла формата MSI в Windows Vista» в этом приложении,
если инсталляционный файл Python не запускается или если уста
новка не выполняется в правильный каталог на вашей машине.
Linux
Для операционной системы Linux интерпретатор Python доступен
в виде одного или нескольких файлов RPM, которые распаковыва
ются обычным способом (за подробностями обращайтесь к странице
справочного руководства по RPM). В зависимости от того, какие па
кеты RPM вы загрузили, в одном может находиться сам интерпре
татор Python, а в других – дополнительная поддержка Tkinter и сре
да разработки IDLE. Так как Linux является UNIXподобной опера
ционной системой, к нему применимы рекомендации, которые да
ются в следующем параграфе.
UNIX
В операционных системах UNIX Python обычно компилируется из
дистрибутива с исходными текстами на языке C. Обычно для этого
требуется распаковать файл и запустить команды config и make – Py
thon настроит процедуру сборки автоматически, в соответствии
с системой, где выполняется сборка. Однако обязательно ознакомь
тесь с содержимым файла README, где приводятся дополнитель
780 Приложение A
ные замечания по процессу сборки. Поскольку Python является
программным продуктом, распространяемым с открытыми исход
ными текстами, его исходный программный код может свободно
использоваться и распространяться.
Процедура установки в других платформах может существенно отли
чаться. Так, установка «Pippy», версии Python для PalmOS, напри
мер, требует выполнения операции синхронизации вашего PDA, а Py
thon для PDA Sharp Zaurus, работающего под управлением Linux, по
ставляется в виде одного или более файлов .ipk, которые достаточно
просто запустить, чтобы выполнить установку. Дополнительные про
цедуры установки для дистрибутивов в виде исполняемых файлов и па
кетов с исходными текстами прекрасно документированы, поэтому
мы пропустим дальнейшие подробности.
Настройка Python
После установки Python вам может потребоваться выполнить некото
рые настройки, влияющие на то, как Python будет выполнять ваш
программный код. (Если вы только начинаете знакомство с языком,
возможно, вам лучше вообще пропустить этот раздел – для создания
программ начального уровня обычно не требуется изменять какиели
бо параметры настройки.)
Вообще говоря, некоторые особенности поведения интерпретатора мо
гут быть настроены с помощью переменных окружения и параметров
командной строки. В этом разделе мы коротко рассмотрим перемен
ные окружения Python. Параметры командной строки, которые ука
зываются при запуске программ на языке Python из командной строки
системы, используются достаточно редко и часто играют узкоспециа
лизированные роли – за дополнительной информацией по этому во
просу обращайтесь к другим источникам документации.
Установка Python 2.5 из установочного файла
формата MSI в Windows Vista
В середине 2007 года, когда я писал эти строки, дистрибутив Py
thon для Windows распространялся в виде инсталляционного
файла .msi. Файлы этого формата прекрасно работают в Windows
XP (достаточно просто выполнить двойной щелчок мышью на
этом файле, чтобы запустить его), однако в текущей версии Win
dows Vista все может оказаться не так просто. В частности, за
пуск инсталлятора щелчком мыши на моей машине привел к то
му, что Python был установлен в корневой каталог диска C: вме
сто выбранного по умолчанию каталога C:\Python25. Интерпре
татор вполне работоспособен и в корневом каталоге, но это
неправильное место для установки.
Установка и настройка 781
Переменные окружения Python
Переменные окружения, иногда известные как переменные команд
ной оболочки или переменные DOS, определяются за пределами ин
терпретатора Python и потому могут использоваться для настройки
его поведения каждый раз, когда он запускается на данном компьюте
ре. Интерпретатор Python пользуется множеством переменных окру
жения, но лишь немногие из них используются достаточно часто; они
приведены ниже. В табл. A.1. приводятся основные переменные окру
жения, используемые для настройки интерпретатора Python.
Эта проблема обусловлена особенностями поведения системы
безопасности в Windows Vista. Дело в том, что в действительно
сти файлы MSI не являются настоящими исполняемыми файла
ми, поэтому они неправильно наследуют права администратора,
даже если запускаются администратором. Файлы MSI запуска
ются программойинсталлятором MSI, ассоциация с которой
определена в реестре Windows.
Чтобы установить Python 2.5.1 на свой карманный компьютер
OQO, работающий под управлением Windows Vista, мне пришлось
воспользоваться командной строкой и выполнить установку
с правами администратора. Вот как это делается: откройте меню
кнопки Пуск (Start), выберите пункт Все программы (All Programs),
выберите пункт Стандартные (Accessories), щелкните правой кноп
кой на пункте Командная строка (Command Prompt), в контекстном
меню выберите пункт Запуск с правами администратора (Run as admin
istrator) и выберите кнопку Продолжить (Continue) в диалоге управ
ления доступом. Теперь в окне Командная строка (Command Prompt)
запустите команду cd, чтобы перейти в каталог, где находится
файл MSI с дистрибутивом Python (например, cd C:\user\down

loads), и затем запустите программуинсталлятор MSI, выполнив
команду вида: msiexec /i python
2.5.1.msi. Для завершения уста
новки следуйте обычным указаниям мастера установки с графи
ческим интерфейсом.
Естественно, такое поведение может измениться через какоето
время. Эта процедура может оказаться необязательной в буду
щих версиях Vista и, возможно, появятся другие обходные пути
(такие как отключение системы безопасности Vista, если вы ре
шитесь на это). Возможно также, что сам установочный файл
Python будет распространяться в другом формате, ликвидирую
щем эту проблему, например, в виде настоящего исполняемого
файла. Прежде чем использовать какиелибо обходные пути, по
пробуйте сначала просто запустить установку щелчком мыши,
возможно, она уже работает должным образом.
782 Приложение A
Таблица A.1. Переменные окружения, имеющие важное значение
Эти переменные просты в обращении и, тем не менее, приведу не
сколько рекомендаций:
• Переменная PATH определяет список каталогов, где операционная
система будет пытаться отыскать исполняемые файлы программ.
Обычно этот список должен включать каталог, где находится ин
терпретатор Python (файл python в операционной системе UNIX
или файл python.exe в Windows).
Вам вообще не придется настраивать эту переменную, если вы рабо
таете в каталоге, где находится интерпретатор Python, например,
настройки в переменной PATH не имеют значения, если перед за
пуском какоголибо программного кода выполнить команду cd
C:\Python25 (чтобы перейти в каталог, где находится интерпретатор
Python) или вместо команды python всегда выполнять команду
C:\Python25\python (в команде присутствует полный путь к испол
няемому файлу). Кроме того, переменная окружения PATH в основ
ном используется для запуска команд из командной строки – эта
Переменная Назначение
PATH (или path) Путь поиска файлов, используемый системой (ис
пользуется при поиске исполняемого файла python)
PYTHONPATH Путь поиска модулей Python (используется опера
цией импортирования)
PYTHONSTARTUP Путь к интерактивному файлу запуска Python
TCL_LIBRARY, TK_LIBRARY Переменные окружения для Tkinter (расширение
для создания графического интерфейса)
Установка поддержки Tkinter в Linux
Среда разработки IDLE, описанная в главе 2, представляет собой
программу на языке Python, которая использует библиотеку
Tkinter для создания графического интерфейса. Библиотека
Tkinter – это набор инструментальных средств для построения
графического интерфейса; она является стандартным компонен
том дистрибутива Python для Windows и некоторых других
платформ. Однако в некоторых дистрибутивах Linux эта библио
тека не входит в стандартный комплект устанавливаемых ком
понентов. Чтобы добавить в интерпретатор Python поддержку
графического интерфейса в операционной системе Linux, попро
буйте запустить команду yum tkinter, которая автоматически ус
тановит все необходимые библиотеки. Эта команда должна рабо
тать в дистрибутивах Linux (и в некоторых других системах), где
имеется программа установки пакетов yum.
Установка и настройка 783
переменная не имеет значения при запуске программ щелчком мы
ши на ярлыке или из интегрированной среды разработки.
• Переменная окружения PYTHONPATH играет похожую роль: интерпре
татор Python использует переменную PYTHONPATH во время поиска фай
лов модулей, когда они импортируются программами. (Дополнитель
ную информацию о переменной PYTHONPATH вы найдете в главе 18.) Эта
переменная содержит список каталогов в формате, зависящем от ти
па используемой платформы, – в UNIX каталоги в списке отделяют
ся двоеточием, а в Windows – точкой с запятой. Обычно этот список
должен включать только каталоги с вашими исходными текстами.
Вам не потребуется настраивать эту переменную, если не импортиро
вать модули, находящиеся в других каталогах, потому что интерпре
татор всегда автоматически пытается отыскать модули в домашнем
каталоге программы. Настраивать эту переменную придется, только
если какойлибо модуль должен импортировать другой модуль, рас
положенный в другом каталоге. Как упоминалось в главе 18, недав
но появилась альтернатива переменной PYTHONPATH – файлы .pth.
• Если в переменной PYTHONSTARTUP указано полное имя файла с про
граммным кодом на языке Python, интерпретатор будет запускать
этот файл автоматически всякий раз, когда запускается интерак
тивный сеанс работы с интерпретатором, как если бы инструкции
из этого файла вводились вручную в интерактивной командной обо
лочке. Этот способ используется редко, но его удобно применять,
когда необходимо обеспечить загрузку некоторых утилит для рабо
ты в интерактивной оболочке, т. к. это позволяет сэкономить время
на импортировании вручную.
• Если вы предполагаете использовать набор инструментальных
средств построения графического интерфейса Tkinter, вам может
понадобиться записать в две переменные из табл. A.1 имена катало
гов библиотек Tcl и Tk (похоже на PYTHONPATH). Однако в Windows
(где поддержка Tkinter устанавливается вместе с интерпретатором
Python) это не требуется, и обычно не требуется, если Tcl и Tk уста
новлены в стандартные каталоги.
Обратите внимание: эти настройки окружения (так же, как и файлы
.pth) являются внешними по отношению к интерпретатору Python, по
этому совершенно неважно, когда будет выполнена их настройка. Они
могут быть настроены как до, так и после установки Python, главное,
что это должно быть сделано перед запуском интерпретатора.
Как установить параметры конфигурации
Способ установки переменных окружения, имеющих отношение к Py
thon, и устанавливаемые значения зависят от типа компьютера, с ко
торым вы работаете. Не забывайте, что вам не обязательно выполнять
все эти настройки, особенно если вы работаете в среде IDLE (описан
ной в главе 3).
784 Приложение A
Но предположим для иллюстрации, что у вас имеется несколько весь
ма полезных модулей в каталогах utilities и package1 гдето в компью
тере, и вам необходимо иметь возможность импортировать их из фай
лов модулей, расположенных не в домашнем каталоге. То есть, чтобы
загрузить файл с именем spam.py из каталога utilities, вам необходимо
обеспечить возможность выполнить инструкцию:
import spam
из другого файла, расположенного в какомто другом каталоге. Для
этого следует одним из возможных способов настроить путь поиска мо
дулей, чтобы включить в него каталог, содержащий файл spam.py. Ни
же приводится несколько советов, как это можно сделать.
Переменные окружения в UNIX/Linux
В системе UNIX способ установки значения переменной окружения
зависит от используемой командной оболочки. При использовании ко
мандной оболочки csh для установки пути поиска модулей можно до
бавить строку, как показано ниже, в свой файл .cshrc или .login:
setenv PYTHONPATH /usr/home/pycode/utilities:/usr/lib/pycode/package1
Она сообщает интерпретатору Python о том, что поиск импортируемых
модулей должен выполняться в двух каталогах. Однако, если вы ис
пользуете командную оболочку ksh, настройки можно выполнить в фай
ле .kshrc, и на этот раз строка будет иметь следующий вид:
export PYTHONPATH="/usr/home/pycode/utilities:/usr/lib/pycode/package1"
Другие командные оболочки могут использовать другой (но достаточ
но похожий) синтаксис.
Переменные DOS (Windows)
Если вы используете MSDOS или старую версию Windows, вам может
потребоваться добавить определение переменных окружения в свой
файл C:\autoexec.bat и перезагрузить компьютер, чтобы изменения
вступили в силу. Команда настройки для таких компьютеров имеет
синтаксис, уникальный для DOS:
set PYTHONPATH=c:\pycode\utilities;d:\pycode\package1
Вы можете ввести эту команду в окне сеанса DOS, но тогда настройки
будут иметь эффект только в этом окне. Настройки в файле .bat сохра
няются постоянно и являются глобальными для всех программ.
Другие способы в Windows
В наиболее свежих версиях Windows имеется возможность устанавли
вать значение переменной окружения PYTHONPATH и других переменных
с помощью графического интерфейса и тем самым избежать редакти
рования файлов и перезагрузки компьютера. В Windows XP выберите
ярлык Система (System) в меню Панель управления (Control Panel), перейдите
Установка и настройка 785
на вкладку Дополнительно (Advanced) и щелкните на кнопке Переменные
среды (Environment Variables), чтобы отредактировать или добавить новые
переменные (PYTHONPATH – это обычно пользовательская переменная).
Вам не потребуется перезагружать компьютер, но необходимо будет
перезапустить интерпретатор Python, если к моменту внесения изме
нений он уже был запущен (он воспринимает настройки пути только
во время запуска).
Если вы опытный пользователь Windows, вы можете также настроить
путь с помощью редактора реестра Windows. Выберите пункт меню
«Старт→Выполнить…» («Start→Run…») и введите команду regedit. Если этот
инструмент редактирования установлен у вас на компьютере, вы сможе
те с его помощью отыскать записи, имеющие отношение к Python, и вы
полнить необходимые изменения. Это достаточно сложная процедура,
при выполнении которой легко ошибиться, поэтому если вы не знако
мы с реестром, я рекомендую использовать другие возможности.
Файлы путей
Наконец, если для настройки пути поиска модулей вы решили исполь
зовать файл .pth, а не переменную окружения PYTHONPATH, в операцион
ной системе Windows можно создать текстовый файл со следующим
содержимым (файл C:\Python25\mypath.pth):
c:\pycode\utilities
d:\pycode\package1
Его содержимое будет отличаться для разных платформ, а каталог его
размещения может отличаться как в зависимости от платформы, так
и в зависимости от версии Python. Интерпретатор отыскивает эти фай
лы автоматически во время запуска.
Имена каталогов в файлах пути могут быть абсолютными или относи
тельными по отношению к каталогу, где находится файл пути. Допус
кается использовать несколько файлов .pth (все каталоги, перечислен
ные в них, будут добавлены в путь поиска), а сами файлы .pth могут
размещаться в любых каталогах, которые проверяются автоматиче
ски, в зависимости от используемой платформы и версии Python. На
пример, Python 2.5 пытается отыскать такие файлы в каталогах
C:\Python25 и C:\Python25\Lib\site+packages в операционной системе
Windows и в каталогах /usr/local/lib/python2.5/site+packages and /usr/
local/lib/site+python в Unix и Linux.
Поскольку эти настройки часто бывают необязательными и эта книга
не описывает командные оболочки операционных систем, я оставляю
освещение подробностей другим источникам информации. За более
подробными сведениями обращайтесь к страницам справочного руко
водства своей командной оболочки или к другой документации. Если
вы испытываете затруднения в определении того, какие настройки
вам следует выполнить, обратитесь за помощью к своему системному
администратору или другому опытному товарищу.
B
Решения упражнений
Часть I. Введение
Упражнения находятся в главе 3, в разделе «Упражнения к первой
части».
1. Взаимодействие. Предположим, что настройка Python выполнена
правильно, тогда сеанс взаимодействия с интерактивной оболочкой
должен выглядеть примерно так, как показано ниже (вы можете за
пустить интерактивную оболочку любым способом, по своему ус
мотрению – в IDLE, из системной командной строки и т. д.):
% python
...строки с информацией об авторских правах...
>>> "Hello World!"
'Hello World!'
>>> # Для выхода используйте CtrlD или CtrlZ, или закройте окно
2. Программы. Содержимое файла (то есть модуля) module1.py и сеанс
взаимодействия с командной оболочкой операционной системы
должны выглядеть, как показано ниже:
print 'Hello module world!'
% python module1.py
Hello module world!
Вы можете запустить этот файл любым другим способом – щелчком
мыши на ярлыке файла, с помощью пункта меню Run→Run Module
(Запустить→Запустить модуль) и т. д.
3. Модули. Следующий пример сеанса взаимодействия иллюстрирует
запуск модуля при его импортировании:
% python
>>> import module1
Решения упражнений 787
Hello module world!
>>>
Не забывайте: чтобы запустить модуль еще раз в течение этого же
сеанса работы в интерактивной оболочке, необходимо перезагру
зить его. Просьба переместить файл в другой каталог и снова им
портировать его содержит одну хитрость: если интерпретатор Py
thon создал в первоначальном каталоге файл module1.pyc, при им
порте он будет использовать этот файл, даже если файл с исходным
программным кодом (.py) будет перемещен в другой каталог, распо
ложенный за пределами пути поиска модулей. Если интерпретатор
имел доступ к файлу с исходным программным кодом, он автомати
чески создаст файл .pyc, содержащий байткод скомпилированной
версии модуля. Подробнее о модулях рассказывается в пятой части
книги.
4. Сценарии. Предположим, что ваша платформа поддерживает ин
терпретацию комбинации символов #!, решение этого упражнения
должно выглядеть примерно так, как показано ниже ( на вашем
компьютере в строке #! может потребоваться указать другой путь):
#!/usr/local/bin/python (или #!/usr/bin/env python)
print 'Hello module world!'
% chmod +x module1.py
% module1.py
Hello module world!
5. Ошибки. Ниже показано, какие сообщения об ошибках будут полу
чены по завершении этого упражнения. В действительности вы вы
зываете исключения – по умолчанию при возникновении исключе
ний интерпретатор завершает работу программы и выводит сообще
ние об ошибке вместе содержимым стека вызовов на экран. Инфор
мация из стека показывает, в каком месте программы произошло
исключение. В седьмой части книги вы узнаете, как перехватывать
исключения с помощью инструкции try и как обрабатывать их. Вы
также увидите, что в состав Python входит полноценный отладчик
исходного программного кода, обладающий возможностями анали
за ошибок после возникновения исключения. А пока обратите вни
мание, что в случае появления ошибок Python выводит вполне ин
формативные сообщения (вместо того чтобы просто аварийно завер
шать программу вообще без какихлибо сообщений):
% python
>>> 1 / 0
Traceback (innermost last):
File "<stdin>", line 1, in ?
ZeroDivisionError: integer division or modulo
(ZeroDivisionError: целочисленное деление или деление по модулю)
>>>
788 Приложение B
>>> x
Traceback (innermost last):
File "<stdin>", line 1, in ?
NameError: x
6. Прерывание программы. Если ввести следующие инструкции:
L = [1, 2]
L.append(L)
тем самым вы создадите циклическую структуру данных. В верси
ях ниже, чем Python 1.5.1, интерпретатор еще не обладает возмож
ностью определять случаи зацикливания в объектах, и он будет вы
водить бесконечный поток [1, 2, [1, 2, [1, 2, [1, 2, и т. д., пока
вы не нажмете комбинацию клавиш, выполняющих прерывание
программы (которая, с технической точки зрения, возбуждает ис
ключение прерывания с клавиатуры и приводит к выводу сообще
ния по умолчанию). Начиная с версии Python 1.5.1, интерпретатор
уже умеет определять случаи зацикливания и вместо бесконечной
последовательности выведет [[...]].
Причина зацикливания пока для вас неочевидна; чтобы ее понять,
необходимы знания, которые вы получите во второй части книги.
Однако в двух словах замечу, что операции присваивания в языке
Python всегда создают ссылки на объекты (которые можно предста
вить себе, как неявное следование по указателям). После выполне
ния первой инструкции из тех, что представлены выше, имя L пре
вратится в именованную ссылку на объект списка, состоящий из
двух элементов. Списки в языке Python в действительности явля
ются массивами ссылок на объекты, обладающими методом append,
который изменяет сам массив, добавляя ссылку на другой объект.
В данном случае вызов метода append добавляет в конец списка L
ссылку на сам список L, что приводит к зацикливанию, как показа
но на рис. B.1. В некоторых программах, где выполняется обход
произвольных объектов, вам, возможно, самим придется опреде
Имена Объекты
L
1 2
Рис. B.1. Циклический объект, созданный за счет добавления списка
к самому себе. По умолчанию интерпретатор добавляет ссылку
на оригинальный список, а не его копию
Решения упражнений 789
лять такие зацикливания и внимательно изучать действия про
граммы, чтобы избежать зацикливания.
Хотите верьте, хотите нет, но циклические структуры данных ино
гда могут быть полезны (но не тогда, когда выводятся на экран!).
Часть II. Типы и операции
Упражнения находятся в главе 9, в разделе «Упражнения ко второй
части».
1. Основы. Ниже приводятся результаты, которые вы должны полу
чить, с некоторыми комментариями к ним. Обратите внимание, что
здесь иногда используется символ ;, чтобы поместить несколько
инструкций в одну строку. Символ ; – это разделитель инструкций:
# Числа
>>> 2 ** 16 # 2 в степени 16
65536
>>> 2 / 5, 2 / 5.0 # / усекает целые числа, а с плавающей точкой  нет
(0, 0.40000000000000002)
# Строки
>>> "spam" + "eggs" # Конкатенация
'spameggs'
>>> S = "ham"
>>> "eggs " + S
'eggs ham'
>>> S * 5 # Повторение
'hamhamhamhamham'
>>> S[:0] # Пустой срез с первого элемента  [0:0]
''
>>> "green %s and %s" % ("eggs", S) # Форматирование
'green eggs and ham'
# Кортежи
>>> ('x',)[0] # Индексирование кортежа, состоящего из одного
элемента
'x'
>>> ('x', 'y')[1] # Индексирование кортежа, состоящего из двух
элементов
'y'
# Списки
>>> L = [1,2,3] + [4,5,6] # Операции над списками
>>> L, L[:], L[:0], L[
2], L[
2:]
([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [], 5, [5, 6])
>>> ([1,2,3]+[4,5,6])[2:4]
[3, 4]
>>> [L[2], L[3]] # Извлечение по смещениям с сохранением в списке
[3, 4]
790 Приложение B
>>> L.reverse(); L # Метод: обратное упорядочивание элементов в списке
[6, 5, 4, 3, 2, 1]
>>> L.sort(); L # Метод: сортировка элементов в списке
[1, 2, 3, 4, 5, 6]
>>> L.index(4) # Метод: смещение первого вхождения 4 (поиск)
3
# Словари
>>> {'a':1, 'b':2}['b'] # Извлечение элемента словаря по ключу
2
>>> D = {'x':1, 'y':2, 'z':3}
>>> D['w'] = 0 # Создаст новую запись
>>> D['x'] + D['w']
1
>>> D[(1,2,3)] = 4 # Использование кортежа в качестве
# ключа (неизменяемый)
>>> D
{'w': 0, 'z': 3, 'y': 2, (1, 2, 3): 4, 'x': 1}
>>> D.keys(), D.values(), D.has_key((1,2,3)) # Методы
(['w', 'z', 'y', (1, 2, 3), 'x'], [0, 3, 2, 4, 1], 1)
# Пустые объекты
>>> [[]], ["",[],(),{},None] # Множество пустых объектов
([[]], ['', [], (), {}, None])
2. Индексирование и извлечение среза. Если попытаться получить
доступ к элементу, индекс которого выходит за пределы списка (на
пример, L[4]), будет возбуждено исключение – интерпретатор все
гда проверяет выход за пределы последовательностей.
С другой стороны, операция извлечения среза с использованием
индексов, выходящих за пределы последовательности (например,
L[1000:100]), будет выполнена без ошибок, потому что интерпрета
тор Python всегда корректирует срезы, выходящие за пределы, так,
чтобы они соответствовали границам последовательности (пределы
устанавливаются равными нулю и длине последовательности, если
это необходимо).
Извлечение последовательности в обратном порядке, когда нижняя
граница больше верхней (например, L[3:1]), в действительности ра
ботать не будет. Вы получите пустой срез ([ ]), потому что интерпре
татор скорректирует границы среза так, чтобы нижняя граница
оказалась меньше или равна верхней границе (например, выраже
ние L[3:1] будет преобразовано в выражение L[3:3]– пустая позиция
со смещением 3). Срезы в языке Python всегда извлекаются слева
направо, даже при использовании отрицательных индексов (они
сначала будут преобразованы в положительные индексы за счет до
бавления длины последовательности). Обратите внимание, что в Py
thon 2.5 появились срезы с тремя пределами: выражение L[3:1:1]
на самом деле извлекает срез справа налево:
Решения упражнений 791
>>> L = [1, 2, 3, 4]
>>> L[4]
Traceback (innermost last):
File "<stdin>", line 1, in ?
IndexError: list index out of range
(IndexError: выход индекса за пределы списка)
>>> L[
1000:100]
[1, 2, 3, 4]
>>> L[3:1]
[]
>>> L
[1, 2, 3, 4]
>>> L[3:1] = ['?']
>>> L
[1, 2, 3, '?', 4]
3. Индексирование, извлечение среза и инструкция del. Сеанс взаимо
действия с интерпретатором должен выглядеть примерно так, как
показано ниже. Обратите внимание, что присваивание пустого спи
ска по указанному смещению приведет к сохранению объекта пус
того списка в этой позиции, но присваивание пустого списка срезу
приведет к удалению этого среза. Операция присваивания срезу
ожидает получить другую последовательность, в противном случае
будет получено сообщение о неверном типе операнда – она вставля
ет элементы, находящиеся внутри этой последовательности, а не
саму последовательность:
>>> L = [1,2,3,4]
>>> L[2] = []
>>> L
[1, 2, [], 4]
>>> L[2:3] = []
>>> L
[1, 2, 4]
>>> del L[0]
>>> L
[2, 4]
>>> del L[1:]
>>> L
[2]
>>> L[1:2] = 1
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: illegal argument type for builtin operation
(TypeError: неверный тип аргумента встроенной операции)
4. Кортежи. Значения X и Y поменяются местами. Когда слева и спра
ва от оператора присваивания (=) появляются кортежи, интерпрета
тор выполнит присваивание объектов справа объектам слева в соот
ветствии с их позициями. Это объяснение, пожалуй, самое простое
для понимания, хотя целевые объекты слева и не являются настоя
792 Приложение B
щим кортежем несмотря на то, что они именно так и выглядят, – это
просто набор независимых имен, которым выполняется присваива
ние. Элементы справа – это кортеж, который распаковывается в про
цессе выполнения операции присваивания (кортеж играет роль
временного хранилища присваиваемых данных, необходимого для
достижения эффекта обмена):
>>> X = 'spam'
>>> Y = 'eggs'
>>> X, Y = Y, X
>>> X
'eggs'
>>> Y
'spam'
5. Ключи словарей. В качестве ключа словаря может использоваться
любой неизменяемый объект, включая целые числа, кортежи, стро
ки и т. д. Это действительно словарь, несмотря на то, что некоторые
из его ключей выглядят как целочисленные смещения. Допускает
ся с одним и тем же словарем использовать ключи разных типов:
>>> D = {}
>>> D[1] = 'a'
>>> D[2] = 'b'
>>> D[(1, 2, 3)] = 'c'
>>> D
{1: 'a', 2: 'b', (1, 2, 3): 'c'}
6. Индексирование словарей. Извлечение элемента по несуществую
щему ключу (D['d']) приводит к появлению ошибки. Присваивание
по несуществующему ключу (D['d']='spam') создает новый элемент
словаря. С другой стороны, выход индекса за границы списка тоже
вызывает появление ошибки; ошибкой считается и присваивание
по индексу, выходящему за границы списка. Имена переменных на
поминают ключи словаря – прежде чем обратиться к переменным,
им необходимо присвоить значение. Имена переменных, если пона
добится, можно обрабатывать как ключи словарей (они становятся
видимы в пространстве имен модуля или в пределах словарей):
>>> D = {'a':1, 'b':2, 'c':3}
>>> D['a']
1
>>> D['d']
Traceback (innermost last):
File "<stdin>", line 1, in ?
KeyError: d
>>> D['d'] = 4
>>> D
{'b': 2, 'd': 4, 'a': 1, 'c': 3}
>>>
>>> L = [0, 1]
Решения упражнений 793
>>> L[2]
Traceback (innermost last):
File "<stdin>", line 1, in ?
IndexError: list index out of range
(IndexError: выход индекса за границы списка)
>>> L[2] = 3
Traceback (innermost last):
File "<stdin>", line 1, in ?
IndexError: list assignment index out of range
(IndexError: присваивание по индексу за границами списка)
7. Общие операции. Ответы на вопросы:
• Оператор + не работает с объектами разных типов (например,
строка + список, список + кортеж).
• Оператор + не работает со словарями, так как они не являются
последовательностями.
• Метод append может применяться только к спискам, но не к стро
кам, а метод keys может применяться только к словарям. Метод
append предполагает, что целевой объект является изменяемым,
поскольку изменяется сам объект; строки относятся к неизме
няемым типам.
• Операции извлечения среза и конкатенации всегда возвращают
новый объект того же типа, что и объектыоперанды.
>>> "x" + 1
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: illegal argument type for builtin operation
(TypeError: неверный тип аргумента встроенной операции)
>>>
>>> {} + {}
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: bad operand type(s) for +
(TypeError: неверный тип операнда(ов) для +)
>>>
>>> [].append(9)
>>> "".append('s')
Traceback (innermost last):
File "<stdin>", line 1, in ?
AttributeError: attributeless object
(AttributeError: объект без атрибутов)
>>>
>>> {}.keys()
[]
>>> [].keys()
Traceback (innermost last):
File "<stdin>", line 1, in ?
AttributeError: keys
(AttributeError: ключи)
794 Приложение B
>>>
>>> [][:]
[]
>>> ""[:]
''
8. Индексирование строк. Так как строки представляют собой кол
лекции односимвольных строк, каждый раз, когда извлекается
элемент строки, возвращается строка, из которой также допускает
ся извлекать элементы по индексам. Выражение S[0][0][0][0][0]
всего лишь извлекает первый символ снова и снова. Этот прием не
применим к спискам (списки могут хранить объекты произволь
ных типов), если список не содержит строки:
>>> S = "spam"
>>> S[0][0][0][0][0]
's'
>>> L = ['s', 'p']
>>> L[0][0][0]
's'
9. Неизменяемые типы. Правильными являются оба следующих ре
шения. Присваивание по индексу недопустимо, потому что строки
являются неизменяемыми объектами:
>>> S = "spam"
>>> S = S[0] + 'l' + S[2:]
>>> S
'slam'
>>> S = S[0] + 'l' + S[2] + S[3]
>>> S
'slam'
10. Вложенные структуры. Ниже приводится пример такой структуры:
>>> me = {'name':('mark', 'e', 'lutz'), 'age':'?', 'job':'engineer'}
>>> me['job']
'engineer'
>>> me['name'][2]
'lutz'
11. Файлы. Ниже приводится пример одного из способов создания фай
ла и чтения информации из него в языке Python (ls – это команда
UNIX, в Windows вместо нее следует использовать команду dir):
# Файл: maker.py
file = open('myfile.txt', 'w')
file.write('Hello file world!\n') # Или: open().write()
file.close() # закрывать файл не всегда обязательно
# Файл: reader.py
file = open('myfile.txt') # 'r'  режим открытия по умолчанию
print file.read() # Или print open().read()
Решения упражнений 795
% python maker.py
% python reader.py
Hello file world!
% ls 
l myfile.txt
rwxrwxrwa 1 0 0 19 Apr 13 16:33 myfile.txt
12. Функция dir. Ниже показано, что будет получено в случае списков.
Для словарей будет получена та же информация, но имена методов
будут другими. Обратите внимание, действие функции dir в Py
thon 2.2 было расширено – она дополнительно выводит имена, на
чинающиеся и заканчивающиеся символами подчеркивания, кото
рые реализуют операторы выражений и могут быть унаследованы
подклассами, как описывается в шестой части книги. Атрибут
__methods__ был удален в версии Python 2.2 изза его противоречи
вой реализации – используйте вместо него функцию dir для извле
чения списка атрибутов:
>>> [].__methods__
['append', 'count', 'index', 'insert', 'remove', 'reverse', 'sort',...]
>>> dir([])
['append', 'count', 'index', 'insert', 'remove', 'reverse', 'sort',...]
Часть III. Инструкции и синтаксис
Упражнения находятся в главе 14, в разделе «Упражнения к третьей
части».
1. Основы циклов. При выполнении этого упражнения вы получите
примерно такой программный код:
>>> S = 'spam'
>>> for c in S:
... print ord(c)
...
115
112
97
109
>>> x = 0
>>> for c in S: x += ord(c) # Или: x = x + ord(c)
...
>>> x
433
>>> x = []
>>> for c in S: x.append(ord(c))
...
>>> x
[115, 112, 97, 109]
>>> map(ord, S)
[115, 112, 97, 109]
796 Приложение B
2. Символы обратного слеша. Пример выводит символ подачи звуко
вого сигнала (\a) 50 раз – здесь предполагается, что ваш компьютер
в состоянии воспроизвести его, поэтому при запуске этого фрагмен
та не под управлением IDLE вы можете получить серию звуковых
сигналов (или один длинный сигнал, если ваш компьютер обладает
достаточно высоким быстродействием). Эй! Я предупреждал вас!
3. Сортировка словарей. Ниже приводится один из возможных вари
антов решения этого упражнения (вернитесь к главе 8, если чтото
показалось вам непонятным). Не забывайте, что вам необходимо
разделить вызовы методов keys и sort, как это сделано здесь, потому
что метод sort возвращает объект None. Начиная с версии Python 2.2
появилась возможность организовать итерации по ключам словаря
без вызова метода keys (например, for key in D:), но ключи не будут
отсортированы этим программным кодом. В самых свежих версиях
Python того же эффекта можно добиться с помощью встроенной
функции sorted:
>>> D = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5, 'f':6, 'g':7}
>>> D
{'f': 6, 'c': 3, 'a': 1, 'g': 7, 'e': 5, 'd': 4, 'b': 2}
>>>
>>> keys = D.keys()
>>> keys.sort()
>>> for key in keys:
... print key, '=>', D[key]
...
a => 1
b => 2
c => 3
d => 4
e => 5
f => 6
g => 7
>>> for key in sorted(D): # В наиболее свежих версиях Pythons
... print key, '=>', D[key]
4. Программирование альтернативной логики. Ниже приводятся не
сколько вариантов решения этого упражнения. Ваши решения мо
гут несколько отличаться – цель этого упражнения состоит в том,
чтобы дать вам возможность поэкспериментировать с созданием
альтернативных ветвей исполнения программы, поэтому приветст
вуются любые правильные решения:
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
i = 0
while i < len(L):
if 2 ** X == L[i]:
print 'at index', i
Решения упражнений 797
break
i = i+1
else:
print X, 'not found'
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
for p in L:
if (2 ** X) == p:
print (2 ** X), 'was found at', L.index(p)
break
else:
print X, 'not found'
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
if (2 ** X) in L:
print (2 ** X), 'was found at', L.index(2 ** X)
else:
print X, 'not found'
X = 5
L = []
for i in range(7): L.append(2 ** i)
print L
if (2 ** X) in L:
print (2 ** X), 'was found at', L.index(2 ** X)
else:
print X, 'not found'
X = 5
L = map(lambda x: 2**x, range(7))
print L
if (2 ** X) in L:
print (2 ** X), 'was found at', L.index(2 ** X)
else:
print X, 'not found'
Часть IV. Функции
Упражнения находятся в главе 17, в разделе «Упражнения к четвер
той части».
1. Основы. В этом упражнении нет ничего сложного, но обратите вни
мание на то, что инструкция print (а следовательно, и ваша функ
ция) с технической точки зрения является полиморфической опера
цией, которая правильно интерпретирует типы всех объектов:
% python
>>> def func(x): print x
...
798 Приложение B
>>> func("spam")
spam
>>> func(42)
42
>>> func([1, 2, 3])
[1, 2, 3]
>>> func({'food': 'spam'})
{'food': 'spam'}
2. Аргументы. Ниже приводится пример решения. Не забывайте, что
для вывода результата необходимо использовать инструкцию print,
потому что выполнение программного кода в модуле – это совсем не
то же самое, что выполнение программного кода, который вводится
в интерактивной оболочке, – интерпретатор не выводит автомати
чески результаты выражений, вычисляемых в файлах модулей:
def adder(x, y):
return x + y
print adder(2, 3)
print adder('spam', 'eggs')
print adder(['a', 'b'], ['c', 'd'])
% python mod.py
5
spameggs
['a', 'b', 'c', 'd']
3. Переменное число аргументов. В следующем файле adder.py пока
заны два варианта реализации функции adder. Самое сложное здесь
заключается в инициализации значения суммы пустым значением
в зависимости от типа передаваемых аргументов. Первое решение
выясняет, является ли первый аргумент целым числом, и извлека
ет пустой срез первого аргумента (предполагается, что он является
последовательностью), если он не является целым числом. Во вто
ром решении в качестве начального значения используется первый
аргумент, а затем выполняется сканирование аргументов, начиная
со второго, почти как в одном из вариантов функции min, показан
ной в главе 16.
Второе решение является более предпочтительным. Но в обоих ва
риантах предполагается, что все аргументы принадлежат к одному
и тому же типу, а, кроме того, предполагается, что функция не бу
дет работать со словарями (как мы видели во второй части книги,
оператор + не работает с операндами разных типов и со словарями).
Вы можете добавить проверку типа аргументов и предусмотреть
специальный программный код для обработки словарей, за что вам
причитаются дополнительные баллы:
def adder1(*args):
print 'adder1',
if type(args[0]) == type(0): # Целое число?
Решения упражнений 799
sum = 0 # Инициализировать нулем
else: # иначе  последовательность:
sum = args[0][:0] # Использовать пустой срез первого аргумента
for arg in args:
sum = sum + arg
return sum
def adder2(*args):
print 'adder2',
sum = args[0] # Инициализировать значением первого аргумента
for next in args[1:]:
sum += next # Прибавить аргументы 2..N
return sum
for func in (adder1, adder2):
print func(2, 3, 4)
print func('spam', 'eggs', 'toast')
print func(['a', 'b'], ['c', 'd'], ['e', 'f'])
% python adders.py
adder1 9
adder1 spameggstoast
adder1 ['a', 'b', 'c', 'd', 'e', 'f']
adder2 9
adder2 spameggstoast
adder2 ['a', 'b', 'c', 'd', 'e', 'f']
4. Передача аргументов по ключу. Ниже приводится мое решение
первой части этого упражнения (файл mod.py). Для обхода аргумен
тов, передаваемых по ключу, в заголовке функции следует исполь
зовать форму списка аргументов **args и цикл в теле функции (на
пример, for x in args.keys(): и использовать args[x]) или использо
вать args.values(), чтобы реализовать сложение по позициям аргу
ментов в списке *args:
def adder(good=1, bad=2, ugly=3):
return good + bad + ugly
print adder()
print adder(5)
print adder(5, 6)
print adder(5, 6, 7)
print adder(ugly=7, good=6, bad=5)
% python mod.py
6
10
14
18
18
5. (и 6.) Ниже приводится мое решение упражнений 5 и 6 (файл
dicts.py). Однако это решение пригодно только в качестве упражне
ния, потому что в Python 1.5 у словарей появились методы D.copy()
800 Приложение B
и D1.update(D2), которые реализуют операции копирования и сложе
ние (слияние) словарей. (За дополнительной информацией обращай
тесь к справочному руководству по библиотеке Python или к книге
«Python Pocket Reference», выпущенной издательством O’Reilly.)
Операция извлечения среза X[:] не применима к словарям, потому
что они не являются последовательностями (подробности в главе 8).
Кроме того, не забывайте, что в случае присваивания (e = d) просто
создается вторая ссылка на один и тот же объект словаря – измене
ния в словаре d будут приводить к изменениям в словаре e:
def copyDict(old):
new = {}
for key in old.keys():
new[key] = old[key]
return new
def addDict(d1, d2):
new = {}
for key in d1.keys():
new[key] = d1[key]
for key in d2.keys():
new[key] = d2[key]
return new
% python
>>> from dicts import *
>>> d = {1: 1, 2: 2}
>>> e = copyDict(d)
>>> d[2] = '?'
>>> d
{1: 1, 2: '?'}
>>> e
{1: 1, 2: 2}
>>> x = {1: 1}
>>> y = {2: 2}
>>> z = addDict(x, y)
>>> z
{1: 1, 2: 2}
6. Дополнительные примеры на сопоставление аргументов. Ниже
приводится пример диалога с интерактивной оболочкой, который
вы должны получить в ходе выполнения этого упражнения, с неко
торыми комментариями, поясняющими порядок сопоставления ар
гументов:
def f1(a, b): print a, b # Обычные аргументы
def f2(a, *b): print a, b # Сопоставление выполняется по позиции
def f3(a, **b): print a, b # Сопоставление выполняется по ключам
def f4(a, *b, **c): print a, b, c # Смешанный режим
Решения упражнений 801
def f5(a, b=2, c=3): print a, b, c # Аргументы со значениями по умолчанию
def f6(a, b=2, *c): print a, b, c # Аргументы по умолчанию и позиционные
% python
>>> f1(1, 2) # Сопоставление по позиции (важен порядок)
1 2
>>> f1(b=2, a=1) # Сопоставление по имени (порядок не важен)
1 2
>>> f2(1, 2, 3) # Дополнительные аргументы объединяются
1 (2, 3) # в кортеж
>>> f3(1, x=2, y=3) # Дополнительные ключи объединяются
1 {'x': 2, 'y': 3} # в словарь
>>> f4(1, 2, 3, x=2, y=3) # Дополнительные аргументы обоих типов
1 (2, 3) {'x': 2, 'y': 3}
>>> f5(1) # Два последних аргумента получают
1 2 3 # значения по умолчанию
>>> f5(1, 4) # Используется только одно значение
1 4 3 # по умолчанию
>>> f6(1) # Один аргумент: соответствует имени "a"
1 2 ()
>>> f6(1, 3, 4) # Дополнительный позиционный аргумент
1 3 (4,) # собирается в кортеж
7. Снова простые числа. Ниже приводится пример нахождения про
стых чисел, оформленный в виде функции в модуле (файл primes.py),
которую можно вызывать несколько раз. Я добавил проверку, чтобы
отсечь отрицательные числа, 0 и 1. Кроме того, я заменил оператор /
на //, чтобы это решение правильно работало в Python 3.0, где будут
внесены изменения в действие оператора /, о чем рассказывалось
в главе 5, и чтобы добавить поддержку чисел с плавающей точкой.
В настоящее время в решении можно использовать как оператор //,
так и оператор /, но в будущем оператор / будет завершаться ошиб
кой (раскомментируйте инструкцию from и замените оператор // на /
, чтобы увидеть разницу между версиями Python 2.2 и 3.0):
#from __future__ import division
def prime(y):
if y <= 1: # У некоторых может быть y > 1
print y, 'not prime'
else:
x = y // 2 # В будущем / будет терпеть неудачу
while x > 1:
if y % x == 0: # нет остатка?
print y, 'has factor', x
break # Обойти ветку else
x = 1
802 Приложение B
else:
print y, 'is prime'
prime(13); prime(13.0)
prime(15); prime(15.0)
prime(3); prime(2)
prime(1); prime(3)
Далее приводится пример работы модуля. Оператор // позволяет
модулю работать с вещественными числами тоже, хотя этого быть
не должно.
% python primes.py
13 is prime
13.0 is prime
15 has factor 5
15.0 has factor 5.0
3 is prime
2 is prime
1 not prime
3 not prime
Эта функция все еще не слишком пригодна к многократному ис
пользованию – вместо вывода результата она могла бы возвращать
значения, но для экспериментов вполне достаточно и такой реали
зации. Кроме того, она не строго соответствует математическому
определению простых чисел, которыми могут быть только целые
числа, и не обладает достаточной эффективностью. Эти улучшения
я оставляю для самостоятельной реализации читателям, склонным
к математике. Подсказка: цикл for через range(y, 1, 1) будет вы
полняться немного быстрее, чем цикл while (на самом деле, в Py
thon 2.2 скорость увеличивается почти в два раза), но самым узким
местом здесь является сам алгоритм. Для измерения производи
тельности альтернативных реализаций воспользуйтесь встроенным
модулем time и отрывком кода, подобным следующей универсаль
ной функции timer (за дополнительной информацией обращайтесь
к справочному руководству по библиотеке):
def timer(reps, func, *args):
import time
start = time.clock()
for i in xrange(reps):
apply(func, args)
return time.clock()  start
8. Генераторы списков. Ниже приводится вариант программного ко
да, который должен получиться у вас, – у меня есть свои предпочте
ния, но я о них умолчу:
>>> values = [2, 4, 9, 16, 25]
>>> import math
>>> res = []
Решения упражнений 803
>>> for x in values: res.append(math.sqrt(x))
...
>>> res
[1.4142135623730951, 2.0, 3.0, 4.0, 5.0]
>>> map(math.sqrt, values)
[1.4142135623730951, 2.0, 3.0, 4.0, 5.0]
>>> [math.sqrt(x) for x in values]
[1.4142135623730951, 2.0, 3.0, 4.0, 5.0]
Часть V. Модули
Упражнения находятся в главе 21, в разделе «Упражнения к пятой
части».
1. Основы импортирования. Решение этого упражнения выглядит го
раздо проще, чем можно было бы подумать. Когда вы закончите,
у вас должен получиться файл (mymod.py) и сеанс взаимодействия
с интерактивной оболочкой, как показано ниже. Не забывайте, что
интерпретатор Python moжет читать содержимое файла целиком
в список строк, а получить длину каждой строки в списке можно
с помощью встроенной функции len:
def countLines(name):
file = open(name)
return len(file.readlines())
def countChars(name):
return len(open(name).read())
def test(name): # Или передать объект файла
return countLines(name), countChars(name) # Или вернуть словарь
% python
>>> import mymod
>>> mymod.test('mymod.py')
(10, 291)
Обратите внимание, что эти функции читают файл в память цели
ком и потому не в состоянии работать с патологически большими
файлами, которые не смогут уместиться в памяти компьютера. Что
бы обеспечить более высокую устойчивость, можно организовать
построчное чтение содержимого файла с помощью итератора и на
капливать длины строк в ходе итераций:
def countLines(name):
tot = 0
for line in open(name): tot += 1
return tot
def countChars(name):
tot = 0
804 Приложение B
for line in open(name): tot += len(line)
return tot
В операционной системе UNIX полученный результат можно про
верить с помощью команды wc. В Windows можно щелкнуть на фай
ле правой кнопкой мыши и посмотреть его свойства. Обратите вни
мание, что результат, возвращаемый сценарием, может несколько
отличаться от того, что сообщает Windows, – с целью обеспечения
переносимости интерпретатор Python преобразует пары символов
\r\n, отмечающих конец каждой строки, в один символ \n, в резуль
тате чего теряется по одному байту на каждую строку. Чтобы ре
зультат сценария в точности соответствовал тому, что сообщает
Windows, файл необходимо открыть в режиме двоичного доступа
('rb') или прибавлять к общему результату число строк.
Чтобы реализовать часть упражнения «для честолюбивых» (пере
давать функциям объект файла, чтобы открывать его приходилось
всего один раз), вам, скорее всего, придется использовать метод seek
объекта файла. Мы не рассматривали этот метод в книге, но он ра
ботает точно так же, как функция fseek в языке C (которая, собст
венно, и вызывается внутренней реализацией метода): метод seek
переустанавливает текущую позицию в файле в указанное смеще
ние. После вызова метода seek последующие операции ввода/выво
да будут выполняться относительно новой позиции. Чтобы пере
меститься в начало файла, не закрывая и не открывая его повторно,
можно вызвать метод file.seek(0); все вызовы метода read выполня
ют чтение из текущей позиции в файле, поэтому, чтобы начать по
вторное чтение, необходимо переместить текущую позицию в нача
ло файла. Ниже показано, как может выглядеть такая реализация:
def countLines(file):
file.seek(0) # Переместиться в начало файла
return len(file.readlines())
def countChars(file):
file.seek(0) # То же самое(переместиться в начало)
return len(file.read())
def test(name):
file = open(name) # Передать объект файла
return countLines(file), countChars(file) # Открыть файл один раз
>>> import mymod2
>>> mymod2.test("mymod2.py")
(11, 392)
2. from/from *. Ниже приводится решение в части использования инст
рукции вида from *. Чтобы выполнить вторую часть упражнения,
замените * именем countChars:
% python
>>> from mymod import *
Решения упражнений 805
>>> countChars("mymod.py")
291
3. __main__. Если вы не допустили ошибок в модуле, он сможет рабо
тать в любом из режимов (в режиме самостоятельной программы
или в режиме импортируемого модуля):
def countLines(name):
file = open(name)
return len(file.readlines())
def countChars(name):
return len(open(name).read())
def test(name): # Или передать объект файла
return countLines(name), countChars(name) # Или вернуть словарь
if __name__ == '__main__':
print test('mymod.py')
% python mymod.py
(13, 346)
4. Вложенное импортирование. Ниже представлено мое решение
(файл myclient.py):
from mymod import countLines, countChars
print countLines('mymod.py'), countChars('mymod.py')
% python myclient.py
13 346
Что касается остальной части этого упражнения, функции модуля
mymod доступны (то есть были импортированы) на верхнем уровне мо
дуля myclient, потому что инструкция from просто присваивает их
именам в импортирующем модуле (выглядит так, как если бы опре
деления функций def находились в модуле myclient). Например, в сле
дующем файле приводится альтернативный вариант реализации:
import myclient
myclient.countLines(...)
from myclient import countChars
countChars(...)
Если бы в модуле myclient вместо инструкции from использовалась
инструкция import, вам пришлось бы использовать полные имена
функций из модуля mymod:
import myclient
myclient.mymod.countLines(...)
from myclient import mymod
mymod.countChars(...)
Вообще говоря, можно определить модуль+коллектор, который будет
импортировать все имена из других модулей, чтобы сделать их дос
806 Приложение B
тупными в виде единого модуля. Если воспользоваться следующим
программным кодом, вы покончите с тремя разными копиями имени
somename (mod1.somename, collector.somename и __main__.somename) – все
три имени изначально будут ссылаться на один и тот же объект це
лого числа, а в интерактивной оболочке будет существовать только
одно имя somename:
# Файл: mod1.py
somename = 42
# Файл: collector.py
from mod1 import * # Выборка всех имен переменных
from mod2 import * # из инструкций присваивания и превращение их
from mod3 import * # в собственные имена этого модуля
>>> from collector import somename
5. Импорт пакетов. Для этого упражнения я поместил файл mymod.py
из упражнения 3 в каталог пакета. Далее описываются мои действия
по настройке каталога и необходимого файла __init__.py в консоли
Windows – вы должны учитывать особенности своей платформы
(например, использовать команды mv и vi вместо move и edit). Эти
действия можно выполнять в любом произвольном каталоге (про
сто так вышло, что я запускал команды, находясь в каталоге, куда
был установлен Python), частично эти действия можно выполнить
в проводнике файловой системы с графическим интерфейсом.
По окончании я получил подкаталог mypkg, содержащий файлы
__init__.py и mymod.py. В каталоге mypkg обязательно должен нахо
диться файл __init__.py, но его наличие в родительском каталоге не
обязательно. Каталог mypkg находится в домашнем каталоге, в пути
поиска модулей. Обратите внимание, что инструкция print в ини
циализационном файле выполняется только при первой операции
импорта:
C:\python25> mkdir mypkg
C:\Python25> move mymod.py mypkg\mymod.py
C:\Python25> edit mypkg\__init__.py
...добавление инструкции print...
C:\Python25> python
>>> import mypkg.mymod
initializing mypkg
>>> mypkg.mymod.countLines('mypkg\mymod.py')
13
>>> from mypkg.mymod import countChars
>>> countChars('mypkg\mymod.py')
346
6. Повторная загрузка. В этом упражнении вам просто предлагает
поэкспериментировать с возможностью повторной загрузки модуля
changer.py из примера в книге, поэтому мне нечего показать здесь.
Решения упражнений 807
7. Циклический импорт. Суть в том, что, когда первым импортируется
модуль recur2, ситуация рекурсивного импорта возникает в инструк
ции import в модуле recur1, а не в инструкции from в модуле recur2.
Если говорить более подробно, все происходит следующим образом:
когда модуль recur2 импортируется первым, в результате рекурсив
ного импорта модуля recur2 из модуля recur1 модуль recur2 извлека
ется целиком. К моменту, когда модуль recur2 импортируется моду
лем recur1, его пространство имен еще не заполнено, но так как им
портирование выполняется инструкцией import, а не инструкцией
from, никаких проблем не возникает: интерпретатор отыскивает
и возвращает уже созданный объект модуля recur2 и продолжает
выполнять оставшуюся часть модуля recur1 без сбоев. Когда импорт
в модуле recur2 возобновляется, вторая инструкция from обнаружи
вает в модуле recur1 имя Y (модуль был выполнен полностью), по
этому в такой ситуации не возникает ошибок. Запуск файла как от
дельного сценария – это не то же самое, что импортирование его
в виде модуля: это равноценно интерактивному выполнению первой
инструкции import или from в сценарии. Например, запуск модуля
recur1 как сценария равносилен предварительному импортирова
нию модуля recur2 в интерактивной оболочке, поскольку recur2 –
это первый модуль, импортируемый в recur1.
Часть VI. Классы и ООП
Упражнения находятся в главе 26, в разделе «Упражнения к шестой
части».
1. Наследование. Ниже приводится решение этого упражнения (файл
adder.py) вместе с несколькими примерами действий в интерактив
ной оболочке. Метод перегрузки оператора __add__ присутствует
только в суперклассе и вызывает конкретные методы add, опреде
ляемые подклассами:
class Adder:
def add(self, x, y):
print 'not implemented!'
def __init__(self, start=[]):
self.data = start
def __add__(self, other): # Или в подклассах?
return self.add(self.data, other) # Или возвращать тип?
class ListAdder(Adder):
def add(self, x, y):
return x + y
class DictAdder(Adder):
def add(self, x, y):
new = {}
for k in x.keys(): new[k] = x[k]
for k in y.keys(): new[k] = y[k]
808 Приложение B
return new
% python
>>> from adder import *
>>> x = Adder()
>>> x.add(1, 2)
not implemented!
>>> x = ListAdder()
>>> x.add([1], [2])
[1, 2]
>>> x = DictAdder()
>>> x.add({1:1}, {2:2})
{1: 1, 2: 2}
>>> x = Adder([1])
>>> x + [2]
not implemented!
>>>
>>> x = ListAdder([1])
>>> x + [2]
[1, 2]
>>> [2] + x
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: __add__ nor __radd__ defined for these operands
(TypeError: ни __add__, ни __radd__ не определен для этих операндов)
Обратите внимание, что в последнем тесте возникла ошибка при по
пытке использовать экземпляр класса справа от оператора +. Если
вы захотите исправить эту ошибку, реализуйте метод __radd__, как
описывается в главе 24, в разделе «Перегрузка операторов».
Если вы начнете сохранять текущее значение в экземпляре, вы мо
жете также переписать метод add, чтобы он принимал единствен
ный аргумент, в духе других примеров из шестой части:
class Adder:
def __init__(self, start=[]):
self.data = start
def __add__(self, other): # Передается единственный аргумент
return self.add(other) # Операнд слева хранится в self
def add(self, y):
print 'not implemented!'
class ListAdder(Adder):
def add(self, y):
return self.data + y
class DictAdder(Adder):
def add(self, y):
pass # Измените, чтобы использовать self.data вместо x
x = ListAdder([1, 2 ,3])
y = x + [4, 5, 6]
print y # Выведет [1, 2, 3, 4, 5, 6]
Решения упражнений 809
Поскольку значения присоединяются к самим объектам, а не пере
даются в виде аргументов, эта версия определенно является более
объектноориентированной. И как только вы доберетесь до этого мо
мента, вы наверняка обнаружите, что вообще можно избавиться от
методов add и просто определить методы __add__ в двух подклассах.
2. Перегрузка операторов. В программном коде решения (файл myl+
ist.py) используется несколько методов перегрузки операторов, о ко
торых в книге рассказывается не слишком много, однако в них нет
ничего сложного. Операция копирования начального значения
в конструкторе имеет большое значение, потому что оно может быть
представлено изменяемым объектом – едва ли есть разумная причи
на, чтобы изменять или обладать ссылкой на объект, который,
вполне возможно, используется гдето за пределами класса. Метод
__getattr__ перехватывает попытки обращения к обернутому спи
ску. Подсказки, которые помогут упростить реализацию, вы найде
те в разделе «Расширение типов наследованием» в главе 26:
class MyList:
def __init__(self, start):
#self.wrapped = start[:] # Скопировать start:
# без побочных эффектов
self.wrapped = [] # Убедиться, что это список
for x in start: self.wrapped.append(x)
def __add__(self, other):
return MyList(self.wrapped + other)
def __mul__(self, time):
return MyList(self.wrapped * time)
def __getitem__(self, offset):
return self.wrapped[offset]
def __len__(self):
return len(self.wrapped)
def __getslice__(self, low, high):
return MyList(self.wrapped[low:high])
def append(self, node):
self.wrapped.append(node)
def __getattr__(self, name): # Другие члены: sort/reverse/и т. д.
return getattr(self.wrapped, name)
def __repr__(self):
return repr(self.wrapped)
if __name__ == '__main__':
x = MyList('spam')
print x
print x[2]
print x[1:]
print x + ['eggs']
print x * 3
x.append('a')
x.sort()
for c in x: print c,
810 Приложение B
% python mylist.py
['s', 'p', 'a', 'm']
a
['p', 'a', 'm']
['s', 'p', 'a', 'm', 'eggs']
['s', 'p', 'a', 'm', 's', 'p', 'a', 'm', 's', 'p', 'a', 'm']
a a m p s
Обратите внимание, насколько важно копировать начальное значе
ние, выполняя добавление в конец вместо извлечения среза, потому
что в противном случае может получиться объект, не являющийся
списком и потому не обладающий методами списка, такими как ap
pend (например, операция извлечения среза строки возвращает дру
гую строку, но не список). Если бы начальное значение было объек
том типа MyList, можно было бы выполнить копирование с помощью
операции извлечения среза, потому что этот класс перегружает эту
операцию и обеспечивает ожидаемый интерфейс списков. Однако
для других объектов, таких как строки, следует избегать использо
вания операции извлечения среза. Кроме того, следует заметить,
что на сегодняшний день тип множества стал встроенным типом
в языке Python, поэтому цель данного упражнения в значительной
степени заключается в том, чтобы просто дать возможность попрак
тиковаться (подробнее о множествах рассказывается в главе 5).
3. Подклассы. Мое решение (файл mysub.py) приводится ниже. Ваше
решение должно быть похожим:
from mylist import MyList
class MyListSub(MyList):
calls = 0 # Используется всеми экземплярами
def __init__(self, start):
self.adds = 0 # Свой для каждого экземпляра
MyList.__init__(self, start)
def __add__(self, other):
MyListSub.calls = MyListSub.calls + 1 # Счетчик, единый для класса
self.adds = self.adds + 1 # Подсчет экземпляров
return MyList.__add__(self, other)
def stats(self):
return self.calls, self.adds # All adds, my adds
if __name__ == '__main__':
x = MyListSub('spam')
y = MyListSub('foo')
print x[2]
print x[1:]
print x + ['eggs']
print x + ['toast']
print y + ['bar']
print x.stats()
Решения упражнений 811
% python mysub.py
a
['p', 'a', 'm']
['s', 'p', 'a', 'm', 'eggs']
['s', 'p', 'a', 'm', 'toast']
['f', 'o', 'o', 'bar']
(3, 2)
4. Методы метакласса. Я решил это упражнение, как показано ни
же. Обратите внимание, что операторы будут извлекать атрибуты
с помощью метода __getattr__ – он должен возвращать значение,
чтобы операторы могли работать:
>>> class Meta:
... def __getattr__(self, name):
... print 'get', name
... def __setattr__(self, name, value):
... print 'set', name, value
...
>>> x = Meta()
>>> x.append
get append
>>> x.spam = "pork"
set spam pork
>>>
>>> x + 2
get __coerce__
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: call of nonfunction
(TypeError: попытка вызова объекта, не являющегося функцией)
>>>
>>> x[1]
get __getitem__
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: call of nonfunction
(TypeError: попытка вызова объекта, не являющегося функцией)
>>> x[1:5]
get __len__
Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: call of nonfunction
(TypeError: попытка вызова объекта, не являющегося функцией)
5. Объекты множеств. Ниже приводится сеанс взаимодействия, ко
торый должен у вас получиться. Комментарии описывают, какие
методы вызываются.
% python
>>> from setwrapper import Set
>>> x = Set([1, 2, 3, 4]) # Вызывается __init__
812 Приложение B
>>> y = Set([3, 4, 5])
>>> x & y # __and__, intersect, затем __repr__
Set:[3, 4]
>>> x | y # __or__, union, затем __repr__
Set:[1, 2, 3, 4, 5]
>>> z = Set("hello") # __init__ удаляет повторяющиеся символы
>>> z[0], z[
1] # __getitem__
('h', 'o')
>>> for c in z: print c, # __getitem__
...
h e l o
>>> len(z), z # __len__, __repr__
(4, Set:['h', 'e', 'l', 'o'])
>>> z & "mello", z | "mello"
(Set:['e', 'l', 'o'], Set:['h', 'e', 'l', 'o', 'm'])
Мой расширенный подкласс, позволяющий обрабатывать сразу не
сколько операндов, приводится ниже (файл multiset.py). В нем по
требовалось изменить всего два метода из оригинального набора.
Строка документирования в классе поясняет принцип его действия:
from setwrapper import Set
class MultiSet(Set):
"""
Наследует все атрибуты класса Set, но расширяет методы intersect
и union, добавляя возможность обработки нескольких операндов;
обратите внимание, что "self" – попрежнему первый аргумент
(теперь сохраняется в списке аргументов *args). Кроме того,
обратите внимание, что теперь унаследованные операторы & и |
вызывают новые методы с двумя аргументами, но для одновременной
обработки более чем 2 операндов требуется вызов метода,
а не выражения:
"""
def intersect(self, *others):
res = []
for x in self: # Сканировать первую последовть
for other in others: # Для всех остальных аргументов
if x not in other: break # Элемент присутствует во всех?
else: # Нет: прервать цикл
res.append(x) # Да: добавить элемент в конец
return Set(res)
def union(*args): # Self  args[0]
res = []
for seq in args: # Для всех аргументов
for x in seq: # Для всех узлов
if not x in res:
res.append(x) # Добавить новый элемент в результат
return Set(res)
Решения упражнений 813
Ваш сеанс взаимодействия с интерактивной оболочкой должен вы
глядеть примерно так, как показано ниже. Обратите внимание, что
пересечение двух множеств можно находить как с помощью опера
тора &, так и с помощью метода intersect, но для случая трех и более
множеств обязательно нужно вызывать метод intersect – оператор &
является двухместным. Кроме того, обратите внимание, что можно
было класс MultiSet назвать просто Set, чтобы сделать это изменение
более прозрачным, если бы в файле multiset в качестве имени насле
дуемого класса мы использовали полное имя setwrapper.Set:
>>> from multiset import *
>>> x = MultiSet([1,2,3,4])
>>> y = MultiSet([3,4,5])
>>> z = MultiSet([0,1,2])
>>> x & y, x | y # Два операнда
(Set:[3, 4], Set:[1, 2, 3, 4, 5])
>>> x.intersect(y, z) # Три операнда
Set:[]
>>> x.union(y, z)
Set:[1, 2, 3, 4, 5, 0]
>>> x.intersect([1,2,3], [2,3,4], [1,2,3]) # Четыре операнда
Set:[2, 3]
>>> x.union(range(10)) # Два операнда также допустимы
Set:[1, 2, 3, 4, 0, 5, 6, 7, 8, 9]
6. Связи в дереве классов. Ниже показано, как я изменил класс Lister,
и результат повторного запуска теста. Чтобы дополнительно ото
бразить унаследованные атрибуты, необходимо реализовать метод,
аналогичный текущему методу attrnames, и предусмотреть в нем ре
курсивный обход ссылок __bases__ в каждом классе. Поскольку, на
чиная с версии Python 2.2, функция dir включает в результат унас
ледованные атрибуты, можно было бы просто организовать цикл
по ее результатам: например, for x in dir(self) и использовать
getattr(self,x). Однако такой прием не поможет, если вам потребу
ется вывести структуру дерева классов (как в примере classtree.py
в главе 24):
class Lister:
def __repr__(self):
return ("<Instance of %s(%s), address %s:\n%s>" %
(self.__class__.__name__, # Имя моего класса
self.supers(), # Мои суперклассы
id(self), # Мой адрес
self.attrnames()) ) # список name=value
def attrnames(self):
...не изменился...
def supers(self):
result = ""
first = 1
for super in self.__class__.__bases__: # Вверх на один уровень
814 Приложение B
if not first:
result = result + ", "
first = 0
result = result + super.__name__ # имя, не repr(super)
return result
C:\python\examples> python testmixin.py
<Instance of Sub(Super, Lister), address 7841200:
name data3=42
name data2=eggs
name data1=spam
>
7. Композиция. Мое решение с комментариями, взятыми из описания,
приводится ниже (файл lunch.py). Это один из случаев, когда свою
мысль проще выразить на языке Python, чем на естественном языке:
class Lunch:
def __init__(self): # Создать/встроить Customer и Employee
self.cust = Customer()
self.empl = Employee()
def order(self, foodName): # Начать имитацию оформления заказа
self.cust.placeOrder(foodName, self.empl)
def result(self): # Узнать у клиента название блюда
self.cust.printFood()
class Customer:
def __init__(self): # Инициализировать блюдо значением None
self.food = None
def placeOrder(self, foodName, employee): # Передать заказ официанту
self.food = employee.takeOrder(foodName)
def printFood(self): # Вывести название блюда
print self.food.name
class Employee:
def takeOrder(self, foodName): # Вернуть блюдо с требуемым названием
return Food(foodName)
class Food:
def __init__(self, name): # Сохранить название блюда
self.name = name
if __name__ == '__main__':
x = Lunch() # Программный код самопроверки
x.order('burritos') # Если запускается как сценарий,
x.result() # а не импортируется как модуль
x.order('pizza')
x.result()
% python lunch.py
burritos
pizza
8. Классификация животных в зоологии. Ниже приводится мой спо
соб реализации классификации животных на языке Python (файл
Решения упражнений 815
zoo.py); этот пример достаточно искусственный, но сам принцип
применим ко многим реальным ситуациям, начиная от реализации
графического интерфейса и заканчивая базами данных сотрудни
ков. Обратите внимание, что в классе Animal выполняется обраще
ние к методу self.speak, это приводит к выполнению независимого
поиска метода speak в дереве наследования, начиная с подкласса.
Протестируйте работу этого дерева классов, следуя описанию уп
ражнения. Попробуйте дополнить эту иерархию новыми классами
и создать экземпляры различных классов в дереве:
class Animal:
def reply(self): self.speak() # Вызов метода подкласса
def speak(self): print 'spam' # Собственное сообщение
class Mammal(Animal):
def speak(self): print 'huh?'
class Cat(Mammal):
def speak(self): print 'meow'
class Dog(Mammal):
def speak(self): print 'bark'
class Primate(Mammal):
def speak(self): print 'Hello world!'
class Hacker(Primate): pass # Наследует класс Primate
9. Сценка с мертвым попугаем. Ниже приводится мое решение этого
упражнения (файл parrot.py). Обратите внимание на то, как работа
ет метод line в суперклассе Actor: он дважды обращается к атрибу
там аргумента self, дважды отсылая интерпретатор к экземпляру,
и тем самым дважды инициирует поиск в дереве наследования –
self.name и self.says(), с целью отыскать требуемую информацию
в подклассах:
class Actor:
def line(self): print self.name + ':', repr(self.says())
class Customer(Actor):
name = 'customer'
def says(self): return "that's one exbird!"
class Clerk(Actor):
name = 'clerk'
def says(self): return "no it isn't..."
class Parrot(Actor):
name = 'parrot'
def says(self): return None
class Scene:
def __init__(self):
self.clerk = Clerk() # Встраивание некоторых экземпляров
self.customer = Customer() # Scene – это составной объект
816 Приложение B
self.subject = Parrot()
def action(self):
self.customer.line() # Делегировать выполнение встроенным
self.clerk.line() # экземплярам
self.subject.line()
Часть VII. Исключения и инструменты
Упражнения находятся в главе 29, в разделе «Упражнения к седьмой
части».
1. try/except. Ниже приводится моя версия функции oops (файл
oops.py). Что касается вопросов, не связанных с реализацией про
граммного кода: если изменить функцию oops так, чтобы вместо In
dexError она возбуждала исключение KeyError, то обработчик в инст
рукции try не сможет перехватывать исключение (оно достигнет
верхнего уровня и приведет к появлению сообщения об ошибке по
умолчанию). Имена KeyError и IndexError определены во встроенной
области видимости. Импортируйте модуль __builtin__ и передайте
его функции dir, чтобы убедиться в этом:
def oops():
raise IndexError
def doomed():
try:
oops()
except IndexError:
print 'caught an index error!'
else:
print 'no error caught...'
if __name__ == '__main__': doomed()
% python oops.py
caught an index error!
2. Объекты исключений и списки. Ниже показано, как я дополнил
модуль своим собственным исключением (для начала исключение
определено в виде строки):
MyError = 'hello'
def oops():
raise MyError, 'world'
def doomed():
try:
oops()
except IndexError:
print 'caught an index error!'
except MyError, data:
print 'caught error:', MyError, data
Решения упражнений 817
else:
print 'no error caught...'
if __name__ == '__main__':
doomed()
% python oops.py
caught error: hello world
Чтобы идентифицировать исключение как класс, я просто изменил
первую часть файла, как показано ниже, и сохранил его под име
нем oop_oops.py:
class MyError: pass
def oops():
raise MyError()
...остальная часть осталась без изменений...
Как и в случае любого другого исключения на основе класса, в виде
дополнительных данных передается сам экземпляр – теперь сооб
щение об ошибке содержит имя класса и указание на его экземпляр
(<...>).
% python oop_oops.py
caught error: __main__.MyError <__main__.MyError instance at 0x00867550>
Не забывайте, что внешний вид сообщения можно улучшить, если
определить метод __repr__ или __str__ в своем классе так, чтобы он
возвращал нужную строку. Подробнее об этом рассказывается в гла
ве 24.
3. Обработка ошибок. Ниже приводится мое собственное решение
этого упражнения (файл safe2.py). Я добавил тесты непосредствен
но в файл, чтобы не проводить их в интерактивной оболочке, но ре
зультаты от этого не меняются.
import sys, traceback
def safe(entry, *args):
try:
apply(entry, args) # Перехватывать любые исключения
except:
traceback.print_exc()
print 'Got', sys.exc_type, sys.exc_value
import oops
safe(oops.oops)
% python safe2.py
Traceback (innermost last):
File "safe2.py", line 5, in safe
apply(entry, args) # Перехватывать любые исключения
File "oops.py", line 4, in oops
raise MyError, 'world'
818 Приложение B
hello: world
Got hello world
Сегодня я реализовал бы эту функцию, как показано ниже, исполь
зуя новый синтаксис *args и функцию exc_info:
def safe(entry, *args):
try:
entry(*args) # Перехватывать любые исключения
except:
traceback.print_exc()
print 'Got', sys.exc_info(){0], sys.exc_info()[1]
4. Далее приводится несколько примеров для самостоятельного изу
чения на досуге; еще больше примеров программ на языке Python
вы найдете в последующих книгах и в Сети:
# Поиск наибольшего файла в единственном каталоге
dirname = r'C:\Python25\Lib'
import os, glob
allsizes = []
allpy = glob.glob(os.path.join(dirname, '*.py'))
for filename in allpy:
filesize = os.path.getsize(filename)
allsizes.append((filesize, filename))
allsizes.sort()
print allsizes[:2]
print allsizes[2:]
# Поиск наибольшего файла в дереве каталогов
import sys
if sys.platform[:3] == 'win':
dirname = r'C:\Python25\Lib'
else:
dirname = '/usr/lib/python'
import os, glob
allsizes = []
for (thisDir, subsHere, filesHere) in os.walk(dirname):
for filename in filesHere:
if filename.endswith('.py'):
fullname = os.path.join(thisDir, filename)
fullsize = os.path.getsize(fullname)
allsizes.append((fullsize, fullname))
allsizes.sort()
print allsizes[:2]
print allsizes[2:]
# Поиск наибольшего файла с исходным программным кодом на языке Python
# в пути поиска модулей
import sys, os, pprint
Решения упражнений 819
visited = {}
allsizes = []
for srcdir in sys.path:
for (thisDir, subsHere, filesHere) in os.walk(srcdir):
thisDir = os.path.normpath(thisDir)
if thisDir.upper() in visited:
continue
else:
visited[thisDir.upper()] = True
for filename in filesHere:
if filename.endswith('.py'):
pypath = os.path.join(thisDir, filename)
try:
pysize = os.path.getsize(pypath)
except:
print 'skipping', pypath
allsizes.append((pysize, pypath))
allsizes.sort()
pprint.pprint(allsizes[:3])
pprint.pprint(allsizes[3:])
# Сумма по столбцам, разделенным запятыми, в текстовом файле
filename = 'data.txt'
sums = {}
for line in open(filename):
cols = line.split(',')
nums = [int(col) for col in cols]
for (ix, num) in enumerate(nums):
sums[ix] = sums.get(ix, 0) + num
for key in sorted(sums):
print key, '=', sums[key]
# То же, что и выше, но суммы накапливаются в списке, а не в словаре
import sys
filename = sys.argv[1]
numcols = int(sys.argv[2])
totals = [0] * numcols
for line in open(filename):
cols = line.split(',')
nums = [int(x) for x in cols]
totals = [(x + y) for (x, y) in zip(totals, nums)]
print totals
# Регрессивное тестирование результатов работы нескольких сценариев
import os
testscripts = [dict(script='test1.py', args=''),
dict(script='test2.py', args='spam')]
for testcase in testscripts:
820 Приложение B
commandline = '%(script)s %(args)s' % testcase
output = os.popen(commandline).read()
result = testcase['script'] + '.result'
if not os.path.exists(result):
open(result, 'w').write(output)
print 'Created:', result
else:
priorresult = open(result).read()
if output != priorresult:
print 'FAILED:', testcase['script']
print output
else:
print 'Passed:', testcase['script']
# Создание ГИП с помощью Tkinter: кнопка, изменяющая цвет и размер
from Tkinter import *
import random
fontsize = 25
colors = ['red', 'green', 'blue', 'yellow', 'orange',
'white', 'cyan', 'purple']
def reply(text):
print text
popup = Toplevel()
color = random.choice(colors)
Label(popup, text='Popup', bg='black', fg=color).pack()
L.config(fg=color)
def timer():
L.config(fg=random.choice(colors))
win.after(250, timer)
def grow():
global fontsize
fontsize += 5
L.config(font=('arial', fontsize, 'italic'))
win.after(100, grow)
win = Tk()
L = Label(win, text='Spam',
font=('arial', fontsize, 'italic'),
fg='yellow', bg='navy', relief=RAISED)
L.pack(side=TOP, expand=YES, fill=BOTH)
Button(win, text='press',
command=(lambda: reply('red'))).pack(side=BOTTOM, fill=X)
Button(win, text='timer', command=timer).pack(side=BOTTOM, fill=X)
Button(win, text='grow' , command=grow).pack(side=BOTTOM, fill=X)
win.mainloop()
# То же, что и выше, но на основе классов, поэтому каждое окно может
# иметь свою собственную информацию о состоянии
from Tkinter import *
import random
Решения упражнений 821
class MyGui:
"""
ГИП с кнопками, которые изменяют цвет и размер надписи
"""
colors = ['blue', 'green', 'orange', 'red', 'brown', 'yellow']
def __init__(self, parent, title='popup'):
parent.title(title)
self.growing = False
self.fontsize = 10
self.lab = Label(parent, text='Gui1', fg='white', bg='navy')
self.lab.pack(expand=YES, fill=BOTH)
Button(parent, text='Spam', command=self.reply).pack(side=LEFT)
Button(parent, text='Grow', command=self.grow).pack(side=LEFT)
Button(parent, text='Stop', command=self.stop).pack(side=LEFT)
def reply(self):
" при нажатии кнопки Spam изменяет цвет случайным образом "
self.fontsize += 5
color = random.choice(self.colors)
self.lab.config(bg=color,
font=('courier', self.fontsize, 'bold italic'))
def grow(self):
"при нажатии кнопки Grow начинает увеличивать размер надписи"
self.growing = True
self.grower()
def grower(self):
if self.growing:
self.fontsize += 5
self.lab.config(font=('courier', self.fontsize, 'bold'))
self.lab.after(500, self.grower)
def stop(self):
"при нажатии кнопки Stop останавливает увеличение размера"
self.growing = False
class MySubGui(MyGui):
colors = ['black', 'purple'] # Настройка изменения цвета
MyGui(Tk(), 'main')
MyGui(Toplevel())
MySubGui(Toplevel())
mainloop()
# Сканирование и обслуживание ящика электронной почты
"""
Проверяет ящик входящей электронной почты, извлекает заголовки писем,
позволяет удалять сообщения, не загружая их полностью
"""
import poplib, getpass, sys
mailserver = 'здесь требуется указать имя почтового сервера pop'
# pop.rmi.net
822 Приложение B
mailuser = 'здесь требуется указать имя пользователя' # brian
mailpasswd = getpass.getpass('Password for %s?' % mailserver)
print 'Connecting...'
server = poplib.POP3(mailserver)
server.user(mailuser)
server.pass_(mailpasswd)
try:
print server.getwelcome()
msgCount, mboxSize = server.stat()
print 'There are', msgCount, 'mail messages, size ', mboxSize
msginfo = server.list()
print msginfo
for i in range(msgCount):
msgnum = i+1
msgsize = msginfo[1][i].split()[1]
resp, hdrlines, octets = server.top(msgnum, 0) # Get hdrs only
print ''*80
print '[%d: octets=%d, size=%s]' % (msgnum, octets, msgsize)
for line in hdrlines: print line
if raw_input('Print?') in ['y', 'Y']:
for line in server.retr(msgnum)[1]: print line # Получить сообщ.
if raw_input('Delete?') in ['y', 'Y']:
print 'deleting'
server.dele(msgnum) # Удалить на сервере
else:
print 'skipping'
finally:
server.quit() # Закрыть почтовый ящик
raw_input('Bye.') # Предотвратить самопроизвольное закрытие окна
# CGI
сценарий для взаимодействия с броузером на стороне клиента
#!/usr/bin/python
import cgi
form = cgi.FieldStorage() # Разбор данных формы
print "Contenttype: text/html\n" # заголовок и пустая строка
print "<HTML>"
print "<title>Reply Page</title>" # разметка html страницы
print "<BODY>"
if not form.has_key('user'):
print "<h1>Who are you?</h1>"
else:
print "<h1>Hello <i>%s</i>!</h1>" % cgi.escape(form['user'].value)
print "</BODY></HTML>"
# Сценарий для заполнения и выполнения запросов к базе данных MySql
from MySQLdb import Connect
conn = Connect(host='localhost', user='root', passwd='darling')
curs = conn.cursor()
try:
Решения упражнений 823
curs.execute('drop database testpeopledb')
except:
pass # Отсутствует
curs.execute('create database testpeopledb')
curs.execute('use testpeopledb')
curs.execute('create table people (name char(30), job char(10), pay
int(4))')
curs.execute('insert people values (%s, %s, %s)', ('Bob', 'dev', 50000))
curs.execute('insert people values (%s, %s, %s)', ('Sue', 'dev', 60000))
curs.execute('insert people values (%s, %s, %s)', ('Ann', 'mgr', 40000))
curs.execute('select * from people')
for row in curs.fetchall():
print row
curs.execute('select * from people where name = %s', ('Bob',))
print curs.description
colnames = [desc[0] for desc in curs.description]
while True:
print '' * 30
row = curs.fetchone()
if not row: break
for (name, value) in zip(colnames, row):
print '%s => %s' % (name, value)
conn.commit() # Сохранить добавленные записи
# Сценарий для заполнения базы данных shelve объектами Python
rec1 = {'name': {'first': 'Bob', 'last': 'Smith'},
'job': ['dev', 'mgr'],
'age': 40.5}
rec2 = {'name': {'first': 'Sue', 'last': 'Jones'},
'job': ['mgr'],
'age': 35.0}
import shelve
db = shelve.open('dbfile')
db['bob'] = rec1
db['sue'] = rec2
db.close()
# Сценарий для вывода и изменения базы данных shelve,
# созданной предыдущим сценарием
import shelve
db = shelve.open('dbfile')
for key in db:
print key, '=>', db[key]
bob = db['bob']
bob['age'] += 1
db['bob'] = bob
db.close()
Алфавитный указатель
Специальные символы
: символ двоеточия, 276, 377
#, комментарии, 365
% (остаток/формат) оператор, 147
& (побитовое И) оператор, 146
* (умножение) оператор, 147
/ (деление) оператор, 147
<< (сдвиг влево) оператор, 146
== (проверка равенства) оператор, 175,
257
^ (побитовое исключающее ИЛИ)
оператор, 146
| (побитовое ИЛИ) оператор, 146
…, приглашение к вводу, 76
>> (сдвиг вправо) оператор, 146
>>>, приглашение к вводу, 74, 77
A
abs, функция, 159
__add__, метод, 587, 607, 608
__all__, переменная, 534
all, функция, 348
and, оператор, 146, 323
any, функция, 348
Apache, 47
apply, функция, 447
applyподобный синтаксис вызова, 448
ArithmeticError, исключение
(встроенное), 742
assert, инструкция, 275, 701, 725
проверка соблюдения ограничений,
725
AssertionError, исключение, 725
AttributeError, исключение, 616
B
__base__, атрибут, 591
__bases__, атрибут, 628
bool, тип данных, 163
Boolean, 136
break, инструкция, 275, 332, 334
__builtin__, модуль, 159, 401, 404
C
C, язык программирования,
интеграция, 50
C++, язык программирования, 40, 50
__call__, метод, 608, 620
chr, функция, 453
__class__, атрибут, 591, 628
class, инструкция, 275, 561, 578, 595
атрибуты данных, 597
вложенные инструкции, 596
общая форма, 596
пример, 596
пространство имен, 596
сравнение с именами в модуле, 596
сравнение с функциями, 596
classtree, функция, 630
__cmp__, метод, 608
COM, поддержка в MS Windows, 44
contextlib, модуль, 730
continue, инструкция, 275, 332, 334
CPython, 65
csh, командная оболочка, 784
D
Dabo, 43
__debug__, флаг, 725
def, инструкция, 275, 387, 389, 599
return, yield, 386
и lambda, 441
del, инструкция, 275
__del__, метод, 608, 623
Алфавитный указатель 825
__dict__, атрибут, 590, 627, 649
dict, функцияконструктор, 356
dir, функция, 90, 121, 366
distutils, 498
Django, 44
__doc__, атрибут, 367, 657
Doctest, 769
E
Eclipse, интегрированная среда
разработки, 98, 769
else, инструкция, 335
__enter__, метод, 729
enumerate, функция, 356
env, команда в UNIX, 82
__eq__, метод, 608
eval, функция, 64, 158, 432
использование функции eval для
строк в объекты, 249
except, предложение инструкции try,
710
Exception, исключение (встроенное),
742
exec, инструкция, 275
exec, функция, 64
execfile(module.py), встроенная
функция, 92
__exit__, метод, 729
F
False, предопределенное имя, 163
FIFO, файлы, 252
filter, функция, 331, 454
find, метод, 205
for, циклы, 337
readlines, метод, 346
вложенные, 341
внутри функции, 393
и генераторы списков, 458
итераторы, 345
кортежи, 340
переменные цикла, 340
общий формат, 337
строки, 339
типичные варианты использования,
339
for/else, инструкция, 275
freeze, 69, 770
from *, инструкция, 503, 550
from, инструкция, 275, 503, 549
и import, 506
модули, 485
потенциальные проблемы, 507
рекурсия, 553
G
__getattr__, метод, 608, 615, 648
__getattribute__, метод, только в
классах нового стиля, 676
__getitem__, метод, 608
реализует доступ к элементам по
индексу, 609
global, инструкция, 275, 386, 388, 406
GTK, 43
H
help, функция, 121, 205, 369, 372
hex, функция, 158
HTML (Hyper Text Markup Language –
гипертекстовый язык разметки), 44
I
__iadd__, метод, 607, 608
IDLE, индегрированная среда
разработки, 769
if, инструкции, 315
множественное ветвление, 316
общая форма, 315
простые примеры, 316
if/elif/else, инструкция, 274
if/else, трехместное выражение, 325
import as, расширение, 539
import, инструкция, 87, 275, 488, 490,
503
sys.path, список, 494
выбор файла модуля, 495
выполняется только один раз, 504
домашний каталог, 492
дополнительные возможности
выбора модуля, 496
запуск, 497
и from, 506
и пространства имен, 91
использование расширений имен
файлов, 379
каталоги стандартной библиотеки,
492
когда необходимо использовать, 508
компиляция, 496
826 Алфавитный указатель
модули, 485
переменная окружения PYTHON
PATH, 492
примечания к использованию, 91
содержимое файлов с расширением .
pht, 492
__import__, функция, 496, 549
in, оператор проверки на вхождение,
146, 331, 342, 348
IndexError, исключение, 704
Informix, система управления базами
данных, 45
__init__, метод, 570, 588, 608
__init__.py, файлы, 523
int, функция, 158, 196, 286
intersect, функция, 394
IronPython, 44, 66
is not, оператор, 146
__iter__, метод, 608, 609
iter, функция, 346, 461
J
join, метод, 205, 207, 349
Jython, 43, 65
K
Komodo, индегрированная среда
разработки, 99, 769
ksh, командная оболочка, 784
L
lambdaвыражения, 415, 440, 441
вложенные, 445
где используются, 442
и def, 441
операторы, 146
тело, 441
lambda, инструкция, 386
LEGB, правило, 401, 406, 511
__len__, метод, 608
len, функция, 117, 227, 387
Linux, 47
list, функция, 174, 207, 243, 349
__lt__, метод, 608
M
map, функция, 331, 348, 354, 449, 465
и генераторы списков, 459
и функциональное
программирование, 449
math, модуль, 116
MFC, 43
mod_python, 44
__mul__, метод, 587
MySQL, система управления базами
данных, 45
N
__name__, атрибут, 535
.NET, платформа, 44
NLTK, пакет, 46
None, объект, 259
not in, оператор, 146
not, оператор, 146
NotImplementedError, исключение, 606
NULL, указатель в языке C, 259
NumPy, расширение, 45, 145
O
oct, функция, 158
ODBC, 45
open, функция, 135, 136, 387
__or__, метод, 608
or, оператор, 146, 323
Oracle, система управления базами
данных, 45
ord, функция, 453
OverflowError, исключение
(встроенное), 742
P
Parrot, 70
pass, инструкция, 275, 332, 333
PATH, переменная окружения, 73, 782
Perl, язык программирования, 47, 51
pickle, модуль, 45, 249, 647
PMW, 43, 69
pop, метод, 230
PostgreSQL, система управления базами
данных, 45
pow, функция, 450
print, инструкция, 74, 80, 274, 307
в интерактивном режиме, 76
и sys.stdout, 311
перенаправление потока вывода, 308
программа Hello World, 308
расширение print >> file, 309
Алфавитный указатель 827
числа, 152
Psyco, 771
динамический компилятор, 67
.py, расширение имен файлов, 78, 95
py2exe, 69, 770
PyChecker, 768
PyDev, модуль расширения, 98
PyDoc, 121, 365, 768
help, функция, 365, 369, 372
отчеты в формате HTML, 365, 372
pygame, 46, 69
PyGTK, библиотека создания
графического интерфейса, 69
PyInstaller, 69, 770
Pylons, 44
PyPI, вебсайты, 46
PyPy, 70
PySol, программа, 46
Python
архитектура программы, 487
импортирование и атрибуты, 487
как организована программа, 487
в сравнении с другими языками
программирования, 54
структура, 273
Python 3.0, 447, 450, 452
nonlocal, инструкция, 411
инструкция print, 312
исключения, 712
классы, 669
сильные стороны языка, 46
смешивание типов, 222
Python for .NET, 66
PythonCard, интегрированная среда
разработки, 99
PYTHONPATH, переменная
окружения, 492, 782
каталоги, 492
PYTHONSTARTUP, переменная
окружения, 782
PythonWin, интегрированная среда
разработки, 99
PyUnit, 768
Q
Qt, 43
R
__radd__, метод, 607, 608, 619
raise, инструкция, 275, 701, 722
общие формы, 747
передача дополнительных данных,
723
передача сигналов из функций по
условию, 756
random, модуль, 116, 159
range, функция, 297, 332, 350
изменение списков, 352
обход части последовательнсти, 352
счетные циклы, 350
raw_input, функция, 285, 312, 756
readlines, метод, 346
reduce, функция, 331
reload, функция, 88, 514, 552
вместе с инструкцией from, 550
модули, 485
основы использования, 515
подробнее, 516
пример использования, 516
примечания к использованию, 91
replace, метод, 205
__repr__, метод, 608, 618, 621, 650
repr, функция, 147, 153, 196
return, инструкция, 275, 388, 389
round, функция, 159
Run Module, пункт меню в среде IDLE,
92
S
self, 579
set, функция, 136, 161
__setattr__, метод, 608, 615
__setitem__, метод, 608
Shedskin, 68, 771
shelve, модуль, 647
SIP, 44
__slots__, атрибут, в классах нового
стиля, 673
sorted, функция, 131, 348, 379, 465
SQLite, 45
SQLObject, 45
Stackless Python, 70
StandardError, исключение
(встроенное), 742
stdout, объект, 307
StopIteration, исключение, 461, 611
__str__, метод, 608, 618, 621
str, функция, 147, 153
sum, функция, 348, 465
SWIG, 44
828 Алфавитный указатель
Swing, 43
Sybase, система управления базами
данных, 45
SyntaxError, исключение, 715
sys, модуль, 307
sys.exc_info, функция, 729, 759
sys.modules, словарь, 545
sys.path, список, 494, 538
sys.stdout, объект, 311
T
Tcl, язык программирования, 47
TCL_LIBRARY, переменная
окружения, 782
Tkinter, 43, 69
GUI
API, 562
графический интерфейс, 93
TK_LIBRARY, переменная окружения,
782
True, предопределенное имя, 163
try, инструкция
обработка ошибок, 288
отладка с помощью инструкции try,
757
try/else, инструкция, 713
try/except, инструкция, 701, 708, 718
вложение, 720
вложенная, 752
пример использования объединенной
инструкции, 720
try/except/else, инструкция, 709
try/except/finally, инструкция, 275
try/finally, инструкция, 701, 708, 716
вложенная, 753
программирование завершающих
действий, 716
tuple, функция, 243, 349, 422
TurboGears, 44
type, функция, 393
U
unittest, модуль, 768
update, метод, 230
V
Vaults of Parnassus, вебсайты, 46
Vista, установка Python 2.5 из
установочного файла формата MSI,
780
W
WebWare, 44
while, циклы, 330
имитация циклов while языка C, 338
общий формат, 331
примеры, 331
while/else, инструкция, 275
win32all, пакет расширений для Win
dows, 531
WingIDE, интегрированная среда
разработки, 99
with/as, инструкция, 275, 701, 726
протокол управления контекстом,
728
wxPython, 43, 69
X
xmlrpclib, модуль, 46
Y
yield, инструкция, 275
Z
zip, функция, 350, 354
конструирование словарей, 355
ZODB, 45
Zope, 44
А
абсолютный импорт, 540
абстрактные суперклассы, 605
автоматическое присвоение расширений
файлам в операционной системе Win
dows, 79
автоматическое управление памятью, 49
агрегирование, 643
адаптация через наследование, 563
альтернативные реализации
CPython, 65
IronPython, 66
Jython, 65
анонимные функции, 440
аргументы
значения по умолчанию, 427
Алфавитный указатель 829
и разделяемые ссылки, 419
извлечение аргументов из
коллекции, 429
изменяемые объекты передаются по
указателю, 419
комбинирование ключей и значений
по умолчанию, 430
неизменяемые объекты передаются
по значению, 419
передача в функции, 388
передача по ключу, 426, 436, 448
передача через операцию
присваивания, 423
применение функций, 447
произвольное количество, 428
режимы сопоставления
переменное число аргументов,
424
по ключам, 424
по позиции, 423
по умолчанию, 424
сбор аргументов в коллекцию, 428
функция поиска минимума, 430
аргументы командной строки, 196
аргументы передаются через
автоматическое присваивание
объектов локальным именам, 418
аргументы по ключу
передача, 448
аргументы со значениями по
умолчанию, 414
ассоциативные массивы, 225
атрибуты, 487, 767
def, инструкция, 597
имена, 624
классов, 603
псевдочастные, 665
для чего нужны, 666
экземпляров, 602
атрибуты данных, 597
Б
базы данных, 45
байткод, 40
компиляция, 62
библиотеки утилит, 50
битовые операторы, 146
блок else в циклах, 332
быстрое создание прототипов, 45
В
ввод составных инструкций, 76
вебсценарии, 44
взаимодействие, 469
взаимосвязи типа «имеет», 643
взаимосвязи типа «является», 641
включение будущих возможностей
языка, 534
вложенные модули, 96
вложенные области видимости
lambda, 445
вложенные функции, области
видимости, 410
и lambdaвыражения, 415
вложенные циклы, 454
внешние инструменты, 767
возбуждение и обработка собственных
исключений, 722
возможность запуска программ из
текстового редактора, 101
восьмеричные литералы, 144, 158
вспомогательные модули, 145
встраивание
кода на языке Python в C, 44
расширение типов, 662
встроенные
инструменты, 49
типы объектов, 49
встроенные типы
зачем нужны, 112
расширение, 661
встраиванием, 662
наследованием, 663
встроенные функции
abs, 159
all, 348
any, 348
apply, 447
chr, 453
dict, 356
dir, 121, 366
enumerate, 356
eval, 158, 432
execfile(module.py), 92
False, имя, 163
filter, 454
help, 121
hex, 158
__import__, 496, 549
int, 158, 196, 286
830 Алфавитный указатель
iter, 346, 461
len, 117, 387
list, 174, 243, 349
map, 342, 348, 354, 449, 465
__name__, атрибут, 535
oct, 158
open, 135, 136, 387
ord, 453
pow, 450
random, модуль, 159
range, 297, 332, 350
raw_input, 285, 312, 756
reload, 514
пример использования, 516
repr, 147, 153, 196
round, 159
set, 136, 161
sorted, 131, 348, 465
str, 147, 153
sum, 348, 465
sys.path, список, 538
True, имя, 163
tuple, 243, 349, 422
type, 393
zip, 350, 354
длинные целые, 156
принудительное преобразование
типов, 149
числовые литералы, 145
вызов метода, 599, 600
вызовы, 386, 390
встроенные, 100
обработка, 620
вызовы функций, 274
выполнение
PVM, 63
виртуальная машина Python, 63
выполнение программы, 60
компиляция в байткод, 62
производительность, 63
скорость разработки, 64
выражениягенераторы, 465
высокая скорость разработки, 38
выходные параметры, имитация, 422
Г
Гвидо ван Россума (Guido van Rossum),
669
генераторы, 459
методы send и next, 463
пример, 461
генераторы списков, 348, 357, 452
выражениягенераторы, 465
и map, 459
и кортежи, 243
и матрицы, 456
и циклы for, 458
основы, 358, 453
проверки и вложенные циклы, 454
расширенный синтаксис, 360
файлы, 359
гибкость кода
нарушение, 137
гибкость объектов, 253
глобальная область видимости, 399
глобальные переменные, минимизация
количества, 407
границы блоков, 319, 320
границы инструкций, 319
групповое присваивание, 293, 294, 298
разделяемые ссылки, 298
Д
декораторы функций, 623, 649, 681
пример, 683
делегирование, 648
деление
истинное, 153
классическое, 153
с округлением вниз, 153
дескрипторы файлов, 136, 252
деструктор, 623
динамическая типизация, 49, 114, 166
отсутствие инструкций объявления,
166
переменные, объекты и ссылки, 167
разделяемые ссылки, 171
и изменяемые объекты, 173
и равенство, 175
сборка мусора, 170
типы, 169
динамический компилятор (justin
time, JIT), 67
длинные целые, 156
домашний каталог программы, 492
дополняющее присваивание, 299
преимущества, 300
разделяемые ссылки, 301
Алфавитный указатель 831
З
завершающие действия
с помощью инструкции try/finally,
716
заключительные операции, 703
замыкания, 412
записи, в виде классов, 639
запуск Python
интерпретатор, 61
запутать программный код, как не, 444
зарезервированные слова, 302
значения по умолчанию, 474
И
иерархии
типов, 260
понятий, 273
избегать воздействий на изменяемые
аргументы, 421
извлечение среза, 180
изменения
внутри функции аргумента, который
является изменяемым объектом,
419
в соседних модулях, минимизация,
408
значений имен в других файлах, 506
изменяемые объекты, 474
в операциях присваивания, 378
изменяемые типы, 212
имена атрибутов, 403
имитация частных атрибутов
экземпляра, 617
импортирование
и перезагрузка, 86
и атрибуты, 487
и области видимости, 512
пример, 90
примечания к использованию, 91
индексация, 117, 180
инкапсуляция, 573, 637
инструкции, 273
в форме выражений, 444
не имеющие вложенных
инструкций, 323
присваивания, 274
разделители, 282, 321
специальные случаи, 282
инструкции выражений, 305
типичные, 305
инструкции импортирования
импортирование модулей по имени в
виде строки, 548
синтаксис относительного импорта,
539
инструкции присваивания, 292, 293
групповые, 293, 298
разделяемые ссылки, 298
дополнительные варианты, 296
дополняющие, 299
преимущества, 300
разделяемые ссылки, 301
комбинированные, 293
кортежей и списков, 293
последовательностей, 293
инструменты разработки крупных
проектов, 767
интеграция
компонентов, 44
с языком C, 50
интегрированные среды разработки, 769
Eclipse, 98
Komodo, 99
PythonCard, 99
PythonWin, 99
WingIDE, 99
интерактивные циклы, 284
вложенный программный код, 289
математическая обработка данных
пользователя, 285
пример простого цикла, 284
проверка ввода, 286
интерактивный режим, 72
ввод составных инструкций, 76
изменение строки приглашения к
вводу, 76
использование, 75
отступы, 76
тестирование программного кода, 74
интернационализация, 187
Интернетмодули, 44
интерпретатор, 58
соглашения по именованию, 303
интерфейсы, программные, 43
интроспекция, 545
информация о состоянии, 138
исключения, 701, 767
AssertionError, 725
except, предложение инструкции try,
пустое, 710
IndexError, 704
832 Алфавитный указатель
SyntaxError, 715
вложенные обработчики
исключений, 751
вложение в потоке управления,
753
синтаксическое вложение, 754
возбуждение и обработка
собственных исключений, 722
встроенные
ArithmeticError, 742
Exception, 742
OverflowError, 742
StandardError, 742
перехват, 715
заключительные операции, 703
идиомы, 756
sys.exc_info, 759
запуск тестов в рамках единого
процесса, 758
исключения не всегда являются
ошибками, 756
отладка с помощью внешних
инструкций try, 757
передача сигналов из функций по
условию, 756
использование, 751
на основе классов, 735
в сравнении с исключениями на
основе строк, 736
определение текста исключения,
743
передача данных и поведения в
экземплярах, 744
преимущества, 738
пример, 736
на основе строк, 734
назначение, 703
необычное управление потоком
выполнения, 703
обработка ошибок и особых
ситуаций, 703
обработчик исключений по
умолчанию, 705
повторное возбуждение исключений
с помощью инструкции raise, 724
пример, 704
развивитие, 702
советы по применению исключений,
760
избегайте пустых предложений
except, 761
используйте категории, 763
что должно быть обернуто, 760
типичные проблемы, 764
уведомления о событиях, 703
искусственный интеллект, 46
исполняемые сценарии в UNIX, 81
источники документации, 364
dir, функция, 365, 366
__doc__, атрибут, 367
help, функция, 365
PyDoc
help, функция, 369, 372
отчеты в формате HTML, 372
вебресурсы, 365, 376
комментарии #, 365
отчеты в формате HTML, 365
печатные издания, 365, 376
стандартный набор руководств, 365,
375
строки документирования, 365, 367,
368
определяемые пользователем,
367
стандарты, 368
исходный код, компиляция, 62
итераторы, 342, 459
StopIteration, исключение, 345
выражениягенераторы, 465
другие контексты итераций, 347
других встроенных типов, 346
и встроенные типы, 464
и сканирование файлов, 343
итерационный протокол, 345
несколько итераторов в одном
объекте, 613
определяемые пользователем, 349,
610
файлов, 344
итерации
альтернативы, 466
хронометраж, 466
перегрузка, 609
протокол, 132
итерационный протокол, 345
К
кавычки, 122
каналы, 136
каталоги стандартной библиотеки, 492
категории, на основе классов, 763
Алфавитный указатель 833
категории типов, 211, 252
отображения, 212
последовательности, 212
числа, 211
квадратные скобки, 282
классификация объектов, 252
классы, 562, 565, 567
__bases__, атрибут, 628
атрибуты, 578, 603
возможности
адаптация через наследование,
563
композиция, 562
множество экземпляров, 563
наследование, 562
перегрузка операторов, 563
вызовы методов классов, 567
и их хранение, 647
и модули, 659
как записи, 639
множественное наследование, 649
модули, 584
нового стиля, 668
__getattribute__, метод, 676
__slots__, атрибут, 673
другие расширения, 673
ромбоидальное наследование, 669
пример, 670
явное разрешение конфликтов
имен, 671
свойства, 674
статические методы и методы
класса, 673
операции присваивания внутри
инструкции class, 578
определяемые пользователем, 138
основы программирования, 577
вызов объектов, 579
множество экземпляров, 577
self, 579
конкретные элементы, 579
наследование, 579
поведение по умолчанию, 578
пример, 579
переопределение операторов
языка Python, 586
пример, 587
переопределение операторов языка
Python, 586
пример, 587
программирование, 595
пример, 631
псевдочастные атрибуты, 665
для чего нужны, 666
смеси, 650
создание деревьев классов, 568
типичные проблемы, 684
изменение атрибутов, 684
методы, классы и вложенные
области видимости, 687
многослойное обертывание, 689
множественное наследование, 685
шаблоны проектирования, 637, 661
перегрузка сигнатур вызова, 638
ключевые аргументы, 436
код
компиляция, 62
командная строка интерпретатора Py
thon, 77
командные оболочки, 39
комбинированная инструкция
присваивания, 293
комбинированное присваивание, 294
комментарии, 78, 150, 319
компилируемые расширения, 767
компиляция
Psyco, динамический компилятор,
67
Shedskin, 68
в байткод, 62
комплексные числа, 144, 157
композиция, 562, 643
пример, 643
компоненты
интеграция, 44
конец строки, 277
конкатенация, 118, 180
строк, 190
концепции проектирования
модулей, 543
функций, 469
копии и ссылки, 254
короткая схема вычислений, 324
кортежи, 90, 113, 134, 240
массив ссылок на объекты, 240
в действии, 241
доступ к элементам по смещению,
240
запятые и круглые скобки, 241
и генераторы списков, 243
литералы кортежей и операции, 241
834 Алфавитный указатель
неизменяемые последовательности,
240
преобразования и неизменяемость,
242
упорядоченные коллекции объектов
произвольных типов, 240
уровни вложенности, 240
циклы for, 340
переменные цикла, 340
косвенный вызов, 471
круглые скобки, 148, 277, 283, 378
Л
лексическая область видимости, 399
литералы
длинных целых чисел, 144
чисел, 143
чисел с плавающей точкой, 143
шестнадцатеричные и
восьмеричные, 144
логические значения, 163, 327
логические операторы, 146, 155
локальная область видимости, 399
локальные имена, 472
локальные переменные, 395
М
максимизировать многократное
использование программного кода,
386
математическая обработка данных
пользователя, 285
математические и научные вычисления,
45
математические функции, 145
матрицы и генераторы списков, 456
метапрограммы, 544
методы, 119, 599
find, 205
join, 205, 207
replace, 205
возможности, 601
вызов, 204, 599, 600
вызов конструкторов суперклассов,
601
несвязанные , 655
пример, 600
проверка наличия подстроки
в конце, 209
проверка содержимого, 209
связанные, 658
экземпляра, 655
способы вызова методов, 600
строк, 204
экземпляра, 680
методы send и next, 463
методы класса, 673, 677
и методы экземпляра, 680
использование, 679
несвязанные, 677
минимизировать избыточность
программного кода, 386
мнимая часть, 157
многослойное обертывание в классах,
689
множества, 136, 161
множественное ветвление, 316
множественное наследование, 649, 685
множество экземпляров, 563
модель отношений реального мира, 641
модули, 77, 485, 767
from *, инструкция, 503
from, инструкция, 485, 503
потенциальные проблемы, 507
import as, расширение, 539
import, инструкция, 485, 503
выполняется только один раз, 504
reload, функция, 485
sys.path, список, 494
вложенные, 96
выбор файла модуля, 495
домашний каталог программы, 492
дополнительные возможности
выбора, 496, 533
и использование инструкции import,
508
и классы, 584, 659
и пространства имен, 91
изменение значений имен в других
файлах, 506
изменение пути поиска, 538
имена файлов, 501
использование, 502
каталоги стандартной библиотеки,
492
концепции проектирования, 543
взаимозависимость, 543
интроспекция, 545
согласованность, 543
метапрограммы, 544
назначение, 486
Алфавитный указатель 835
определение, 501
основы программирования, 501
переменная окружения PYTHON
PATH, 492
повторная загрузка, 514
повторное использование
программного кода, 486
присваивание, 505
пространства имен, 509
вложенные, 513
дополнение имен атрибутов, 511
путь поиска модулей, 491
разделение системы пространств
имен, 486
реализация служб или данных для
совместного пользования, 486
синтаксис относительного импорта,
539
смешанные режимы использования,
535
тестирование модулей, 536
содержимое файлов с расширением .
pht, 492
создание, 501
сокрытие данных, 533
__all__, переменная, 534
предотвращение копирования,
534
типичные проблемы, 547
from *, инструкция, 550
from, инструкция, 549
reload, функция, 550, 552
импортирование модулей по
имени в виде строки, 548
порядок следования инструкций,
547
рекурсивный импорт
инструкцией from, 553
тестирование в интерактивной
оболочке, 551
эквивалентность инструкций import
и from, 506
модули расширений, 502
модульное программирование, 49
Н
наследование, 562, 582, 600, 602, 637,
641
__init__, конструктор, 738
абстрактные суперклассы, 605
иерархия, 561
и атрибуты классов, 582
и обращение object.attribute, 582
множественное, 649, 685
модель поиска в дереве
наследования, 603
переопределение унаследованных
методов, 603
подклассы и суперклассы, 582
приемы организации
взаимодействия классов, 604
пример, 583, 670
ромбоидальное, 669
пример, 670
явное разрешение конфликтов
имен, 671
создание дерева атрибутов, 602
специализация унаследованных
методов, 603
суперклассы, 582
экземпляров, 582
явное разрешение конфликтов имен,
671
настройка переменных окружения, 781
неизменяемость (строки), 119
необычное управление потоком
выполнения, 703
несвязанные методы класса, 655, 677
несоставные инструкции, 323
неформатированные строки, 180, 181,
184
подавление экранирования, 184
О
обертывание, 760
области видимости, 398, 624
lambdaвыражения, 415
LEGB, правило, 401
аргументы со значениями по
умолчанию, 414
вложенные, 687
встроенная, 401, 404
глобальные, 400
замыкания, 412
и вложенные функции, 410
изменения в соседних модулях,
минимизация, 408
локальные, 400
объемлющие, 410
объемлющих инструкций def, 401
836 Алфавитный указатель
основы, 399
охранение состояния объемлющей
области видимости с помощью
аргументов по умолчанию, 414
пример, 403
присваивание именам, 400
произвольное вложение, 418
рекурсия, 400
фабричные функции, 412
обработка
особых ситуаций, 703
ошибок, 703
проверкой ввода, 286
обработчик исключений по умолчанию,
705
обработчики событий, 621
объединение разделенных инструкций,
323
объектноориентированный язык
сценариев, 38
объекты, 168
вызов, 579
два стандартных поля, 169
и функции, 471
несвязанные методы класса, 655
связанные методы экземпляра, 655
система хранения, 45
состояние и поведение, 578
строковые методы, 204
числа, 142, 150
объекты исключений, 733
на основе классов, 733
на основе строк, 733
объемлющие инструкции def, 401
объемлющие области видимости, 410
ООП (объектноориентированное
программирование), 46, 561, 564
взаимосвязи типа «имеет», 643
взаимосвязи типа «является», 641
вызовы методов классов, 567
зачем нужны классы, 562
адаптация через наследование,
563
композиция, 562
множество экземпляров, 563
перегрузка операторов, 563
инкапсуляция, 573
классы, 565, 567
многократное использование
программного кода, 571
платформы, 574
поиск унаследованных атрибутов,
564
создание деревьев классов, 568
фабрики, 653
зачем нужны, 654
шаблоны проектирования, 574
экземпляры, 565, 567
операторы выражений, 145
группировка подвыражений, 148
определение старшинства, 147
перегрузка, 149
смешивание операторов, 147
смешивание типов, 148
числа, 150
операции
над строками, 190
операции присваивания
внутри инструкции class, 578
внутри функции, 418
оригинальный модуль string, 209
остаток от деления, оператор, 147
открытое программное обеспечение, 47
отладчики, 770
IDLE, 97
отображения, 212
отрицания оператор, 147
отрицательные смещения в строках, 192
отступы, 320, 377
конец, 278
правила оформления, 278
отсутствие инструкций объявления, 166
очереди, 136
ошибки при работе с функциями, 472
значения по умолчанию, 474
локальные имена, 472
переменные цикла в объемлющей
области видимости, 476
функции, не возвращающие
результат, 476
П
пакеты модулей, 521
инструкции from и import, 526
когда используется операция
импортирования, 527
основы операции импортирования,
521
__init__.py, файлы, 523
инициализация пакета, 524
Алфавитный указатель 837
инициализация пространства
имен модуля, 524
настройка пути поиска, 522
поведение инструкции from *, 524
точечный путь, 522
пример импортирования, 525
перегрузка операторов, 253, 563, 606
имитация частных атрибутов
экземпляра, 617
итераторы
несколько итераторов в одном
объекте, 613
определяемые пользователями,
610
ключевые идеи, 607
общие методы, 608
__add__, 608
__call__, 608
__cmp__, 608
__del__, 608
__eq__, 608
__getattr__, 608
__getitem__, 608
__iadd__, 608
__init__, 608
__iter__, 608
__len__, 608
__lt__, 608
__or__, 608
__radd__, 608
__repr__, 608
__setattr__, 608
__setitem__, 608
__str__, 608
основные идеи, 586
перегрузка сигнатур вызова, 638
передача аргументов, 398, 418
переменные, 168
DOS, 784
и основные выражения, 150
использование, 167
окружения, 781
создание, 167
типы, 167
цикла, 416
переносимый ANSI C, 48
переносимый прикладной программный
интерфейс баз данных, 45
перехват обращения к атрибутам, 615
перечислимые типы данных, 297
платформы, 574
поведение по умолчанию, 578, 714
повторение
последовательности, 263
строки, 118
повторное возбуждение исключений с
помощью инструкции raise, 724
повторное использование программного
кода, 486
подавление экранированных
последовательностей, 184
подвыражения, 148
подклассы, 565
замещение унаследованных
атрибутов, 603
расширение встроенных типов, 663
поиск унаследованных атрибутов, 564
полиморфизм, 118, 138, 149, 392, 637
intersect, функция, 394
положительные смещения в строках,
191
получение среза, 117
пользовательский интерфейс IDLE, 92
Tkinter, 93, 96
вложенные модули, 96
дополнительные возможности, 97
запуск в Windows, 93
запуск редактируемых файлов, 94
запуск сценариев, 96
многопоточные программы, 96
настройка, 96
отладчик, 97
очистка экрана, 96
ошибки соединения, 97
повторное выполнение команд, 94
подсветка синтаксиса, 94
файлы с исходным текстом, 94
поразрядный сдвиг, чисел, 155
последовательности, 116, 179, 212
отображение функций на, 449
почему программисты используют Py
thon, 35
высокая скорость разработки, 36
интеграция компонентов, 36
качество программного обеспечения,
35
переносимость программ, 36
поддержка библиотек, 36
удовольствие, 37
правила именования переменных, 301
предложения инструкции try, 710
формы, 710
838 Алфавитный указатель
предупреждения, 756
преобразование строк, 147
приглашение к вводу, 74
приемы организации взаимодействия
классов, 604
приемы программирования циклов, 349
приложения баз данных, 45
пример использования объединенной
инструкции try, 720
присваивание, 505
классификация имен, 625
именам, 400
кортежей и списков, 293, 294
последовательностей, 293, 294
дополнительные варианты, 296
пробелы, 319
проверка
ввода, 286
и вложенных циклов, 454
ошибок, 730
соблюдения ограничений, 725
проверка истинности, 257, 323
короткая схема вычислений, 324
оператор and, 325
оператор or, 324
операторы and и or, 323
понятия Истина и Ложь, 259
программа Hello World, 308
программирование
интерпретатор, 58
модульное, 49
системное, 43
строковые методы, 204
программные ловушки импорта, 496
программный код
вложенный, 289
многократное использование, 571
повторное использование, 486
самый простой класс на языке Py
thon, 589
типичные ошибки
программирования, 377
производительность, 63
произвольное вложение областей
видимости, 418
пространства имен, 88, 91, 398, 486,
509, 624, 694
вложенные, 513
дополнение имен атрибутов, 511
имена атрибутов, 624
классификация имен, 625
классы, 596
простые имена, 624
разделение системы пространств
имен, 486
словари, 627
составные имена атрибутов, 624
ссылки, 630
пространства имен, объявление, 406
профилировщики, 769
процедурная декомпозиция, 386
псевдочастные атрибуты, 665
для чего нужны, 666
пустые предложения except, 710, 761
пустые строки, 180, 319
Р
равенство, 257
разделение системы пространств имен,
486
разделяемые ссылки, 171
и аргументы, 419
и изменяемые объекты, 173
и равенство, 175
расширение встроенных типов, 661
встраиванием, 662
наследованием, 663
расширения на языке Python, 766
расширения файлов, 79
режимы сопоставления, 423, 435
переменное число аргументов, 424
по ключам, 424
по позиции, 423
по умолчанию, 424
рекурсия, 400, 630
ромбоидальное наследование, 669
пример, 670
явное разрешение конфликтов имен,
671
С
сборка мусора, 49, 130, 170
свободное программное обеспечение, 47
свойства класса, 674
связанные методы экземпляра, 655, 658
связность, 469
сдвига операторы, 146
символы,
крупные наборы, 187
подчеркивания, 534
синтаксис относительного импорта, 539
Алфавитный указатель 839
синтаксические правила, 318
системная командная строка и файлы,
77
исполняемые сценарии в UNIX, 81
использование, 79
сканирование файлов, 343
словари, 113, 127, 224
len, функция, 227
pop, метод, 230
update, метод, 230
базовые операции, 227
вложенность, 129
дополнительные методы, 229
доступ к элементам по ключу, а не по
индексу, 225
другие способы создания, 235
замечания по использованию, 231
изменение, 228
имитация гибких списков, 232
интерфейсы словарей, 236
использование в качестве записей,
234
итерации и оптимизация, 132
как избежать появления ошибок
обращения к несуществующему
ключу, 233
ключи, 128
литералы и операции, 226
неупорядоченные коллекции
произвольных объектов, 225
операции над последовательностями,
231
операции отображения, 128
отсутствующие ключи, 133
переменная длина, гетерогенность и
произвольное число уровней
вложенности, 225
пространств имен, 627
сортировка по ключам, 130
структуры разреженных данных,
233
таблица языков, 230
таблицы ссылок на объекты (хеш
таблицы), 226
словари для хранения записей, 639
сложение, правостороннее, 619
службы или данные для совместного
пользования, 486
смешивание типов, операторы
выражений, 148
соглашения по именованию, 303
содержимое файлов с расширением .pht,
492
создание дерева атрибутов, 602
сокеты, 136, 252
составные инструкции, 315
составные типы, 471
специальные режимы сопоставления,
423
специальный случай оформления блока,
283
списки, 113, 123, 215
базовые операции, 218
вложенные, 125
генераторы списков, 126
доступ к элементам по смещению,
216
изменение, 220
индексы, 219
литералы и операции, 217
массивы ссылок на объекты, 216
матрицы, 219
методы, 221
специфичные для типа, 124
операции над последовательностями,
124
относятся к категории изменяемых
объектов, 216
присваивание по индексам, 220
присваивание срезам, 220
проверка выхода за границы, 125
срезы, 219
упорядоченные коллекции объектов
произвольных типов, 215
часто используемые операции, 224
способы доступа к глобальным
переменным, 409
способы оптимизации, 771
сравнение, 257
операторы, 146
языков, 54
средства оптимизации, 67
Psyco, динамический компилятор,
67
Shedskin, 68
ссылки, 168
и копии, 254
на пространства имен, 630
стандартная библиотека, 490
каталоги, 492
статически вложенные области
видимости, 411
840 Алфавитный указатель
статические методы, 673, 677
использование, 679
стратегический режим, 562
строгая типизация, 114
строки, 113, 116, 179
dir, функция, 121
help, функция, 121
базовые операции, 190
в апострофах и в кавычках, 181
в кавычках, 122, 180
в тройных кавычках, 186
вызов методов, 180
другие способы представления, 122
извлечение среза, 192
изменение, 199
индексирование, извлечение среза,
длина, 180, 191
инструменты преобразования, 195
конкатенация, 118, 180
литералы, 180
в апострофах, 181
в кавычках, 181
в тройных кавычках, 181
в Юникоде, 181
экранированные
последовательности, 181, 182
Юникод, 187
методы, 204
вызов функции, 204
извлечение атрибутов, 204
специфичные для типа, 119
наиболее типичные литералы строк и
операции, 180
неизменяемость, 119
неформатированные, 180, 184
обход в цикле, проверка на
вхождение, 180
операции над последовательностями,
116
повторение, 118
поиск, 180
по шаблону, 123
с заменой, 180
преобразование регистра символов,
180
проверка содержимого, 180
пустые, 180
разбиение на подстроки по символу
разделителю, 180
расширенная операция извлечения
среза, 194
символы обратного слеша, 183
удаление пробелов, 180
форматирование, 180, 200
дополнительные возможности,
201
спецификаторы формата, 202
строк из словаря, 203
циклы for, 339
строки документирования, 319, 367,
368, 657, 768
определяемые пользователем, 367
основное преимущество, 658
стандарты, 368
структура организации программ, 487
структуры
данных, 112
разреженных данных, 233
суперклассы, 565, 604
абстрактные, 605
классысмеси, 650
конструкторы, 601
наследование, 582
расширение методов, 603
суффиксы
комплексные числа, 157
сценарии, 77
счетчик ссылок, 169
Т
тактический режим, 562
текст
изменение строк, 199
разбор, 207
строковые методы, 204
текущий рабочий каталог, 493
тестирование
в интерактивной оболочке, 551
запуск тестов в рамках единого
процесса, 758
программного кода в интерактивном
режиме, 74
типичные проблемы, 764
перехват ненужных исключений,
766
соответствие строковым
исключениям, 764
типы объектов, 49, 111, 767
базовые, 113
встроенные , 112
изменяемые, 212
Алфавитный указатель 841
в модулях стандартной библиотеки,
262
ловушки, 262
неизменяемые типы, 264
повторение последовательности,
263
присваивание, 262
циклические структуры данных,
264
объекты и переменные, 169
преобразование, 148
сравнение, 258
точность представления чисел и
длинные целые, 144
У
уведомления о событиях, 703
удобство в использовании, 39
указатель типа, 169
унарные операторы, 147
универсальные функции, 433
упакованные двоичные данные,
сохранение в файлах и
интерпретация, 250
управление контекстом, 726
протокол, 728
управляющий язык, 39
упражнения
решения, 786
from/from *, 804
__man__, 805
try/except, 816
аргументы, 798
взаимодействие, 786
вложенное импортирование, 805
вложенные структуры, 794
генераторы списков, 802
дополнительные примеры на
сопоставление аргументов, 800
импорт пакетов, 806
индексирование и извлечение
среза, 790
индексирование словарей, 792
индексирование строк, 794
индексирование, извлечение
среза и инструкция del, 791
классификация животных в
зоологии, 814
ключи словарей, 792
композиция, 814
кортежи, 791
методы метакласса, 811
модули, 786
наследование, 807
неизменяемые типы, 794
обработка ошибок, 817
общие операции, 793
объекты исключений и списки,
816
объекты множеств, 811
основы импортирования, 803
основы циклов, 795
основы, 789
основы, 797
ошибки, 787
перегрузка операторов, 809
передача аргументов по ключу,
799
переменное число аргументов,
798
повторная загрузка, 806
подклассы, 810
прерывание программы, 788
примеры для самостоятельного
изучения, 818
программирование
альтернативной логики, 796
программы, 786
связи в дереве классов, 813
символы обратного слеша, 796
снова простые числа, 801
сортировка словарей, 796
сценарии, 787
сценка с мертвым попугаем, 815
файлы, 794
функция dr, 795
циклический импорт, 807
установка и настройка Python, 59, 777
где получить, 778
настройка, 780
настройка переменных окружения,
781
переменные DOS, 784
проверка наличия предыдущей
установки, 777
установка, 778
установка интерпретатора, 777
файлы путей, 785
установка поддержки Tkinter в Linux,
782
утилиты сторонних разработчиков, 50
842 Алфавитный указатель
Ф
фабрики, 653
зачем нужны, 654
фабричные функции, 412
файлы, 113, 135, 244
FIFO, 252
в действии, 247
сохранение и интерпретация
упакованных двоичных данных
в файлах, 250
сохранение объектов с помощью
модуля pickle, 249
вызов метода close, 246
выполнение, 61
выталкивание выходных буферов на
диск, 245
дескрипторы, 252
другие инструменты, 251
другие средства, напоминающие
файлы, 136
закрытие файла вручную, 245
запись всех строк из списка в файл,
245
запись строки в файл, 245
изменение текущей позиции в файле,
245
каналы, 252
операции над файлами, 245
открытие, 244
с доступом по ключу, 136, 252
создают пространства имен, 509
сохранение и интерпретация
объектов Python в файлах, 247
чтение
следующей текстовой строки, 245
следующих N байтов, 245
файла целиком в единственную
строку, 245
файла целиком в список строк,
245
файлы путей, 785
фигурные скобки, 282
фиксированные двоичные файлы, 68
фиксированные исполняемые двоичные
файлы, 101
функции, 385, 398, 767
apply, 447
filter, 451
lambda, 440
reduce, 451
анонимные, 440
вызов, 379, 390
выполняющие непосредственные
изменения в объектах, 378
для работы с числами, 159
инструкции и выражения, имеющие
отношение к функциям, 386
как объекты, 471
концепции проектирования, 469
косвенный вызов, 471
обратного вызова, 446
обработчики, 442
определение, 385
передача сигналов из функций по
условию, 756
пересечение последовательностей,
393
вызов, 394
локальные переменные, 395
определение, 393
полиморфизм, 394
цикл for внутри функции, 393
применение к аргументам, 447
расширенные возможности, 440
создание функций, 387
def, инструкция, 387, 389
global, инструкция, 388
return, инструкция, 388, 389
аргументы, 388
функции обратного вызова, 658
функциональное программирование,
451
filter, функция, 451
reduce, функция, 451
функциональные интерфейсы, 621
функция поиска минимума, 430
Х
хеши, 225
Ц
целые числа, 143
литералы, 143
циклические структуры данных, 264
циклы, 330
break, инструкция, 332, 334
continue, инструкция, 332, 334
else, инструкция, 335
for, 337
pass, инструкция, 332, 333
Алфавитный указатель 843
readlines, метод, 346
while, 330
общий формат, 331
примеры, 331
блок else в циклах, 332
имитация циклов while языка C, 338
интерактивные, 284
вложенный программный код,
289
математическая обработка
данных пользователя, 285
проверка ввода, 286
простой пример, 284
итераторы, 342
общий формат, 333
параллельный обход, 354
приемы программирования, 349
изменение списков, 352
обход части последовательности,
352
счетные циклы, 350
Ч
числа, 113, 142, 211
базовые операторы, 150
инструкция print, 152
комплексные числа, 157
литералы, 143
с плавающей точкой, 143
с фиксированной точностью, 137,
160
смешивание числовых типов в
выражении, 148
форматы отображения, 152
Ш
шаблоны проектирования, 574, 637, 661
шестнадцатеричные
литералы, 158
шестнадцатеричные литералы, 144
Э
экземпляры, 565, 567
__class__, атрибут, 628
атрибуты, 602
имитация частных атрибутов, 617
множество, 563
передача данных и поведения в
экземплярах, 744
экранированные последовательности,
подавление, 184
Я
языки
сравнение, 54
ярлыки, щелчок, 83
raw_input, функция, 84
в Windows, 83
ограничения, 86
По договору между издательством «СимволПлюс» и Интернетмага
зином «Books.Ru – Книги России» единственный легальный способ
получения данного файла с книгой ISBN 9785932861387, назва
ние «Изучаем Python, 3е издание» – покупка в Интернетмагазине
«Books.Ru – Книги России». Если Вы получили данный файл каким
либо другим образом, Вы нарушили международное законодатель
ство и законодательство Российской Федерации об охране авторского
права. Вам необходимо удалить данный файл, а также сообщить из
дательству «СимволПлюс» (piracy@symbol.ru), где именно Вы полу
чили данный файл.
